<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wenke</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://wenkex.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://wenkex.gitee.io/"/>
  <updated>2022-06-24T00:00:27.000Z</updated>
  <id>https://wenkex.gitee.io/</id>
  
  <author>
    <name>wenke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>题目集合</title>
    <link href="https://wenkex.gitee.io/2022/062453983.html"/>
    <id>https://wenkex.gitee.io/2022/062453983.html</id>
    <published>2022-06-24T00:00:27.000Z</published>
    <updated>2022-06-24T00:00:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><p>19.sys模块是python标准库中最常用的模块之一。通过它可以获取命令行参数，从而实现从程序外部向程序内部传递参数的功能，也可以获取程序路径和当前系统平台等信息。</p><p>25、打开一个已有文件，然后在文件末尾添加信息，正确的打开方式为( C )。<br>A.‘r’<br>B.‘w’<br>C.‘a’<br>D.‘w+’</p><p>31.可以使用del释放变量资源</p><p>34、下列表达式的值为True的是 （C）<br>A、5+4j &gt; 2-3j   B、3&gt;2&gt;2<br>C 、1==1and2!=1?  D、not(1==1and 0!=1)<br>复数不能比较大小，只能比较模</p><p>38.(B)函数用于将指定序列中的所有元素作为参数调用指定函数，并将结果构成一个新的序列返回<br>A. lambda<br>B. map<br>C. filter<br>D. zip</p><p>39.（D）函数以一系列列表作为参数，将列表中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。<br>A. lambda<br>B. map<br>C. filter<br>D. zip</p><p>51.若 a = ‘abcd’ ，若想将 a 变为 ‘ebcd’ ，则下列语句正确的是D<br>A. a[0] = ‘e’<br>B. replace(‘a’, ‘e’)<br>C. a[1] = ‘e’<br>D. a = ‘e’ + a[1:]</p><p>53.执行以下两条语句后，lst的结果是B<br>lst = [3, 2, 1]<br>lst.append(lst)</p><p>A. [3, 2, 1, [3, 2, 1]]<br>B. [3, 2, 1, […]]，其中“…”表示无穷递归<br>C. 抛出异常<br>D. [3, 2, 1, lst]</p><p>75、对于列表ls的操作，以下选项中描述错误的是（A）。<br>A．ls.clear()：删除ls的最后一个元素<br>B．ls.copy()：生成一个新列表，复制ls的所有元素<br>C．ls.reverse()：列表ls的所有元素反转<br>D．ls.append(x)：在ls最后增加一个元素</p><p>28%45=28</p><p>82、Button组件属性中哪一个是设置Button可变的文本内容对应的变量（A）。<br>A、textvariable<br>B、text<br>C、anchor<br>D、variable</p><p>84、下面使用geometry方法设置窗口对象win大小的写法正确的是（C）。<br>A、win.geometry(“400*300”)<br>B、win.geometry(400,300)<br>C、win.geometry(“400x300”)<br>D、win.geometry(400x300)</p><p>85、以下哪个不属于SQLite3中的存储类型（B）。<br>A、NULL<br>B、FLOAT<br>C、BLOB<br>D、TEXT</p><p>87，创建游标对象Cur，以下执行SQL语句正确的是（A）。</p><p>A、Cur.execute(“select * from school”)<br>B、Cur.curson(“select * from school”)<br>C、Cur.curson(select * from school)<br>D、Cur.execute(select * from school)</p><p>88，以下哪项不是获取游标的查询结果集（d）。</p><p>A、cur.fetchone()<br>B、cur.fetchmany()<br>C、cur.fetchall()<br>D、cur.fetchrow()</p><p>90、以下关于数据组织的描述中，错误的是（A）。<br>A、一维数据采用线性方式组织，可以用Python集合或列表类型表示<br>B、列表类型仅用于表示一维和二维数据<br>C、二维数据采用表格方式组织，可以用Python列表类型表示<br>D、更高维数据组织由键值对类型的数据构成，可以用Python字典类型表示</p><p>22、使用Python列表的方法   insert( )       为列表插入元素时会改变列表中插入位置之后元素的索引。</p><p>36、表达式 list(zip([1,2],[3,4]))的值为  [(1,3),(2,4)]              。<br>37、表达式 sorted([111,2,33], key=lambda x: len(str(x))) 的值为    [2.33.111]           。<br>38、表达式list(filter(lambda x:x&gt;2, [0,1,2,3,0,0]))的值为    [3]            。<br>41、在用来打开或创建文件并返回文件对象函数中访问模式参数使用    b       表示二进制模式。<br>42、打开随机文件后，可以使用实例方法    seek()            函数进行定位。<br>seek()&nbsp;方法用于移动文件读取指针到指定位置。</p><p>47、创建对象时，默认调用构造方法；当删除一个对象时，同样会默认调用一个方法，这个方法就是  析构方法           。</p><p>50、Tkinter的子模块filedialog中打开文件对话框的函数是  askopenfilename()          。<br>51、Tkinter模块中Label控件的作用是 显示文本和位图          。<br>52、askfloat函数主要用来打开输入对话框,输入并返回 浮点数           。<br>53、SQLite3中浮点数的存储类型是 real           。<br>54、SQLite3中使用   connect           函数建立数据库连接。</p><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><p>1 面向对象语言都有封装，继承，多态，分别描述 封装，继承，多态的含义和作用？<br>答：封装：将类属性赋予给对象    作用：方便调用<br>继承：子类继承父类的属性和方法   作用：减少代码量<br>多态：一类事物的多种表现形式，需要利用继承，方法重写和重载</p><p>2.简述read. readline. readlines的区别<br>read:一次性读取整个文件<br>readline:每次读取文件的一行，每一行末尾会读到\n<br>readlines:以行的形式读取文件的全部内容，返回一个列表</p><p>3.简述实例属性与类属性的区别<br>实例属性：定义在构造方法内，描述类创建的实例对象，需要通过对象来访问。在每个实例对象的内存中都保留一份<br>类属性:在构造方法外定义，描述类对象的属性，所有实例对象公用</p><p>4.简述list和tuple的区别？<br>list 是可变数据类型，tuple是不可变数据类型<br>定义方式：list[]  tuple()<br>list有insert(),extend(),remove()等方法，tuple没有</p><p>5.简述Python 中标识符的命名规则？<br>只能以字母或下划线开头<br>区分大小写<br>关键词不能作为标识符</p><p>6.闭包的形成必要条件是什么<br>闭包函数必须有内嵌函数，内嵌函数必须引用外层函数的变量，外层函数返回内嵌函数</p><p>在Python面向对象编程时，方法中的”self”代表什么？<br>在定义实例方法时，self作为第一个参数，代表类创建的实例对象本身，用self来引用类的属性和函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python&quot;&gt;&lt;a href=&quot;#python&quot; class=&quot;headerlink&quot; title=&quot;python&quot;&gt;&lt;/a&gt;python&lt;/h1&gt;&lt;p&gt;19.sys模块是python标准库中最常用的模块之一。通过它可以获取命令行参数，从而实现从程序外部向程序内</summary>
      
    
    
    
    <category term="待分" scheme="https://wenkex.gitee.io/categories/%E5%BE%85%E5%88%86/"/>
    
    
    <category term="待分" scheme="https://wenkex.gitee.io/tags/%E5%BE%85%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>javascript学习</title>
    <link href="https://wenkex.gitee.io/2022/05319399.html"/>
    <id>https://wenkex.gitee.io/2022/05319399.html</id>
    <published>2022-05-31T07:20:41.000Z</published>
    <updated>2022-05-31T07:20:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><p><a href="https://www.yuque.com/yashujs/bfug6u/ntxhzu#cc4dd1da">https://www.yuque.com/yashujs/bfug6u/ntxhzu#cc4dd1da</a></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>单行注释//<br>块注释/**/</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> item = {</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">addValue</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> item.value + val</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 请使用对象方法的简写方式, 属性不可简写, 方法可以简写  </span></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> item = {</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  addValue (val) {</span><br><span class="line">    <span class="keyword">return</span> item.value + val</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>arr.push()<br>arr.sort()</p><h3 id="数组转字符串"><a href="#数组转字符串" class="headerlink" title="数组转字符串"></a>数组转字符串</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// join() 方法可以把数组转换为字符串，不过它可以指定分隔符。在调用 join() 方法时，可以传递一个参数作为分隔符来连接每个元素。如果省略参数，默认使用逗号作为分隔符</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];  <span class="comment">//定义数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = a.join(<span class="string">""</span>);  <span class="comment">//指定分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s);  <span class="comment">//返回字符串“12345”</span></span><br></pre></td></tr></tbody></table></figure><h3 id="使用数组的多个值时"><a href="#使用数组的多个值时" class="headerlink" title="使用数组的多个值时"></a>使用数组的多个值时</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当需要使用数组的多个值时，请使用解构赋值  </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> second = arr[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [first, second] = arr</span><br></pre></td></tr></tbody></table></figure><h3 id="调用数组每个元素"><a href="#调用数组每个元素" class="headerlink" title="调用数组每个元素"></a>调用数组每个元素</h3><p>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>{<span class="built_in">console</span>.log(i);})</span><br></pre></td></tr></tbody></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>var 存在变量提升的情况，即 var 声明会被提升至该作用域的顶部，但是他们的赋值并不会。而 const 和 let 并不存在这种情况，</p><p>在作用域顶部声明变量，避免变量声明和赋值引起的相关问题。<br>var的作用域被规定为一个函数作用域，<br>而let则被规定为块作用域，块作用域要比函数作用域小一些<br>但是如果两者既没在函数中，也没在块作用域中定义，那么两者都属于全局作用域。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在 JavaScript 函数内部声明的变量是局部变量，所以只能在函数内部访问它，局部变量生命期从被声明的时间开始。在函数运行以后被删除。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串太长的时候，请不要使用字符串连接符换行 \，而是使用 + </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'牙叔教程 牙叔教程 牙叔教程'</span> +</span><br><span class="line">  <span class="string">'牙叔教程 牙叔教程 牙叔教程'</span> +</span><br><span class="line">  <span class="string">'牙叔教程 牙叔教程'</span></span><br></pre></td></tr></tbody></table></figure><p>编程时使用join而不是字符串连接来构建字符串  </p><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.show();</span><br><span class="line"><span class="keyword">var</span> i = { <span class="attr">name</span>: <span class="string">"小明"</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">height</span>: <span class="number">1.72</span> }; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"大家好, 我叫%s, 今年%d岁, 身高%d米"</span>, i.name, i.age, i.height);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"实际上我是一个对象啦，长这样子: %j"</span>, i);</span><br></pre></td></tr></tbody></table></figure><h3 id="随机字符"><a href="#随机字符" class="headerlink" title="随机字符"></a>随机字符</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Radom</span>(<span class="params">n</span>)</span>{</span><br><span class="line">    <span class="comment">//如果不传参就是n=8</span></span><br><span class="line">    <span class="keyword">var</span> n= n || <span class="number">8</span></span><br><span class="line">    <span class="keyword">var</span> str=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        str+=<span class="built_in">String</span>.fromCharCode(random(<span class="number">0</span>,<span class="number">65535</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">log(Radom(<span class="number">8</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="https://www.yuque.com/yashujs/bfug6u/dy5mld">autojs之递归</a></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历文件夹, 获取文件列表</span></span><br><span class="line"><span class="keyword">let</span> dirPath = <span class="string">"/sdcard/脚本"</span>;</span><br><span class="line"><span class="keyword">let</span> filePathList = getFilePathList(dirPath);</span><br><span class="line">log(filePathList);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFilePathList</span>(<span class="params">dirPath, filePathList</span>) </span>{</span><br><span class="line">  filePathList = filePathList || [];</span><br><span class="line">  <span class="keyword">var</span> fileNameList = files.listDir(dirPath);</span><br><span class="line">  <span class="keyword">var</span> len = fileNameList.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">    <span class="keyword">let</span> filepath = files.join(dirPath, fileNameList[i]);</span><br><span class="line">    <span class="keyword">if</span> (files.isFile(filepath)) {</span><br><span class="line">      filePathList.push(filepath);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 文件夹, 继续向下递  </span></span><br><span class="line">      getFilePathList(filepath, filePathList);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 文件遍历完成, 终止条件, 返回结果</span></span><br><span class="line">  <span class="keyword">return</span> filePathList;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置默认参数</span></span><br><span class="line"><span class="keyword">var</span> n= n || <span class="number">8</span></span><br></pre></td></tr></tbody></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> anonymous = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有名函数表达式(在一个非函数块里声明一个函数)</span></span><br><span class="line"><span class="keyword">if</span> (currentUser) {</span><br><span class="line">  <span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Yup.'</span>);</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自执行匿名函数 </span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet. Please follow me.'</span>);</span><br><span class="line">})();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数(使用函数表达式（传递匿名函数）时)</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> y = x + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> x * y</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>相比于其他面向对象语言，JavaScript对象的构造函数比较特殊，它可以是任何一个普通的函数，而且无需在对象中定义。只有两个约定：<br>构造函数的命名通常以大写开头；<br>构造函数只能由new操作符执行；</p><p>当使用new调用一个函数时，这个函数就会变成构造函数<br>使用new调用函数后，函数是有返回值的，即使在定义函数时没有return语句。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>)</span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = name;}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaoming = <span class="keyword">new</span> People(<span class="string">'xiaoming'</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单独运行一个匿名函数，由于不符合语法要求，报错啦！解决方法只需要给匿名函数包裹一个括号即可：</span></span><br><span class="line"><span class="comment">//匿名函数在其它应用场景括号可以省略</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>{</span><br><span class="line">    <span class="comment">//由于没有执行该匿名函数，所以不会执行匿名函数体内的语句。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"张培跃"</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>如果需要执行匿名函数，在匿名函数后面加上一个括号即可立即执行！</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"张培跃"</span>);</span><br><span class="line">})()</span><br></pre></td></tr></tbody></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.经典格式： 函数名 = ( 参数 ) =&gt; { 方法体 } </span></span><br><span class="line"><span class="keyword">const</span> sum3 = <span class="function">(<span class="params">x,y</span>)=&gt;</span>{ </span><br><span class="line">  <span class="keyword">return</span> x+y; </span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(sum3) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.当方法体只有一行时，花括号可以省略： </span></span><br><span class="line"><span class="keyword">const</span> sum4 = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y;  </span><br><span class="line"><span class="built_in">console</span>.log(sum4) </span><br><span class="line"> </span><br><span class="line"><span class="comment">//当只有一个参数时，括号可以省略： </span></span><br><span class="line"><span class="keyword">const</span> sum4 = <span class="function"><span class="params">x</span> =&gt;</span> x+<span class="number">1</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(sum4) </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。<br>stringObject.split(separator,howmany) 方法用于把一个字符串分割成字符串数组。<br>    separator    必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>1.== 双等号 返回值只有true 和false 类型为布尔型，只比较左右的值，若相等则返回true，反之false<br>2.=== 全等号 返回值为true或false 若左右两边的值和类型均相等，则返回true，反之false<br>3.!= 不相等号 返回值为true或false 不比较类型，只比较值，若左边不等于右边则返回true，反正false</p><p>●  使用 === 和 !== 而非 == 和 !=，eslint: eqeqeq<br>●  条件声明例如 if 会用 ToBoolean 这个抽象方法将表达式转成布尔值并遵循如下规则<br>    Objects 等于 true<br>    Undefined 等于 false<br>    Null 等于 false<br>    Booleans 等于 布尔值<br>    Numbers 在 +0, -0, 或者 NaN 的情况下等于 false, 其他情况是 true<br>    Strings 为 ‘’ 时等于 false, 否则是 true  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果等于 ==</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>==<span class="number">1</span>){toastLog(<span class="string">"正确"</span>)};</span><br><span class="line"><span class="comment">//如果 不等于 !=</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != <span class="number">2</span>){toastLog(<span class="string">"正确"</span>)};</span><br><span class="line"><span class="comment">//如果 大于小于 &gt; &lt; 不举例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=<span class="literal">true</span>;b=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//如果真判断简写 正常写 if(a == true){ }</span></span><br><span class="line"><span class="keyword">if</span>(a){toastLog(<span class="string">"a=真"</span>)}</span><br><span class="line"><span class="comment">//如果假判断简写 正常写 if(b == false){ }</span></span><br><span class="line"><span class="keyword">if</span>(!b){toastLog(<span class="string">"b=假"</span>)}</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;&amp; = 并且</span></span><br><span class="line"><span class="keyword">if</span>( a==<span class="literal">true</span> &amp;&amp; b==<span class="literal">false</span> ){</span><br><span class="line">toastLog(<span class="string">"a为真-b为假"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// || = 或者</span></span><br><span class="line"><span class="keyword">if</span>( a==<span class="literal">false</span> || b==<span class="literal">false</span> ){</span><br><span class="line">toastLog(<span class="string">"a或者b其中为假"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="多重判断"><a href="#多重判断" class="headerlink" title="多重判断"></a>多重判断</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(){</span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(){</span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(){</span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span>()</span><br></pre></td></tr></tbody></table></figure><p><strong>Switch 语句</strong><br>计算一次 switch 表达式<br>把表达式的值与每个 case 的值进行对比<br>如果存在匹配，则执行关联代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(表达式) {</span><br><span class="line">     <span class="keyword">case</span> n:</span><br><span class="line">        代码块</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> n:</span><br><span class="line">        代码块</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">        默认代码块</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)</span><br><span class="line">{</span><br><span class="line">    当条件 <span class="number">1</span> 为 <span class="literal">true</span> 时执行的代码</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition2)</span><br><span class="line">{</span><br><span class="line">    当条件 <span class="number">2</span> 为 <span class="literal">true</span> 时执行的代码</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">  当条件 <span class="number">1</span> 和 条件 <span class="number">2</span> 都不为 <span class="literal">true</span> 时执行的代码</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p><strong>for语句</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句 <span class="number">1</span>; 语句 <span class="number">2</span>; 语句 <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">    被执行的代码块</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>for/in - 循环遍历对象的属性</p><p><strong>while</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件)</span><br><span class="line">{</span><br><span class="line">    需要执行的代码</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>do/while</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">    需要执行的代码</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (条件);</span><br></pre></td></tr></tbody></table></figure><h2 id="js正则"><a href="#js正则" class="headerlink" title="js正则"></a>js正则</h2><p>autojspro不支持正则前向断言</p><h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><h3 id="CJS模块管理"><a href="#CJS模块管理" class="headerlink" title="CJS模块管理"></a>CJS模块管理</h3><p><strong>模块化</strong>主要是用于管理代码，解决解耦与复用问题<br>命名冲突，全局污染<br>模块内部逻辑的封装性隔离<br>模块之间的通讯（依赖引用、循环引用、引用顺序）</p><p>CJSCommonJS，主要用于服务器端如node.js，主要使用如下：</p><p><strong>CommonJS规范缺点</strong><br>CommonJS加载模块是同步的：同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行。<br>这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在模块文件中导出</span></span><br><span class="line"><span class="keyword">const</span> object = {</span><br><span class="line">    <span class="attr">HaoranOcrClick</span>: HaoranOcrClick,</span><br><span class="line">    <span class="attr">BdOcrClick</span>: BdOcrClick,</span><br><span class="line">};</span><br><span class="line"><span class="built_in">module</span>.exports = object;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在使用文件引入</span></span><br><span class="line"><span class="keyword">const</span> ocr = <span class="built_in">require</span>(<span class="string">"/sdcard/脚本/模块/ocr模块.js"</span>);</span><br><span class="line"><span class="comment">// "/storage/emulated/0/"</span></span><br><span class="line">ocr.HaoranOcrClick(<span class="string">''</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h3><p>ESM是ESModule，是ECMAScript自己的模块体系，于ES6引入，基本上可以完全取代CJS和AMD。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出：export命令</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = {<span class="attr">name</span>: <span class="string">'E1e'</span>}；</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 默认导出 export default命令</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {<span class="attr">name</span>: <span class="string">'E1e'</span>};</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 引入接口：import命令</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 引入普通导出</span></span><br><span class="line"><span class="keyword">import</span> { obj } <span class="keyword">from</span> <span class="string">'./test.js'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 引入默认导出</span></span><br><span class="line"><span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">'./test.js'</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><h3 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h3><p>initXX：初始化相关方法，使用 init 为前缀标识，如初始化布局 initView<br>isXX：方法返回值为 boolean 型的请使用 is 或 check 为前缀标识<br>getXX：返回某个值的方法，使用 get 为前缀标识，例如 getName<br>setXX：设置某个属性值，使用 set 为前缀标识，例如 setName<br>handleXX/processXX：对数据进行处理的方法，例如 handleMessage<br>displayXX/showXX：弹出提示框和提示信息，例如 showDialog<br>updateXX：更新某个东西，例如 updateData<br>saveXX：保存某个东西，例如 saveData<br>resetXX：重置某个东西，例如 resetData<br>clearXX：清除某个东西，例如 clearData<br>removeXX：移除数据或者视图等，例如 removeView<br>drawXX：绘制数据或效果相关的，使用 draw 前缀标识，例如 drawText</p><h3 id="避免单个字符名，让你的变量名有描述意义。"><a href="#避免单个字符名，让你的变量名有描述意义。" class="headerlink" title="避免单个字符名，让你的变量名有描述意义。"></a>避免单个字符名，让你的变量名有描述意义。</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">q</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">// ..stuff..</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="当命名对象、函数和实例时使用驼峰命名规则"><a href="#当命名对象、函数和实例时使用驼峰命名规则" class="headerlink" title="当命名对象、函数和实例时使用驼峰命名规则"></a>当命名对象、函数和实例时使用驼峰命名规则</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> OBJEcttsssss = {};</span><br><span class="line"><span class="keyword">var</span> this_is_my_object = {};</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">this</span>-is-my-object = {};</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>{};</span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> user({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'Bob Parr'</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> thisIsMyObject = {};</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisIsMyFunction</span>(<span class="params"></span>) </span>{};</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'Bob Parr'</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h1 id="浏览器中运行js"><a href="#浏览器中运行js" class="headerlink" title="浏览器中运行js"></a>浏览器中运行js</h1><p>Chrome浏览器运行环境包括V8引擎，内置API<br>  V8引擎负责解析和执行js代码<br>  内置API是由运行环境提供的特殊接口</p><h1 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h1><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。电脑安装了Node.js后， Node.js 相当于浏览器，也可以在里面运行 JavaScript 了！</p><h2 id="Nodejs的组成："><a href="#Nodejs的组成：" class="headerlink" title="Nodejs的组成："></a>Nodejs的组成：</h2><p>ECMAScript(语言基础，如：语法、数据类型结构以及一些内置对象)</p><p>os(操作系统)</p><p>file(文件系统)</p><p>net(网络系统)</p><p>database(数据库)</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://nodejs.org/en/">Node.js下载地址</a></p><p>打开cmd输入命令检查是否安装成功：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v  #查看node版本</span><br><span class="line">npm -v   #查看npm版本</span><br></pre></td></tr></tbody></table></figure><p>Node.js 安装成功时也默认安装了 npm， npm 是随 Node.js 一起被安装的包管理工具，你可以理解成 Node.js 自带的应用商店。是用来安装/卸载Node.js需要装的东西</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>1.修改全局模块路径和缓存路径<br>当我们在执行<code>npm install express -g</code>命令时，会默认下载到c盘，更改下载盘<br>在nodejs安装目录下创建创建两个文件夹，名称分别为：node_global(全局模块)和node_cache(缓存)，在node_global文件夹下再建一个node_modules文件夹，配置环境变量用</p><p>2.win+R打开运行窗口，输入cmd，再输入以下两条指令<br>npm config set prefix “创建的node_global文件夹所在路径”<br>npm config set cache “创建的node_cache文件夹所在路径”</p><p>3.修改完毕后，再配置环境变量<br>右键此电脑——&gt;高级系统设置——&gt;环境变量<br>在系统变量中，新建，变量名：NODE_PATH<br>变量值：node_global文件夹下的node_modules文件夹。如：E:\develop\nodejs\node_global\node_modules</p><p>修改用户变量中的Path变量，将默认的npm路径修改为新建的node_global路径<br>如：D:\ruanjian\nodejs\node_global</p><h2 id="nodejs执行js代码"><a href="#nodejs执行js代码" class="headerlink" title="nodejs执行js代码"></a>nodejs执行js代码</h2><h3 id="命令行运行nodejs文件"><a href="#命令行运行nodejs文件" class="headerlink" title="命令行运行nodejs文件"></a>命令行运行nodejs文件</h3><p>打开命令行窗口，把当前目录切换到.js所在目录  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node 文件名.js</span><br></pre></td></tr></tbody></table></figure><h3 id="vscode搭建node开发环境"><a href="#vscode搭建node开发环境" class="headerlink" title="vscode搭建node开发环境"></a>vscode搭建node开发环境</h3><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p><a href="https://yafine-blog.cn/posts/8094.html">参考</a><br>npm (node package manager) 是 JavaScript 世界的包管理工具，是 Node.js 平台的默认包管理工具，简单地说，就是通过 npm 下载模块，复用已有的代码，提高工作效率。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>npm 由三个独立的部分组成：</p><ul><li>网站</li><li>注册表（registry）</li><li>命令行工具 (CLI)</li></ul><p><a href="https://www.npmjs.com/">网站</a> 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。</p><p>注册表 是一个巨大的数据库，保存了每个包（package）的信息。</p><p>CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。<br> <a href="https://www.axihe.com/api/npm/api/api.html">npm中文文档</a> </p><h3 id="切换为-taobao-镜像源"><a href="#切换为-taobao-镜像源" class="headerlink" title="切换为 taobao 镜像源"></a>切换为 taobao 镜像源</h3><p>国内使用 npm 可能很慢。你可以考虑切换为 taobao 镜像源。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></tbody></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">npm uninstall</span><br><span class="line"><span class="comment"># 清理缓存</span></span><br><span class="line">npm cache clean -f</span><br></pre></td></tr></tbody></table></figure><h2 id="cnpm-是什么？"><a href="#cnpm-是什么？" class="headerlink" title="cnpm 是什么？"></a>cnpm 是什么？</h2><p>简单的讲就是中国版的 NPM，因为 npm 安装插件是从国外服务器下载，受网络影响大，可能出现异常，<br>需要安装 cnpm 模块，命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></tbody></table></figure><p>cnpm 支持可以使用支持 npm 除 publish 之外的所有命令。</p><p>因为 cnpm 的仓库只是 npm 仓库的一个拷贝，它不承担 publish 工作，所以执行 cnpm publish 命令会失败的。</p><h2 id="yarn-是什么？"><a href="#yarn-是什么？" class="headerlink" title="yarn 是什么？"></a>yarn 是什么？</h2><p>Yarn 是一个软件包管理器，还可以作为项目管理工具，你可以通过它使用全世界开发者的代码， 或者分享自己的代码。</p><p>从 npm 安装软件包并保持相同的包管理流程。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1.速度超快。<br>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。</p><p>2.超级安全<br>在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。</p><p>3.超级可靠<br>使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。<br>通过命令安装</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></tbody></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>yarn init：初始化项目，会在根目录下生成一个 package.json，与 npm 类似具体不做解释</p><p>yarn add <package name="">：安装依赖包，会自动安装最新版本，会覆盖指定版本号</package></p><p>yarn add <package name1=""> <package name1="">：一次性添加多个包</package></package></p><p>yarn add <package name="">@version：添加指定版本的包</package></p><p>yarn upgrade <package name="">@version：将包更新到指定版本</package></p><p>yarn upgrade –latest <package name="">：将包更新到最新版本</package></p><p>yarn remove <package name="">：删除包</package></p><p>yarn remove <package name1=""> <package name2="">：一次性删除多个包</package></package></p><p>yarn info <packagename> ：可以用来查看某个模块的最新版本信息</packagename></p><p>yarn install：安装 package.json 里所有包，并将包及它的所有依赖项保存进 yarn.lock</p><p>yarn install –force ：强制重新下载所有包</p><p>yarn install –flat：安装一个包的单一版本</p><p>yarn install –production：只安装 dependencies 里的包</p><p>yarn install –no-lockfile：不读取或生成 yarn.lock</p><p>yarn install –pure-lockfile：不生成 yarn.lock</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>安装npm模块时，没有权限<br>解决方法：打开nodejs安装目录的属性把权限全部勾上 </p><p>npm的包安装分为本地安装（local）、全局安装（global）两种<br> 本地安装: npm install xxx 安装到命令行所在目录的node_module目录。<br> 全局安装: npm install xxx -g 安装到 \AppData\Roaming\npm\node_modules目录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js&quot;&gt;&lt;a href=&quot;#js&quot; class=&quot;headerlink&quot; title=&quot;js&quot;&gt;&lt;/a&gt;js&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/yashujs/bfug6u/ntxhzu#cc4dd1da&quot;&gt;https:/</summary>
      
    
    
    
    <category term="前端" scheme="https://wenkex.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://wenkex.gitee.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>计算机原理</title>
    <link href="https://wenkex.gitee.io/2022/051717870.html"/>
    <id>https://wenkex.gitee.io/2022/051717870.html</id>
    <published>2022-05-17T03:07:09.000Z</published>
    <updated>2022-05-17T03:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><p>作为用户与计算机硬件之间的接口</p><h3 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h3><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些服务，主要包括命令接口和程序接口</p><h4 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h4><p>允许用户直接使用<br><strong>交互式命令接口</strong><br>cmd<br>联机命令接口=交互式命令接口：用户说一句，系统做一件</p><p><strong>批处理命令接口</strong><br>脱机命令接口=批处理命令接口：用户说一堆，系统做一堆</p><h4 id="系统调用-程序接口"><a href="#系统调用-程序接口" class="headerlink" title="系统调用(程序接口)"></a>系统调用(程序接口)</h4><p>允许用户通过程序间接使用<br>用户进程想要使用硬件资源，只能通过系统调用向操作系统发出请求，操作系统会对各个请求进行协调管理</p><h4 id="GUI图形用户界面"><a href="#GUI图形用户界面" class="headerlink" title="GUI图形用户界面"></a>GUI图形用户界面</h4><h2 id="并发："><a href="#并发：" class="headerlink" title="并发："></a>并发：</h2><p>并发指两个或者多个事件同一时间间隔内发生。这些事件在宏观上是同时发生的，但在微观上是交替发生。</p><p>并行：指两个或者多个事件同一时刻同时发生。</p><h2 id="共享："><a href="#共享：" class="headerlink" title="共享："></a>共享：</h2><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p><strong>两种资源共享方式：</strong></p><p>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段<br>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程”同时”对其进行访问<br>        所谓的”同时”往往是指宏观上的，而为微观上，这些进程可能是交替地对该资源进行访问（即分时共享）。</p><p><strong>并发和共享的关系：</strong></p><p>并发性：指计算机系统中同时存在着多个运行着的程序。<br>共享性：指系统中的资源可以提供给内存中多个并发执行的进程共同使用。<br>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义。<br>如果失去共享性，则多个程序进程不能同时访问硬盘资源，就无法同时对硬盘中的数据进行操作，也就无法并发。</p><h2 id="进程与进程管理"><a href="#进程与进程管理" class="headerlink" title="进程与进程管理"></a>进程与进程管理</h2><p>引入进程的<strong>作用</strong>：为了方便操作系统管理，完成各个程序并发执行<br><strong>程序</strong>：就是一个指令序列！ </p><p><strong>进程的构成</strong><br>程序段：程序的代码存放的内存空间<br>数据段：程序运行过程中处理的数据存放的内存空间<br>PCB：称为进程控制块（PCB），用来描述进程的各种信息（如程序代码存放位置）PCB是进程存在的唯一标志</p><p>程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程。例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。注意：PCB是进程存在的唯一标志！</p><p>从不同的角度，<strong>进程</strong>可以有不同的定义，比较传统典型的定义有：<br>  进程是程序的一次执行过程。执行前需要将该程序放到内存中，才能够被CPU处理<br>  进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>  进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p><p>引用进程实体的概念后，可把进程定义为：<br>  进程是进程实体的运行过程，是系统进程资源分配和调度的一个独立单位。<br>  严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。</p><h3 id="进程特性"><a href="#进程特性" class="headerlink" title="进程特性"></a>进程特性</h3><p>进程的异步性：并发执行的进程以各自独立的、不可预知的速度向前推进</p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制相关的原语：创建、终止、阻塞、唤醒、切换。也就是说我们通过原语进行进程控制，原语的执行具有原子性，不允许被中断，原语的实现可以通过“关中断指令”和“开中断指令”实现。</p><p>进程状态：运行态，就绪态，阻塞态</p><p>进程状态转换的条件：</p><p>  运行 -&gt; 阻塞 等待I/O或事件完成</p><p>  运行 -&gt; 就绪 进程的CPU时间片用完</p><p>  就绪 -&gt; 运行 获得了CPU的时间片</p><p>  阻塞 -&gt; 就绪 I/O或事件完成</p><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><p><a href="https://blog.csdn.net/weixin_46013401/article/details/110819774">https://blog.csdn.net/weixin_46013401/article/details/110819774</a></p><p>1.先来先服务（FCFS）算法：按到达的先后顺序</p><p>2.短作业优先算法：选择当前已到达的，且运行时间最短的进程</p><p>3.优先级调度算法：</p><h3 id="各种时间"><a href="#各种时间" class="headerlink" title="各种时间"></a>各种时间</h3><p>周转时间：作业被提交给系统开始，到作业完成为止的这段时间间隔。<br>包括：（1）作业在外存后备队列上的等待作业调度的时间。（2）进程在就绪队列上等待进程调度的时间。（3）进程在CPU上执行的时间。（4）进程等待IO操作完成的时间（阻塞队列中等待时间）。<br><strong>公式</strong><br>等待时间=周转时间-运行时间<br>周转时间=等待时间+运行时间=完成时间-到达时间</p><p>平均周转时间=各个作业周转时间之和/作业数</p><p>带权周转时间=作业周转时间/作业实际运行时间</p><p>平均带权周转时间=各个作业带权周转时间之和/作业数</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。</p><h3 id="死锁的概念与处理"><a href="#死锁的概念与处理" class="headerlink" title="死锁的概念与处理"></a>死锁的概念与处理</h3><p><strong>死锁的4个条件</strong>，缺一不可</p><p>互斥条件：对必须互斥使用的资源的争抢才会导致死锁</p><p>不剥夺条件：进程所获得的资源未使用完之前，不能被其他进程强行夺走，只能主动释放。</p><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己有的资源保持不放。就像很窄的桥，两个人都要去对面，但谁又都无法让出位置来</p><p>循环等待条件：存在一种进程资源的循环等待，链中的每一个进程已获得的资源同时被下一个进程所请求。想象有一个闭环，闭环上每个人都需要下一个人手上的某个资源，那么所有人都没办法满足</p><p><strong>死锁预防</strong></p><p>破坏互斥条件(创建一个队列，所有的请求都会被快速响应，然后队列逐渐将请求发送到处理器进行整理)</p><p>破坏不剥夺条件(进程的某个资源得不到满足时，就必须立刻释放所持有的资源)</p><p>破坏请求和保持条件(静态分配，进程在运行前就一次性申请全部的资源，不满足就不让允许，就像过桥时保证桥上没人才让通行，否则禁止通行)</p><p>破坏循环等待条件(资源编号，进程必须按照编号递增的顺序请求资源,这样就不会出现持有大资源请求小资源的情况，也就不会有循环的等待)</p><p>(方式较多，这里简单列举一些案例)</p><p><strong>死锁避免</strong></p><p>银行家算法：进程提出资源申请时，先判断这次分配会不会导致系统进入不安全状态，如果会则不答应请求，让该进程阻塞。简而言之，请求不能大于手中的资源。这种算法也叫银行家算法。</p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p><strong>原语</strong>：是一种特殊的程序段。其执行只能一气呵成，不可被中断<br>用户进程通过使用操作系统提供的一对原语来对信号量进行操作，从而实现对进程互斥，进程同步</p><p>信号量其实是一个变量，用一个信号量来表示系统中某种资源的数量<br>对信号量的操作只有三种(初始化，P操作，V操作)</p><p>整型信号量:<br>记录型信号量</p><h3 id="进程同步和进程互斥"><a href="#进程同步和进程互斥" class="headerlink" title="进程同步和进程互斥"></a>进程同步和进程互斥</h3><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>1.管道（pipe）及有名管道（named pipe）：</p><p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>2.信号（signal）：</p><p>  信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>3.消息队列（message queue）：</p><p>消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。       </p><p>其基本思想是:根据”生产者-消费者”原理,利用内存中公用消息缓冲区实现进程之间的信息交换.  </p><p>内存中开辟了若干消息缓冲区,用以存放消息.每当一个进程向另一个进程发送消息时,便申请一个消息缓冲区,并把已准备好的消息送到缓冲区,然后把该消息缓冲区插入到接收进程的消息队列中,最后通知接收进程.接收进程收到发送里程发来的通知后,从本进程的消息队列中摘下一消息缓冲区,取出所需的信息,然后把消息缓冲区不定期给系统.系统负责管理公用消息缓冲区以及消息的传递.<br>一个进程可以给若干个进程发送消息,反之,一个进程可以接收不同进程发来的消息.显然,进程中关于消息队列的操作是临界区.当发送进程正往接收进程的消息队列中添加一条消息时,接收进程不能同时从该消息队列中到出消息:反之也一样.<br>4.共享内存（shared memory）：</p><p>  可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p><p>这种通信模式需要解决两个问题：第一个问题是怎样提供共享内存；第二个是公共内存的互斥关系则是程序开发人员的责任。   </p><p>5.信号量（semaphore）：</p><p>  主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。</p><p>6.套接字（socket）；</p><p>  套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><p>中断机制实现了多道程序并发执行，<br>发生中断意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配i/o设备）需要特权指令，中断使cpu从用户态转换到核心态。并且是唯一途径</p><p><strong>内中断(异常)</strong><br>内中断也称为异常，例外，陷入</p><p><strong>外中断</strong>：信号来源于cpu外部，于当前指令无关</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁（Deadlock）：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。称此时系统处于死锁状态或系统产生了死锁。<br>称这些永远在互相等待的进程为死锁进程。</p><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><h3 id="固定分区存储管理"><a href="#固定分区存储管理" class="headerlink" title="固定分区存储管理"></a>固定分区存储管理</h3><h3 id="可变分区存储管理"><a href="#可变分区存储管理" class="headerlink" title="可变分区存储管理"></a>可变分区存储管理</h3><h3 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h3><h2 id="磁盘移臂调度"><a href="#磁盘移臂调度" class="headerlink" title="磁盘移臂调度"></a>磁盘移臂调度</h2><p>磁盘移臂调度的目的是尽可能地减少输入输出操作中的寻找时间。<br>常用的移臂调度算法有：① 先来先服务算法② 最短寻找时间优先算法③ 电梯调度算法④ 单向扫描算法。</p><h2 id="I-O-控制方式"><a href="#I-O-控制方式" class="headerlink" title="I/O 控制方式"></a>I/O 控制方式</h2><p>①程序I/O控制方式:适用于结构简单，只需少量硬件的电路；<br>②中断驱动I/O控制方式：适用于高效场合；<br>③直接存储访问DMA I/O控制方式：适用于无须CPU介入的控制器来控制内存与外设之间的数据交流的场合；</p><p>④I/O通道控制方式：适用于以字节为单位的干预，同时实现CPU，通道和I/O设备三者并行操作的场合。<br>—- I/O通道控制方式是对DMA控制方式的发展，它进一步使CPU参与到数据传输的控制减少，即把对一个数据块的读/写为单位的干预，减少为对一组数据块的读/写及有关的控制和管理为单位的干预。同时，又可实现CPU、通道和I/O设备的并行操作，从而更有效地提高整个系统的资源利用率。在通道控制方式中，CPU只需发出启动指令，指出要求通道执行的操作和使用的I/O设备，该指令就可以启动通道并使该通道从内存中调出相应的通道程序执行。</p><h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><p>在计算机中任意数据都是以二进制的形式来储存的</p><h2 id="任意进制转十进制"><a href="#任意进制转十进制" class="headerlink" title="任意进制转十进制"></a>任意进制转十进制</h2><p>系数*基数的权次幂 相加<br>基数：当前机制数<br>权：从左到右依次是0，1，2，3</p><h3 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h3><p>8421快速转换法：<br>每一位二进制值的1都代表一个固定数值，把每一位的1代表的十进制数加起来的结果就是所代表的十进制数<br>记住 256      128      64       32      16      8        4         2         1</p><p>01111101<br>先写上 ：  0         1         1       1         1         1          0          1<br>然后填充   128      64        32       16        8          4          2          1<br>十进制为 64+32+16+8+4+1=125</p><h2 id="十进制转其他进制"><a href="#十进制转其他进制" class="headerlink" title="十进制转其他进制"></a>十进制转其他进制</h2><p>除基取余法：不断的除以基数,得到余数，知道商为0，再将余数倒着拼起来即为所求进制数</p><p>注意16进制A<del>F表示10</del>15</p><h1 id="路径相关"><a href="#路径相关" class="headerlink" title="路径相关"></a>路径相关</h1><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h1 id="图像相关"><a href="#图像相关" class="headerlink" title="图像相关"></a>图像相关</h1><p>我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。</p><table><thead><tr><th align="center">名称</th><th align="center">RGBA值</th><th align="center">名称</th><th align="center">RGBA值</th></tr></thead><tbody><tr><td align="center">White</td><td align="center">(255, 255, 255, 255)</td><td align="center">Red</td><td align="center">(255, 0, 0, 255)</td></tr><tr><td align="center">Green</td><td align="center">(0, 255, 0, 255)</td><td align="center">Blue</td><td align="center">(0, 0, 255, 255)</td></tr><tr><td align="center">Gray</td><td align="center">(128, 128, 128, 255)</td><td align="center">Yellow</td><td align="center">(255, 255, 0, 255)</td></tr><tr><td align="center">Black</td><td align="center">(0, 0, 0, 255)</td><td align="center">Purple</td><td align="center">(128, 0, 128, 255)</td></tr></tbody></table><ol start="2"><li>像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3>例如，屏幕分辨率是1024×768，也就是说设备屏幕的水平方向上有1024个像素点，垂直方向上有768个像素点。像素的大小是没有固定长度的，不同设备上一<br>个单位像素色块的大小是不一样的。<br>例如，尺寸面积大小相同的两块屏幕，分辨率大小可以是不一样的，</li></ol><p>分辨率高的屏幕上面像素点（色块）就多，所以屏幕内可以展示的画面就更细致，单个色<br>块面积更小。</p><p>分辨率低的屏幕上像素点（色块）更少，单个像素面积更大，可以显示的画面就没那么细致。</p><h3 id="图像分辨率"><a href="#图像分辨率" class="headerlink" title="图像分辨率"></a>图像分辨率</h3><p>例如，一张图片分辨率是500x200,也就是说这张图片在屏幕上按1:1放大时，水平方向有500个像素点（色块），垂直方向有200个像素点（色块）。</p><p>在同一台设备上，图片分辨率越高，这张图片1:1放大时，图片面积越大；图片分辨率越低，这张图片1:1缩放时，图片面积越小。（可以理解为图片的像素点和<br>屏幕的像素点是一个一个对应的）。</p><p>但是，在屏幕上把图片超过100%放大时，为什么图片上像素色块也变的越大，其实是设备通过算法对图像进行了像素补足，我们把图片放的很大后看到的一块<br>一块的方格子，虽然理解为一个图像像素，但是其实是已经补充了很多个屏幕像素；同理，把图片小于100%缩小时，也是通过算法将图片像素进行减少。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机操作系统&quot;&gt;&lt;a href=&quot;#计算机操作系统&quot; class=&quot;headerlink&quot; title=&quot;计算机操作系统&quot;&gt;&lt;/a&gt;计算机操作系统&lt;/h1&gt;&lt;h2 id=&quot;操作系统的功能和目标&quot;&gt;&lt;a href=&quot;#操作系统的功能和目标&quot; class=&quot;head</summary>
      
    
    
    
    <category term="学习" scheme="https://wenkex.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="知识" scheme="https://wenkex.gitee.io/tags/%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习</title>
    <link href="https://wenkex.gitee.io/2022/050513105.html"/>
    <id>https://wenkex.gitee.io/2022/050513105.html</id>
    <published>2022-05-05T00:53:39.000Z</published>
    <updated>2022-05-05T00:53:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><a href="https://deerchao.net/tutorials/regex/regex.htm">《正则表达式30分钟入门教程》</a></p><p>正则表达式是一种工具<br>验证字符串是否与指定模式匹配(例如，字符串具有电子邮件地址的格式)<br>在字符串中执行替换(例如，将所有美国拼写更改为英国拼写)。</p><p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.匹配除换行符 (\n)以外的任意字符</span><br><span class="line">\w匹配字母或数字或下划线或汉字</span><br><span class="line"></span><br><span class="line">\b匹配单词的开始或结束，只匹配一个位置。</span><br><span class="line"></span><br><span class="line">"/" 是表达式开始和结束的标记</span><br><span class="line"></span><br><span class="line">^ 脱字符表示字符串的开始</span><br><span class="line">$表示字符串的结束</span><br><span class="line">\w匹配字母/数字/下划线</span><br><span class="line">\W匹配非字母/非数字/非下划线</span><br><span class="line">[]匹配来自括号内字符集的任意单一字符</span><br><span class="line">[^]匹配不在字符集中的任意单一字符，^在[]表示取反</span><br><span class="line">\d匹配数字</span><br><span class="line">\s匹配空白字符（包括\r、\n、\t等）</span><br></pre></td></tr></tbody></table></figure><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*重复零次或更多次</span><br><span class="line">+重复一次或更多次</span><br><span class="line">?重复零次或一次</span><br><span class="line">{n}重复n次</span><br><span class="line">{n,}重复n次或更多次</span><br><span class="line">{n,m}重复n到m次</span><br></pre></td></tr></tbody></table></figure><p>当?    字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串<br>而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</p><blockquote><p><strong>说明：</strong> 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则<strong>圆括号被视为正则表达式中的分组。</strong></p></blockquote><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><strong>从高到底</strong><br>\    转义符<br>(), (?:), (?=), []    圆括号和方括号<br>*, +, ?, {n}, {n,}, {n,m}    限定符<br>^, $, \任何元字符、任何字符    定位点和序列（即：位置和顺序）<br>|    替换，”或”操作字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>从浏览器拷贝出来请求头后， 需要手动的一个个加引号和逗号。现在我们利用Pycharm来进行批量替换。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: read_mode=day; default_font=font2; locale=zh-CN; remember_user_token=W1231sxMzYwNzkwMF0sIiQyYSQxMSRnNVl5MWpmZ0JINXJVazFreXlzQ0V1IiwiMTU0MDI1NTAzNS4xMDE5NDAyIl0%3D--10326e210f857747d9a7c9ace127cab6cdf8d947e; Hm_lvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1540276756,1540284104,1540301802,1540371744; _m7e_session=dbf3985c991afa4c90bb79228626ed6e; Hm_lpvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1540453366; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221663393b621590-01c145ebcced4d-8383268-2073600-1663393b62272c%22%2C%22%24device_id%22%3A%221663393b621590-01c145ebcced4d-8383268-2073600-1663393b62272c%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E8%87%AA%E7%84%B6%E6%90%9C%E7%B4%A2%E6%B5%81%E9%87%8F%22%2C%22%24latest_referrer%22%3A%22https%3A%2F%2Fwww.baidu.com%2Flink%22%2C%22%24latest_referrer_host%22%3A%22www.baidu.com%22%2C%22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC%22%2C%22%24latest_utm_source%22%3A%22desktop%22%2C%22%24latest_utm_medium%22%3A%22not-signed-in-like-button%22%2C%22%24latest_utm_campaign%22%3A%22maleskine%22%2C%22%24latest_utm_content%22%3A%22note%22%7D%2C%22first_id%22%3A%22%22%7D</span><br><span class="line">Host: www.jianshu.com</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Referer: https://www.jianshu.com/c/068668542235</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">勾选Regex使用正则来对数据进行匹配批量修改</span><br><span class="line">//利用冒号做分割</span><br><span class="line">正则表达式：(.*?): ?(.*)</span><br><span class="line">//给冒号两边的数据都加上单引号， 并且在末尾增加逗号</span><br><span class="line">//$1表示第一组</span><br><span class="line">需要替换成：'$1':'$2',    </span><br></pre></td></tr></tbody></table></figure><h1 id="js的正则"><a href="#js的正则" class="headerlink" title="js的正则"></a>js的正则</h1><p>exec    一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。</p><p>matchAll    一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。</p><p>search    一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。</p><p>replace    一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。</p><p>split    一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。</p><h2 id="match-方法"><a href="#match-方法" class="headerlink" title="match()方法"></a>match()方法</h2><p>stringObj.match(regExp)<br>一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。<br>    stringObj是必选项，对其进行查找的string对象或字符串文字；<br>    regExp是必选项，为包含正则表达式模式和可用标志的正则表达式对象。</p><h2 id="test-方法"><a href="#test-方法" class="headerlink" title="test()方法"></a>test()方法</h2><p>一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。<br>RegExpObject.test(string)<br>    string是必需。要检测的字符串。</p><h1 id="python的re正则模块"><a href="#python的re正则模块" class="headerlink" title="python的re正则模块"></a>python的re正则模块</h1><p>Python提供了re模块来支持正则表达式相关操作</p><h2 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h2><p>pattern : 一个字符串形式的正则表达式 </p><p>string : 要匹配的内容</p><p>flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：<br>  re.I 忽略大小写<br>  re.L 表示特殊字符集 w, W, 方形, B, s, S 依赖于当前环境<br>  re.M 多行模式<br>  re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）<br>  re.U 表示特殊字符集 w, W,方形, B, d, D, s, S 依赖于 Unicode 字符属性数据库<br>  re.X 为了增加可读性，忽略空格和 # 后面的注释<br>如果需要为flags参数指定多个值，可以使用<a href="http://www.runoob.com/python/python-operators.html#ysf5">按位或运算符</a>进行叠加，如<code>flags=re.I | re.M</code>。</p><h2 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile()"></a>re.compile()</h2><p>re.compile(pattern, flags=0)<br>将正则表达式转化为对象。需要和findall(), search(), match(）搭配使用</p><p>re.search(pattern, string)的调用方式就转换为 pattern.search(string)的调用方式，多次调用一个正则表达式就重复利用这个正则对象，可以实现更有效率的匹配   </p><h2 id="返回Match-object"><a href="#返回Match-object" class="headerlink" title="返回Match object"></a>返回Match object</h2><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search()"></a>re.search()</h3><p>search(pattern, string, flags=0)<br>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象(Match object) 否则返回None<br>    pattern: 匹配的规则,<br>    string : 要匹配的内容<br>    flags : 可选，表示匹配模式，</p><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match()"></a>re.match()</h3><p>必须从字符串开头匹配,如果不是起始位置匹配成功的话，match()就返回none<br>    match函数的第一个参数是正则表达式字符串或正则表达式对象<br>    第二个参数是要跟正则表达式做匹配的字符串对象   </p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户名必须由字母、数字或下划线构成且长度在6~20个字符之间</span></span><br><span class="line">m1 = re.match(<span class="string">r'^[0-9a-zA-Z_]{6,20}$'</span>, username)</span><br><span class="line"><span class="comment"># QQ号是5~12的数字且首位不能为0</span></span><br><span class="line">m2 = re.match(<span class="string">r'^[1-9]\d{4,11}$'</span>, qq)</span><br><span class="line">```   </span><br><span class="line">&gt; **提示：** 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\\\，例如表示数字的\\d得书写成\\\\d，这样不仅写起来不方便，阅读的时候也会很吃力。</span><br><span class="line"></span><br><span class="line"><span class="comment">### re.fullmatch()  </span></span><br><span class="line">re.fullmatch(pattern, string, flags=<span class="number">0</span>)        </span><br><span class="line"> match函数的完全匹配（从字符串开头到结尾）版本   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### .group()</span></span><br><span class="line">```py</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">"abc123def"</span></span><br><span class="line">rex_compile = re.<span class="built_in">compile</span>(<span class="string">"([a-z]*)([0-9]*)([a-z]*)"</span>)</span><br><span class="line">rex = rex_compile.search(content)</span><br><span class="line"><span class="built_in">print</span>(rex.group(<span class="number">0</span>))  <span class="comment"># group()和group(0) 一样匹配的是整体</span></span><br><span class="line"><span class="built_in">print</span>(rex.group(<span class="number">1</span>))  <span class="comment"># 匹配第一个小括号的内容  abc</span></span><br><span class="line"><span class="built_in">print</span>(rex.group(<span class="number">2</span>))  <span class="comment"># 匹配第二个小括号的内容   123</span></span><br></pre></td></tr></tbody></table></figure><h2 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h2><p>findall(pattern, string, flags=0)<br>查找字符串所有与正则表达式匹配的模式 返回字符串的列表  </p><h2 id="finditer-pattern-string-flags-0"><a href="#finditer-pattern-string-flags-0" class="headerlink" title="finditer(pattern, string, flags=0)"></a>finditer(pattern, string, flags=0)</h2><p>函数re.finditer与re.findall做同样的事情，只是它返回一个迭代器，而不是列表。<br>查找字符串所有与正则表达式匹配的模式 返回一个迭代器    </p><h2 id="split-pattern-string-maxsplit-0-flags-0"><a href="#split-pattern-string-maxsplit-0-flags-0" class="headerlink" title="split(pattern, string, maxsplit=0, flags=0)"></a>split(pattern, string, maxsplit=0, flags=0)</h2><p>用正则表达式指定的模式分隔符拆分字符串 返回列表        </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拆分长字符串</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    poem = <span class="string">'窗前明月光，疑是地上霜。举头望明月，低头思故乡。'</span></span><br><span class="line">    sentence_list = re.split(<span class="string">r'[，。, .]'</span>, poem)</span><br><span class="line">    <span class="built_in">print</span>(sentence_list)</span><br><span class="line">        <span class="comment"># 删除列表中的空字符串</span></span><br><span class="line">    <span class="keyword">while</span> <span class="string">''</span> <span class="keyword">in</span> sentence_list:</span><br><span class="line">        sentence_list.remove(<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>(sentence_list)  <span class="comment"># ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>re.sub(pattern, repl, string, count=0, flags=0)<br>用指定的字符串替换原字符串中与正则表达式匹配的模式 </p><p>  pattern : 正则中的模式字符串。<br>  repl : 替换的字符串，也可为一个函数。<br>  string : 要被查找替换的原始字符串。<br>  count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。<br>  flags : 编译时用的匹配模式，数字形式。</p><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><h3 id="查找字符串中有多少个af"><a href="#查找字符串中有多少个af" class="headerlink" title="查找字符串中有多少个af"></a>查找字符串中有多少个af</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找字符串中有多少个af</span></span><br><span class="line"><span class="keyword">import</span> re </span><br><span class="line">s = <span class="string">"asdfjvjadsffvaadfkfasaffdsasdffadsafafsafdadsfaafd"</span></span><br><span class="line"> </span><br><span class="line">ret = re.findall(<span class="string">r'(af)'</span> , s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ret))</span><br><span class="line">```  </span><br><span class="line"><span class="comment">### 提取国内手机号码。</span></span><br><span class="line">```Python, </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字</span></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r'(?&lt;=\D)1[34578]\d{9}(?=\D)'</span>)</span><br><span class="line">    sentence = <span class="string">'''</span></span><br><span class="line"><span class="string">    重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，</span></span><br><span class="line"><span class="string">    不是15600998765，也不是110或119，是不是13512346789，王大锤的手机号才是15600998765。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'查找所有匹配并保存到一个列表中'</span>)</span><br><span class="line">    mylist = re.findall(pattern, sentence)</span><br><span class="line">    <span class="built_in">print</span>(mylist)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'--------通过迭代器取出匹配对象并获得匹配的内容--------'</span>)</span><br><span class="line">    <span class="keyword">for</span> temp <span class="keyword">in</span> pattern.finditer(sentence):</span><br><span class="line">        <span class="built_in">print</span>(temp.group())</span><br><span class="line">    <span class="comment"># 搜索字符串中第一次出现正则表达式的模式 </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'--------通过search函数指定搜索位置找出所有匹配--------'</span>)</span><br><span class="line">    m = pattern.search(sentence)</span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        <span class="built_in">print</span>(m.group())</span><br><span class="line">        m = pattern.search(sentence, m.end())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>说明：</strong> 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：<code>(?&lt;=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)</code>，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。</p></blockquote><h3 id="替换字符串中的不良内容"><a href="#替换字符串中的不良内容" class="headerlink" title="替换字符串中的不良内容"></a>替换字符串中的不良内容</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    sentence = <span class="string">'你丫是傻叉吗? 我操你大爷的. Fuck you.'</span></span><br><span class="line">    purified = re.sub(<span class="string">'[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔'</span>,</span><br><span class="line">                      <span class="string">'*'</span>, sentence, flags=re.IGNORECASE)</span><br><span class="line">    <span class="built_in">print</span>(purified)  <span class="comment"># 你丫是*吗? 我*你大爷的. * you.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h3 id="按规则拆分长字符串"><a href="#按规则拆分长字符串" class="headerlink" title="按规则拆分长字符串"></a>按规则拆分长字符串</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    poem = <span class="string">'窗前明月光，疑是地上霜。举头望明月，低头思故乡。'</span></span><br><span class="line">    sentence_list = re.split(<span class="string">r'[，。, .]'</span>, poem)</span><br><span class="line">    <span class="built_in">print</span>(sentence_list)</span><br><span class="line">        <span class="comment"># 删除列表中的空字符串</span></span><br><span class="line">    <span class="keyword">while</span> <span class="string">''</span> <span class="keyword">in</span> sentence_list:</span><br><span class="line">        sentence_list.remove(<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>(sentence_list)  <span class="comment"># ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h1 id="正则表达式在线工具"><a href="#正则表达式在线工具" class="headerlink" title="正则表达式在线工具"></a>正则表达式在线工具</h1><p><a href="https://c.runoob.com/front-end/854/">https://c.runoob.com/front-end/854/</a></p><p><a href="https://deerchao.cn/tools/wegester/">https://deerchao.cn/tools/wegester/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://deerchao.net/tutorials/regex/regex.htm&quot;&gt;《</summary>
      
    
    
    
    <category term="工具" scheme="https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="正则" scheme="https://wenkex.gitee.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>数据库-SQLite</title>
    <link href="https://wenkex.gitee.io/2022/042334747.html"/>
    <id>https://wenkex.gitee.io/2022/042334747.html</id>
    <published>2022-04-23T08:35:42.000Z</published>
    <updated>2022-04-23T08:35:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h1><p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。</p><p>sql语句不区分大小写</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="SQLite-存储类"><a href="#SQLite-存储类" class="headerlink" title="SQLite 存储类"></a>SQLite 存储类</h3><p>每个存储在 SQLite 数据库中的值都具有以下存储类之一：</p><p>NULL    值是一个 NULL 值。<br>INTEGER    值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。<br>REAL    值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。<br>TEXT    值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。<br>BLOB    值是一个 blob 数据，完全根据它的输入存储。</p><p>SQLite 的存储类稍微比数据类型更普遍。INTEGER 存储类，例如，包含 6 种不同的不同长度的整数数据类型。</p><h3 id="SQLite-亲和-Affinity-类型"><a href="#SQLite-亲和-Affinity-类型" class="headerlink" title="SQLite 亲和(Affinity)类型"></a>SQLite 亲和(Affinity)类型</h3><p>SQLite支持列的亲和类型概念。任何列仍然可以存储任何类型的数据，当数据插入时，该字段的数据将会优先采用亲缘类型作为该值的存储方式。SQLite目前的版本支持以下五种亲缘类型：</p><p>亲和类型    描述<br>TEXT    数值型数据在被插入之前，需要先被转换为文本格式，之后再插入到目标字段中。<br>NUMERIC    当文本数据被插入到亲缘性为NUMERIC的字段中时，如果转换操作不会导致数据信息丢失以及完全可逆，那么SQLite就会将该文本数据转换为INTEGER或REAL类型的数据，如果转换失败，SQLite仍会以TEXT方式存储该数据。对于NULL或BLOB类型的新数据，SQLite将不做任何转换，直接以NULL或BLOB的方式存储该数据。需要额外说明的是，对于浮点格式的常量文本，如”30000.0”，如果该值可以转换为INTEGER同时又不会丢失数值信息，那么SQLite就会将其转换为INTEGER的存储方式。<br>INTEGER    对于亲缘类型为INTEGER的字段，其规则等同于NUMERIC，唯一差别是在执行CAST表达式时。<br>REAL    其规则基本等同于NUMERIC，唯一的差别是不会将”30000.0”这样的文本数据转换为INTEGER存储方式。<br>NONE    不做任何的转换，直接以该数据所属的数据类型进行存储。　　</p><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><h3 id="Insert-语句"><a href="#Insert-语句" class="headerlink" title="Insert 语句"></a>Insert 语句</h3><p>insert or replace：如果不存在就插入，存在就更新<br>insert or ignore：如果不存在就插入，存在就忽略</p><h3 id="Delete-语句"><a href="#Delete-语句" class="headerlink" title="Delete 语句"></a>Delete 语句</h3><h3 id="Update-语句"><a href="#Update-语句" class="headerlink" title="Update 语句"></a>Update 语句</h3><h3 id="Select-语句"><a href="#Select-语句" class="headerlink" title="Select 语句"></a>Select 语句</h3><h2 id="SQLite-Python接口"><a href="#SQLite-Python接口" class="headerlink" title="SQLite-Python接口"></a>SQLite-Python接口</h2><p>SQLite3 可使用 sqlite3 模块与 Python 进行集成</p><h3 id="connection对象"><a href="#connection对象" class="headerlink" title="connection对象"></a>connection对象</h3><p>sqlite3.connect(database [,timeout ,other optional arguments])<br>连接数据库，自动创建</p><p>返回一个连接对象。<br><strong>connection对象方法</strong><br>close()    关闭数据库连接<br>commit()    提交事务<br>rollback()    回滚数据库事务<br>cursor()    获得cursor游标对象</p><h3 id="cursor游标对象"><a href="#cursor游标对象" class="headerlink" title="cursor游标对象"></a>cursor游标对象</h3><p>connection.cursor([cursorClass])</p><p><strong>游标对象方法</strong><br>cursor.execute(sql [, optional parameters])<br>执行sql语句</p><p>cursor.executemany(sql, seq_of_parameters)<br>cursor.executescript(sql_script)</p><p><strong>获取游标的查询结果集</strong><br>cursor.fetchone()<br>返回结果集的下一行(Row对象)，返回一个序列，无数据时，则返回 None。</p><p>cursor.fetchmany([size=cursor.arraysize])<br>返回结果集的多行(Row对象列表)，返回一个列表。无数据时，则返回一个空的列表。该方法尝试获取由 size 参数指定的尽可能多的行。</p><p>cursor.fetchall()<br>返回结果集中所有（剩余）的行(Row对象列表)，返回一个列表。无数据时，则返回一个空的列表。</p><h3 id="创建表-1"><a href="#创建表-1" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">'test.db'</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"数据库打开成功"</span>)</span><br><span class="line">c = conn.cursor()</span><br><span class="line">c.execute(<span class="string">'''CREATE TABLE COMPANY</span></span><br><span class="line"><span class="string">       (ID INT PRIMARY KEY     NOT NULL,</span></span><br><span class="line"><span class="string">       NAME           TEXT    NOT NULL,</span></span><br><span class="line"><span class="string">       AGE            INT     NOT NULL,</span></span><br><span class="line"><span class="string">       ADDRESS        CHAR(50),</span></span><br><span class="line"><span class="string">       SALARY         REAL);'''</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"数据表创建成功"</span>)</span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></tbody></table></figure><h3 id="数据库的增删改查"><a href="#数据库的增删改查" class="headerlink" title="数据库的增删改查"></a>数据库的增删改查</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line">cursor.execute(<span class="string">'CREATE TABLE [exam] ([question] VARCHAR(80)  NULL,[Answer_A] VARCHAR(1)  NULL,[Answer_B] VARCHAR(1)  NULL,[Answer_C] VARCHAR(1)  NULL,[Answer_D] VARCHAR(1)  NULL,[right_Answer] VARCHAR(1)  NULL)'</span>)</span><br><span class="line"><span class="comment">#插入一条数据</span></span><br><span class="line">cursor.execute(<span class="string">"insert into exam (question, Answer_A,Answer_B,Answer_C,Answer_D,right_Answer) values ('哈雷慧星的平均周期为', '54年', '56年', '73年', '83年', 'C')"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入SQLite驱动:</span></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">path=<span class="string">'test.db'</span></span><br><span class="line">conn = sqlite3.connect(path) <span class="comment"># 建立数据库连接，返回一个连接对象。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"连接<span class="subst">{path}</span>数据库成功"</span>)</span><br><span class="line">cursor = conn.cursor()  <span class="comment">#创建游标对象</span></span><br><span class="line"></span><br><span class="line">cursor.close()  <span class="comment"># 关闭Cursor:</span></span><br><span class="line">conn.commit()   <span class="comment"># 提交事务:</span></span><br><span class="line">conn.close()   <span class="comment"># 关闭Connection:</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQLite&quot;&gt;&lt;a href=&quot;#SQLite&quot; class=&quot;headerlink&quot; title=&quot;SQLite&quot;&gt;&lt;/a&gt;SQLite&lt;/h1&gt;&lt;p&gt;SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个</summary>
      
    
    
    
    <category term="数据库" scheme="https://wenkex.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQLite" scheme="https://wenkex.gitee.io/tags/SQLite/"/>
    
  </entry>
  
  <entry>
    <title>web测试</title>
    <link href="https://wenkex.gitee.io/2022/04205354.html"/>
    <id>https://wenkex.gitee.io/2022/04205354.html</id>
    <published>2022-04-20T01:36:28.000Z</published>
    <updated>2022-04-20T01:36:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>抓包（packet capture）就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进行数据截取等。抓包的目的就是为了获取到想要的原始数据，拿到数据以后，我们就可以做以下一些事情:  </p><ol><li><p>分析数据传输协议。 </p></li><li><p>定位网络协议的问题。 </p></li><li><p>从数据包中获取想要的信息。 </p></li><li><p>将截取到的数据包进行修改，伪造，重发。</p><h2 id="为什么抓包？"><a href="#为什么抓包？" class="headerlink" title="为什么抓包？"></a>为什么抓包？</h2></li><li><p>从功能测试角度，通过抓包查看隐藏字段</p></li></ol><p>Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 CRSF 攻击，防网络爬虫，以及一些其他用途。这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。</p><ol start="2"><li>通过抓包工具了解协议内容，方便开展接口和性能测试</li></ol><p>性能测试方面，性能测试其实就是大量模拟用户的请求，所以我们必须要知道请求中的协议内容和特点，才能更好的模拟用户请求，分析协议就需要用到抓包工具；接口测试方面，在接口测试时，虽然我们尽量要求有完善的接口文档。但很多时候接口文档不可能覆盖所有的情况，或者因为文档滞后，在接口测试过程中，还时需要借助抓包工具来辅助我们进行接口测试。</p><ol start="3"><li>需要通过抓包工具，检查数据加密</li></ol><p>安全测试方面，我们需要检查敏感数据在传输过程中是否加密，也需要借助抓包工具才能检查。</p><ol start="4"><li>处理前后端 bug 归属之争</li></ol><p>在我们提交bug的时候，经常会出现前端（客户端展示）和后端（服务端的逻辑）的争议，那么可以通过抓包工具，确实是数据传递问题还是前端显示的问题。如果抓出来的数据就有问题的话，那么一般是后端的问题；如果抓出来的数据是正确的，那么基本上可以断定是前端显示的问题。</p><ol start="5"><li>通过抓包分析，可以更好的理解整个系统</li></ol><p>经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。</p><h2 id="浏览器抓包"><a href="#浏览器抓包" class="headerlink" title="浏览器抓包"></a>浏览器抓包</h2><p>最简单的抓包工具——浏览器开发者工具</p><h1 id="开放api"><a href="#开放api" class="headerlink" title="开放api"></a>开放api</h1><h2 id="API-Hub"><a href="#API-Hub" class="headerlink" title="API Hub"></a>API Hub</h2><h1 id="接口调试工具"><a href="#接口调试工具" class="headerlink" title="接口调试工具"></a>接口调试工具</h1><h2 id="Apifox"><a href="#Apifox" class="headerlink" title="Apifox"></a>Apifox</h2><p>API 文档、API 调试、API Mock、API 自动化测试</p><p>和市面上的老牌调试工具Postman相比，Apifox毫不逊色——Postman支持的功能它都能支持，并且Apifox还提供了支持可视化断言，连接数据库，调用外部函数与脚本，支持多种语言，环境变量设置等功能，调试起来也很快捷方便。</p><h2 id="postman接口测试"><a href="#postman接口测试" class="headerlink" title="postman接口测试"></a>postman接口测试</h2><p>responseCode ：包含请求的返回的状态信息(如：code)<br>responseBody：为接口请求放回的数据内容（类型为字符串）<br>tests ：为键值对形式，用于表示我们的测试结果是成功与否，最终展示在 Test Results 中。<br>key ：（如：code 200）我们可以用来当做结果的一个描述<br>value：其值为布尔型，ture 表示测试通过， false 表示测试失败。<br>所以上述代码应该不难理解了，而有了返回结果的数据以及表示结果成功与否</p><h2 id="预请求脚本-Pre-request-Script"><a href="#预请求脚本-Pre-request-Script" class="headerlink" title="(预请求脚本)Pre-request Script"></a>(预请求脚本)Pre-request Script</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;抓包&quot;&gt;&lt;a href=&quot;#抓包&quot; class=&quot;headerlink&quot; title=&quot;抓包&quot;&gt;&lt;/a&gt;抓包&lt;/h1&gt;&lt;p&gt;抓包（packet capture）就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进</summary>
      
    
    
    
    <category term="web" scheme="https://wenkex.gitee.io/categories/web/"/>
    
    
    <category term="postman" scheme="https://wenkex.gitee.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>数据库-redis</title>
    <link href="https://wenkex.gitee.io/2022/041918402.html"/>
    <id>https://wenkex.gitee.io/2022/041918402.html</id>
    <published>2022-04-19T01:23:48.000Z</published>
    <updated>2022-04-19T01:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p>Redis 是键值对(Key-Value)存储数据库，并提供多种语言的 API。</p><h1 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h1><h2 id="安装-Redis的docker环境"><a href="#安装-Redis的docker环境" class="headerlink" title="安装 Redis的docker环境"></a>安装 Redis的docker环境</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要确保docker环境已经安装成功</span></span><br><span class="line">docker --version</span><br><span class="line"></span><br><span class="line">docker search redis</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">拉取最新版本</span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d：使用指定的镜像在后台运行容器，（使用守护进程运行）通过 docker ps查看不到的。因为在 docker 中，后台服务必须要有一个前台服务才能运行（前台服务即使用 -it 选项启动的服务）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -it 表示已交互模式运行容器,为容器重新分配一个伪输入终端</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 6379:6379 将容器的6379端口映射到主机的6379端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --name=<span class="string">"myredis"</span> 表示自定义容器名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --requirepass <span class="string">"root"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v /docker/redis/data:/data: 将主机中当前目录下的data挂载到容器的/data</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-server : 在容器执行redis-server启动命令，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --appendonly yes  打开redis持久化配置</span></span><br><span class="line">docker run -d redis:latest -p 6379:6379  redis-server --appendonly yes --name="myredis" --requirepass "root"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker start 容器名或容器id</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入redis容器并启动一个redis交互式会话</span></span><br><span class="line">docker exec -it redis容器名 /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在redis交互式会话中连接 redis 服务</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理容器(停止 docker-redis 容器并删除)：</span></span><br><span class="line"></span><br><span class="line">docker stop redis容器名</span><br><span class="line">docker rm redis容器名</span><br></pre></td></tr></tbody></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis-cli  #在redis交互式会话中连接 redis 服务</span><br><span class="line"></span><br><span class="line">config get requirepass  #查看现有的redis密码</span><br><span class="line"></span><br><span class="line">config set requirepass pass_123456 #设置redis密码</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis&quot;&gt;&lt;a href=&quot;#redis&quot; class=&quot;headerlink&quot; title=&quot;redis&quot;&gt;&lt;/a&gt;redis&lt;/h1&gt;&lt;p&gt;Redis 是键值对(Key-Value)存储数据库，并提供多种语言的 API。&lt;/p&gt;
&lt;h1 id=&quot;安装-Re</summary>
      
    
    
    
    <category term="数据库" scheme="https://wenkex.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="redis" scheme="https://wenkex.gitee.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>springboot学习</title>
    <link href="https://wenkex.gitee.io/2022/040423525.html"/>
    <id>https://wenkex.gitee.io/2022/040423525.html</id>
    <published>2022-04-04T10:57:26.000Z</published>
    <updated>2022-04-04T10:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习框架首先要先了解它是干什么的，然后了解它的项目结构即每个文件有什么用</p><h1 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h1><p>springboot是一个用来简化spring应用的初始搭建以及开发过程的框架<br>简化依赖配置，简化常用工程相关配置，内置服务器</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>1.通过idea创建，可以更改成阿里云镜像服务：<a href="https://start.aliyun.com/">https://start.aliyun.com</a><br>spring默认服务器：<a href="https://start.spring.io/">https://start.spring.io</a></p><p>2.若idea不能联网，通过spring boot官网创建</p><h2 id="Druid连接池"><a href="#Druid连接池" class="headerlink" title="Druid连接池"></a>Druid连接池</h2><h3 id="数据源与数据库连接池"><a href="#数据源与数据库连接池" class="headerlink" title="数据源与数据库连接池"></a>数据源与数据库连接池</h3><h4 id="什么是数据源？"><a href="#什么是数据源？" class="headerlink" title="什么是数据源？"></a>什么是数据源？</h4><p>JDBC2.0提供了javax.sql.DataSource接口，它负责建立与数据库的连接，当在应用程序中访问数据库时，不必编写连接数据库的代码，直接引用DataSource获取数据库的连接对象即可。用于获取操作数据的Connection对象。</p><h4 id="什么是数据库连接池？"><a href="#什么是数据库连接池？" class="headerlink" title="什么是数据库连接池？"></a>什么是数据库连接池？</h4><p>数据库连接池的思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。可通过设定连接池的最大连接数来防止系统无尽的与数据库连接。更重要的是我们可以通过连接池的管理机制监视数据库的连接的数量、使用情况，为系统开发、测试以及性能调整提供依据。</p><h4 id="数据源和数据库连接池的关系？"><a href="#数据源和数据库连接池的关系？" class="headerlink" title="数据源和数据库连接池的关系？"></a>数据源和数据库连接池的关系？</h4><p>数据源建立多个数据库连接，这些数据库连接将会保存在数据库连接池中，当需要访问数据库时，只需要从数据库连接池中获取空闲的数据库连接，当程序访问数据库结束时，数据库连接会放回数据库连接池中。</p><h4 id="为什么要使用数据库连接池？"><a href="#为什么要使用数据库连接池？" class="headerlink" title="为什么要使用数据库连接池？"></a>为什么要使用数据库连接池？</h4><p>传统的JDBC访问数据库技术，每次访问数据库都需要通过数据库驱动器Driver和数据库名称以及密码等等资源建立数据库连接。</p><p>如此就会存在两大问题：</p><p>频繁的建立与断开数据库连接，会降低执行效率，增加系统资源的开销。<br>数据库的连接需要用户名和密码等资源，这些也需要一定的内存和CPU的开销。<br>而数据库连接池很好地解决了这些问题。</p><h3 id="加载依赖"><a href="#加载依赖" class="headerlink" title="加载依赖"></a>加载依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--log4j--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h2><p>数据库框架：Mybatis Plus &gt; Mybatis<br>代码生成器：Mybatis Plus Generator &gt; Mybatis Generator</p><p>Mybatis Plus 针对单表的基本CRUD操作，只需要创建好实体类，并创建一个继承自BaseMapper的接口即可，可谓非常简洁。并且，我们注意到，User类中的managerId，createTime属性，自动和数据库表中的manager_id，create_time对应了起来，这是因为mp自动做了数据库下划线命名，到Java类的驼峰命名之间的转化。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1.导入依赖<br>2.配置application.yml<br>3.在数据库中创建表<br>4.在entity层根据数据库表创建相应实体类<br>5.在dao层创建对应mapper接口<br>6.在SpringBoot启动类上配置mapper接口的扫描路径<br>7.编写一个SpringBoot测试类</p><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml  </span></span><br><span class="line">   <span class="attr">spring:</span>  </span><br><span class="line">     <span class="attr">datasource:</span>  </span><br><span class="line">       <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span>  </span><br><span class="line">       <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/数据库名?serverTimezone=Asia/Shanghai</span>  </span><br><span class="line">       <span class="attr">username:</span> <span class="string">root</span>  </span><br><span class="line">       <span class="attr">password:</span> <span class="string">root</span>  </span><br><span class="line">         </span><br><span class="line">   <span class="attr">mybatis-plus:</span>  </span><br><span class="line">     <span class="attr">configuration:</span>  </span><br><span class="line">       <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="comment">#开启SQL语句打印</span></span><br></pre></td></tr></tbody></table></figure><h3 id="mybatisplus分页工具类-IPage"><a href="#mybatisplus分页工具类-IPage" class="headerlink" title="mybatisplus分页工具类 IPage"></a>mybatisplus分页工具类 IPage</h3><h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><p>最常用的用法就是在实体类中使用它的@Data注解，这样实体类就不用写set、get、toString等方法</p><p>@Data注解包含了 @ToString、@EqualsAndHashCode、@Getter / @Setter和@RequiredArgsConstructor的功能</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a>REST风格</h2><p>REST(Representational State Transfer),表现形式状态转换。它是一种针对网络应用的设计风格</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.隐藏资源的访问行为，无法通过地址得知对资源是何种操作<br>2.书写简化</p><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>根据REST风格对资源进行访问称为RESTful</p><h6 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h6><p>类型：类注解<br>位置：springMVC控制器类定义上方<br>作用：设置当前控制器类为RESTful风格，等同于@Controller + @ResponseBody两个注解组合功能</p><h6 id="请求动作映射"><a href="#请求动作映射" class="headerlink" title="请求动作映射"></a>请求动作映射</h6><p>名称：@GetMapping   @PostMapping  @PutMapping  @DeleteMapping<br>类型：方法注解<br>位置：基于SpringMVC的RESTful开发控制器方法定义上方<br>作用：设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求</p><h6 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h6><p>类型：形参注解<br>位置：springMVC控制器方法形参定义前面<br>作用：绑定路径参数与处理器方法形参间的关系</p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>区别<br>@RequestParam用于接收url地址传参或表单传参<br>@RequestBody用于接收json数据<br>@PathVariable用于接收路径参数，使用{参数名称）描述路径参数</p><p>应用<br>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody,应用较广<br>如果发送非json格式数据，选用@RequestParam接收请求参数<br>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1.设定http请求动作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = "/users",method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(<span class="meta">@ResponseBody</span> User user)</span></span>{</span><br><span class="line">    System.out.println(<span class="string">"user save"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"{'module':'save'}"</span>;</span><br></pre></td></tr></tbody></table></figure><p>2.设定请求参数(路径变量)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径上要有参数占位{id}</span></span><br><span class="line"><span class="meta">@RequestMapping(value = "/users/{id}",method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// 在形参上加@PathVariable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>{</span><br><span class="line">    System.out.println(<span class="string">"user save"</span>+id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"{'module':'delete'}"</span>;</span><br></pre></td></tr></tbody></table></figure><p>controller调用service,service调用dao</p><h2 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h2><p>DAO(Data Access Object) 是数据访问层，也被称为mapper层。<br>即数据持久层，对数据做持久化操作。dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。</p><p>使用mybatis-plus后不用写mapper.xml文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dao/接口名.java</span></span><br><span class="line"><span class="comment">// 定义数据层接口与映射配置，继承BaseMapper&lt;把实体类作为泛型传入&gt;</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;实体类&gt; </span>{       </span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="entity层"><a href="#entity层" class="headerlink" title="entity层"></a>entity层</h2><p>即数据库实体层，也被称为model层，pojo层，domain层存放的是实体类，属性值与数据库中的属性值保持一致。 实现set和get方法。</p><p>一般数据库一张表对应一个实体类，类属性同表字段一一对应</p><p>使用了 Lombok 简化代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entity:</span></span><br><span class="line"><span class="meta">@TableName(value = "user")</span>  <span class="comment">//value指定表名</span></span><br><span class="line"><span class="meta">@Date</span>     <span class="comment">//使用Lombok插件，这样实体类就不用写set、get、toString等方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//value与数据库主键列名一致，若实体类属性名与表主键列名一致可省略value</span></span><br><span class="line">    <span class="meta">@TableId(value = "id", type = IdType.AUTO)</span>  <span class="comment">//指定自增策略</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">     <span class="comment">//若没有开启驼峰命名，或者表中列名不符合驼峰规则，可通过该注解指定数据库表中的列名，exist标明数据表中有没有对应列</span></span><br><span class="line">    <span class="meta">@TableField(value = "last_name",exist = true)</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">  </span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="业务层-service"><a href="#业务层-service" class="headerlink" title="业务层(service)"></a>业务层(service)</h2><p>业务层，service层的作用为完成功能设计。存放业务逻辑处理，不直接对数据库进行操作，有接口和接口实现类(定义一个接口，然后再一个或多个类去实现),提供controller层调用的方法。调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。（也就是说对于项目中的功能的需求就是在这里完成的）</p><h4 id="快速开发方案"><a href="#快速开发方案" class="headerlink" title="快速开发方案"></a>快速开发方案</h4><p>使用MyBatisPlus提供有业务层通用接口(ISerivce<t>)与业务层通用实现类(ServiceImpl&lt;M,T&gt;)<br>在通用类基础上做功能重载或功能追加<br>注意重载时不要覆盖原始操作，避免原始提供的功能丢失</t></p><h4 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h4><p>在java内的项目包下 新建 service包（一般接口都放在其中） 然后再其中新建XXXService接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于mybatisplus快速开发，ctrl+o查看mp帮你重写或覆盖的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookService</span> <span class="keyword">extends</span> <span class="title">IService</span> &lt;实体类&gt;</span>{ }</span><br></pre></td></tr></tbody></table></figure><h4 id="创建接口实现类"><a href="#创建接口实现类" class="headerlink" title="创建接口实现类"></a>创建接口实现类</h4><p>service 包内 新建 impl 包（实现类全部在impl包内）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// 继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类</span></span><br><span class="line"><span class="comment">// extends ServiceImpl&lt;BookDao,Book&gt;  //传入两个泛型(dao层,实体类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IBookServiceImpl</span>  <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">BookDao</span>,<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">IBookService</span> </span>{}</span><br></pre></td></tr></tbody></table></figure><h4 id="单元测试类"><a href="#单元测试类" class="headerlink" title="单元测试类"></a>单元测试类</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ke.bookm.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wenke</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> BookServiceTestCasde</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/4/7 20:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceTestCase</span> </span>{</span><br><span class="line">    <span class="comment">// 接口有多个实现类时使用@Qualifier注解指定实现类：</span></span><br><span class="line">    <span class="comment">// @Qualifier("qualifierServiceImpl2")</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testGetById</span><span class="params">()</span></span>{</span><br><span class="line">        bookService.getById(<span class="number">4</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="控制器层-controller"><a href="#控制器层-controller" class="headerlink" title="控制器层(controller)"></a>控制器层(controller)</h2><p>表现层，控制器层，controller层的功能为请求和响应控制。controller层负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端。</p><h3 id="Controller和-ResponseBody注解"><a href="#Controller和-ResponseBody注解" class="headerlink" title="@Controller和@ResponseBody注解"></a>@Controller和@ResponseBody注解</h3><p>在一个类上添加@Controller注解，表明了这个类是一个控制器类<br>在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面,若返回json等内容到页面，则需要加@ResponseBody注解</p><p>@ResponseBody表示方法的返回值直接以指定的格式写入Http response body中，而不是解析为跳转路径。<br>格式的转换是通过HttpMessageConverter中的方法实现的，因为它是一个接口，因此由其实现类完成转换。</p><h3 id="RestController-1"><a href="#RestController-1" class="headerlink" title="@RestController"></a>@RestController</h3><p>如果需要返回的是数据（如：JSON、XML或自定义的metatype等数据类型）时，@RestController完全等同于@Controller+@Responsebody<br>如果要求方法返回的是json格式数据，而不是跳转页面，可以直接在类上标注@RestController，而不用在每个方法中标注@ResponseBody，简化了开发过程。但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面</p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>@RequestMapping注解是用来映射请求的，即指明处理器可以处理哪些URL请求，该注解既可以用在类上，也可以用在方法上。</p><p>当使用@RequestMapping标记控制器类时，方法的请求地址是相对类的请求地址而言的；当没有使用@RequestMapping标记类时，方法的请求地址是绝对路径。</p><p>@RequestMapping的地址可以是url变量，并且通过@PathVariable注解获取作为方法的参数。也可以是通配符来筛选请求地址。</p><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。</p><p>在使用@Autowired时，首先在容器中查询对应类型的bean<br>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据<br>如果查询的结果不止一个，那么@Autowired会根据名称来查找。</p><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p>@Override 注解是用来指定方法重写的，只能修饰方法并且只能用于方法重写，不能修饰其它的元素。它可以强制一个子类必须重写父类方法或者实现接口的方法。</p><h3 id="创建控制器类"><a href="#创建控制器类" class="headerlink" title="创建控制器类"></a>创建控制器类</h3><p>创建控制器类com.controller.UserController.java</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/users")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>{ </span><br><span class="line">    <span class="comment">// 添加业务层对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;        </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="controller-utils"><a href="#controller-utils" class="headerlink" title="controller.utils"></a>controller.utils</h3><p>表现层数据一致性处理</p><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mp;  </span><br><span class="line">   <span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;  </span><br><span class="line">   <span class="keyword">import</span> org.springframework.boot.SpringApplication;  </span><br><span class="line">   <span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;  </span><br><span class="line">   <span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="comment">//    在SpringBoot启动类上配置mapper接口的扫描路径</span></span><br><span class="line">   <span class="meta">@MapperScan("com.example.mp.mappers")</span>  </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusApplication</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        <span class="comment">//        定义容器对象，并启动</span></span><br><span class="line">     SpringApplication.run(MybatisPlusApplication.class, args);  </span><br><span class="line">    }  </span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目<br>SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean</p><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot04JunitApplicationTests</span> </span>{</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">"two..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><p>在官方文档里找到application.properties文件，可查看可修改的配置<br><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">官方文档</a></p><p>默认是application.properties，我们将application.properties改为application.yaml</p><h2 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h2><p>后缀使用.yml或者.yaml都行</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>易阅读<br>易于脚本语言交互<br>以数据为核心，重数据轻格式</p><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p>大小写敏感<br>属性层级关系使用多行描述，每行结尾使用冒号结束<br>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格(不允许使用Tab键)<br>属性值前面添加空格(属性名与属性值之间使用冒号+空格作为分隔)<br>#表示注释<br>使用” “括住的内容可以使用转义字符</p><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p>用$进行变量引用<br>path: c:\user\bin</p><p>temp: ${path}\temp</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h4><p>键值对的集合，又称为映射(mapping)/ 哈希(hashes) / 字典(dictionary)</p><h4 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h4><p>一组按次序排列的值，又称为序列(sequence) / 列表(list)</p><p>使用一个短横线加一个空格代表一个数组项：<br>hobby:</p><ul><li>Java<br>jdk</li><li>python<br>py<h4 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h4>(scalars)：单个的、不可再分的值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习框架首先要先了解它是干什么的，然后了解它的项目结构即每个文件有什么用&lt;/p&gt;
&lt;h1 id=&quot;springboot&quot;&gt;&lt;a href=&quot;#springboot&quot; class=&quot;headerlink&quot; title=&quot;springboot&quot;&gt;&lt;/a&gt;springboot&lt;/</summary>
      
    
    
    
    <category term="java" scheme="https://wenkex.gitee.io/categories/java/"/>
    
    
    <category term="web" scheme="https://wenkex.gitee.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>前端学习</title>
    <link href="https://wenkex.gitee.io/2022/040312750.html"/>
    <id>https://wenkex.gitee.io/2022/040312750.html</id>
    <published>2022-04-03T14:07:51.000Z</published>
    <updated>2022-04-03T14:07:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="好用的网站"><a href="#好用的网站" class="headerlink" title="好用的网站"></a>好用的网站</h1><h2 id="CODEPEN"><a href="#CODEPEN" class="headerlink" title="CODEPEN"></a>CODEPEN</h2><p>CodePen 是一个基于 Web 的开发平台，允许用户在网页编写 HTML、CSS 和 JavaScript 等前端语言。并且它是实时可见的，这会使故障排除更加容易。开发人员和设计人员还可以与世界其他地方交换代码示例。</p><h2 id="Responsively"><a href="#Responsively" class="headerlink" title="Responsively"></a>Responsively</h2><p>这是一个基于开源项目的网站，它能够将各个设备屏幕展现在同一个页面上，能够让你非常方便的开发响应式网站，大幅提高前端开发的效率。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>HTML:（HyperText Markup Language）【超文本标记语言】</p><p>狭义的HTML指的是网页；<br>广义的HTML指的是前端技术（html,css,js,以及各种框架）——网页，移动端网页，小程序，公众号，移动端的app，快应用等。</p><p>HTML是一门标记语言，标记语言由一套标记标签组成，学习HTML，就是学习标签。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>HTML注释符号是以 &lt;– 开始以 –&gt; 结束的</p><h2 id="vscode编辑html"><a href="#vscode编辑html" class="headerlink" title="vscode编辑html"></a>vscode编辑html</h2><p>open in brower<br>按下快捷键ALT+B 即可在浏览器运行html</p><p>HTMLHint<br>错误提示</p><p>html snippets<br>常用html代码片段模板</p><p>live server<br>实时预览html文件</p><p>beautify<br>格式化代码工具，美化javascript，JSON，CSS，Sass，和HTML</p><h2 id="HTML文件的规范"><a href="#HTML文件的规范" class="headerlink" title="HTML文件的规范"></a>HTML文件的规范</h2><p>html文件以开始，以结尾，其他任何标签，需要写在和之间；<br>Html标签只包含两个子标签：head和body；<br>和网页设置相关的内容都写在head标签里；<br>需要显示的内容都写在body标签里；</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><code>由尖括号包裹单词构成，如：&lt;html&gt;，所以标签不可能以数字开头。</code><br>标签不区分大小写，但推荐小写。<br>标签也称为元素。</p><h3 id="单标签"><a href="#单标签" class="headerlink" title="单标签"></a>单标签</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单标签有两种写法：</span><br><span class="line">   写法一：只写开标签即可&lt;br&gt;</span><br><span class="line">   写法二：在开标签的结尾写一个/，如&lt;br/&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="双标签："><a href="#双标签：" class="headerlink" title="双标签："></a>双标签：</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开始标签又称开放标签<span class="tag">&lt;<span class="name">a</span>&gt;</span>标签体<span class="tag">&lt;/<span class="name">a</span>&gt;</span>结束标签又称闭合标签或关标签</span><br><span class="line">自闭合标签/单标签，如：<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>，<span class="tag">&lt;<span class="name">br</span>&gt;</span>等</span><br></pre></td></tr></tbody></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>指向 w3school 的超链接：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.w3school.com.cn"</span>  &gt;</span>文字说明<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">rel：规定当前文档与被链接文档之间的关系。</span><br></pre></td></tr></tbody></table></figure><h2 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h2><p>表单数据可以作为 URL 变量（method=”get”）或者 HTTP post （method=”post”）的方式来发送。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一个简单的 HTML 表单，包含两个文本输入框和一个提交按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"form_action.asp"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">  First name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"fname"</span> /&gt;</span></span><br><span class="line">  Last name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"lname"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h3><p>action 属性规定当提交表单时，向何处发送表单数据。<br>method属性规定如何发送表单数据（表单数据发送到 action 属性所规定的页面）。</p><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>input 标签用于搜集用户信息。<br>根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等。<br><code>&lt;input type="表单元素的类型" name="名称" value="默认值" size="宽度"&gt; </code></p><h4 id="type属性"><a href="#type属性" class="headerlink" title="type属性"></a>type属性</h4><p>text    单行文本框    省略时默认就是text<br>password    密码框    输入时以点号显示，安全<br>redio    单选按钮    只能选择其中一个<br>checkbox    复选框    可以同时选择多个<br>submit    提交按钮    提交表单数据<br>reset    重置按钮    重置表单元素的初始值<br>image    图像按钮    可以使用图片作为按钮<br>button    普通按钮    默认情况下无功能<br>file    文件选择器    选择要上传的文件<br>hidden    隐藏域    在页面上不显示，但是会提交，可以用来存储数据</p><h4 id="placeholder属性"><a href="#placeholder属性" class="headerlink" title="placeholder属性"></a>placeholder属性</h4><p>placeholder属性提供可描述输入字段预期值的提示信息</p><h1 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h1><h2 id="div标签中id、class属性的使用与区别"><a href="#div标签中id、class属性的使用与区别" class="headerlink" title="div标签中id、class属性的使用与区别"></a>div标签中id、class属性的使用与区别</h2><p>div用于标示块级元素，而span标示行内元素。</p><p>1、语法区别<br>id对应CSS是用样式选择符“#”（井号）；<br>class对应CSS是用样式选择符“.”(英文半角输入句号)。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"abc"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure><p>对应CSS应该是：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#header</span>{...} </span><br><span class="line"><span class="selector-class">.abc</span>{...} </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>id：在同一个页面，只可以被调用一次，在CSS里用“#”表示。<br>class：是类标签，在同一个页面可以调用无数次（没限制的），在CSS里用“.”表示。</p><h3 id="使用css"><a href="#使用css" class="headerlink" title="使用css"></a>使用css</h3><p>三种使用 CSS 的方法</p><p>外部 CSS<br>内部 CSS<br>行内 CSS</p><h3 id="外部-CSS"><a href="#外部-CSS" class="headerlink" title="外部 CSS"></a>外部 CSS</h3><p>外部样式表可以在任何文本编辑器中编写，并且必须以 .css 扩展名保存。<br>外部样式在 HTML 页面  部分内的 <link> 元素中进行定义：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h2><p>CSS 选择器用于“查找”（或选取）要设置样式的 HTML 元素。</p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器:"></a>id选择器:</h3><p>#id</p><p>id 名称不能以数字开头。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这条CSS 规则将应用于 id="para1" 的 HTML 元素 */</span></span><br><span class="line"><span class="selector-id">#para1</span> {</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器:"></a>类选择器:</h3><p>如需选择拥有特定 class 的元素，请写一个句点（.）字符，后面跟类名。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在此例中，所有带有 class="center" 的 HTML 元素将为红色且居中对齐： */</span></span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="CSS-通用选择器"><a href="#CSS-通用选择器" class="headerlink" title="CSS 通用选择器"></a>CSS 通用选择器</h4><p>通用选择器（*）选择页面上的所有的 HTML 元素。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 下面的 CSS 规则会影响页面上的每个 HTML 元素： */</span></span><br><span class="line"></span><br><span class="line">* {</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="CSS-分组选择器"><a href="#CSS-分组选择器" class="headerlink" title="CSS 分组选择器"></a>CSS 分组选择器</h4><p>分组选择器选取所有具有相同样式定义的 HTML 元素。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">p</span> {</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="组合器选择器（根据它们之间的特定关系来选取元素）"><a href="#组合器选择器（根据它们之间的特定关系来选取元素）" class="headerlink" title="组合器选择器（根据它们之间的特定关系来选取元素）"></a>组合器选择器（根据它们之间的特定关系来选取元素）</h2><h2 id="伪类选择器（根据特定状态选取元素）"><a href="#伪类选择器（根据特定状态选取元素）" class="headerlink" title="伪类选择器（根据特定状态选取元素）"></a>伪类选择器（根据特定状态选取元素）</h2><h2 id="伪元素选择器（选取元素的一部分并设置其样式）"><a href="#伪元素选择器（选取元素的一部分并设置其样式）" class="headerlink" title="伪元素选择器（选取元素的一部分并设置其样式）"></a>伪元素选择器（选取元素的一部分并设置其样式）</h2><h2 id="属性选择器（根据属性或属性值来选取元素）"><a href="#属性选择器（根据属性或属性值来选取元素）" class="headerlink" title="属性选择器（根据属性或属性值来选取元素）"></a>属性选择器（根据属性或属性值来选取元素）</h2><h2 id="css基础属性"><a href="#css基础属性" class="headerlink" title="css基础属性"></a>css基础属性</h2><h3 id="文字类"><a href="#文字类" class="headerlink" title="文字类"></a>文字类</h3><p>color<br>font-size<br>text-decoration<br>text-align</p><h3 id="尺寸类"><a href="#尺寸类" class="headerlink" title="尺寸类"></a>尺寸类</h3><p>width<br>height</p><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>background-color<br>background-image<br>background-size:cover</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="谷歌浏览器"><a href="#谷歌浏览器" class="headerlink" title="谷歌浏览器"></a>谷歌浏览器</h3><h4 id="CSS-Overview"><a href="#CSS-Overview" class="headerlink" title="CSS Overview"></a>CSS Overview</h4><p>在 Chrome 的管理面板中，开启CSS Overview面板之后，就可以查看当前网站的样式信息了，包括颜色信息、字体信息、媒体查询等</p><p>1.在任意页面打开 Chrome 浏览器的 DevTools；<br>2.单击更多选项 -&gt; More tools -&gt; CSS Overview。</p><h4 id="新的字体编辑器工具"><a href="#新的字体编辑器工具" class="headerlink" title="新的字体编辑器工具"></a>新的字体编辑器工具</h4><p>Chrome DevTools 提供了一个实验性的字体编辑器工具，可以用来改变字体设置。可以用它来改变字体、大小、粗细、行高、字符间距，并实时看到变化</p><p>1.在任意页面打开 Chrome 浏览器的 DevTools；<br>2.点击右上角设置图标 -&gt; 选中左侧 Experiments -&gt; 勾选 Enable New Font Editor Tools within Styles Pane；<br>3.重启浏览器的 DevTools；<br>4.选择HTML元素，其中包括想改变的字体，点击字体图标即可。</p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>JavaScript是一种轻量级的脚本语言。</p><p>JavaScript 插入 HTML 页面后，由浏览器执行。JavaScript 控制了网页的行为</p><p>推荐<a href="https://www.w3school.com.cn/js/index.asp">w3school</a>或者<a href="https://www.runoob.com/js/js-tutorial.html">runoob</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">7</span>;                             <span class="comment">// 数字</span></span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">"Gates"</span>;                      <span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">var</span> cars = [<span class="string">"Porsche"</span>, <span class="string">"Volvo"</span>, <span class="string">"BMW"</span>];         <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> x = {<span class="attr">firstName</span>:<span class="string">"Bill"</span>, <span class="attr">lastName</span>:<span class="string">"Gates"</span>};    <span class="comment">// 对象</span></span><br></pre></td></tr></tbody></table></figure><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 [ n, m ) 范围内的随机数（大于等于n，小于m）</span></span><br><span class="line"><span class="comment">// var random = Math.random()*(m-n)+n</span></span><br><span class="line">    a=<span class="built_in">Math</span>.random()*<span class="number">5</span>+<span class="number">1</span></span><br><span class="line">    toastLog (a)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 生成 [ min, max ] 范围内的随机整数（大于等于min，小于等于max）</span></span><br><span class="line"><span class="comment">// var random =Math.floor(Math.random()*(max-min+1))+min</span></span><br><span class="line">    b=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(<span class="number">5</span>))+<span class="number">1</span></span><br><span class="line">    toastLog(b)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><p>在字符串中换行，需要加一个反斜杠(非ECMAScript标准）：</p>  <figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"Hello \</span></span><br><span class="line"><span class="string">Kitty!"</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>String</code>和<code>Number</code>相加时，会将数字转为字符串；<code>String</code>和<code>Number</code>相减时，会将字符串转为数字；</p></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>JavaScript 对象是变量的容器。但是，我们通常认为 “JavaScript 对象是键值对的容器”。<br>对象也是一个变量，但对象可以包含多个值（多个变量），每个值以 name:value 对呈现。<br>总结：JavaScript 对象是属性和方法的容器。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = {<span class="attr">name</span>:<span class="string">"Fiat"</span>, <span class="attr">model</span>:<span class="number">500</span>, <span class="attr">color</span>:<span class="string">"white"</span>};</span><br></pre></td></tr></tbody></table></figure><ul><li><p><code>null</code>：类型是对象，不存在的事物。</p>  <figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>            <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>             <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h4><p>键值对在 JavaScript 对象通常称为 对象属性。<br>访问对象属性<br>你可以通过两种方式访问对象属性:</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>person.lastName;</span><br><span class="line"><span class="number">2.</span>person[<span class="string">"lastName"</span>];</span><br></pre></td></tr></tbody></table></figure><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><pre><code><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以通过person.firstName="..."的方式初始化</span></span><br><span class="line"><span class="keyword">var</span> person = {</span><br><span class="line"><span class="attr">firstName</span>: <span class="string">"Bill"</span>,</span><br><span class="line"><span class="attr">lastName</span> : <span class="string">"Gates"</span>,</span><br><span class="line"><span class="attr">id</span>       : <span class="number">678</span>,</span><br><span class="line"><span class="attr">fullName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{   <span class="comment">//成员函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">" "</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>脚本放置 HTML 的  或  部分中，或者同时存在于两个部分中。位于<script> 与 </script> 标签之间。</p><p>也可以把脚本保存到外部文件中，在 <script> 标签的 "src" 属性中设置该 .js 文件：</p><h1 id="Thymeleaf模板引擎"><a href="#Thymeleaf模板引擎" class="headerlink" title="Thymeleaf模板引擎"></a>Thymeleaf模板引擎</h1><p><a href="https://developer.aliyun.com/article/769977">https://developer.aliyun.com/article/769977</a></p><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的html文档。</p><p>将模板设计好之后直接填充数据即可而不需要重新设计整个页面。让网站实现界面和数据分离，提高页面、代码的复用性。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎</p><p>特点<br>1.动静分离： Thymeleaf选用html作为模板页，这是任何一款其他模板引擎做不到的！Thymeleaf使用html通过一些特定标签语法代表其含义，但并未破坏html结构，即使无网络、不通过后端渲染也能在浏览器成功打开，大大方便界面的测试和修改。</p><p>2.开箱即用： Thymeleaf提供标准和Spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改JSTL、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</p><p>3.Springboot官方大力推荐和支持，Springboot官方做了很多默认配置，开发者只需编写对应html即可，大大减轻了上手难度和配置复杂度。</p><h2 id="第一个Thymeleaf程序"><a href="#第一个Thymeleaf程序" class="headerlink" title="第一个Thymeleaf程序"></a>第一个Thymeleaf程序</h2><p>步骤</p><h2 id="创建程序，添加依赖"><a href="#创建程序，添加依赖" class="headerlink" title="创建程序，添加依赖"></a>创建程序，添加依赖</h2><p>首先，打开你的IDEA创建新项目，选择Spring Initializr方式创建Springboot项目 ，然后点击next，然后填写项目名</p><p>勾选其中Web 模块的Spring web依赖以及Template 模块的Thymeleaf依赖。finish 即可：</p><p>如果你创建项目时没有勾选依赖也不要紧，在pom.xml中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h2><p>pom.xml：是项目中的Maven依赖，因为Springboot使用Maven来管理外部jar包依赖，我们只需填写依赖名称配置即可引入该依赖，在本系统中引入Spring web模块(Springmvc)和Thymeleaf的依赖.我们不需要自己去招相关jar包。<br>application.properties: 编写Springboot与各框架整合的一些配置内容。<br>controller：用来编写控制器，主要负责处理请求以及和视图(Thymeleaf)绑定。<br>static：用于存放静态资源，例如html、JavaScript、css以及图片等。<br>templates：用来存放模板引擎Thymeleaf(本质依然是.html文件)</p><h2 id="编写Controller"><a href="#编写Controller" class="headerlink" title="编写Controller"></a>编写Controller</h2><p>项目基于Springboot框架，且选了Spring web(Springmvc)作为mvc框架，其中Thymeleaf就是v(view)视图层，我们需要在controller中指定Thymeleaf页面的url，然后再Model中绑定数据。</p><p>我们在com.Thymeleaf文件下创建controller文件夹，在其中创建urlController.java的controller文件，文件内容(代码)为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Thymeleaf.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">urlController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;index&quot;)</span><span class="comment">//页面的url地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getindex</span><span class="params">(Model model)</span><span class="comment">//对应函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;bigsai&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;<span class="comment">//与templates中index.html对应</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分含义如下：<br>@controller 注解的意思就是声明这个java文件为一个controller控制器。<br>@GetMapping(“index”) 其中@GetMapping的意思是请求的方式为get方式(即可通过浏览器直接请求)，而里面的index表示这个页面(接口)的url地址(路径)。即在浏览器对项目网页访问的地址。<br>getindex() 是@GetMapping(“index”)注解对应的函数，其类型为String类型返回一个字符串，参数Model类型即用来储存数据供我们Thymeleaf页面使用。<br>model.addAttribute(“name”,”bigsai”) 就是Model存入数据的书写方式，Model是一个特殊的类，相当于维护一个Map一样，而Model中的数据通过controller层的关联绑定在view层(即Thymeleaf中)可以直接使用。<br>return “hello”：这个index就是在templates目录下对应模板(本次为Thymeleaf模板)的名称，即应该对应hello.html这个Thymeleaf文件(与页面关联默认规则为：templates目录下返回字符串.html)。</p><h2 id="编写Thymeleaf页面"><a href="#编写Thymeleaf页面" class="headerlink" title="编写Thymeleaf页面"></a>编写Thymeleaf页面</h2><p>咱们在项目的resources目录下的templates文件夹下面创建一个叫index.html的文件，咱们在这个html文件中的<html>标签修改为<html xmlns:th="http://www.thymeleaf.org">这样在Thymeleaf中就可以使用Thymeleaf的语法和规范啦。</p><p>对于第一个Thymelaf程序，你只需将index.html文件改成这样即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>  <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello 第一个Thymeleaf程序</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span>name是bigsai(我是离线数据)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Thymeleaf语法详解"><a href="#Thymeleaf语法详解" class="headerlink" title="Thymeleaf语法详解"></a>Thymeleaf语法详解</h2><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><h2 id="链接表达式-…"><a href="#链接表达式-…" class="headerlink" title="链接表达式: @{…}"></a>链接表达式: @{…}</h2><h2 id="变量表达式-…"><a href="#变量表达式-…" class="headerlink" title="变量表达式: ${…}"></a>变量表达式: ${…}</h2><h2 id="选择变量表达式-…"><a href="#选择变量表达式-…" class="headerlink" title="选择变量表达式: *{…}"></a>选择变量表达式: *{…}</h2><h2 id="消息表达-…"><a href="#消息表达-…" class="headerlink" title="消息表达: #{…}"></a>消息表达: #{…}</h2><h1 id="Bootstrap组件库"><a href="#Bootstrap组件库" class="headerlink" title="Bootstrap组件库"></a>Bootstrap组件库</h1><p>Bootstrap:前端页面框架，用于快速开发响应式页面，一套代码就可以适应平板和PC</p><p>Bootstrap 3 是移动设备优先的，在这个意义上，Bootstrap 代码从小屏幕设备（比如移动设备、平板电脑）开始，然后扩展到大屏幕设备（比如笔记本电脑、台式电脑）上的组件和网格。</p><p><a href="https://www.runoob.com/bootstrap/bootstrap-tutorial.html">教程</a></p><p><a href="https://www.runoob.com/try/bootstrap/layoutit/">Bootstrap 可视化布局系统！</a></p><h2 id="引入bootstrap框架"><a href="#引入bootstrap框架" class="headerlink" title="引入bootstrap框架"></a>引入bootstrap框架</h2><p>1、直接引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优点：方便，简单；</p><p>缺点：使网页加载缓慢，需要有网络的情况；</p><p>2.下载好库再进行引入：<br>优点：加载网页会快点，没有网络的情况也可用；</p><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p><a href="https://www.runoob.com/jquery/jquery-tutorial.html">jQuery菜鸟教程</a><br>jQuery ：是一个 JavaScript 函数库。使用选择器（$）选取DOM对象，并对其进行赋值、取值、事件绑定等操作；主要是操作DOM</p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>国内用百度CDN</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="jQuery-语法"><a href="#jQuery-语法" class="headerlink" title="jQuery 语法"></a>jQuery 语法</h2><p>基础语法： $(selector).action()</p><p>美元符号定义 jQuery<br>选择符（selector）”查询”和”查找” HTML 元素<br>jQuery 的 action() 执行对元素的操作</p><h2 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h2><h2 id="jQuery-事件"><a href="#jQuery-事件" class="headerlink" title="jQuery 事件"></a>jQuery 事件</h2><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>可实现页面无刷新更新数据</p><p>Ajax相当于浏览器发送请求与接受响应的代理人，以实现在不重新加载整个页面下，与服务器交换数据并局部更新网页数据</p><h2 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h2><p>open(method,url,async)<br>规定请求的类型、URL 以及是否异步处理请求。<br>参数<br>    method：请求的类型；GET 或 POST<br>    url：文件在服务器上的位置<br>    async：true（异步）或 false（同步）</p><p>send(string)<br>    将请求发送到服务器。</p><pre><code>string：仅用于 POST 请求</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">loadXMLDoc</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript"></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> xmlhttp;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span></span><br><span class="line"><span class="javascript">&#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建 XMLHttpRequest 对象</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">&#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">// IE6, IE5 浏览器执行代码</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript"></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span></span><br><span class="line"><span class="javascript">&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/ajax_info.txt&quot;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">xmlhttp.send();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>使用 AJAX 修改该文本内容<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;loadXMLDoc()&quot;</span>&gt;</span>修改内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>axios实现了对ajax的封装。<br>Axios 是可以发出 http 请求的 JavaScript 库，在 浏览器 和 node.js 环境中都可以运行。</p><h2 id="axios与ajax的优缺点"><a href="#axios与ajax的优缺点" class="headerlink" title="axios与ajax的优缺点"></a>axios与ajax的优缺点</h2><p>1.axios优点：<br>（1）从浏览器中创建 XMLHttpRequest；<br>（2）支持 Promise API；<br>（3）从 node.js 创建 http 请求；<br>（4）转换请求和响应数据；<br>（5）自动转换JSON数据。</p><p>1.ajax缺点:<br>（1）基于原生的XHR开发，XHR本身的架构不清晰；<br>（2）JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理；<br>（3）不符合关注分离（Separation of Concerns）的原则；<br>（4）配置和调用方式非常混乱，而且基于事件的异步模型不友好。</p><h2 id="GET-请求和POST-请求"><a href="#GET-请求和POST-请求" class="headerlink" title="GET 请求和POST 请求"></a>GET 请求和POST 请求</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 1、向给定ID的用户发起GET 请求</span></span></span><br><span class="line"><span class="javascript">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 处理成功情况</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 处理错误情况</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(error);</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 总是会执行</span></span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 2.POST 请求</span></span></span><br><span class="line"><span class="javascript">axios.post(<span class="string">&#x27;/user&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(error);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p>官方文档：<a href="http://vuejs.org/v2/guide/syntax.html">http://vuejs.org/v2/guide/syntax.html</a></p><p>中文文档: <a href="https://cn.vuejs.org/v2/guide/syntax.html">https://cn.vuejs.org/v2/guide/syntax.html</a></p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="直接引入"><a href="#直接引入" class="headerlink" title="直接引入"></a>直接引入</h3><h2 id="js表达式与js代码-语句-的区别"><a href="#js表达式与js代码-语句-的区别" class="headerlink" title="js表达式与js代码(语句)的区别"></a>js表达式与js代码(语句)的区别</h2><p>1.表达式：一个表达式会生成一个值<br>  (1)a+b<br>  (2)x===y ‘a’ ? ‘b’</p><p>2.代码<br>  (1)if (){}  </p><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h3><p>功能：用于解析标签体内容<br>写法：容器中的是js表达式，可以自动读取vue实例中data的所有属性 </p><h3 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h3><p>功能：用于解析标签(包括标签属性，标签体内容，绑定事件)</p><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind:"></a>v-bind:</h4><p>v-bind用于单向绑定数据和元素属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可简写为： --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>双向数据绑定,一般用在表单类元素如：input，select</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">双向<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model:value</span>=<span class="string">&quot;school.name&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 因为v-model默认收集的就是value值，所以可简写为 --&gt;</span></span><br><span class="line">双向<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;school.name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义一个容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &#123;&#123; &#125;&#125; 用于输出对象属性和函数返回值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>site : &#123;&#123;site&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>url : &#123;&#123;url&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;details()&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对于制作原型或学习，你可以这样导入最新版本： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// vue实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// el 参数的两种写法</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// vm.$mount(&#x27;#rood&#x27;),</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#rood&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// data参数用于定义属性</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1.data参数的对象式写法</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">site</span>: <span class="string">&quot;菜鸟教程&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">url</span>: <span class="string">&quot;www.runoob.com&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">alexa</span>: <span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2.data参数的函数式写法(vue管理的函数，不能用箭头函数)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// data:function()&#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//   return&#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     name:&#x27;菜鸟&#x27;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// methods参数用于定义函数</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">details</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>  <span class="built_in">this</span>.site + <span class="string">&quot; - 学的不仅是技术，更是梦想！&quot;</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>created() {}<br>VUE对象初始化完成后自动执行</p><h2 id="Element-UI组件库"><a href="#Element-UI组件库" class="headerlink" title="Element UI组件库"></a>Element UI组件库</h2><p>Element UI 是一套采用 Vue 2.0 作为基础框架实现的组件库</p><p><a href="https://element.eleme.cn/#/zh-CN/component/installation">组件</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入组件库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>Layout 布局<br>Container 布局容器<br>Color 色彩<br>Typography 字体<br>Border 边框<br>Icon 图标<br>Button 按钮<br>Link 文字链接<br>Form</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>Radio 单选框<br>Checkbox 多选框<br>Input 输入框<br>InputNumber 计数器<br>Select 选择器<br>Cascader 级联选择器<br>Switch 开关<br>Slider 滑块<br>TimePicker 时间选择器<br>DatePicker 日期选择器<br>DateTimePicker 日期时间选择器<br>Upload 上传<br>Rate 评分<br>ColorPicker 颜色选择器<br>Transfer 穿梭框<br>Form 表单</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>Table 表格<br>Tag 标签<br>Progress 进度条<br>Tree 树形控件<br>Pagination 分页<br>Badge 标记<br>Avatar 头像<br>Skeleton 骨架屏<br>Empty 空状态<br>Descriptions 描述列表<br>Result 结果</p><h3 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h3><p><code>  &lt;el-input v-model=&quot;input1&quot;&gt;&lt;/el-input&gt; 输入内容为：&#123;&#123;input1&#125;&#125;</code></p><h3 id="Table表格组件"><a href="#Table表格组件" class="headerlink" title="Table表格组件"></a>Table表格组件</h3><h4 id="el-table"><a href="#el-table" class="headerlink" title="el-table"></a>el-table</h4><p>:data属性   单向数据绑定</p><p>stripe属性可以创建带斑马纹的表格</p><p>Table 组件提供了单选的支持，只需要配置highlight-current-row属性即可实现单选。之后由current-change事件来管理选中时触发的事件，它会传入currentRow，oldCurrentRow。如果需要显示索引，可以增加一列el-table-column，设置type属性为index即可显示从 1 开始的索引号。</p><h4 id="el-table-column"><a href="#el-table-column" class="headerlink" title="el-table-column"></a>el-table-column</h4><p>prop属性来对应对象中的键名即可填入数据，<br>label属性来定义表格的列名。<br>width属性来定义列宽。<br>align=“center”：设置表格内居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> <span class="attr">current-row-key</span>=<span class="string">&quot;id&quot;</span> <span class="attr">:data</span>=<span class="string">&quot;dataList&quot;</span> <span class="attr">stripe</span> <span class="attr">highlight-current-row</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">&quot;index&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">label</span>=<span class="string">&quot;序号&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;type&quot;</span> <span class="attr">label</span>=<span class="string">&quot;图书类别&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;name&quot;</span> <span class="attr">label</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;description&quot;</span> <span class="attr">label</span>=<span class="string">&quot;描述&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;操作&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpdate(scope.row)&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleDelete(scope.row)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>Alert 警告<br>Loading 加载<br>Message 消息提示<br>MessageBox 弹框<br>Notification 通知<br>Navigation<br>NavMenu 导航菜单<br>Tabs 标签页<br>Breadcrumb 面包屑<br>PageHeader 页头<br>Dropdown 下拉菜单<br>Steps 步骤条</p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Dialog 对话框<br>Tooltip 文字提示<br>Popover 弹出框<br>Popconfirm 气泡确认框<br>Card 卡片<br>Carousel 走马灯<br>Collapse 折叠面板<br>Timeline 时间线<br>Divider 分割线<br>Calendar 日历<br>Image 图片<br>Backtop 回到顶部<br>InfiniteScroll 无限滚动<br>Drawer 抽屉<br>¶Button 按钮</p><h3 id="通过js触发按钮的点击事件"><a href="#通过js触发按钮的点击事件" class="headerlink" title="通过js触发按钮的点击事件"></a>通过js触发按钮的点击事件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpdate(scope.row)&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//弹出编辑窗口</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">handleUpdate</span>(<span class="params">row</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        axios.get(<span class="string">&quot;/books/&quot;</span>+row.id).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(res.data.flag &amp;&amp; res.data.data != <span class="literal">null</span> )&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.dialogFormVisible4Edit = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.formData = res.data.data;</span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$message.error(<span class="string">&quot;数据同步失败，自动刷新&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;).finally(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//2.重新加载数据</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.getAll();</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></script></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;好用的网站&quot;&gt;&lt;a href=&quot;#好用的网站&quot; class=&quot;headerlink&quot; title=&quot;好用的网站&quot;&gt;&lt;/a&gt;好用的网站&lt;/h1&gt;&lt;h2 id=&quot;CODEPEN&quot;&gt;&lt;a href=&quot;#CODEPEN&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="前端" scheme="https://wenkex.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="框架" scheme="https://wenkex.gitee.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>qq机器人</title>
    <link href="https://wenkex.gitee.io/2022/032659541.html"/>
    <id>https://wenkex.gitee.io/2022/032659541.html</id>
    <published>2022-03-26T09:09:00.000Z</published>
    <updated>2022-03-26T09:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h2><p>WebSocket 是HTML5 提供的一种在单个TCP连接上进行全双工通信的协议。</p><p>WebSocket 只需要完成一次握手，客户端和服务器之间就可以创建持久性的连接，并进行双向数据传输。这就使得客户端和服务器之间的数据交换变得更加简单。</p><h1 id="go-cqhttp"><a href="#go-cqhttp" class="headerlink" title="go-cqhttp"></a>go-cqhttp</h1><p><a href="https://onebot.dev/ecosystem.html#onebot-%E5%AE%9E%E7%8E%B0">OneBot</a><br>go-cqhttp（一个 QQ 平台的 OneBot 实现）<br><a href="https://docs.go-cqhttp.org/guide/quick_start.html#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B"> go-cqhttp 文档</a></p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>建议使用ubuntu服务器<br>下载：64 位 Linux    Not available    go-cqhttp_linux_amd64.tar.gz</p><p>Linux下在命令行中输入 tar -xzvf [文件名] 解压到想要的文件夹内</p><p>进入对应目录 <code>./go-cqhttp</code>启动</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.第一次无法登录，隔了一天再登录又可以了</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进入对应目录 <code>./go-cqhttp</code>前台运行。如果你操作其他命令或者关闭 ssh 工具，程序自然就关闭了</p><h1 id="Nonebot2框架"><a href="#Nonebot2框架" class="headerlink" title="Nonebot2框架"></a>Nonebot2框架</h1><p>是一个可扩展的 Python 异步机器人框架：<a href="https://docs.nonebot.dev/">https://docs.nonebot.dev/</a></p><p>Nonebot2需要先搭建go-cqhttp</p><h2 id="搭建-1"><a href="#搭建-1" class="headerlink" title="搭建"></a>搭建</h2><p>可以使用 pip 安装已发布的最新版本：<br><code>pip install nonebot</code></p><p>在提示选择通信方式时，选择「反向 Websocket 通信」，程序将会自动生成默认配置文件。</p><p>打开 go-cqhttp 默认配置文件 config.yml 进行简单配置，修改 QQ 账号以及密码。再次运行 go-cqhttp，可能需要根据提示进行扫码或滑块验证，如果得到以下提示则登录成功：</p><h3 id="使用脚手架"><a href="#使用脚手架" class="headerlink" title="使用脚手架"></a>使用脚手架</h3><p><a href="https://v2.nonebot.dev/docs/start/nb-cli">https://v2.nonebot.dev/docs/start/nb-cli</a></p><p>pip install nb-cli</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><a href="https://v2.nonebot.dev/store">插件</a><br><a href="https://github.com/nonepkg/nonebot-plugin-manager">https://github.com/nonepkg/nonebot-plugin-manager</a></p><h1 id="Mirai"><a href="#Mirai" class="headerlink" title="Mirai"></a>Mirai</h1><p>使用 Kotlin 编写的高效率 QQ 机器人框架<br><a href="https://github.com/mamoe/mirai">github地址</a></p><p><a href="https://github.com/mamoe/mirai/blob/dev/docs/mirai-ecology.md">mirai官方生态文档</a></p><h2 id="下载-MCL-Installer"><a href="#下载-MCL-Installer" class="headerlink" title="下载 MCL Installer"></a>下载 MCL Installer</h2><p><a href="https://github.com/iTXTech/mcl-installer">MCL Installer</a><br>支持自动下载Java运行环境 和 Mirai Console Loader </p><p>MCL Installer安装时自动下载了 Mirai Console Loader（简称 MCL）。<br>Mirai Console Loader它的工作就是简化 console 启动流程，一键帮你下载 jar 文件，自动更新，文件损坏检查…… 你能在手动启动时担心的问题 mirai-console-loader 都帮你想到了</p><h2 id="了解运行环境"><a href="#了解运行环境" class="headerlink" title="了解运行环境"></a>了解运行环境</h2><p>文件夹名称    用途<br>scripts    存放启动器的脚本，一般不需要在意他们<br>plugins    存放插件<br>data    存放插件的数据，一般不需要在意它们<br>config    存放插件的配置，可以打开并修改配置<br>logs    存放运行时的日志，日志默认保留 7 天</p><h2 id="插件-1"><a href="#插件-1" class="headerlink" title="插件"></a>插件</h2><p>官方(chat-command，mirai-api-http，mirai-native）</p><p>刚刚装好的 Mirai Console 是没有任何功能的。功能将由插件提供。<br><a href="https://mirai.mamoe.net/category/11/%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83">插件发布</a><br>如果是 JAR 文件的插件，放入 plugins 即可。其他插件一般都有特殊说明如何使用，请参考它们的说明。</p><h3 id="Plum"><a href="#Plum" class="headerlink" title="Plum"></a>Plum</h3><p><a href="https://mirai.mamoe.net/topic/241/plum-%E6%A2%85%E8%8A%B1%E5%A8%98-%E6%8A%A5%E6%97%A9%E6%99%9A%E5%AE%89-%E6%99%BA%E8%83%BD%E7%82%B9%E6%AD%8C-%E4%B8%80%E8%A8%80-%E9%9A%8F%E6%9C%BA%E5%8A%A8%E6%BC%AB%E5%A3%81%E7%BA%B8-%E8%81%8A%E5%A4%A9ai/2">Plum</a></p><p>Plum-1.0-SNAPSHOT.mirai.jar<br>功能</p><p>每天5点：每日句子 + 倒计时（可自定义倒计时事件）<br>每天21点：每日诗词<br>戳一戳：随机一言<br>@ + 问题：AI聊天（默认实现是青云客API，可自行修改）<br>点歌：本插件支持3种主流音乐平台 网易云音乐，酷狗音乐，QQ音乐。默认按照 网易云音乐 -&gt; 酷狗音乐 -&gt; QQ音乐 顺序查找。通过“点歌”指令以卡片形式点歌，通过“唱歌”指令以语音条形式唱歌。</p><h3 id="自动定义回复插件"><a href="#自动定义回复插件" class="headerlink" title="自动定义回复插件"></a>自动定义回复插件</h3><p><a href="https://mirai.mamoe.net/topic/636/console-%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%B9%89%E5%9B%9E%E5%A4%8D%E6%8F%92%E4%BB%B6">https://mirai.mamoe.net/topic/636/console-%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%B9%89%E5%9B%9E%E5%A4%8D%E6%8F%92%E4%BB%B6</a></p><p>浏览器进入<a href="http://localhost:20044/index.html">http://localhost:20044/index.html</a></p><h3 id="思知机器人插件"><a href="#思知机器人插件" class="headerlink" title="思知机器人插件"></a>思知机器人插件</h3><p>自己跟自己聊天，不好用<br><a href="https://github.com/thetbw/my-bot">https://github.com/thetbw/my-bot</a> </p><h2 id="滑动验证助手"><a href="#滑动验证助手" class="headerlink" title="滑动验证助手"></a>滑动验证助手</h2><p><a href="https://github.com/mzdluo123/TxCaptchaHelper">https://github.com/mzdluo123/TxCaptchaHelper</a></p><p>下载手机客户端<br>在mcl控制台中使用命令<code>login &lt;qq&gt; [password] [protocol]</code><br>会弹出url,把它复制到滑动验证助手app中</p><p>第二种登录方式（将弹出的链接发送给手机QQ打开，会得到一个二维码，使用手机QQ扫码验证）</p><p>ANDROID_PAD是ipad</p><p>login 3385642151 密码 ANDROID_PAD</p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><h3 id="搭建在Centos-7错误"><a href="#搭建在Centos-7错误" class="headerlink" title="搭建在Centos 7错误"></a>搭建在Centos 7错误</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mcl-installer-d5a51f8-linux-amd64: /lib64/libc.so.6: version `GLIBC_2.25' not found (required by ./mcl-installer-d5a51f8-linux-amd64)</span><br></pre></td></tr></tbody></table></figure><p>根据一些研究，GLIBC_2.25 不能安装在 Centos 7 上</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/411513359">https://zhuanlan.zhihu.com/p/411513359</a></p><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>下载插件：Mirai Console</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;h2 id=&quot;WebSocket协议&quot;&gt;&lt;a href=&quot;#WebSocket协议&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="工具" scheme="https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="qq" scheme="https://wenkex.gitee.io/tags/qq/"/>
    
  </entry>
  
  <entry>
    <title>python高级</title>
    <link href="https://wenkex.gitee.io/2022/03267198.html"/>
    <id>https://wenkex.gitee.io/2022/03267198.html</id>
    <published>2022-03-26T01:55:02.000Z</published>
    <updated>2022-03-26T01:55:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FuzzyWuzzy模糊匹配库"><a href="#FuzzyWuzzy模糊匹配库" class="headerlink" title="FuzzyWuzzy模糊匹配库"></a>FuzzyWuzzy模糊匹配库</h1><p><a href="https://mp.weixin.qq.com/s/Zj6AoQSD4u2KwY6D1PCfew">https://mp.weixin.qq.com/s/Zj6AoQSD4u2KwY6D1PCfew</a></p><p>FuzzyWuzzy 是一个简单易用的模糊字符串匹配工具包。它依据 Levenshtein Distance 算法，计算两个序列之间的差异。</p><p>Levenshtein Distance算法，又叫 Edit Distance算法，是指两个字符串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越大。</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。</p><h2 id="Python中的多进程"><a href="#Python中的多进程" class="headerlink" title="Python中的多进程"></a>Python中的多进程</h2><p>Unix和Linux操作系统上提供了<code>fork()</code>系统调用来创建进程，调用<code>fork()</code>函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。<code>fork()</code>函数非常特殊它会返回两次，父进程中可以通过<code>fork()</code>函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。<br>Python的os模块提供了<code>fork()</code>函数。由于Windows系统没有<code>fork()</code>调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的<code>Process</code>类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（<code>Pool</code>）、用于进程间通信的队列（<code>Queue</code>）和管道（<code>Pipe</code>）等。</p><p>下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_task</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    download_task(<span class="string">'Python从入门到住院.pdf'</span>)</span><br><span class="line">    download_task(<span class="string">'Peking Hot.avi'</span>)</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>下面是运行程序得到的一次运行结果。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开始下载Python从入门到住院.pdf...</span><br><span class="line">Python从入门到住院.pdf下载完成! 耗费了6秒</span><br><span class="line">开始下载Peking Hot.avi...</span><br><span class="line">Peking Hot.avi下载完成! 耗费了7秒</span><br><span class="line">总共耗费了13.01秒.</span><br></pre></td></tr></tbody></table></figure><p>从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getpid</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_task</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'启动下载进程，进程号[%d].'</span> % getpid())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    <span class="comment"># Process类创建了进程对象</span></span><br><span class="line">    <span class="comment"># 通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。</span></span><br><span class="line">    p1 = Process(target=download_task, args=(<span class="string">'Python从入门到住院.pdf'</span>, ))</span><br><span class="line">    p1.start()   <span class="comment">#启动进程</span></span><br><span class="line">    p2 = Process(target=download_task, args=(<span class="string">'Peking Hot.avi'</span>, ))</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()  <span class="comment">#表示等待进程执行结束</span></span><br><span class="line">    p2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>在上面的代码中，我们通过<code>Process</code>类创建了进程对象，通过<code>target</code>参数我们传入一个函数来表示进程启动后要执行的代码，后面的<code>args</code>是一个元组，它代表了传递给函数的参数。<code>Process</code>对象的<code>start</code>方法用来启动进程，而<code>join</code>方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动下载进程，进程号[1530].</span><br><span class="line">开始下载Python从入门到住院.pdf...</span><br><span class="line">启动下载进程，进程号[1531].</span><br><span class="line">开始下载Peking Hot.avi...</span><br><span class="line">Peking Hot.avi下载完成! 耗费了7秒</span><br><span class="line">Python从入门到住院.pdf下载完成! 耗费了10秒</span><br><span class="line">总共耗费了10.01秒.</span><br></pre></td></tr></tbody></table></figure><p>我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_task</span>(<span class="params">string</span>):</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="keyword">while</span> counter &lt; <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(string, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    Process(target=sub_task, args=(<span class="string">'Ping'</span>, )).start()</span><br><span class="line">    Process(target=sub_task, args=(<span class="string">'Pong'</span>, )).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个<code>counter</code>变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的<code>Queue</code>类，它是可以被多个进程共享的队列，底层是通过管道和<a href="">信号量（semaphore）</a>机制来实现的，有兴趣的读者可以自己尝试一下。</p><h2 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h2><p>在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    <span class="comment"># 使用threading模块的Thread类来创建线程</span></span><br><span class="line">    t1 = Thread(target=download, args=(<span class="string">'Python从入门到住院.pdf'</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = Thread(target=download, args=(<span class="string">'Peking Hot.avi'</span>,))</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'总共耗费了%.3f秒'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>我们可以直接使用threading模块的<code>Thread</code>类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承<code>Thread</code>类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'开始下载%s...'</span> % self._filename)</span><br><span class="line">        time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        sleep(time_to_download)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (self._filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    t1 = DownloadTask(<span class="string">'Python从入门到住院.pdf'</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = DownloadTask(<span class="string">'Peking Hot.avi'</span>)</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="comment"># 计算存款后的余额</span></span><br><span class="line">        new_balance = self._balance + money</span><br><span class="line">        <span class="comment"># 模拟受理存款业务需要0.01秒的时间</span></span><br><span class="line">        sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="comment"># 修改账户余额</span></span><br><span class="line">        self._balance = new_balance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, account, money</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="comment"># 创建100个存款的线程向同一个账户中存钱</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account, <span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="comment"># 等所有存款的线程都执行完毕</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'账户余额为: ￥%d元'</span> % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到<code>new_balance = self._balance + money</code>这行代码，多个线程得到的账户余额都是初始状态下的<code>0</code>，所以都是<code>0</code>上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line">        self._lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="comment"># 先获取锁才能执行后续的代码</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            new_balance = self._balance + money</span><br><span class="line">            sleep(<span class="number">0.01</span>)</span><br><span class="line">            self._balance = new_balance</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 在finally中执行释放锁的操作保证正常异常锁都能释放</span></span><br><span class="line">            self._lock.release()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, account, money</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account, <span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'账户余额为: ￥%d元'</span> % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。</p><h2 id="多进程还是多线程"><a href="#多进程还是多线程" class="headerlink" title="多进程还是多线程"></a>多进程还是多线程</h2><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。</p><p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。</p><p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到过Python中有嵌入C/C++代码的机制。</p><p>除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。</p><blockquote><p><strong>说明：</strong> 上面的内容和例子来自于<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰官方网站的《Python教程》</a>，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。</p></blockquote><h2 id="单线程-异步I-O"><a href="#单线程-异步I-O" class="headerlink" title="单线程+异步I/O"></a>单线程+异步I/O</h2><p>现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下并发编程的一种流行方案。</p><p>在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，在后续的课程中会进行讲解。</p><h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><h3 id="将耗时间的任务放到线程中以获得更好的用户体验。"><a href="#将耗时间的任务放到线程中以获得更好的用户体验。" class="headerlink" title="将耗时间的任务放到线程中以获得更好的用户体验。"></a>将耗时间的任务放到线程中以获得更好的用户体验。</h3><p>如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验</p><p>如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadTaskHandler</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">            time.sleep(<span class="number">10</span>)</span><br><span class="line">            tkinter.messagebox.showinfo(<span class="string">'提示'</span>, <span class="string">'下载完成!'</span>)</span><br><span class="line">            <span class="comment"># 启用下载按钮</span></span><br><span class="line">            button1.config(state=tkinter.NORMAL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span>():</span></span><br><span class="line">        <span class="comment"># 禁用下载按钮</span></span><br><span class="line">        button1.config(state=tkinter.DISABLED)</span><br><span class="line">        <span class="comment"># 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行)</span></span><br><span class="line">        <span class="comment"># 在线程中处理耗时间的下载任务</span></span><br><span class="line">        DownloadTaskHandler(daemon=<span class="literal">True</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_about</span>():</span></span><br><span class="line">        tkinter.messagebox.showinfo(<span class="string">'关于'</span>, <span class="string">'作者: 骆昊(v1.0)'</span>)</span><br><span class="line"></span><br><span class="line">    top = tkinter.Tk()</span><br><span class="line">    top.title(<span class="string">'单线程'</span>)</span><br><span class="line">    top.geometry(<span class="string">'200x150'</span>)</span><br><span class="line">    top.wm_attributes(<span class="string">'-topmost'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    panel = tkinter.Frame(top)</span><br><span class="line">    button1 = tkinter.Button(panel, text=<span class="string">'下载'</span>, command=download)</span><br><span class="line">    button1.pack(side=<span class="string">'left'</span>)</span><br><span class="line">    button2 = tkinter.Button(panel, text=<span class="string">'关于'</span>, command=show_about)</span><br><span class="line">    button2.pack(side=<span class="string">'right'</span>)</span><br><span class="line">    panel.pack(side=<span class="string">'bottom'</span>)</span><br><span class="line"></span><br><span class="line">    tkinter.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h3 id="使用多进程对复杂任务进行“分而治之”。"><a href="#使用多进程对复杂任务进行“分而治之”。" class="headerlink" title="使用多进程对复杂任务进行“分而治之”。"></a>使用多进程对复杂任务进行“分而治之”。</h3><p>我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    number_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100000001</span>)]</span><br><span class="line">    start = time()</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> number_list:</span><br><span class="line">        total += number</span><br><span class="line">    <span class="built_in">print</span>(total)</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Execution time: %.3fs'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_handler</span>(<span class="params">curr_list, result_queue</span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> curr_list:</span><br><span class="line">        total += number</span><br><span class="line">    result_queue.put(total)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    processes = []</span><br><span class="line">    number_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100000001</span>)]</span><br><span class="line">    result_queue = Queue()</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 启动8个进程将数据切片后进行运算</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        p = Process(target=task_handler,</span><br><span class="line">                    args=(number_list[index:index + <span class="number">12500000</span>], result_queue))</span><br><span class="line">        index += <span class="number">12500000</span></span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="comment"># 开始记录所有进程执行完成花费的时间</span></span><br><span class="line">    start = time()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line">    <span class="comment"># 合并执行结果</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> result_queue.empty():</span><br><span class="line">        total += result_queue.get()</span><br><span class="line">    <span class="built_in">print</span>(total)</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Execution time: '</span>, (end - start), <span class="string">'s'</span>, sep=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过<code>multiprocessing.managers</code>模块中提供的管理器将<code>Queue</code>对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。</p><h1 id="openpyxl模块处理Excel电子表格"><a href="#openpyxl模块处理Excel电子表格" class="headerlink" title="openpyxl模块处理Excel电子表格"></a>openpyxl模块处理Excel电子表格</h1><p><a href="https://zhuanlan.zhihu.com/p/351814769">https://zhuanlan.zhihu.com/p/351814769</a></p><p><a href="https://blog.csdn.net/weixin_44288604/article/details/120731317">https://blog.csdn.net/weixin_44288604/article/details/120731317</a></p><p>Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，由于微软从Office 2007开始使用了新的文件格式，这使得Office Excel和LibreOffice Calc、OpenOffice Calc是完全兼容的，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line">ws[<span class="string">'A1'</span>] = <span class="number">42</span></span><br><span class="line">ws.append([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">ws[<span class="string">'A2'</span>] = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">"sample.xlsx"</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="excel文档和创建对象"><a href="#excel文档和创建对象" class="headerlink" title="excel文档和创建对象"></a>excel文档和创建对象</h2><ol><li>工作薄(workbook):一个EXCEL文件就称为一个工作薄,一个工作薄中可以包含若干张工作表。打开或者创建一个Excel需要创建一个<strong>Workbook对象</strong></li><li>工作表(sheet):工作薄中的每一张表格称为工作表,每张工作表都有一个标签,默认为sheet1\sheet2\sheet3来命名，(一个工作 薄默认为由3个工作表组成)。获取一个表则需要先创建一个Workbook对象，然后使用该对象的方法来得到一个<strong>Worksheet对象</strong></li><li>活动表(active sheet)：指当前正在操作的工作表</li><li>行(row): 工作表中的每一行行首数字(1、2、3、)称为行标题;一张工作表最多有65536行</li><li>列(column): 列标题:工作表中每一列列首的字母(A、B、C)称为列标题;一张工作表最多有256列</li><li>单元格(cell): 工作表的每一个格称为单元格。如果要获取表中的数据，那么得到Worksheet对象以后再从中获取代表单元格的<strong>Cell对象</strong></li></ol><h2 id="Workbook对象"><a href="#Workbook对象" class="headerlink" title="Workbook对象"></a>Workbook对象</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.创建</span></span><br><span class="line"><span class="keyword">from</span>  openpyxl <span class="keyword">import</span>  Workbook </span><br><span class="line"><span class="comment">#实例化Workbook对象</span></span><br><span class="line">wb = Workbook()</span><br><span class="line"><span class="comment"># 激活 worksheet</span></span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.打开已有的excel</span></span><br><span class="line"><span class="keyword">from</span> openpyxl  <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment">#实例化Workbook对象</span></span><br><span class="line">wb2 = load_workbook(<span class="string">'文件名称.xlsx'</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="Workbook对象属性（工作簿操作）"><a href="#Workbook对象属性（工作簿操作）" class="headerlink" title="Workbook对象属性（工作簿操作）"></a>Workbook对象属性（工作簿操作）</h3><p>sheetnames：获取工作簿中的表（列表）<br>active：获取当前活跃的Worksheet<br>worksheets：以列表的形式返回所有的Worksheet(表格)<br>read_only：判断是否以read_only模式打开Excel文档<br>encoding：获取文档的字符集编码<br>properties：获取文档的元数据，如标题，创建者，创建日期等</p><h2 id="Worksheet对象-工作表操作"><a href="#Worksheet对象-工作表操作" class="headerlink" title="Worksheet对象(工作表操作)"></a>Worksheet对象(工作表操作)</h2><p>title：表格的标题<br>max_row：表格的最大行<br>min_row：表格的最小行<br>max_column：表格的最大列<br>min_column：表格的最小列<br>rows：按行获取单元格(Cell对象) - 生成器<br>columns：按列获取单元格(Cell对象) - 生成器<br>values：按行获取表格的内容(数据) - 生成器</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实例化Worksheet对象</span></span><br><span class="line">worksheet = wb[<span class="string">'排序商品信息'</span>]</span><br></pre></td></tr></tbody></table></figure><h2 id="Cell对象（单元格）"><a href="#Cell对象（单元格）" class="headerlink" title="Cell对象（单元格）"></a>Cell对象（单元格）</h2><p>row：单元格所在的行<br>column：单元格坐在的列<br>value：单元格的值<br>coordinate：单元格的坐标</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实例化Cell对象</span></span><br><span class="line">cell = sheet[<span class="string">'B1'</span>]</span><br></pre></td></tr></tbody></table></figure><h1 id="docx模块处理Word文档"><a href="#docx模块处理Word文档" class="headerlink" title="docx模块处理Word文档"></a>docx模块处理Word文档</h1><p><a href="https://blog.csdn.net/weixin_44374471/article/details/100010360">https://blog.csdn.net/weixin_44374471/article/details/100010360</a></p><h2 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h2><h1 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h1><h2 id="Time库"><a href="#Time库" class="headerlink" title="Time库"></a>Time库</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time.time() <span class="comment">#获取当前时间戳（计算机内部时间）</span></span><br><span class="line"><span class="comment"># 1643336568.9237003</span></span><br><span class="line">time.ctime(time.time())  <span class="comment">#可以传入时间戳格式化时间</span></span><br><span class="line"><span class="comment">#'Sat Jan 29 15:21:48 2022'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.loaltime() <span class="comment">#本地时间  Sat Apr 16 22:34:40 2022</span></span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime()))  <span class="comment">#格式化时间</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>获取时间：</p><h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><p>time.strftime(tpl,ts)<br>    tpl：定义输出效果<br>    ts：struct_time元组</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,time.gmtime())</span><br><span class="line"><span class="comment">#'2022-01-28 03:04:00'</span></span><br><span class="line"></span><br><span class="line">time.strftime(<span class="string">"%a %b %d %H:%M:%S"</span>,time.gmtime())</span><br><span class="line"><span class="comment">#'Fri Jan 28 03:07:14'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="将格式化字符串转换为时间戳"><a href="#将格式化字符串转换为时间戳" class="headerlink" title="将格式化字符串转换为时间戳"></a>将格式化字符串转换为时间戳</h3><p>strptime(str,tpl)<br>    str:字符串形式的时间值<br>    tpl：定义输入效果</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timestr = <span class="string">'2022-01-28 03:04:00'</span></span><br><span class="line">                     </span><br><span class="line">time.strptime(timestr,<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">                     </span><br><span class="line"><span class="comment">#time.struct_time(tm_year=2022, tm_mon=1, tm_mday=28, tm_hour=3, tm_min=4, tm_sec=0, #tm_wday=4, tm_yday=28, tm_isdst=-1)</span></span><br></pre></td></tr></tbody></table></figure><h3 id="计时器功能"><a href="#计时器功能" class="headerlink" title="计时器功能"></a>计时器功能</h3><h2 id="datetime库"><a href="#datetime库" class="headerlink" title="datetime库"></a>datetime库</h2><p>datetime 基于 time 进行了封装，提供了更多实用的函数。</p><h3 id="date类"><a href="#date类" class="headerlink" title="date类"></a>date类</h3><p>只关注日期</p><h3 id="time类"><a href="#time类" class="headerlink" title="time类"></a>time类</h3><p>只关注时间</p><h3 id="datetime类"><a href="#datetime类" class="headerlink" title="datetime类"></a>datetime类</h3><p>同时有时间和日期</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">d=datetime.datetime.now()</span><br><span class="line">d.year</span><br><span class="line">d.month</span><br><span class="line">d.day</span><br><span class="line">d.hour</span><br><span class="line">d.minute</span><br><span class="line">d.second</span><br><span class="line">d.microsecond</span><br><span class="line">d.tzinfo</span><br><span class="line"> </span><br><span class="line">d.date() <span class="comment"># 返回 date 对象</span></span><br><span class="line">d.time() <span class="comment"># 返回 time 对象</span></span><br><span class="line">d.replace(name=value) <span class="comment"># 前面所述各项属性是 read-only 的，需要此方法才可更改</span></span><br><span class="line">d.timetuple() <span class="comment"># 返回time.struct_time 对象</span></span><br><span class="line">dattime.strftime(<span class="built_in">format</span>) <span class="comment"># 按照 format 进行格式化输出</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h3 id="timedelta类"><a href="#timedelta类" class="headerlink" title="timedelta类"></a>timedelta类</h3><p>主要用于计算时间跨度</p><h1 id="click命令行模块"><a href="#click命令行模块" class="headerlink" title="click命令行模块"></a>click命令行模块</h1><p>使用@click.command()装饰指定函数，使之成为命令行接口；<br>使用@click.argument()或者@click.option()装饰函数，为其添加命令行选项等。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> click </span><br><span class="line"><span class="comment"># 装饰器@click.command()会将函数包装成 click 对象</span></span><br><span class="line"><span class="meta">@click.command() </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    click.echo(<span class="string">"hello click"</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="打包跨平台可执行程序"><a href="#打包跨平台可执行程序" class="headerlink" title="打包跨平台可执行程序"></a>打包跨平台可执行程序</h2><p>通过click编写了简单的命令行方法后，还需要把.py文件转换成可以在控制台里运行的命令行程序。最简单的方法就是加上如下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == '__main__':</span><br><span class="line">    command()</span><br></pre></td></tr></tbody></table></figure><p>click支持使用setuptools来更好的实现命令行程序打包，把源码文件打包成系统中的可执行程序，并且不限平台。一般可通过在源码根目录下创建setup.py脚本，下面是一段简单的打包代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from setuptools import setup</span><br><span class="line">setup(</span><br><span class="line">    name='hello',</span><br><span class="line">    version='0.1',</span><br><span class="line">    py_modules=['hello'],</span><br><span class="line">    install_requires=[</span><br><span class="line">        'click',</span><br><span class="line">    ],</span><br><span class="line">    entry_points='''</span><br><span class="line">        [console_scripts]</span><br><span class="line">        hello=hello:cli</span><br><span class="line">    ''',</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>)<br>留意entry_points字段，在console_scripts下，每一行都是一个控制台脚本，等号左边的是脚本的名称，右边的是click命令的导入路径。</p><h1 id="PyScript"><a href="#PyScript" class="headerlink" title="PyScript"></a>PyScript</h1><p><a href="https://pyscript.net/">PyScript</a>是 Anaconda 团队开发的一个 Javascipt 库，可以在 HTML 标签里嵌入 Python 代码，无需服务端就可以运行 Python 代码。</p><h2 id="如何使用-PyScript"><a href="#如何使用-PyScript" class="headerlink" title="如何使用 PyScript"></a>如何使用 PyScript</h2><p>PyScript 使用以下三个主要组件在 html 中编写 Python：</p><p>py-env 定义了运行 Python 代码所需的包。<br>py-script 是在网页中编写 Python 代码的地方。<br>py-repl 创建一个 REPL（读取-评估-打印循环）组件，用于评估用户输入的代码并显示结果。</p><h1 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h1><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime   <span class="comment">#导入datetime模块中的datetime类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将时间戳转换为有用的时间格式。</span></span><br><span class="line">time = datetime.fromtimestamp(<span class="string">"传入时间戳"</span>)</span><br></pre></td></tr></tbody></table></figure><p><strong>程序运行时间</strong></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> b_tuple:</span><br><span class="line">  aa = b_tuple[<span class="number">20000</span>]</span><br><span class="line">end_time = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Lookup time for TUPLE: "</span>, end_time - start_time)</span><br></pre></td></tr></tbody></table></figure><h1 id="random库"><a href="#random库" class="headerlink" title="random库"></a>random库</h1><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( random.randint(<span class="number">1</span>,<span class="number">10</span>) )        <span class="comment"># 产生 1 到 10 的一个整数型随机数  </span></span><br><span class="line"><span class="built_in">print</span>( random.randrange(<span class="number">1</span>,<span class="number">100</span>,<span class="number">2</span>) )   <span class="comment"># 生成从1到100的间隔为2的随机整数</span></span><br><span class="line"><span class="built_in">print</span>( random.random() )             <span class="comment"># 产生 0 到 1 之间的随机浮点数</span></span><br><span class="line"><span class="built_in">print</span>( random.uniform(<span class="number">1.1</span>,<span class="number">5.4</span>) )     <span class="comment"># 产生  1.1 到 5.4 之间的随机浮点数，区间可以不是整数</span></span><br><span class="line"><span class="built_in">print</span>( random.choice(<span class="string">'tomorrow'</span>) )   <span class="comment"># 从序列中随机选取一个元素</span></span><br><span class="line"></span><br><span class="line">random.shuffle(<span class="built_in">list</span>)     <span class="comment">#将一个列表内的元素打乱顺序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个字符中选取指定数量的字符组成新字符串：</span></span><br><span class="line"><span class="string">''</span>.join(random.sample([<span class="string">'z'</span>,<span class="string">'y'</span>,<span class="string">'x'</span>,<span class="string">'w'</span>,<span class="string">'v'</span>,<span class="string">'u'</span>,<span class="string">'t'</span>,<span class="string">'s'</span>,<span class="string">'r'</span>,<span class="string">'q'</span>,<span class="string">'p'</span>,<span class="string">'o'</span>,<span class="string">'f'</span>,<span class="string">'e'</span>,<span class="string">'d'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>], <span class="number">5</span>))     </span><br><span class="line">random.shuffle([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])  <span class="comment"># 将序列a中的元素顺序打乱</span></span><br></pre></td></tr></tbody></table></figure><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>文本文件：存储的是普通“字符”文本，默认为unicode字符集，可以使用记本事程序打开</p><p>二进制文件：把数据内容用“字节”进行存储，无法用记事本打开，必须使用专用的软件打开，举例：mp3音频文件，jpg图片。doc文档等<br>open(name[, mode[, buffering]])<br>参数：<br>    name : 一个包含了你要访问的文件名称的字符串值。<br>    mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</p><table><thead><tr><th>打开模式</th><th>描述</th></tr></thead><tbody><tr><td>r:</td><td>只读。这是<strong>默认模式</strong>。文件不存在将报错</td></tr><tr><td>r+:</td><td>用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>w:</td><td>只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr></tbody></table><p>|w+:  |  打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。|<br>|wb+:|以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。|<br>|a:   | 追加写入内容。如果该文件已存在，文件指针将会放在文件的结尾。新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。|<br>|a+:  |  打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。|</p><p>|wb:   | 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。|<br>|ab+:|以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。|<br>|rb: |以二进制格式打开一个文件用于只读,默认模式。|<br>|ab:   | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。|<br>|rb+:|以二进制格式打开一个文件用于读写|</p><p>要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可<br>以二进制的形式读取，禁用encoding编码格式；读取时，不知道读多少</p><h2 id="with-open"><a href="#with-open" class="headerlink" title="with open"></a>with open</h2><p>wth语句可以自动管理上下文资源，不论什么原因跳出with，都能确保文件正确的关闭，以此来达到释放资源的目的</p><p>read()会一次性读取文件的全部内容，如果文件有20G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。<br>调用readline()可以每次读取一行内容，<br>调用readlines()一次读取所有内容并按行返回list。</p><p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p><p>file.write(str)   将字符串写入文件<br>file.writelines(strings)   将字符串序列写入文件</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'Hi.text'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">"Hello, there"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># with file.open(encoding='utf-8') as f:</span></span><br></pre></td></tr></tbody></table></figure><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p><strong>glob.glob</strong><br>同时返回所有匹配的文件路径列表。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取指定目录下的所有图片</span></span><br><span class="line"><span class="built_in">print</span> (glob.glob(<span class="string">r"/home/qiaoyunhao/*/*.png"</span>),<span class="string">"\n"</span>)<span class="comment">#加上r让字符串不转义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取上级目录的所有.py文件</span></span><br><span class="line"><span class="built_in">print</span> (glob.glob(<span class="string">r'../*.py'</span>)) <span class="comment">#相对路径</span></span><br></pre></td></tr></tbody></table></figure><h3 id="glob-iglob"><a href="#glob-iglob" class="headerlink" title="glob.iglob"></a>glob.iglob</h3><p>获取一个可编历对象，使用它可以逐个获取匹配的文件路径名。</p><p><strong>shutil 模块</strong>(拷贝、删除、移动、压缩和解压)<br>shutil可以简单地理解为sh + util，shell工具的意思。shutil模块是对os模块的补充，主要针对文件的拷贝、删除、移动、压缩和解压操作。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br></pre></td></tr></tbody></table></figure><h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><p>shutil会自动识别拷贝的到底是文件还是文件夹, 如果存在同名的文件将会自动进行覆盖。</p><p>shutil.copy($file_path, $dir_path)</p><h2 id="移动或重命名文件，但如果路径下已有重名的文件，将报错！"><a href="#移动或重命名文件，但如果路径下已有重名的文件，将报错！" class="headerlink" title="移动或重命名文件，但如果路径下已有重名的文件，将报错！"></a>移动或重命名文件，但如果路径下已有重名的文件，将报错！</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil </span><br><span class="line"></span><br><span class="line">shutil.move(<span class="string">r'.\practice.txt'</span>, <span class="string">r'.\文件夹1/'</span>)   <span class="comment"># 移动到另外一个文件夹中</span></span><br><span class="line">shutil.move(<span class="string">r'.\practice.txt'</span>, <span class="string">r'.\文件夹1/new.txt'</span>)    <span class="comment">#移动并重命名</span></span><br></pre></td></tr></tbody></table></figure><h2 id="拷贝文件夹-删除文件夹"><a href="#拷贝文件夹-删除文件夹" class="headerlink" title="拷贝文件夹/删除文件夹"></a>拷贝文件夹/删除文件夹</h2><p>shutil.copytree($file_path, $dir_path) # 拷贝所有文件到新的文件夹下，保持原有的文件结构。<br>shutil.rmtree($dir_path) # 删除此路径的文件夹</p><h2 id="生成压缩文件"><a href="#生成压缩文件" class="headerlink" title="生成压缩文件:"></a>生成压缩文件:</h2><p>shutil.make_archive(base_name, ‘gztar’, root_dir, [base_dir)<br>    base_name : 创建的目标文件名，包括路径，减去任何特定格式的扩展。<br>    format : 压缩包格式。”zip”, “tar”, “bztar”或”gztar”中的一个。<br>    root_dir : 需要打包的文件夹路径。打包完成时存储在上一级目录。<br>    base_dir : 使用后会将base_dir作为路径，解压后有个有层级的文件夹，而仅非只有单独的打包内容。</p><h2 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件:"></a>解压文件:</h2><p>shutil.unpack_archive(filename[, extract_dir[, format]])<br>    filename是压缩文档的完整路径<br>    extract_dir是解压缩路径，默认为当前目录。<br>    format是压缩格式。默认使用文件后缀名代码的压缩格式。”zip”, “tar”, “bztar”或”gztar”中的一个。</p><h2 id="pathlib模块"><a href="#pathlib模块" class="headerlink" title="pathlib模块"></a>pathlib模块</h2><p>多平台使用<br>对于多层文件夹的读取，用os模块只能一层一层读取出文件，要写多个for循环，效率不高，这时我们可以用 Path.glob(**/*) 大法，</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime   <span class="comment">#导入datetime模块中的datetime类</span></span><br><span class="line"></span><br><span class="line">p = Path(<span class="string">'E:\github\python\自动化\打开所有网址.py'</span>)    <span class="comment">#实例化Path对象(可传入绝对路径，当前目录下文件名)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"文件名:<span class="subst">{p.name}</span>"</span>)     </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"文件完整路径:<span class="subst">{p.resolve() }</span>"</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"文件后缀:<span class="subst">{p.suffix}</span>"</span>)     </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"文件前缀:<span class="subst">{p.stem}</span>"</span>)    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(p.stat())            <span class="comment"># 获取文件详细信息</span></span><br><span class="line"><span class="built_in">print</span>(p.stat().st_size)    <span class="comment"># 文件的字节大小</span></span><br><span class="line"><span class="built_in">print</span>(p.stat().st_ctime)   <span class="comment"># 文件创建时间戳</span></span><br><span class="line"><span class="built_in">print</span>(p.stat().st_mtime)   <span class="comment"># 上次修改文件的时间戳</span></span><br><span class="line">creat_time = datetime.fromtimestamp(p.stat().st_ctime)</span><br><span class="line">st_mtime = datetime.fromtimestamp(p.stat().st_mtime)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'该文件创建时间：<span class="subst">{creat_time}</span>'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'上次修改该文件的时间：<span class="subst">{st_mtime}</span>'</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">p = Path(<span class="string">'E:\github\python\自动化\整理文件.ipynb'</span>)    <span class="comment">#实例化Path对象(可传入绝对路径，当前目录下文件名)</span></span><br><span class="line">p1 = Path .cwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"上级文件夹路径:<span class="subst">{p.parent}</span>"</span>) </span><br><span class="line"><span class="built_in">print</span>(p.parts)      <span class="comment"># 将路径通过分隔符分割成一个元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------------"</span>)</span><br><span class="line"><span class="comment"># 获取指定文件夹下所有文件和文件夹路径</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p1.iterdir():</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------------"</span>)</span><br><span class="line"><span class="comment"># 返回一个iterable 包含所有父目录</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p.parents:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------------"</span>)    </span><br><span class="line"><span class="comment"># 获取该文件目录下所有.py文件路径</span></span><br><span class="line">file_name = p1.glob(<span class="string">'**/*.py'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_name:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></tbody></table></figure><h1 id="os库"><a href="#os库" class="headerlink" title="os库"></a>os库</h1><p>./res是head<br>1.jpg是jpg</p><h2 id="1-os库基本介绍"><a href="#1-os库基本介绍" class="headerlink" title="1. os库基本介绍"></a>1. os库基本介绍</h2><p>用于访问操作系统相关功能</p><h2 id="2-os库之路径操作"><a href="#2-os库之路径操作" class="headerlink" title="2. os库之路径操作"></a>2. os库之路径操作</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件不存在，创建文件</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(folder_path): </span><br><span class="line">    os.mkdir(folder_path)</span><br><span class="line"></span><br><span class="line">os.path.isdir()   <span class="comment">#判断是否为目录</span></span><br><span class="line"></span><br><span class="line">os.path.join(<span class="string">'annotations'</span>, <span class="string">'xmls'</span>)  <span class="comment">#按照路径的方式拼接字符串</span></span><br><span class="line">os.rename(<span class="string">"要修改的目录名"</span>, <span class="string">"修改后的目录名"</span>)    <span class="comment">#重命名文件或目录，两个参数都要传入路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path =./ res / <span class="number">1.j</span>pg</span><br><span class="line"></span><br><span class="line">os.path.split(path)  <span class="comment"># 将路径划分为head和tail两部分并存为元组 ('./res', '1.jpg')</span></span><br><span class="line">basename = os.path.basename(path)  <span class="comment"># 获取路径的tail部分   1.jpg</span></span><br><span class="line">name = basename.split(<span class="string">'.'</span>)[<span class="number">0</span>]   <span class="comment">#切割出文件名  1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="os-listdir-path"><a href="#os-listdir-path" class="headerlink" title="os.listdir(path)"></a>os.listdir(path)</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.listdir(<span class="string">'.'</span>)  <span class="comment">#返回指定路径下所有文件名的列表。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="os-walk"><a href="#os-walk" class="headerlink" title="os.walk"></a>os.walk</h3><p>遍历文件夹后产生三个参数：<br>当前文件夹路径<br>包含文件夹名称[列表形式]<br>包含文件名称[列表形式]</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(<span class="string">r'C:\\Program Files (x86)'</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'打开文件夹<span class="subst">{dirpath}</span>'</span>) <span class="comment"># 当前文件夹路径 </span></span><br><span class="line">    <span class="keyword">if</span> dirnames:</span><br><span class="line">        <span class="built_in">print</span>(dirnames) <span class="comment"># 包含文件夹名称[列表形式] </span></span><br><span class="line">    <span class="keyword">if</span> filenames:</span><br><span class="line">        <span class="built_in">print</span>(filenames) <span class="comment"># 包含文件名称[列表形式]</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'-'</span> * <span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="os-scandir"><a href="#os-scandir" class="headerlink" title="os.scandir"></a>os.scandir</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = <span class="string">'.'</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.scandir(path): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"获取路径下文件名：<span class="subst">{file.name}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"获取路径下文件路径：<span class="subst">{file.path}</span>\n"</span>) </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="3-os库之进程管理"><a href="#3-os库之进程管理" class="headerlink" title="3. os库之进程管理"></a>3. os库之进程管理</h2><h2 id="4-os库之环境参数"><a href="#4-os库之环境参数" class="headerlink" title="4. os库之环境参数"></a>4. os库之环境参数</h2><h1 id="web自动化selenium"><a href="#web自动化selenium" class="headerlink" title="web自动化selenium"></a>web自动化selenium</h1><h2 id="安装webdriver"><a href="#安装webdriver" class="headerlink" title="安装webdriver"></a>安装webdriver</h2><p>各大浏览器webdriver地址可参见：<a href="https://docs.seleniumhq.org/download/">https://docs.seleniumhq.org/download/</a><br>Firefox：<a href="https://github.com/mozilla/geckodriver/releases/">https://github.com/mozilla/geckodriver/releases/</a><br>Chrome：<a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a><br><strong>webdriver安装路径</strong><br>Win：复制webdriver到Python安装目录下<br>Mac：复制webdriver到/usr/local/bin目录下</p><h2 id="定位页面元素"><a href="#定位页面元素" class="headerlink" title="定位页面元素"></a>定位页面元素</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment">#定位一个元素</span></span><br><span class="line">ele = driver.find_element(By.XPATH,<span class="string">''</span>)</span><br><span class="line"><span class="comment">#表示定位一组元素(元素相同时使用)</span></span><br><span class="line">lis = driver.find_elements(By.XPATH,<span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(lis)&gt;<span class="number">0</span>:</span><br><span class="line">  lis[<span class="number">0</span>].click()</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'没有元素'</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="id-定位"><a href="#id-定位" class="headerlink" title="id 定位"></a>id 定位</h3><h3 id="name-定位"><a href="#name-定位" class="headerlink" title="name 定位"></a>name 定位</h3><h3 id="class-定位"><a href="#class-定位" class="headerlink" title="class 定位"></a>class 定位</h3><h3 id="link定位"><a href="#link定位" class="headerlink" title="link定位"></a>link定位</h3><p>find_element_by_link_text()<br>此种方法是专门用来定位文本链接的，</p><h3 id="partial-link定位："><a href="#partial-link定位：" class="headerlink" title="partial_link定位："></a>partial_link定位：</h3><p>find_element_by_partial_link_text()</p><p>有时候一个超链接的文本很长很长，我们如果全部输入，既麻烦，又显得代码很不美观，这时候我们就可以只截取一部分字符串，用这种方法模糊匹配了。</p><h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><p>xpath定位：find_element_by_xpath()</p><p>前面介绍的几种定位方法都是在理想状态下，有一定使用范围的，那就是：在当前页面中，每个元素都有一个唯一的id或name或class或超链接文本的属性，那么我们就可以通过这个唯一的属性值来定位他们。</p><p>但是在实际工作中并非有这么美好，有时候我们要定位的元素并没有id,name,class属性，或者多个元素的这些属性值都相同，又或者刷新页面，这些属性值都会变化。那么这个时候我们就只能通过xpath或者CSS来定位了。</p><p>xpath 是一种在 XML 文档中定位元素的语言，它拥有多种定位方式</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>...<span class="tag">&lt;<span class="name">head</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"csdn-toolbar"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-inside"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-container"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-container-left"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-container-middle"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-search onlySearch"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-search-container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"toolbar-search-input"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">placeholder</span>=<span class="string">"C++难在哪里？"</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>根据上面的标签需要定位 最后一行 input 标签，以下列出了四种方式，xpath 定位的方式多样并不唯一，使用时根据情况进行解析即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绝对路径（层级关系）定位  （绝对路径以/开头）</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"/html/body/div/div/div/div[2]/div/div/input[1]"</span>)</span><br><span class="line"><span class="comment"># 利用元素属性定位     （相对路径以//开头）</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*[@id='toolbar-search-input']"</span>))</span><br><span class="line"><span class="comment"># 层级+元素属性定位</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//div[@id='csdn-toolbar']/div/div/div[2]/div/div/input[1]"</span>)</span><br><span class="line"><span class="comment"># 逻辑运算符定位</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*[@id='toolbar-search-input' and @autocomplete='off']"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>1.相对路径+索引<br>先定位要找的元素，再找它唯一的父标签<br>2.相对路径+属性<br>3.相对路径+通配符定位<br>4.相对路径+部分属性值<br>5.相对路径+文本</p><h3 id="css-定位"><a href="#css-定位" class="headerlink" title="css 定位"></a>css 定位</h3><p>link 定位<br>partial_link 定位</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="下拉框的处理"><a href="#下拉框的处理" class="headerlink" title="下拉框的处理"></a>下拉框的处理</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--select标签--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">size</span>=<span class="string">"5"</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">tabindex</span>=<span class="string">"1"</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span> <span class="attr">tabindex</span>=<span class="string">"2"</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>河南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line">ele = driver.find_element_by_name(<span class="string">"city"</span>)</span><br><span class="line"><span class="comment">#创建Select类对象</span></span><br><span class="line">sel = Select(ele)</span><br><span class="line">sel.select_by_value(<span class="string">"3"</span>)  </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="select类中的函数列表"><a href="#select类中的函数列表" class="headerlink" title="select类中的函数列表"></a>select类中的函数列表</h4><p>options    返回select元素所有的options<br>all_selected_options    返回select元素中所有已选中的选项<br>first_selected_option    返回select元素中选中的第一个选项<br>select_by_index(index)    通过索引定位，index索引是从“0”开始<br>select_by_value(value)    通过value属性值定位<br>select_by_visible_text(text)t    通过文本值定位，visible_text是在option标签中间的值，即显示在下拉框的值；<br>deselect_all()    取消全部的已选择项<br>deselect_by_index(index)    取消已选中的索引项<br>deselect_by_value(value)    取消已选中的value值<br>deselect_by_visible_text(text)    取消已选中的文本值</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>定位到元素后用.send_keys(r’文件路径’)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_name(<span class="string">"city"</span>).send_keys(<span class="string">r'文件路径'</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="处理弹窗"><a href="#处理弹窗" class="headerlink" title="处理弹窗"></a>处理弹窗</h3><p>alert(只有确定)，confirm(有确认和取消)，prompt(有确认取消还可以输入值)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#alert是一个属性</span></span><br><span class="line"><span class="comment">#创建一个alert对象</span></span><br><span class="line">ale = driver.switch_to.alert</span><br><span class="line"></span><br><span class="line"><span class="comment">#点击确定</span></span><br><span class="line">ale.accept()</span><br><span class="line"><span class="comment">#点击取消</span></span><br><span class="line">ale.dismiss() </span><br><span class="line"><span class="comment">#获得文本</span></span><br><span class="line">ale.text()</span><br><span class="line"><span class="comment">#输入值</span></span><br><span class="line">ale.send_keys()</span><br></pre></td></tr></tbody></table></figure><h2 id="设计模式（封装）"><a href="#设计模式（封装）" class="headerlink" title="设计模式（封装）"></a>设计模式（封装）</h2><p>pom(page object model)页面对象模式</p><p>分三层<br>1.基础层：base 主要放seleni原生的方法<br>2.页面对象层：主要用于放页面的元素和页面的动作<br>3.测试用例层:testcase存放测试用例，测试数据</p><p>页面对象层调用基础层的方法，测试用例层调用页面对象的方法</p><h1 id="UIautomation"><a href="#UIautomation" class="headerlink" title="UIautomation"></a>UIautomation</h1><p><a href="https://blog.csdn.net/MicalChen/article/details/120296341">https://blog.csdn.net/MicalChen/article/details/120296341</a><br>最新版uiautomation2.0目前只支持Python 3版本，依赖comtypes和typing这两个包，但不要使用3.7.6和3.8.1这两个版本，comtypes在这两个版本中不能正常工作。</p><h2 id="UIautomation环境搭建"><a href="#UIautomation环境搭建" class="headerlink" title="UIautomation环境搭建"></a>UIautomation环境搭建</h2><h2 id="界面元素定位"><a href="#界面元素定位" class="headerlink" title="界面元素定位"></a>界面元素定位</h2><p>常用的控件类<br>控件类支持的参数<br>常用方法<br>窗口相关方法<br>程序关闭与打开相关方法<br>组合框相关方法<br>鼠标事件<br>键盘事件<br>延时等待<br>滚动条<br>日志<br>粘贴板<br>控件判断相关方法<br>控件矩形坐标<br>截图方法</p><h1 id="pyautogui"><a href="#pyautogui" class="headerlink" title="# pyautogui"></a># pyautogui</h1><p>是一个非常强大的库，可以操作鼠标和键盘   基于坐标操作</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://mp.weixin.qq.com/s/6OJYwnzC1fHyOj_rBFIGxg</span></span><br><span class="line"><span class="comment"># https://zhuanlan.zhihu.com/p/302592540</span></span><br><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler <span class="comment"># 阻塞当前进程的调度器</span></span><br><span class="line"><span class="comment"># blocking类型调度器会阻塞当前进程，若你想要后台运行的调度器，可以使用以下代码：</span></span><br><span class="line"><span class="comment"># from apscheduler.schedulers.background import BackgroundScheduler</span></span><br><span class="line">pyautogui.PAUSE = <span class="number">1</span> <span class="comment"># 设置每一步操作的间隔（秒），可防止操作太快</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pyautogui.position()) <span class="comment"># 打印坐标，Point(x=148, y=879)</span></span><br><span class="line">icon_position = pyautogui.position() <span class="comment"># Point(x=148, y=879)</span></span><br></pre></td></tr></tbody></table></figure><h1 id="Tkinter库-内置GUI库"><a href="#Tkinter库-内置GUI库" class="headerlink" title="Tkinter库(内置GUI库)"></a>Tkinter库(内置GUI库)</h1><p>import tkinter as tk</p><h2 id="窗口的创建和设置"><a href="#窗口的创建和设置" class="headerlink" title="窗口的创建和设置"></a>窗口的创建和设置</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line">root=tk.Tk()<span class="comment">#生成主窗口</span></span><br><span class="line">root.geometry(<span class="string">'250x250'</span>)<span class="comment">#改变窗体大小（‘宽x高’），注意是x不是*</span></span><br><span class="line">root.geometry(<span class="string">'+450+450'</span>)<span class="comment">#改变窗体位置（‘+横坐标+纵坐标’）</span></span><br><span class="line">root.title(<span class="string">'标题'</span>)<span class="comment">#修改框体的名字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root.mainloop()<span class="comment">#显示主窗口</span></span><br><span class="line"></span><br><span class="line">root.resizable(<span class="number">0</span>, <span class="number">0</span>)将窗口大小设置为不可变</span><br><span class="line">root.resizable(<span class="literal">False</span>, <span class="literal">False</span>)将窗口大小设置为不可变</span><br></pre></td></tr></tbody></table></figure><h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><h3 id="控件的共同属性"><a href="#控件的共同属性" class="headerlink" title="控件的共同属性"></a>控件的共同属性</h3><pre><code>height    指定控件的高度，单位为像素(文本控件的单位为行，不是像素)width    指定控件的宽度，单位为像素(文本控件的单位为行，不是像素)bg (background)    控件的背景颜色fg (foreground)    前景颜色(字体颜色)cursor    鼠标移动到框架时，光标的形状(参数值：arrow[默认箭头], circle, cross[十字], plus，watch[圈圈转动]等）justify    显示多行文本的时候,设置不同行之间的对齐方式（参数值：LEFT, RIGHT, CENTER）bd    加粗（默认 2 像素）    无padx    设置按钮文本与按钮边框x轴方向的距离pady    设置按钮文本与按钮边框y轴方向的距离state    设置按钮状态,参数值：NORMAL、ACTIVE、 DISABLED。默认 NORMALanchor    控制按钮文本的位置(参数值：S,W,E,N,SE,SW,NW,NE,CENTER,默认为CENTER)image    显示图像与PhotoImage 一起使用，图片只能为gif格式relief    三维效果 （参数值：FLAT、SUNKEN、RAISED、GROOVE、RIDGE。默认为 FLAT）bitmap    位图anchor    文本起始位置    CENTER(默认)，E,S,W,N,NE,SE,SW,NWbitmap    黑白二值图标    网上查找cursor    鼠标悬停光标    网上查找font    字体    无</code></pre><h3 id="Label标签"><a href="#Label标签" class="headerlink" title="Label标签"></a>Label标签</h3><p>用来显示文字或图片<br>tkinter.Label(text=”文字”)</p><h3 id="Button按钮控件模块"><a href="#Button按钮控件模块" class="headerlink" title="Button按钮控件模块"></a>Button按钮控件模块</h3><p>类似标签,但提供额外的功能,例如鼠标掠过、按下、释放以及键盘操作、事件<br>Button ( master, option=value, … )<br><strong>参数</strong><br>    master: 按钮的父容器。<br>    options: 可选项，即该按钮的可设置的属性。<br>    command :按钮关联的函数，当按钮被点击时，执行该函数</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"></span><br><span class="line">button=Button(root,command=绑定的函数,text=<span class="string">"转换温度"</span>)</span><br><span class="line">button.pack()</span><br></pre></td></tr></tbody></table></figure><h3 id="Entry单行文字域"><a href="#Entry单行文字域" class="headerlink" title="Entry单行文字域"></a>Entry单行文字域</h3><p>参数：<br>    show    1. 设置输入框用指定字符显示文本的内容 例如： “*”，<br>单行文字域用来收集键盘输入</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root=tk.Tk()</span><br><span class="line">entry=Entry(root)     <span class="comment">#创建Entry对象</span></span><br><span class="line">entry.pack()  <span class="comment">#显示 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">entry.get()   <span class="comment">#获取当前输入框的文本</span></span><br><span class="line">entry.config()   <span class="comment">#修改相应属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eventhandler</span>(<span class="params">event</span>):</span></span><br><span class="line">    entry.focus() <span class="comment">#(聚焦)文本框</span></span><br><span class="line">entry=Entry(root,bd=<span class="number">4</span>)</span><br><span class="line">entry.bind_all(<span class="string">'&lt;Control-f&gt;'</span>, eventhandler ) <span class="comment"># 绑定快捷键Ctrl-f</span></span><br></pre></td></tr></tbody></table></figure><p><strong>texts属性绑定变量</strong><br>在Button，Lable，Entry 这3个组件，有一个属性：textvariable 这个属性绑定一个变量后，它们的Text就会以变量方法来呈现。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var.<span class="built_in">set</span>(<span class="string">'初始文本'</span>)   <span class="comment"># 设置变量</span></span><br><span class="line"> </span><br><span class="line">la1=Label(root,textvariable=var) <span class="comment"># 将变量var跟文本绑定在一起</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Text多行文字区域"><a href="#Text多行文字区域" class="headerlink" title="Text多行文字区域"></a>Text多行文字区域</h3><pre><code>可用来收集(或显示)用户输入的文字</code></pre><h3 id="Listbox列表框："><a href="#Listbox列表框：" class="headerlink" title="Listbox列表框："></a>Listbox列表框：</h3><p>一个选项列表,用户可以从中选择</p><h3 id="Menu菜单"><a href="#Menu菜单" class="headerlink" title="Menu菜单"></a>Menu菜单</h3><p>点下菜单按钮后弹出的一个选项列表,用户可以从中选择<br>菜单栏(menu bar)、菜单(menu)、菜单项(menu item)<br><strong>菜单属性</strong><br>tearoff的作用就是可以将每个菜单分离出去，单独形成一个子窗口。默认是打开的状态1，通常将tearoff设置为0。<br>activebackground设置活动背景色。当鼠标移动到菜单选项上时，该菜单项的背景色。<br>activeforeground设置活动前景色。当鼠标移动到菜单选项上时，该菜单项文字显示的颜色。<br><strong>菜单方法</strong><br>add_command() 通常用于 给菜单添加普通的菜单项。<br>add_cascade() 通常用于 给menu对象添加一个瀑布菜单，点击menu对象就会弹出多个菜单项。<br>add_radiobutton() 给菜单添加radiobutton菜单项。<br>add_checkbutton() 给菜单添加checkbutton菜单项<br>add_separator() 给菜单添加分割线<br>add() 给菜单添加指定类型的菜单项，前面5中添加菜单项的方法其实都是在add函数的基础上做一个封装。<br>type() 查看菜单项的类型。通常菜单项的类型有”cascade”, “checkbutton”, “command”, “radiobutton”, “separator”, “tearoff”。</p><h3 id="Canvas画布控件模块"><a href="#Canvas画布控件模块" class="headerlink" title="Canvas画布控件模块"></a>Canvas画布控件模块</h3><p>create_polygon(x0, y0, x1, y1, … , xn, yn, options)  绘制一个至少三个点的多边形</p><h3 id="Frame-框架-包含其他组件的纯容器"><a href="#Frame-框架-包含其他组件的纯容器" class="headerlink" title="Frame    框架    包含其他组件的纯容器"></a>Frame    框架    包含其他组件的纯容器</h3><h3 id="Checkbutton-选择按钮-一组方框-可以选择其中的任意个"><a href="#Checkbutton-选择按钮-一组方框-可以选择其中的任意个" class="headerlink" title="Checkbutton    选择按钮    一组方框,可以选择其中的任意个"></a>Checkbutton    选择按钮    一组方框,可以选择其中的任意个</h3><h3 id="Menubutton-菜单按钮-用来包含菜单的组件-有下拉式、层叠式等等"><a href="#Menubutton-菜单按钮-用来包含菜单的组件-有下拉式、层叠式等等" class="headerlink" title="Menubutton    菜单按钮    用来包含菜单的组件(有下拉式、层叠式等等)"></a>Menubutton    菜单按钮    用来包含菜单的组件(有下拉式、层叠式等等)</h3><h3 id="Message-消息框-类似于标签-但可以显示多行文本"><a href="#Message-消息框-类似于标签-但可以显示多行文本" class="headerlink" title="Message    消息框    类似于标签,但可以显示多行文本"></a>Message    消息框    类似于标签,但可以显示多行文本</h3><h3 id="Radiobutton-单选按钮-一组按钮-其中只有一个可被“按下”-类似-HTML-中的-radio"><a href="#Radiobutton-单选按钮-一组按钮-其中只有一个可被“按下”-类似-HTML-中的-radio" class="headerlink" title="Radiobutton    单选按钮    一组按钮,其中只有一个可被“按下” (类似 HTML 中的 radio)"></a>Radiobutton    单选按钮    一组按钮,其中只有一个可被“按下” (类似 HTML 中的 radio)</h3><h3 id="Scale-进度条-线性“滑块”组件-可设定起始值和结束值-会显示当前位置的精确值"><a href="#Scale-进度条-线性“滑块”组件-可设定起始值和结束值-会显示当前位置的精确值" class="headerlink" title="Scale    进度条    线性“滑块”组件,可设定起始值和结束值,会显示当前位置的精确值"></a>Scale    进度条    线性“滑块”组件,可设定起始值和结束值,会显示当前位置的精确值</h3><h3 id="Scrollbar-滚动条-对其支持的组件-文本域、画布、列表框、文本框-提供滚动功能"><a href="#Scrollbar-滚动条-对其支持的组件-文本域、画布、列表框、文本框-提供滚动功能" class="headerlink" title="Scrollbar    滚动条    对其支持的组件(文本域、画布、列表框、文本框)提供滚动功能"></a>Scrollbar    滚动条    对其支持的组件(文本域、画布、列表框、文本框)提供滚动功能</h3><h3 id="Toplevel-顶级-类似框架-但提供一个独立的窗口容器"><a href="#Toplevel-顶级-类似框架-但提供一个独立的窗口容器" class="headerlink" title="Toplevel    顶级    类似框架,但提供一个独立的窗口容器"></a>Toplevel    顶级    类似框架,但提供一个独立的窗口容器</h3><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p>在tkinter中有三种标准对话框：<br>messagebox<br>filedialog<br>colorchooser</p><h3 id="弹窗messagebox"><a href="#弹窗messagebox" class="headerlink" title="弹窗messagebox"></a>弹窗messagebox</h3><p><code>from tkinter import messagebox</code></p><p>消息提示框    messagebox.showinfo(‘弹窗名称’,’弹窗内容 ‘)<br>消息警告框    messagebox.showwarning(‘弹窗名称’,’弹窗内容 ‘)<br>错误消息框    messagebox.showerror(‘弹窗名称’,’弹窗内容 ’ )<br>对话框    messagebox.askokcancel(‘弹窗名称’, ‘弹窗内容 ‘)    确定/取消，返回值true/false<br>对话框    messagebox.askquestion (‘弹窗名称’, ‘弹窗内容 ‘)    是/否，返回值yes/no<br>对话框    messagebox.askyesno (‘弹窗名称’,’弹窗内容 ‘)    是/否， 返回值true/false<br>对话框    messagebox.askretrycancel (‘弹窗名称’,’弹窗内容 ‘)    重试/取消，返回值true/false</p><h3 id="filedialog模块"><a href="#filedialog模块" class="headerlink" title="filedialog模块"></a>filedialog模块</h3><p>如果你的应用程序会需要到打开文件、保存文件、选择目录等关于文件的操作，那么就必须要用到 filedialog 。</p><p>askopenfilename 打开文件、<br>asksaveasfilename 保存文件</p><h2 id="对话输入框"><a href="#对话输入框" class="headerlink" title="对话输入框"></a>对话输入框</h2><p>Python的tkinter模块中，有一个子模块simpledialog.py，这个子模块里有这样三个函数：askinteger，askfloat，askstring。他们通过GUI窗口的方式，让用户输入一个整数，浮点数，或者字符串，并且自带输入合法性检测！使用非常方便。</p><p>from tkinter.simpledialog import askinteger,askfloat,askstring</p><h2 id="PhotoImage图片对象"><a href="#PhotoImage图片对象" class="headerlink" title="PhotoImage图片对象"></a>PhotoImage图片对象</h2><p>为了解决PhotoImage不支持jpg等格式问题，可以使用Image+ImageTk实现多种格式图片的载入。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageTk</span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">'1.jpg'</span>)</span><br><span class="line">photo = ImageTk.PhotoImage(img)</span><br><span class="line">tk.Label(paned, image=photo).grid(row=<span class="number">0</span>, column=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="控件几何状态管理方法"><a href="#控件几何状态管理方法" class="headerlink" title="控件几何状态管理方法"></a>控件几何状态管理方法</h2><p>pack和grid请参考：<a href="https://www.jianshu.com/p/91844c5bca78">https://www.jianshu.com/p/91844c5bca78</a></p><h3 id="pack"><a href="#pack" class="headerlink" title="pack()"></a>pack()</h3><p>是一种简单的布局方法，如果不加参数的默认方式，将按布局语句的先后，以最小占用空间的方式自上而下地排列控件实例，并且保持控件本身的最小尺寸。</p><p>使用pack()方法可设置 fill、side 等属性参数。其中，参数fill 可取值：fill=X,fill=Y或fill=BOTH，分别表示允许控件向水平方向、垂直方向或二维伸展填充未被占用控件。参数 side 可取值：side=TOP(默认)，side=LEFT,side=RIGHT,side=BOTTOM,分别表示本控件实例的布局相对于下一个控件实例的方位。</p><p>Button(root,text=’A’).pack(side=LEFT,expand=YES,fill=Y)</p><h3 id="grid"><a href="#grid" class="headerlink" title="grid()"></a>grid()</h3><p>是基于网格的布局。先虚拟一个二维表格，再在该表格中布局控件实例。由于在虚拟表格的单元中所布局的控件实例大小不一，单元格也没有固定或均一的大小，因此其仅用于布局的定位。pack()方法与grid()方法不能混合使用。<br>grid()方法常用布局参数如下：</p><p>column: 控件实例的起始列，最左边为第0列。<br>columnspan: 控件实例所跨越的列数，默认为1列。<br>ipadx,ipady: 控件实例所呈现区域内部的像素数，用来设置控件实例的大小。<br>padx,pady: 控件实例所占据空间像素数，用来设置实例所在单元格的大小。<br>row: 控件实例的起始行，最上面为第0行。<br>rowspan: 控件实例的起始行数，默认为1行。</p><h3 id="place-绝对布局"><a href="#place-绝对布局" class="headerlink" title="place()绝对布局"></a>place()绝对布局</h3><p>当使用 Place 布局管理容器中的组件时，需要设置组件的 x、y 或 relx、rely 选项，Tkinter 容器内的坐标系统的原点 (0,0) 在左上角，其中 X 轴向右延伸，Y 轴向下延伸<br>控件对象.place()</p><p>x,y：控件实例在根窗体中水平和垂直方向上的其实位置（单位为像素）。注意，根窗体左上角为0,0,水平向右，垂直向下为正方向。</p><p>relx,rely：控件实例在根窗体中水平和垂直方向上起始布局的相对位置。即相对于根窗体宽和高的比例位置，取值在0.0~1.0之间。</p><p>height,width：控件实例本身的高度和宽度（单位为像素）。</p><p>relheight,relwidth：控件实例相对于根窗体的高度和宽度比例，取值在0.0~1.0之间。</p><p>利用place()方法配合relx,rely和relheight,relwidth参数所得的到的界面可自适应根窗体尺寸的大小。place()方法与grid()方法可以混合使用。</p><h1 id="图像处理库"><a href="#图像处理库" class="headerlink" title="图像处理库"></a>图像处理库</h1><h2 id="PIL，cv2，plt的使用与区别"><a href="#PIL，cv2，plt的使用与区别" class="headerlink" title="PIL，cv2，plt的使用与区别"></a>PIL，cv2，plt的使用与区别</h2><ol><li>建议使用opencv的库来进行图像处理的基本操作，数据格式为numpy，可以直接进行numpy的处理；</li><li>进行折线图这类图绘制的时候，一般使用matplotlib库。</li><li>Opencv默认为 BGR顺序，而其他软件（PIL、scopy.misc）一般使用RGB。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较三者的打开图片、显示图片、打开图片的类型</span></span><br><span class="line"><span class="comment"># ************PIL************</span></span><br><span class="line">PIL_img = Image.<span class="built_in">open</span>(<span class="string">'D:/images/Rimi.jpg'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(PIL_img))  <span class="comment"># &lt;class 'PIL.JpegImagePlugin.JpegImageFile'&gt;</span></span><br><span class="line"><span class="built_in">print</span>(PIL_img.size)   <span class="comment"># (1152, 720) (w,h)</span></span><br><span class="line"><span class="built_in">print</span>(np.array(PIL_img).shape)  <span class="comment"># (720, 1152, 3) (h,w,c)</span></span><br><span class="line">PIL_img.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ************cv2************</span></span><br><span class="line">cv2_img = cv2.imread(<span class="string">'D:/images/Rimi.jpg'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(cv2_img))  <span class="comment"># &lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line"><span class="built_in">print</span>(cv2_img.shape)  <span class="comment"># (720, 1152, 3) (h,w,c)</span></span><br><span class="line">cv2.imshow(<span class="string">'cv2'</span>, cv2_img)</span><br><span class="line"><span class="comment"># cv2.waitKey()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ************plt***********</span></span><br><span class="line">plt_img = plt.imread(<span class="string">'D:/images/Rimi.jpg'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(plt_img))  <span class="comment"># &lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line"><span class="built_in">print</span>(plt_img.shape)  <span class="comment"># (720, 1152, 3) (h,w,c)</span></span><br><span class="line">plt.imshow(plt_img)  <span class="comment"># PIL_img也可以显示</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><p>OpenCV中已经包含如下应用领域功能：二维和三维特征工具箱、运动估算、人脸识别系统、姿势识别、人机交互、移动机器人、运动理解、对象鉴别、分割与识别、立体视觉、运动跟踪、增强现实（AR技术）。基于上述功能实现需要，OpenCV中还包括以下基于统计学机器学习库：Boosting算法、Decision Tree(决策树)学习、Gradient Boosting算法、EM算法(期望最大化)、KNN算法、朴素贝叶斯分类、人工神经网络、随机森林、支掌向量机。</p><p>cv2默认为 BGR顺序，而其他（PIL、scopy.misc）一般使用RGB</p><p>导入的时候采用 import cv2。</p><h3 id="cv2-imread-filepath-flags"><a href="#cv2-imread-filepath-flags" class="headerlink" title="cv2.imread(filepath,flags)"></a>cv2.imread(filepath,flags)</h3><p>加载图片</p><p>filepath：要读入图片的完整路径，路径中不要有中文名<br>flags：读入图片的标志<br>    cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道<br>    cv2.IMREAD_GRAYSCALE：读入灰度图片<br>    cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道</p><h3 id="cv2-cvtColor"><a href="#cv2-cvtColor" class="headerlink" title="cv2.cvtColor()"></a>cv2.cvtColor()</h3><p>颜色空间转换：其实就是数学运算</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread()   读取图片，默认是BGR通道</span><br><span class="line">img2 = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)    <span class="comment">#BGR通道转为RGB通道</span></span><br><span class="line"><span class="comment">#img2 = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY) #灰度化：彩色图像转为灰度图像</span></span><br><span class="line"><span class="comment">#img3 = cv2.cvtColor(img,cv2.COLOR_GRAY2RGB) #彩色化：灰度图像转为彩色图像</span></span><br></pre></td></tr></tbody></table></figure><p>cv2.COLOR_X2Y，其中X,Y = RGB, BGR, GRAY, HSV, YCrCb, XYZ, Lab, Luv, HLS</p><h3 id="cv2-imshow-wname-img"><a href="#cv2-imshow-wname-img" class="headerlink" title="cv2.imshow(wname,img)"></a>cv2.imshow(wname,img)</h3><p>#显示图像</p><p>第一个参数是显示图像的窗口的名字<br>第二个参数是要显示的图像（imread读入的图像），窗口大小自动调整为图片大小<br>cv2.imshow(‘image’,img) cv2.waitKey(0) #等待键盘输入，单位为毫秒，即等待指定的毫秒数看是否有键盘输入，若在等待时间内按下任意键则返回按键的ASCII码，程序继续运行。 #若没有按下任何键，超时后返回-1。参数为0表示无限等待。不调用waitKey的话，窗口会一闪而逝，看不到显示的图片。 cv2.destroyAllWindow() #销毁所有窗口 cv2.destroyWindow(wname) #销毁指定窗口</p><h3 id="cv2-imwrite-file，img，num"><a href="#cv2-imwrite-file，img，num" class="headerlink" title="cv2.imwrite(file，img，num)"></a>cv2.imwrite(file，img，num)</h3><p>  #保存一张图像</p><p>第一个参数是要保存的文件名<br>第二个参数是要保存的图像。可选的第三个参数，它针对特定的格式：对于JPEG，其表示的是图像的质量，用0 - 100的整数表示，默认95。<br>第三个参数表示的是压缩级别。默认为3.<br>img.copy() #图像复制</p><p>cv2.resize(image, image2,dsize) #图像缩放：(输入原始图像，输出新图像，图像的大小)<br>cv2.flip(img,flipcode) #图像翻转，flipcode控制翻转效果。</p><p>flipcode = 0：沿x轴翻转；flipcode &gt; 0：沿y轴翻转；flipcode &lt; 0：x,y轴同时翻转<br>cv2.warpAffine(img, M, (400, 600)) #图像仿射变换 ：平移；裁剪、剪切、旋转、仿射变换，<br>M、M_crop、M_shear、M_rotate</p><p>cv2.putText(img,’text’,(50,150) #图像添加文字：(照片，添加的文字，左上角坐标，字体，字体大小，颜色，字体粗细)</p><p>cv2.putText(image, caption, (b[0], b[1] - 10), cv2.FONT_HERSHEY_PLAIN, 1, (255, 0, 0), 1) cv2.putText(I,’there 0 error(s):’,(50,150),cv2.FONT_HERSHEY_COMPLEX,6,(0,0,255),25)</p><p>cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2) #画出矩行：img原图、(x，y)是矩阵的左上点坐标、(x+w，y+h)是矩阵的右下点坐标、(0,255,0)是画线对应的rgb颜色、2是所画的线的宽度。</p><p>cv2.boundingRect(img) #返回图像的四值属性：img是一个二值图，即是它的参数； 返回四个值，分别是x，y，w，h； x，y是矩阵左上点的坐标，w，h是矩阵的宽和高。</p><h3 id="固定阈值分隔"><a href="#固定阈值分隔" class="headerlink" title="固定阈值分隔"></a>固定阈值分隔</h3><h2 id="PIL库"><a href="#PIL库" class="headerlink" title="PIL库"></a>PIL库</h2><p>PIL（Python Imaging Library）是Python常用的图像处理库，而Pillow是PIL的一个友好Fork，提供了了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。相比opencv更为轻巧。Image模块是在Python PIL图像处理中常见的模块，对图像进行基础操作的功能基本都包含于此模块内。如open、save、show等功能。</p><p><a href="https://www.osgeo.cn/pillow/reference/index.html">https://www.osgeo.cn/pillow/reference/index.html</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>#安装pillow<br>pip install pillow</p><p>from PIL import Image<br>Image模块 是 PIL 库中代表一个图像的类（对象）</p><h3 id="ImageDraw-模块"><a href="#ImageDraw-模块" class="headerlink" title="ImageDraw 模块"></a>ImageDraw 模块</h3><p><strong>ImageDraw.text()</strong><br>ImageDraw.text(xy, text, fill=None, font=None, anchor=None, spacing=4, align=’left’, direction=None, features=None, language=None, stroke_width=0, stroke_fill=None, embedded_color=False)<br>在给定位置绘制字符串。</p><pre><code>xy -- 文本的锚点坐标。text -- 要绘制的字符串。如果它包含任何换行符，则文本将传递到 multiline_text() 。fill -- 用于文本的颜色。</code></pre><h2 id="Matplotlib库"><a href="#Matplotlib库" class="headerlink" title="Matplotlib库"></a>Matplotlib库</h2><p>Matplotlib是一个Python 2D绘图库，它可以在不同的平台上以各种硬拷贝格式和交互环境生成发布质量数据。Matplotlib可以用于Python脚本、Python和IPython shell、Jupyter notebook、web应用服务器和四个图形用户界面工具包。对于简单的绘图，pyplot模块提供了一个类似于matlab的接口，特别是与IPython结合使用时。对于power用户，您可以通过面向对象的界面或通过MATLAB用户熟悉的一组函数来完全控制线样式、字体属性、轴属性等.</p><p>matplotlib.pylot是绘制各类可视化图形的命令字库</p><p>更多学习，可参考Matplotlib中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn</a></p><p>#安装<br>pip install matplotlib<br>#导库<br>import matplotlib.pyplot as plt</p><h2 id="pyplot模块方法"><a href="#pyplot模块方法" class="headerlink" title="pyplot模块方法"></a>pyplot模块方法</h2><p>1.plt.imread(fname， format=None)<br>将图像从文件读取到数组中。返回一个numpy.array<br>  fname:<br>    要读取的图像文件：文件名、URL 或以读取二进制模式打开的类似文件的对象。<br>    不推荐传递 URL。请打开URL进行阅读并将结果传递给Pillow<br>  format:<br>    用于读取数据而假定的图像文件格式。如果格式设置为”png”，如果 fname 是扩展名为”.png”的路径或打开的文件，或者如果它是 URL，则图像将作为 PNG 文件加载。在所有其他情况下，格式将被忽略，PIL 会自动检测格式</p><p>2.plt.imshow(numpy.array)<br>将数据显示为图像<br>3.plt.show()<br>显示所有打开的图表</p><h1 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h1><h2 id="数学矩阵知识"><a href="#数学矩阵知识" class="headerlink" title="数学矩阵知识"></a>数学矩阵知识</h2><p><a href="https://paul.pub/the-matrix/#id-%E6%A0%87%E9%87%8F%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BC%A0%E9%87%8F">https://paul.pub/the-matrix/#id-%E6%A0%87%E9%87%8F%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BC%A0%E9%87%8F</a></p><h3 id="矩阵算术"><a href="#矩阵算术" class="headerlink" title="矩阵算术"></a>矩阵算术</h3><h4 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h4><p>矩阵的加减法只在两个矩阵具有相同大小时才有意义。</p><p>两个矩阵的加（减）法通过对应元素相加（减）得到</p><h4 id="标量乘法"><a href="#标量乘法" class="headerlink" title="标量乘法"></a>标量乘法</h4><p>设A为一矩阵，b为一标量，则bA为将A中的每一个元素乘以b而构成的一个矩阵</p><h4 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h4><p>矩阵的转置是以对角线为轴的镜像。</p><p>这条从左上角到右下角的对角线被称之为主对角线</p><h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>第一个矩阵的列要等于第二个矩阵的行，则两矩阵可以相乘。<br>一个m∗n的的A矩阵，和一个n∗p的B矩阵相乘，将得到一个m∗p的矩阵C</p><h3 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h3><p>逆(Inverse)<br>设A为n阶方阵，如果存在一个n阶方阵B，使得<br>AB=BA=In<br>AB=BA=In</p><p>则称A为可逆矩阵，B为A的逆阵，记作 B=A−1B=A−1<br>(A−1)−1=A(A−1)−1=A<br>(kA)−1=1kA−1(k≠0)(kA)−1=1kA−1(k≠0)<br>A、B均是同阶可逆矩阵，则(AB)−1=B−1A−1A、B均是同阶可逆矩阵，则(AB)−1=B−1A−1<br>(A−1)T=(AT)−1(A−1)T=(AT)−1</p><h4 id="求逆矩阵一般有三种方法。"><a href="#求逆矩阵一般有三种方法。" class="headerlink" title="求逆矩阵一般有三种方法。"></a>求逆矩阵一般有三种方法。</h4><p>1、方阵的逆矩阵等于方阵的伴随矩阵与方阵对应的行列式的值的倒数的积；</p><p>即A^-1=A*/(|A|).</p><p>只有当|A|≠0时，方阵A才可逆。</p><p>这种方法并不简便。</p><p>2、利用初等变换求逆矩阵；</p><p>一般是将矩阵(A,E)化为(E,A^-1)的形式；从而得到A逆矩阵；</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>为了创建一个2D（二维）数组，我们传递一个列表的列表（或者是一个序列的序列）给array()函数。如果我们想要一个3D（三维）数组，我们就要传递一个列表的列表的列表，如果是一个4D（四维）数组，那就是列表的列表的列表的列表，以此类推。</p><h3 id="多维数组切片"><a href="#多维数组切片" class="headerlink" title="多维数组切片"></a>多维数组切片</h3><p>通过对每个以逗号分隔的维度执行单独的切片，你可以对多维数组进行切片。因此，对于2D数组，我们的第一片定义了行的切片，第二片定义了列的切片。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>np.zeros():可以创建指定长度或者形状的全0数组</p><p>ones():可以创建指定长度或者形状的全1数组</p><p>empty():创建一个数组，其初始内容是随机的,取决于内存的状态</p><p>为了创建数字组成的数组，NumPy提供了一个类似于range的函数，该函数返回数组而不是列表。<br>array = np.arange( 10, 31,5 )   -&gt;array([10, 15, 20, 25, 30])</p><h3 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h3><p>array = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])</p><p>#数组维度<br>print(array.ndim)</p><p>#数组形状<br>print(array.shape)</p><p>#数组元素个数<br>print(array.size)</p><p>#数组元素类型<br>print(array.dtype)</p><h3 id="数组的计算"><a href="#数组的计算" class="headerlink" title="数组的计算"></a>数组的计算</h3><p>数组很重要，因为它可以使我们不用编写循环即可对数据执行批量运算。这通常叫做矢量化</p><h4 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h4><p>对应位置的数相运算</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">arr1 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">arr2 = np.ones([<span class="number">2</span>,<span class="number">3</span>],dtype=np.int64)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr1 + arr2)</span><br><span class="line"><span class="built_in">print</span>(arr1 - arr2)</span><br><span class="line"><span class="built_in">print</span>(arr1 * arr2)</span><br><span class="line"><span class="built_in">print</span>(arr1 / arr2)</span><br><span class="line"><span class="built_in">print</span>(arr1 ** <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>print(np.dot(arr3,arr4))</p><h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1><p>pandas是python第三方库，提供高性能易用数据类型和分析工具。</p><p>pandas基于numpy实现，常与numpy和matplotlib一同使用</p><p>更多学习，请参考pandas中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></p><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>Series是一种类似于一维数组的对象，它由一维数组（各种numpy数据类型）以及一组与之相关的数据标签（即索引）组成.</p><p>可理解为带标签的一维数组，可存储整数、浮点数、字符串、Python 对象等类型的数据。</p><p>Seris中可以使用index设置索引列表。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#与字典不同的是：Series允许索引重复</span></span><br><span class="line">s = pd.Series([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>],index=[<span class="number">100</span>,<span class="number">200</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">500</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Series 可以用字典实例化</span></span><br><span class="line">d = {<span class="string">'b'</span>: <span class="number">1</span>, <span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'c'</span>: <span class="number">2</span>}</span><br><span class="line">pd.Series(d)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过Series的values和index属性获取其数组表示形式和索引对象</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(s.values)</span><br><span class="line"><span class="built_in">print</span>(s.index)</span><br></pre></td></tr></tbody></table></figure><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>DataFrame是一个表格型的数据结构，类似于Excel或sql表</p><p>它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）<br>DataFrame可以进行行索引和列索引，它可以被看做由Series组成的字典（共用同一个索引）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用多维数组字典、列表字典生成 DataFrame</span></span><br><span class="line">data = {<span class="string">'state'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>], <span class="string">'year'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>], <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>]}</span><br><span class="line">frame = pd.DataFrame(data) </span><br><span class="line"><span class="built_in">print</span>(frame)</span><br><span class="line"></span><br><span class="line">frame2 = pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>, <span class="string">'debt'</span>], index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>])</span><br><span class="line"><span class="built_in">print</span>(frame2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#列可以通过赋值的方式进行修改,例如，给那个空的“delt”列赋上一个标量值或一组值</span></span><br><span class="line">frame2[<span class="string">'debt'</span>] = <span class="number">16.5</span></span><br><span class="line"><span class="built_in">print</span>(frame2)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="内部库"><a href="#内部库" class="headerlink" title="内部库"></a>内部库</h1><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><p>通过它可以获取命令行参数，从而实现从程序外部向程序内部传递参数的功能，也可以获取程序路径和当前系统平台等信息。</p><p>B. platform<br>C. math<br>D. time</p><h1 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h1><p>SMTP（Simple Mail Transfer Protocol）是简单传输协议，它是一组用于用于由源地址到目的地址的邮件传输规则。</p><p>smtplib模块</p><p>python中对SMTP进行了简单的封装，可以发送纯文本邮件、HTML邮件以及带附件的邮件。两个核心模块如下：</p><p>email模块：负责构建邮件<br>smtplib模块：负责发送邮件</p><h2 id="二、邮件发送协议介绍"><a href="#二、邮件发送协议介绍" class="headerlink" title="二、邮件发送协议介绍"></a>二、邮件发送协议介绍</h2><p>什么是POPO3、SMTP和IMAP?服务器地址和端口是什么？ </p><p>2.1、POP3<br>      POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离 线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循 POP3协议的接收邮件服务器，用来接收电子邮件的。(与IMAP有什么区别？) </p><p>2.2、SMTP<br>       SMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。 SMTP 认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。 增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰。 </p><p>2.3、IMAP<br>IMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留 在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端 软件登录邮箱，看到的邮件以及状态都是一致的。（与POP3有什么区别？） </p><h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>JSON 的本质是字符串。是一种通用的，跨平台的数据交换格式。类似python的字典</p><h2 id="json数据类型"><a href="#json数据类型" class="headerlink" title="json数据类型"></a>json数据类型</h2><p>json 类型转换到 python 的类型对照表：<br>| JSON          | Python     |<br>|—————|————|<br>| object        | dict       |<br>| array         | list,tuple |<br>| string        | str        |<br>| number (int)  | int, long  |<br>| number (real) | float      |<br>| true，false   | True,False |<br>| null          | None       |</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">json.load()   <span class="comment">#读取json文件,转换为python字典</span></span><br><span class="line">json.loads()  <span class="comment">#将json字符串转换为python对象如字典</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json.dumps()<span class="comment">#  将python数据转换为json字符串</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FuzzyWuzzy模糊匹配库&quot;&gt;&lt;a href=&quot;#FuzzyWuzzy模糊匹配库&quot; class=&quot;headerlink&quot; title=&quot;FuzzyWuzzy模糊匹配库&quot;&gt;&lt;/a&gt;FuzzyWuzzy模糊匹配库&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://m</summary>
      
    
    
    
    <category term="python" scheme="https://wenkex.gitee.io/categories/python/"/>
    
    
    <category term="python" scheme="https://wenkex.gitee.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python-pandas</title>
    <link href="https://wenkex.gitee.io/2022/03226351.html"/>
    <id>https://wenkex.gitee.io/2022/03226351.html</id>
    <published>2022-03-22T13:29:33.000Z</published>
    <updated>2022-03-22T13:29:33.000Z</updated>
    
    
    
    
    <category term="python" scheme="https://wenkex.gitee.io/categories/python/"/>
    
    
    <category term="pandas" scheme="https://wenkex.gitee.io/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>python-NumPy</title>
    <link href="https://wenkex.gitee.io/2022/032261592.html"/>
    <id>https://wenkex.gitee.io/2022/032261592.html</id>
    <published>2022-03-22T06:42:45.000Z</published>
    <updated>2022-03-22T06:42:45.000Z</updated>
    
    
    
    
    <category term="python" scheme="https://wenkex.gitee.io/categories/python/"/>
    
    
    <category term="numpy" scheme="https://wenkex.gitee.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫学习</title>
    <link href="https://wenkex.gitee.io/2022/031717083.html"/>
    <id>https://wenkex.gitee.io/2022/031717083.html</id>
    <published>2022-03-16T23:56:59.000Z</published>
    <updated>2022-03-16T23:56:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络数据采集概述"><a href="#网络数据采集概述" class="headerlink" title="网络数据采集概述"></a>网络数据采集概述</h1><p>爬虫（crawler）也经常被称为网络蜘蛛（spider），是按照一定的规则自动浏览网站并获取所需信息的机器人程序（自动化脚本代码），被广泛的应用于互联网搜索引擎和数据采集。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接，网络爬虫正是通过网页中的超链接信息，不断获得网络上其它页面的地址，然后持续的进行数据采集。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为爬虫或者网络蜘蛛。</p><h2 id="爬虫的应用领域"><a href="#爬虫的应用领域" class="headerlink" title="爬虫的应用领域"></a>爬虫的应用领域</h2><p>爬虫的应用领域其实非常广泛，下面我们列举了其中的一部分</p><ol><li>搜索引擎</li><li>新闻聚合</li><li>社交应用</li><li>舆情监控</li><li>行业数据<h2 id="爬虫合法性探讨"><a href="#爬虫合法性探讨" class="headerlink" title="爬虫合法性探讨"></a>爬虫合法性探讨</h2></li></ol><p>经常听人说起“爬虫写得好，牢饭吃到饱”，那么编程爬虫程序是否违法呢？关于这个问题，我们可以从以下几个角度进行解读。</p><ol><li>网络爬虫这个领域目前还属于拓荒阶段，虽然互联网世界已经通过自己的游戏规则建立起了一定的道德规范，即 Robots 协议（全称是“网络爬虫排除标准”），但法律部分还在建立和完善中，也就是说，现在这个领域暂时还是灰色地带。</li><li>“法不禁止即为许可”，如果爬虫就像浏览器一样获取的是前端显示的数据（网页上的公开信息）而不是网站后台的私密敏感信息，就不太担心法律法规的约束，因为目前大数据产业链的发展速度远远超过了法律的完善程度。</li><li>在爬取网站的时候，需要限制自己的爬虫遵守 Robots 协议，同时控制网络爬虫程序的抓取数据的速度；在使用数据的时候，必须要尊重网站的知识产权（从Web 2.0时代开始，虽然Web上的数据很多都是由用户提供的，但是网站平台是投入了运营成本的，当用户在注册和发布内容时，平台通常就已经获得了对数据的所有权、使用权和分发权）。如果违反了这些规定，在打官司的时候败诉几率相当高。</li><li>适当的隐匿自己的身份在编写爬虫程序时必要的，而且最好不要被对方举证你的爬虫有破坏别人动产（例如服务器）的行为。</li><li>不要在公网（如代码托管平台）上去开源或者展示你的爬虫代码，这些行为通常会给自己带来不必要的麻烦。</li></ol><h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><p>下面我们先介绍一些开发爬虫程序的辅助工具，这些工具相信能帮助你事半功倍。</p><ol><li><p>Chrome Developer Tools：谷歌浏览器内置的开发者工具。该工具最常用的几个功能模块是：</p><ul><li>元素（ELements）：用于查看或修改 HTML 元素的属性、CSS 属性、监听事件等。CSS 可以即时修改，即时显示，大大方便了开发者调试页面。</li><li>控制台（Console）：用于执行一次性代码，查看 JavaScript 对象，查看调试日志信息或异常信息。控制台其实就是一个执行 JavaScript 代码的交互式环境。</li><li>源代码（Sources）：用于查看页面的 HTML 文件源代码、JavaScript 源代码、CSS 源代码，此外最重要的是可以调试 JavaScript 源代码，可以给代码添加断点和单步执行。</li><li>网络（Network）：用于 HTTP 请求、HTTP 响应以及与网络连接相关的信息。</li><li>应用（Application）：用于查看浏览器本地存储、后台任务等内容，本地存储主要包括Cookie、Local Storage、Session Storage等。</li></ul><p><img src="https://gitee.com/jackfrued/mypic/raw/master/20210824004034.png" alt="chrome-developer-tools"></p></li><li><p>Postman：功能强大的网页调试与 RESTful 请求工具。Postman可以帮助我们模拟请求，非常方便的定制我们的请求以及查看服务器的响应。</p><p><img src="https://gitee.com/jackfrued/mypic/raw/master/20210824004048.png" alt="postman"></p></li><li><p>HTTPie：命令行HTTP客户端。</p><p>安装。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install httpie</span><br></pre></td></tr></tbody></table></figure><p>使用。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http --header http --header https://movie.douban.com/</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Date: Tue, 24 Aug 2021 16:48:00 GMT</span><br><span class="line">Keep-Alive: timeout=30</span><br><span class="line">Server: dae</span><br><span class="line">Set-Cookie: bid=58h4BdKC9lM; Expires=Wed, 24-Aug-22 16:48:00 GMT; Domain=.douban.com; Path=/</span><br><span class="line">Strict-Transport-Security: max-age=15552000</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-DOUBAN-NEWBID: 58h4BdKC9lM</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>builtwith</code>库：识别网站所用技术的工具。</p><p>安装。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install builtwith</span><br></pre></td></tr></tbody></table></figure><p>使用。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> builtwith</span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line"><span class="built_in">print</span>(builtwith.parse(<span class="string">'http://www.bootcss.com/'</span>))</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>python-whois</code>库：查询网站所有者的工具。</p><p>安装。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install python-whois</span><br></pre></td></tr></tbody></table></figure><p>使用。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> whois</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(whois.whois(<span class="string">'https://www.bootcss.com'</span>))</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="爬虫的基本工作流程"><a href="#爬虫的基本工作流程" class="headerlink" title="爬虫的基本工作流程"></a>爬虫的基本工作流程</h2><h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><p>获取网页源代码</p><h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><p>获取网也源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。</p><p>由于网页的结构有一定的规侧，所以还有一些根据网页节点属性、CSS选择器或XPath来提取网顶信息的库，如Beautifu1Soup、<br>pyquery、1xm1等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。<br>提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。</p><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为TXT文本或json文本，也可以保存到数据库，如MySQL和MongoDB等，也可保存至远程服务器，如借助SFTP进行操作等。</p><h1 id="代理ip"><a href="#代理ip" class="headerlink" title="代理ip"></a>代理ip</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>代理实际上指的就是代理服务器，英文叫作proxy server，它的功能是代理网络用户去取得网络信息。形象地说，它是网络信息的中转站。在我们正常请求一个网站时，是发送了请求给Web服务器，Web服务器把响应传回给我们。如果设置了代理服务器，实际上就是在本机和服务器之间搭建了一个桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发出请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机。这样我们同样可以正常访问网页，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP了，就成功实现了IP伪装，这就是代理的基本原理。</p><h2 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h2><p>突破自身IP访问限制，访问一些平时不能访问的站点。<br>访问一些单位或团体内部资源：比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。<br>提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。<br>隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP，防止自身的IP被封锁。</p><h1 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h1><p>Python爬虫时，更建议用requests库。因为requests比urllib更为便捷，requests可以直接构造get，post请求并发起，而urllib.request只能先构造get，post请求，再发起。</p><h2 id="添加请求头"><a href="#添加请求头" class="headerlink" title="添加请求头"></a>添加请求头</h2><p>在发起一个 HTTP 请求的时候，会有一个请求头 Request Headers，<br>如果不设置Request Headers 信息，某些网站会发现这不是一个正常的浏览器发起的请求，网站可能会返回异常的结果，导致网页抓取失败。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用 headers 参数来指定请求头</span><br><span class="line">headers = {</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36'</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">requests.get(url, headers=headers)</span><br></pre></td></tr></tbody></table></figure><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(url)  <span class="comment">#返回一个repose对象</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Response对象的方法"><a href="#Response对象的方法" class="headerlink" title="Response对象的方法"></a>Response对象的方法</h3><p>r.text()   </p><h3 id="Response对象的属性"><a href="#Response对象的属性" class="headerlink" title="Response对象的属性"></a>Response对象的属性</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">r.status_code： <span class="comment">#HTTP请求的返回状态码，200表示连接成功，404表示失败</span></span><br><span class="line">r.text：<span class="comment"># HTTP响应内容的字符串形式，即，url对应的页面内容</span></span><br><span class="line"></span><br><span class="line">r.encoding：<span class="comment">#从HTTP header中猜测的响应内容编码方式</span></span><br><span class="line">r.apparent_encoding：<span class="comment">#从内容中分析出的响应内容编码方式（备选编码方式）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.content： <span class="comment">#返回HTTP响应内容的bytes(二进制)，有中文时，用这个</span></span><br><span class="line">r.content.decode(<span class="string">'utf-8'</span>)     <span class="comment">#将二进制内容解码</span></span><br><span class="line">json.loads(r.content.decode())     <span class="comment">#将json格式转换为字典  </span></span><br></pre></td></tr></tbody></table></figure><h2 id="抓取二进制数据"><a href="#抓取二进制数据" class="headerlink" title="抓取二进制数据"></a>抓取二进制数据</h2><p>图片、音频、视频这些文件本质上都是由二进制码组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests r = requests.get(<span class="string">'https://github.com/favicon.ico'</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'favicon.ico'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">   f.write(r.content)</span><br></pre></td></tr></tbody></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">files = {<span class="string">'file'</span>: <span class="built_in">open</span>(<span class="string">'favicon.ico'</span>, <span class="string">'rb'</span>)} </span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, files=files) </span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>urllib.request.urlretrieve(url, filename=None, reporthook=None, data=None)<br>参数说明<br>   url：外部或者本地url<br>   filename：指定了保存到本地的路径,文件夹必须已有（如果未指定该参数，urllib会生成一个临时文件来保存数据）；</p><p>   reporthook：是一个回调函数，当连接上服务器、以及相应的数据块传输完毕的时候会触发该回调。我们可以利用这个回调函数来显示当前的下载进度。</p><p>   data：指post到服务器的数据。该方法返回一个包含两个元素的元组(filename, headers)，filename表示保存到本地的路径，header表示服务器的响应头。</p><h2 id="获取和设置-Cookies"><a href="#获取和设置-Cookies" class="headerlink" title="获取和设置 Cookies"></a>获取和设置 Cookies</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="comment"># 获取</span></span><br><span class="line">r = requests.get(<span class="string">'http://www.baidu.com'</span>) </span><br><span class="line"><span class="comment"># 先调用 cookies 属性即可成功得到 Cookies，可以发现它是 RequestCookieJar 类型</span></span><br><span class="line"><span class="built_in">print</span>(r.cookies) </span><br><span class="line"><span class="comment"># 用 items 方法将其转化为元组组成的列表，遍历输出每一个 Cookie 的名称和值，实现 Cookie 的遍历解析。</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> r.cookies.items(): </span><br><span class="line">   <span class="built_in">print</span>(key + <span class="string">'='</span> + value)</span><br></pre></td></tr></tbody></table></figure><h2 id="Session维持"><a href="#Session维持" class="headerlink" title="Session维持"></a>Session维持</h2><p>在 requests 中，如果直接利用 get 或 post 等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的 Session，相当于你用两个浏览器打开了不同的页面。 设想这样一个场景，第一个请求利用 post 方法登录了某个网站，第二次想获取成功登录后的自己的个人信息，你又用了一次 get 方法去请求个人信息页面。实际上，这相当于打开了两个浏览器，是两个完全不 相关的 Session，能成功获取个人信息吗？当然不能。 有人会问，我在两次请求时设置一样的 Cookies 不就行了？可以，但这样做起来很烦琐，我们有更简单的解决方法。 解决这个问题的主要方法就是维持同一个 Session，相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但我又不想每次设置 Cookies，那该怎么办呢？这时候就有了新的利器 ——Session对象。 利用它，我们可以方便地维护一个 Session，而且不用担心 Cookies 的问题，它会帮我们自动处理好。</p><h2 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h2><h1 id="提取html内容"><a href="#提取html内容" class="headerlink" title="提取html内容"></a>提取html内容</h1><p>Python中解析网页HTML内容的四种方法：<br>BeautifulSoup<br>lxml的XPath<br>requests-html<br>正则表达式</p><h2 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h2><p><a href="http://c.biancheng.net/python_spider/lxml.html">http://c.biancheng.net/python_spider/lxml.html</a><br>lxml 是 Python 的第三方解析库，完全使用 Python 语言编写，它对 Xpath 表达式提供了良好的支持，因此能够使用Xpath 表达式高效地解析 HTML/XML 文档，从中提取想要的内容</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pip3 install lxml  #安装</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h2><p>xpath是一种HTML与XML的查询语言，能在HTML与XML的树状结构中寻找节点</p><p>开头是单斜杠就是从文档开头匹配，双斜杠就是任意位置匹配</p><p>获取文本<br>//标签一[@属性1=”属性值一”]/标签二[@属性2=”属性值2”]/…/text()</p><p>获取属性值<br>//标签一[@属性1=”属性值一”]/标签二[@属性2=”属性值2”]/.../@属性n</p><h2 id="Beautifulsoup"><a href="#Beautifulsoup" class="headerlink" title="Beautifulsoup"></a>Beautifulsoup</h2><p><a href="https://beautifulsoup.cn/">Beautiful Soup 4.4.0 文档</a><br>一个灵活又方便的HTML解析库，处理高效，支持多种解析器，利用它不使用正则表达式也能抓取网页内容。<br><code>pip install brautiful4</code><br><strong>安装解析器</strong><br>Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 lxml .根据操作系统不同,可以选择下列方法来安装lxml:</p><p>$ apt-get install Python-lxml</p><p>$ easy_install lxml</p><p>$ pip install lxml</p><p>另一个可供选择的解析器是纯Python实现的 html5lib , html5lib的解析方式与浏览器相同,可以选择下列方法来安装html5lib:</p><p>$ apt-get install Python-html5lib</p><p>$ easy_install html5lib</p><p>$ pip install html5lib</p><p><strong>BeautifulSoup类的基本元素</strong><br><img src="https://pic2.zhimg.com/80/v2-b0c428a1556d00e54cd8f4175d76bb19_1440w.jpg"></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment"># 实例化Beautifulsoup对象，可以传入一段字符串(html字符串)或一个文件句柄(html文件).</span></span><br><span class="line">soup = Beautifulsoup(html,<span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">通过点号操作符，可以直接访问文档中的特定标签</span></span><br><span class="line"><span class="string">这样的方式每次只会返回文档中的第一个标签，对于多个标签，则通过find_all方法返回多个标签构成的列表。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">soup.head.tltle </span><br><span class="line"></span><br><span class="line">soup.find_all(<span class="string">'a'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup.a</span><br><span class="line">&lt;a <span class="class"><span class="keyword">class</span>="<span class="title">sister</span>" <span class="title">href</span>="<span class="title">http</span>:</span>//example.com/elsie<span class="string">" id="</span>link1<span class="string">"&gt;Elsie&lt;/a&gt;</span></span><br><span class="line"><span class="string">soup.a['class']     #['sister']</span></span><br><span class="line"><span class="string">soup.a.get('class')    #['sister']  获取a标签的class属性的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup.a.name   'a'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup.a.string   #获取a标签的文本  'Elsie'</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></tbody></table></figure><p><strong>soup.find()</strong><br>find(name, attrs, recursive, text, **wargs)　只返回第一个匹配到的对象<br>参数：　<br>   name    标签名<br>   attrs ：属性{‘class’: ‘img’}   {“属性名”:”属性值”}<br>   text    查找文本</p><p><strong>soup.findAll()</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid = soup.find(attrs={"id":"aa"})</span><br><span class="line">pid = soup.findAll('a',{'class':'sister'})</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络数据采集概述&quot;&gt;&lt;a href=&quot;#网络数据采集概述&quot; class=&quot;headerlink&quot; title=&quot;网络数据采集概述&quot;&gt;&lt;/a&gt;网络数据采集概述&lt;/h1&gt;&lt;p&gt;爬虫（crawler）也经常被称为网络蜘蛛（spider），是按照一定的规则自动浏览网站并获</summary>
      
    
    
    
    <category term="python" scheme="https://wenkex.gitee.io/categories/python/"/>
    
    
    <category term="爬虫" scheme="https://wenkex.gitee.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>flask学习笔记</title>
    <link href="https://wenkex.gitee.io/2022/031560473.html"/>
    <id>https://wenkex.gitee.io/2022/031560473.html</id>
    <published>2022-03-15T12:00:45.000Z</published>
    <updated>2022-03-15T12:00:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.w3cschool.cn/flask/">https://www.w3cschool.cn/flask/</a></p><p><a href="https://dormousehole.readthedocs.io/en/latest/index.html">flask中文文档</a></p><p><a href="https://www.imooc.com/wiki/flasklesson/flaskormoverview.html">https://www.imooc.com/wiki/flasklesson/flaskormoverview.html</a></p><p><a href="https://www.w3cschool.cn/flask/flask-kbid3h91.html">https://www.w3cschool.cn/flask/flask-kbid3h91.html</a></p><p><a href="https://www.zlkt.net/book/detail/10">知了传课</a></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p><a href="https://blog.csdn.net/asd529735325/article/details/103011940">https://blog.csdn.net/asd529735325/article/details/103011940</a></p><h1 id="web前置"><a href="#web前置" class="headerlink" title="web前置"></a>web前置</h1><h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h2><p>M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式<br>model：模型<br>view：视图<br>controler:控制器</p><h2 id="WSGI-Python-Web-Server-Gateway-Interface"><a href="#WSGI-Python-Web-Server-Gateway-Interface" class="headerlink" title="WSGI(Python Web Server Gateway Interface)"></a>WSGI(Python Web Server Gateway Interface)</h2><p>指定了web服务器和Python web应用或web框架之间的标准接口，以提高web应用在一系列web服务器间的移植性</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>超文本传输协议（HTTP）<br>因为我们在网页上看到的内容通常是浏览器执行 HTML （超文本标记语言）得到的结果，而 HTTP 就是传输 HTML 数据的协议。HTTP 和其他很多应用级协议一样是构建在 TCP（传输控制协议）之上的，它利用了 TCP 提供的可靠的传输服务实现了 Web 应用中的数据交换。 关于 HTTP 的详细信息以及目前的发展状况，大家可以阅读<a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a>、<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">《互联网协议入门》</a>、<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">《图解 HTTPS 协议》</a>等文章进行了解。</p><h3 id="reques请求"><a href="#reques请求" class="headerlink" title="reques请求"></a>reques请求</h3><p>请求头（headers）<br>请求头由若干键值对构成，包含了浏览器、编码方式、首选语言、缓存策略等信息；</p><p>请求体（request body）</p><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>请求方法有8种：<br>GET（完整请求一个资源）、<br>POST（提交表单）<br>PUT（上传文件）<br>DELETE（删除）、</p><h3 id="repose响应"><a href="#repose响应" class="headerlink" title="repose响应"></a>repose响应</h3><p>响应行包含了协议版本和响应状态码</p><p>响应头<br>响应头与 HTTP 请求中的请求头类似，同样由头部字段名、冒号、空格和值组成<br>响应头中包含了一系列服务器的信息，以及服务器对请求的响应。</p><p>响应体<br>HTTP 响应中同样使用空行来表示响应头结束。响应体则是服务器根据客户端的请求返回给客户端的具体数据。可能是 HTML 页面，也有可能是JSON或二进制数据等</p><h1 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h1><p>安装<code>pip install flask</code></p><h2 id="flask应用"><a href="#flask应用" class="headerlink" title="flask应用"></a>flask应用</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入Flask模块</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Flask实例对象，这是一个WSGI应用程序。</span></span><br><span class="line"><span class="comment"># 使用当前模块（__name __）的名称作为参数。</span></span><br><span class="line"><span class="comment">#作用一，寻找模板时以当前文件为参考</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># route装饰器将url绑定一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/'</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   app.run(debug = <span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><p>Flask类的run()方法在本地开发服务器上运行应用程序。</p><p>app.run(host, port, debug, options)<br>    host要监听的主机名。 默认为127.0.0.1（localhost）。设置为“0.0.0.0”以使服务器在外部可用<br>    port默认值为5000<br>    debug默认为false。 如果设置为true，则提供调试信息<br>    options要转发到底层的Werkzeug服务器。</p><h2 id="app-route-路由"><a href="#app-route-路由" class="headerlink" title="@app.route()路由"></a>@app.route()路由</h2><p>使用@app.route()装饰器，并传入URL规则作为参数，将函数绑定到URL，这个过程便将一个视图函数注册为路由</p><h3 id="变量规则"><a href="#变量规则" class="headerlink" title="变量规则"></a>变量规则</h3><p>通过把 URL 的一部分标记为 <code>&lt;variable_name&gt;</code> 就可以在 URL 中添加变量。标记的 部分会作为关键字参数传递给函数。通过使用 <code>&lt;converter:variable_name&gt;</code> ，可以 选择性的加上一个转换器，为变量指定规则。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/hello/&lt;name&gt;'</span></span>)   </span><span class="comment">#路由</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_name</span>(<span class="params">name</span>):</span>         <span class="comment">#视图函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">'Hello %s!'</span> % name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#调试模式,如果代码更改，服务器将自行重新加载。会在终端提示错误</span></span><br><span class="line">app.run(host=<span class="string">"127.0.0.1"</span>,post=<span class="string">''</span>,debug = <span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>还可以使用转换器构建规则<br>  <code>@app.route('/blog/&lt;int:postID&gt;')</code><br>  int    接受正整数<br>  float    接受正浮点数<br>  path    类似 string ，但可以包含斜杠<br>  uuid    接受 UUID 字符串<br>  string    （缺省值） 接受任何不包含斜杠的文本</p><h3 id="唯一的URL-重定向行为"><a href="#唯一的URL-重定向行为" class="headerlink" title="唯一的URL/重定向行为"></a>唯一的URL/重定向行为</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/user/'</span></span>) </span></span><br></pre></td></tr></tbody></table></figure><p>尾部有/，无论请求的Url是否带有/，都可以执行视图函数，访问一个没有斜杠结尾的 URL 时 Flask 会自动进行重定向，帮你在尾部加上一个斜杠。</p><p>尾部没有/，如果访问这个 URL 时添加了尾部斜杠就会得到一个 404 错误。这样可以保持 URL 唯一，并帮助 搜索引擎避免重复索引同一页面。</p><h3 id="URL-构建"><a href="#URL-构建" class="headerlink" title="URL 构建"></a>URL 构建</h3><p><strong>url_for()函数</strong>用于构建指定函数的 URL。</p><p>  接受函数的名称作为第一个参数，<br>  任意个关键字参数，每个参数对应于URL的变量部分。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, redirect, url_for</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/admin'</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_admin</span>():</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">'Hello Admin'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/user/&lt;name&gt;'</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_user</span>(<span class="params">name</span>):</span></span><br><span class="line">   <span class="keyword">if</span> name ==<span class="string">'admin'</span>:</span><br><span class="line">    <span class="comment"># 如果匹配，则使用url_for()将应用程序重定向到hello_admin()函数</span></span><br><span class="line">      <span class="keyword">return</span> redirect(url_for(<span class="string">'hello_admin'</span>))</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> redirect(url_for(<span class="string">'hello_guest'</span>, guest = name))</span><br></pre></td></tr></tbody></table></figure><p>为什么不在把 URL 写死在模板中，而要使用反转函数 url_for() 动态构建？</p><p>1.URL反转：根据视图函数名称得到当前所指向的url,函数名一般很少更改，当更改url时就不用改全部辣</p><p>2.url_for() 函数最简单的用法是以视图函数名作为参数，返回对应的url，还可以用作加载静态文件，如在模版中加载css静态文件.<code>&lt;link rel="stylesheet" href="{{url_for('static',filename='css/index.css')}}"&gt;</code></p><h3 id="页面跳转和重定向："><a href="#页面跳转和重定向：" class="headerlink" title="页面跳转和重定向："></a>页面跳转和重定向：</h3><p>redirect 是重定向函数，输入一个URL后，自动跳转到另一个URL所在的地址 </p><ul><li><p>永久性重定向：http的状态码是301，多用于旧网址被废弃了要转到一个新的网址确保用户的访问，最经典的就是京东网站，你输入<a href="http://www.jingdong.com的时候,会被重定向到www.jd.com,因为jingdong.com这个网址已经被废弃了,被改成jd.com,所以这种情况下应该用永久重定向./">www.jingdong.com的时候，会被重定向到www.jd.com，因为jingdong.com这个网址已经被废弃了，被改成jd.com，所以这种情况下应该用永久重定向。</a></p></li><li><p>暂时性重定向：http的状态码是302，表示页面的暂时性跳转。比如访问一个需要权限的网址，如果当前用户没有登录，应该重定向到登录页面，这种情况下，应该用暂时性重定向。</p></li></ul><p>在flask中，重定向是通过flask.redirect(location,code=302)这个函数来实现的，location表示需要重定向到的URL，应该配合之前讲的url_for()函数来使用，code表示采用哪个重定向，默认是302也即暂时性重定向，可以修改成301来实现永久性重定向。</p><p>以下来看一个例子，关于在flask中怎么使用重定向：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,url_for,redirect</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/login/'</span>,methods=[<span class="string">'GET'</span>,<span class="string">'POST'</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'login page'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/profile/'</span>,methods=[<span class="string">'GET'</span>,<span class="string">'POST'</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profile</span>():</span></span><br><span class="line">    name = request.args.get(<span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> name:</span><br><span class="line">    <span class="comment"># 如果没有name，说明没有登录，重定向到登录页面</span></span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'login'</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> name</span><br></pre></td></tr></tbody></table></figure><h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><p>Web 应用使用不同的 HTTP 方法处理 URL 。 缺省情况下，一个路由只回应 GET 请求。 可以使用 route() 装饰器的 methods 参数来处理不同的 HTTP 方法:</p><p>1.从服务器获取数据一般用Get请求<br>2.把数据发送给服务器用Post请求</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/login'</span>, methods=[<span class="string">'GET'</span>, <span class="string">'POST'</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="keyword">return</span> do_the_login()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> show_the_login_form()</span><br></pre></td></tr></tbody></table></figure><p>如果当前使用了 GET 方法， Flask 会自动添加 HEAD 方法支持，并且同时还会 按照 HTTP RFC 来处理 HEAD 请求。同样， OPTIONS 也会自动实现。</p><h2 id="Jinja模板"><a href="#Jinja模板" class="headerlink" title="Jinja模板"></a>Jinja模板</h2><p>视图函数只负责业务逻辑和数据处理(业务逻辑方面)<br>而模板则取到视图函数的数据结果进行展示(视图展示方面)</p><p>在项目下创建 templates 文件夹，用于存放所有html模板文件</p><h3 id="Flask渲染Jinja模板"><a href="#Flask渲染Jinja模板" class="headerlink" title="Flask渲染Jinja模板"></a>Flask渲染Jinja模板</h3><p>当访问/about/的时候，about()函数会在当前目录下的templates文件夹下寻找about.html模板文件。如果想更改模板文件地址，应该在创建app的时候，给Flask传递一个关键字参数template_folder，指定具体的路径，再看以下例子：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template</span><br><span class="line"><span class="comment">#在C盘的templates文件夹中寻找模板文件。</span></span><br><span class="line">app = Flask(__name__,template_folder=<span class="string">r'C:\templates'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/about/'</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">about</span>():</span></span><br><span class="line">  <span class="comment">#要渲染一个模板，通过render_template方法即可</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'about.html'</span>)```</span><br></pre></td></tr></tbody></table></figure><h3 id="静态文件的配置"><a href="#静态文件的配置" class="headerlink" title="静态文件的配置"></a>静态文件的配置</h3><p>Web应用中会出现大量的静态文件来使得网页更加生动美观。类似于CSS样式文件、JavaScript脚本文件、图片文件、字体文件等静态资源。在Jinja中加载静态文件非常简单，只需要通过url_for全局函数就可以实现，看以下代码：</p><p><code>&lt;link href="{{ url_for('static',filename='about.css') }}"&gt;</code><br>url_for函数默认会在项目根目录下的static文件夹中寻找about.css文件，如果找到了，会生成一个相对于项目根目录下的/static/about.css路径。当然我们也可以把静态文件不放在static文件夹中，此时就需要具体指定了，看以下代码：</p><p><code>app = Flask(__name__,static_folder='C:\static')</code><br>那么访问静态文件的时候，将会到/static这个文件夹下寻找。</p><h3 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h3><p> 如果想要传递变量到模板中，那么可以把变量定义成字典，然后在<code>render_template</code>中，通过关键字参数的方式传递过去。<code>render_template('',**context)</code>。<br>代码中传入字符串，列表，字典到模板中</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/'</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="comment"># 往模板中传入的数据</span></span><br><span class="line">    my_str = <span class="string">'Hello Word'</span></span><br><span class="line">    my_int = <span class="number">10</span></span><br><span class="line">    my_array = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">    my_dict = {</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'xiaoming'</span>,</span><br><span class="line">        <span class="string">'age'</span>: <span class="number">18</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>,</span><br><span class="line">                           my_str=my_str,</span><br><span class="line">                           my_int=my_int,</span><br><span class="line">                           my_array=my_array,</span><br><span class="line">                           my_dict=my_dict</span><br><span class="line">                           )</span><br></pre></td></tr></tbody></table></figure><p>模板中代码</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  我的模板html内容</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span>{{ my_str }}</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span>{{ my_int }}</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span>{{ my_array }}</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span>{{ my_dict }}</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Jinja2模版概述"><a href="#Jinja2模版概述" class="headerlink" title="Jinja2模版概述"></a>Jinja2模版概述</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">2. <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">3.    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Webpage<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">4. <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">5. <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">6.     <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"navigation"</span>&gt;</span></span><br><span class="line">7.     {% for item in navigation %}</span><br><span class="line">8.         <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"{{ item.href }}"</span>&gt;</span>{{ item.caption }}<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">9.     {% endfor %}</span><br><span class="line">10.    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">11.</span><br><span class="line">12.    {{ a_variable }}</span><br><span class="line">13.    {{ user.name }}</span><br><span class="line">14.    {{ user['name'] }}</span><br><span class="line">15.</span><br><span class="line">16.    {# a comment #}</span><br><span class="line">17. <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">18.<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>以上示例有需要进行解释：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 第12~14行的{{ ... }}：用来装载一个变量，模板渲染的时候，会把这个变量代表的值替换掉。并且可以间接访问一个变量的属性或者一个字典的key。关于点.号访问和[]中括号访问，没有任何区别，都可以访问属性和字典的值。</span><br><span class="line">  第7~9行的{% ... %}：用来装载一个控制语句，以上装载的是for循环，</span><br><span class="line">  第14行的{# ... #}：用来装载一个注释，模板渲染的时候会忽视这中间的值。</span><br><span class="line"></span><br><span class="line">二、属性访问规则：</span><br><span class="line">比如在模板中有一个变量这样使用：foo.bar，那么在Jinja2中是这样进行访问的：</span><br><span class="line"></span><br><span class="line">先去查找foo的bar这个属性，也即通过getattr(foo,'bar')。</span><br><span class="line">如果没有，就去通过foo.__getitem__('bar')的方式进行查找。</span><br><span class="line">如果以上两种方式都没有找到，返回一个undefined。</span><br><span class="line">在模板中有一个变量这样使用：foo['bar']，那么在Jinja2中是这样进行访问：</span><br><span class="line"></span><br><span class="line">通过foo.__getitem__('bar')的方式进行查找。</span><br><span class="line">如果没有，就通过getattr(foo,'bar')的方式进行查找。</span><br><span class="line">如果以上没有找到，则返回一个undefined。</span><br></pre></td></tr></tbody></table></figure><h3 id="模版过滤器"><a href="#模版过滤器" class="headerlink" title="模版过滤器"></a>模版过滤器</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Jinja2模版过滤器相当于是一个函数，把当前的变量传入到过滤器中，然后过滤器根据自己的功能，再返回相应的值，之后再将结果渲染到页面中。在html中使用，{{  }}</span><br><span class="line">过滤器是通过管道符号（|）进行使用的，例如：{{ name|length }}，将返回name的长度。</span><br><span class="line"></span><br><span class="line">Jinja2中内置了许多过滤器，在这里可以看到所有的过滤器，现对一些常用的过滤器进行讲解：</span><br><span class="line"></span><br><span class="line">abs(value)：返回一个数值的绝对值。 例如：-1|abs。</span><br><span class="line"></span><br><span class="line">default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。name|default('xiaotuo')——如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。</span><br><span class="line"></span><br><span class="line">escape(value)或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。例如：content|escape或content|e。</span><br><span class="line"></span><br><span class="line">first(value)：返回一个序列的第一个元素。names|first。</span><br><span class="line"></span><br><span class="line">format(value,*arags,**kwargs)：格式化字符串。例如以下代码：</span><br><span class="line"></span><br><span class="line">`{{ "%s" - "%s"|format('Hello?',"Foo!") }}`</span><br><span class="line">将输出：Helloo? - Foo!</span><br><span class="line"></span><br><span class="line">last(value)：返回一个序列的最后一个元素。示例：names|last。</span><br><span class="line"></span><br><span class="line">length(value)：返回一个序列或者字典的长度。示例：names|length。</span><br><span class="line"></span><br><span class="line">join(value,d=u'')：将一个序列用d这个参数的值拼接成字符串。</span><br><span class="line"></span><br><span class="line">safe(value)：如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例：content_html|safe。</span><br><span class="line"></span><br><span class="line">int(value)：将值转换为int类型。</span><br><span class="line"></span><br><span class="line">float(value)：将值转换为float类型。</span><br><span class="line"></span><br><span class="line">lower(value)：将字符串转换为小写。</span><br><span class="line"></span><br><span class="line">upper(value)：将字符串转换为小写。</span><br><span class="line"></span><br><span class="line">replace(value,old,new)： 替换将old替换为new的字符串。</span><br><span class="line"></span><br><span class="line">truncate(value,length=255,killwords=False)：截取length长度的字符串。</span><br><span class="line"></span><br><span class="line">striptags(value)：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格。</span><br><span class="line"></span><br><span class="line">trim：截取字符串前面和后面的空白字符。</span><br><span class="line"></span><br><span class="line">string(value)：将变量转换成字符串。</span><br><span class="line"></span><br><span class="line">wordcount(s)：计算一个长字符串中单词的个数。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="flask模版继承"><a href="#flask模版继承" class="headerlink" title="flask模版继承"></a>flask模版继承</h3><p>一个系统网站往往需要统一的结构，这样看起来比较“整洁”。<br>比如说，一个页面中都有标题、内容显示、底部等几个部分。如果在每一个网页中都进行这几部分的编写，那么这个网站将会有很多冗余部分，这时可以采用模板继承，即将相同的部分提取出来，形成一个base.html，具有这些相同部分的网页通过继承base.html来得到对应的模块。</p><p>基本模板直接在templates目录中，蓝图的模板将放置在与蓝图同名的目录中。例如：flaskr/templates/auth/register.html</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{% extends "base.html" %}</span><br><span class="line"></span><br><span class="line">{% block 模板名称 %}</span><br><span class="line">    ....</span><br><span class="line">{% endblock %}</span><br></pre></td></tr></tbody></table></figure><p>base.html作为基类（父模块），index.html和product.html文件作为子类（子模块），子类去继承基类的基本内容。</p><p>base.html文件内容如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>{% block title %}{% endblock %} -我的网站<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">{% block body %}</span><br><span class="line">    这是基类（base.html）中的内容</span><br><span class="line">{% endblock %}</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>子模版</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{% extends "base.html" %}</span><br><span class="line"></span><br><span class="line">{% block title %}产品列表页{% endblock %}</span><br><span class="line"></span><br><span class="line">{% block body %}</span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>这是产品列表页（product.html）的内容！<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">获取网页标题内容：<span class="tag">&lt;<span class="name">h4</span>&gt;</span>{{ self.title() }}<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">{% endblock %}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><a href="https://flask.palletsprojects.com/en/2.1.x/config/#configuration-basics">所有的内置配置项</a><br>在Flask项目中，有四种方式进行项目的配置：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过加载模块的方式进行配置</span></span><br><span class="line"><span class="comment"># 1. 通过模块字符串</span></span><br><span class="line">app.config.from_object(<span class="string">'settings'</span>)</span><br><span class="line"><span class="comment"># 2. 通过模块对象</span></span><br><span class="line"><span class="keyword">import</span> settings</span><br><span class="line">app.config.from_object(settings)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过app.config对象来进行配置</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = <span class="string">"xxx"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为app.config是flask.config.Config的实例，而Config类是继承自dict，因此可以通过update方法：</span></span><br><span class="line"></span><br><span class="line">app.config.update(</span><br><span class="line">   DEBUG=<span class="literal">True</span>,</span><br><span class="line">   SECRET_KEY=<span class="string">'...'</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.config.from_pyfile()，该方法传入一个文件名，通常是以.py结尾的文件，但也不限于只使用.py后缀的文件：</span></span><br><span class="line">app.config.from_pyfile(<span class="string">'settings.py'</span>,silent=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># silent=True表示如果配置文件不存在的时候不抛出异常，默认是为False，会抛出异常。</span></span><br></pre></td></tr></tbody></table></figure><h2 id="蓝图技术"><a href="#蓝图技术" class="headerlink" title="蓝图技术"></a>蓝图技术</h2><p>蓝图技术(BluePrint )，可以帮助你实现flask应用的模块划分,一个模块拥有一个属于自己的文件目录，与之相关的代码都将写在这里</p><p>它是一个存储视图方法的集合，Flask 程序通过 Blueprint 来组织 URL 以及处理请求。</p><h3 id="功能式架构"><a href="#功能式架构" class="headerlink" title="功能式架构"></a>功能式架构</h3><p>按照 功能结构 组织。模板在一个文件夹中，静态文件在另外一个文件夹中，视图在第三个文件夹中。<br>如果应用的组件之间联系较为紧密，则建议使用功能式架构。<br>project/<br>  forms/<br>    myform.py<br>    …<br>  models/<br>    <strong>init</strong>.py<br>    mymodel.py<br>    …<br>  routes/<br>    <strong>init</strong>.py<br>    myroute.py<br>    …<br>  static/<br>    …<br>  services/<br>    <strong>init</strong>.py<br>    …<br>  templates/<br>    index.html<br>    …<br>  <strong>init</strong>.py<br>  config.py<br>  manage.py</p><p>forms(表单): 存放表单对象<br>models(模型): 存放数据模型，即库表在程序中的映射对象，以及对象之间的关系<br>routes(路由): 存放请求路由以及处理逻辑<br>static(静态文件): flask约定存放静态文件的目录<br>templates(模板): flask约定存放页面模板的目录<br>services(服务): 存放业务逻辑或者其他服务类功能<br>init.py: flask app初始化方法<br>config.py: 项目配置文件<br>manage.py: 启动一个开发服务器，但是不会在生产环境中用到</p><h3 id="分区式架构"><a href="#分区式架构" class="headerlink" title="分区式架构"></a>分区式架构</h3><p>基于应用的结构<br>如果应用是由独立的且仅仅共享模型和配置的各组件组成，建议选择分区式；<br>按照基于应用组织。同一个功能的模板，静态文件，视图都在一个文件夹内。<br>project/<br>  <strong>init</strong>.py<br>  db.py<br>  auth/<br>    <strong>init</strong>.py<br>    route.py<br>    models.py<br>    templates/<br>    static/<br>  blog/<br>    <strong>init</strong>.py<br>    route.py<br>    models.py<br>    templates/<br>    static/<br>…<br>每个目录都对应一个应用。Django 默认是使用这种方式来组织目录。当然这并不意味该方式是很好的，你需要按照项目来选择目录结构。某些时候，你将不得不使用一个混合模式。</p><h3 id="使用蓝图步骤"><a href="#使用蓝图步骤" class="headerlink" title="使用蓝图步骤"></a>使用蓝图步骤</h3><h4 id="1-创建一个蓝图对象"><a href="#1-创建一个蓝图对象" class="headerlink" title="1.创建一个蓝图对象"></a>1.创建一个蓝图对象</h4><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user/__init__.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个蓝图对象</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">参数1：蓝图名字</span></span><br><span class="line"><span class="string">2.模块名</span></span><br><span class="line"><span class="string">3.蓝图前缀</span></span><br><span class="line"><span class="string">4.template_folder :设置模板目录;蓝图对象默认的模板目录为系统的模版目录,如果存在同名模板文件,则系统会优先使用 系统的模版目录中的文件</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">bp = Blueprint(<span class="string">'user'</span>,__name__,url_prefix=<span class="string">'/user/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">'/'</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"用户首页"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">'profile/'</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profile</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"个人简介"</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="2-主程序上注册这个蓝图对象"><a href="#2-主程序上注册这个蓝图对象" class="headerlink" title="2.主程序上注册这个蓝图对象"></a>2.主程序上注册这个蓝图对象</h4><p>然后我们在主程序中，通过app.register_blueprint()方法将这个蓝图注册进url映射中，看下主app的实现：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> user</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.register_blueprint(user.bp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=<span class="number">9000</span>)</span><br></pre></td></tr></tbody></table></figure><p>以后访问/user/，/user/profile/，都是执行的user.py文件中的视图函数，这样就实现了项目的模块化。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><h4 id="1-1-寻找静态文件："><a href="#1-1-寻找静态文件：" class="headerlink" title="1.1. 寻找静态文件："></a>1.1. 寻找静态文件：</h4><p>默认不设置任何静态文件路径，Jinja2会在项目的static文件夹中寻找静态文件。也可以设置其他的路径，在初始化蓝图的时候，Blueprint这个构造函数，有一个参数static_folder可以指定静态文件的路径，如：</p><p><code>bp = Blueprint('admin',__name__,url_prefix='/admin',static_folder='static')</code><br>static_folder可以是相对路径（相对蓝图文件所在的目录），也可以是绝对路径。在配置完蓝图后，还有一个需要注意的地方是如何在模板中引用静态文件。在模板中引用蓝图，应该要使用蓝图名+.+static来引用，如下所示：</p><p><code>  &lt;link href="{{ url_for('admin.static',filename='about.css') }}"&gt;</code></p><h4 id="1-2-寻找模板文件："><a href="#1-2-寻找模板文件：" class="headerlink" title="1.2. 寻找模板文件："></a>1.2. 寻找模板文件：</h4><p>跟静态文件一样，默认不设置任何模板文件的路径，将会在项目的templates中寻找模板文件。也可以设置其他的路径，在构造函数Blueprint中有一个template_folder参数可以设置模板的路径，如下所示：</p><p><code>bp = Blueprint('admin',__name__,url_prefix='/admin',template_folder='templates')</code><br>模板文件和静态文件有点区别，以上代码写完以后，如果你渲染一个模板return render_template(‘admin.html’)，Flask默认会去项目根目录下的templates文件夹中查找admin.html文件，如果找到了就直接返回，如果没有找到，才会去蓝图文件所在的目录下的templates文件夹中寻找。</p><h4 id="1-3-url-for生成url："><a href="#1-3-url-for生成url：" class="headerlink" title="1.3. url_for生成url："></a>1.3. url_for生成url：</h4><p>用url_for生成蓝图的url，使用的格式是：蓝图名称+.+视图函数名称。比如要获取admin这个蓝图下的index视图函数的url，应该采用以下方式：</p><p><code>url_for('admin.index')</code><br>其中这个蓝图名称是在创建蓝图的时候，传入的第一个参数。bp = Blueprint(‘admin’,<strong>name</strong>,url_prefix=’/admin’,template_folder=’templates’)</p><h3 id="组织扩展-Extensions"><a href="#组织扩展-Extensions" class="headerlink" title="组织扩展(Extensions)"></a>组织扩展(Extensions)</h3><p>一般推荐将所有扩展在app/extensions.py中进行实例化，如以下代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## app/extensions.py</span></span><br><span class="line"><span class="keyword">from</span> flask_bootstrap <span class="keyword">import</span> Bootstrap</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"><span class="keyword">from</span> flask_login <span class="keyword">import</span> LoginManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bootstrap = Bootstrap()</span><br><span class="line">db = SQLAlchemy()</span><br><span class="line">login_manager = LoginManager()</span><br><span class="line">login_manager.login_view = <span class="string">'auth_bp.login'</span></span><br></pre></td></tr></tbody></table></figure><p>然后在实例化Flask时，进行绑定：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## app/__init__.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span> app.extensions <span class="keyword">import</span> bootstrap, db, login_manager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>(<span class="params">config_name</span>):</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(config[config_name])</span><br><span class="line">    config[config_name].init_app(app)</span><br><span class="line"></span><br><span class="line">    bootstrap.init_app(app)</span><br><span class="line">    db.init_app(app)</span><br><span class="line">    login_manager.init_app(app)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## register blueprint</span></span><br><span class="line">    <span class="keyword">from</span> .main <span class="keyword">import</span> main_bp</span><br><span class="line">    app.register_blueprint(main_bp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> .auth <span class="keyword">import</span> auth_bp <span class="keyword">as</span> auth_blueprint</span><br><span class="line">    app.register_blueprint(auth_blueprint)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> .api <span class="keyword">import</span> api_bp <span class="keyword">as</span> api_blueprint</span><br><span class="line">    app.register_blueprint(api_blueprint, url_prefix=<span class="string">'/api'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></tbody></table></figure><h3 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h3><p>子域名在许多网站中都用到了，比如一个网站叫做xxx.com，那么我们可以定义一个子域名cms.xxx.com来作为cms管理系统的网址，子域名的实现一般也是通过蓝图来实现，在之前章节中，我们创建蓝图的时候添加了一个url_prefix=/user作为url前缀，那样我们就可以通过/user/来访问user下的url。但使用子域名则不需要。另外，还需要配置SERVER_NAME，比如app.config[SERVER_NAME]=’example.com:9000’。并且在注册蓝图的时候，还需要添加一个subdomain的参数，这个参数就是子域名的名称，先来看一下蓝图的实现(admin.py)：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line">bp = Blueprint(<span class="string">'admin'</span>,__name__,subdomain=<span class="string">'admin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">'/'</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">admin</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Admin Page'</span></span><br></pre></td></tr></tbody></table></figure><p>这个没有多大区别，接下来看主app的实现：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置`SERVER_NAME`</span></span><br><span class="line">app.config[<span class="string">'SERVER_NAME'</span>] = <span class="string">'example.com:8000'</span></span><br><span class="line"><span class="comment"># 注册蓝图，指定了subdomain</span></span><br><span class="line">app.register_blueprint(admin.bp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=<span class="number">8000</span>,debug=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><p>写完以上两个文件后，还是不能正常的访问admin.example.com:8000这个子域名，因为我们没有在host文件中添加域名解析，你可以在最后添加一行127.0.0.1 admin.example.com，就可以访问到了。另外，子域名不能在127.0.0.1上出现，也不能在localhost上出现。</p><h2 id="request和reposr对象"><a href="#request和reposr对象" class="headerlink" title="request和reposr对象"></a>request和reposr对象</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## request 封装了请求消息，可以获取请求的各种参数。</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 定义处理路径 /login 的函数 login，装饰器 @app.route(’/login’, methods = [‘GET’]) 表示使用 GET 方法处理路径 /login 的请求。</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/login'</span>, methods = [<span class="string">'GET'</span>]</span>)</span></span><br><span class="line"><span class="comment">## 函数 login 返回一段用于登录的 HTML 表单，表单包括 2 个字段: name 和 password。在第 4 行，指定使用 POST 方法提交表单给服务端的 /check_login 页面。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;form action="/check_login" method="POST"&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;&lt;input type="text" name="name"/&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;&lt;input type="password" name="password"/&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;&lt;input type="submit" value="submit"/&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 使用 POST 方法处理路径 /check_login 的请求。</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/check_login'</span>, methods = [<span class="string">'POST'</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_login</span>():</span></span><br><span class="line">    name = request.form[<span class="string">'name'</span>]</span><br><span class="line">    password = request.form[<span class="string">'password'</span>]</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">'guest'</span> <span class="keyword">and</span> password == <span class="string">'123'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Login succeed'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Login failed'</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="setting-py"><a href="#setting-py" class="headerlink" title="setting.py"></a>setting.py</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> setting</span><br><span class="line">app.config.from_object(setting)   <span class="comment">#导入配置文件</span></span><br></pre></td></tr></tbody></table></figure><h2 id="一键安装依赖包"><a href="#一键安装依赖包" class="headerlink" title="一键安装依赖包"></a>一键安装依赖包</h2><p>##requirements.txt 用来记录项目所有的依赖包和版本号<br>pip freeze &gt; requirements.txt</p><p>##一次性安装 requirements.txt 里面所有的依赖包，<br>pip install -r requirements.txt</p><h2 id="abort函数返回异常"><a href="#abort函数返回异常" class="headerlink" title="abort函数返回异常"></a>abort函数返回异常</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response,json,request,render_template,abort</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/index'</span>,methods=[<span class="string">'GET'</span>,<span class="string">'POST'</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">  <span class="keyword">if</span> request.method == <span class="string">'GEt'</span>:</span><br><span class="line">      <span class="comment">##渲染模板</span></span><br><span class="line">      <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>)</span><br><span class="line">  <span class="keyword">if</span>  request.method == <span class="string">'POST'</span>:</span><br><span class="line">      name = request.form.get(<span class="string">'name'</span>)</span><br><span class="line">      password  = request.form.get(<span class="string">'password'</span>)</span><br><span class="line">      <span class="keyword">if</span> name == <span class="string">'zhangsan'</span> <span class="keyword">and</span> password==<span class="string">'123'</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'login success'</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          abort(<span class="number">404</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug = <span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="返回json数据给前端"><a href="#返回json数据给前端" class="headerlink" title="返回json数据给前端"></a>返回json数据给前端</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response,json</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/index'</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    data = {</span><br><span class="line">        <span class="string">'name'</span>:<span class="string">'张三'</span>    </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> make_response(json.dumps(data,ensure_ascii=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug = <span class="literal">True</span>) </span><br></pre></td></tr></tbody></table></figure><h1 id="Flask结合Bootstrap框架"><a href="#Flask结合Bootstrap框架" class="headerlink" title="Flask结合Bootstrap框架"></a>Flask结合Bootstrap框架</h1><p>pip install flask-bootstrap</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入bootstrap并进行初始化</span></span><br><span class="line"><span class="keyword">from</span> flask_bootstrap <span class="keyword">import</span> Bootstrap</span><br><span class="line">bootstrap=Bootstrap()</span><br></pre></td></tr></tbody></table></figure><h1 id="flask扩展"><a href="#flask扩展" class="headerlink" title="flask扩展"></a>flask扩展</h1><p>Flask扩展是一个Python模块，它向Flask应用程序添加了特定类型的支持。</p><p>Flask Extension Registry（Flask扩展注册表）是一个可用的扩展目录。</p><p>Flask常用扩展包：<br>Flask-SQLalchemy：操作数据库；</p><p>Flask-script：插入脚本；</p><p>Flask-migrate：管理迁移数据库；</p><p>Flask-Session：Session存储方式指定；</p><p>Flask-WTF：表单；</p><p>Flask-Mail：邮件；</p><p>Flask-Bable：提供国际化和本地化支持，翻译；</p><p>Flask-Login：认证用户状态；</p><p>Flask-OpenID：认证；</p><p>Flask-RESTful：开发REST API的工具；</p><p>Flask-Bootstrap：集成前端Twitter Bootstrap框架；</p><p>Flask-Moment：本地化日期和时间；</p><p>Flask-Admin：简单而可扩展的管理接口的框架</p><p>每种类型的扩展通常提供有关其用法的大量文档。</p><p>由于扩展是一个Python模块，因此需要导入它才能使用它。</p><p>Flask 的扩展通常命名为“ Flask-Foo ”或者“ Foo-Flask ” 。可以在 PyPI 搜索 标记为 <a href="https://pypi.org/search/?c=Framework+::+Flask">Framework :: Flask</a> 扩展包。</p><h2 id="命令行控制启动"><a href="#命令行控制启动" class="headerlink" title="命令行控制启动"></a>命令行控制启动</h2><p>安装<br><code>pip install flask-script</code></p><p>使用</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入类库</span></span><br><span class="line"><span class="keyword">from</span> flask_script <span class="keyword">import</span> Manager</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">manager = Manager(app)</span><br><span class="line"><span class="comment"># 启动程序</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment"># app.run()</span></span><br><span class="line"><span class="comment"># 命令行控制启动</span></span><br><span class="line">manager.run()</span><br></pre></td></tr></tbody></table></figure><p>参数：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">启动：python manager.py runserver [-d] [-r]</span><br><span class="line">-? &amp; --help 查看帮助</span><br><span class="line">-d 开启调试模式</span><br><span class="line">-r修改文件自动加载</span><br><span class="line">-h --host指定主机</span><br><span class="line">-p --port指定端口</span><br><span class="line">--threaded使用多线程  </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Flask-SQLAlchemy库"><a href="#Flask-SQLAlchemy库" class="headerlink" title="Flask-SQLAlchemy库"></a>Flask-SQLAlchemy库</h2><p><strong>SQLAlchemy</strong> 是 Python 中一个通过 ORM 操作数据库的框架。SQLAlchemy 对象关系映射器提供了一种方法，用于将用户定义的 Python 类与数据库表相关联，并将这些类实例与其对应表中的行相关联。SQLAlchemy 可以让开发者使用类和对象的方式操作数据库，从而从繁琐的 sql 语句中解脱出来。</p><p><strong>Flask-SQLAlchemy</strong>是对SQLAlchemy进行了一个简单的封装，使得我们在flask中使用sqlalchemy更加的简单。只能在flask中使用</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install  flask-sqlalchemy  # 安装</span><br><span class="line"><span class="meta">#</span><span class="bash">如果使用 mysql 数据库，还需要安装 mysqldb 驱动。</span></span><br><span class="line">pip install pymysql</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="ORM-模型概念"><a href="#ORM-模型概念" class="headerlink" title="ORM 模型概念"></a>ORM 模型概念</h3><p>对象 - 关系映射 (Object Relation Mapping) 模型<br>ORM 模型定义了关系数据库和对象的映射关系，使得访问数据库的代码简单清晰、易于维护。</p><table><thead><tr><th align="center">关系数据库中的概念</th><th align="center">面向对象中的概念</th></tr></thead><tbody><tr><td align="center">表</td><td align="center">类</td></tr><tr><td align="center">表记录</td><td align="center">对象</td></tr><tr><td align="center">字段</td><td align="center">属性</td></tr></tbody></table><p>假设关系数据库中存在一张表 Students，包括 sno、name 和 age 等字段，使用如下 SQL 语句进行创建：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students(</span><br><span class="line">    sno <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在 ORM 模型中，存在一个类 Student 与关系数据库中的表 students 相对应，代码如下所示：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类Student映射表students</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, sno, name, age</span>):</span></span><br><span class="line">  <span class="comment"># 属性 sno、name 和 age映射字段 sno、name 和 age</span></span><br><span class="line">        self.sno = sno</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment">#对象tom映射表students中的一条记录 </span></span><br><span class="line">tom = Student(<span class="string">'1918001'</span>, <span class="string">'tom'</span>, <span class="number">12</span>)        </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="数据库连接配置"><a href="#数据库连接配置" class="headerlink" title="数据库连接配置"></a>数据库连接配置</h3><table><thead><tr><th>配置选项</th><th>说明</th></tr></thead><tbody><tr><td>SQLALCHEMY_DATABASE_URI</td><td>连接数据库。示例：mysql://username:password@host/post/db?charset=utf-8</td></tr><tr><td>SQLALCHEMY_BINDS</td><td>一个将会绑定多种数据库的字典。 更多详细信息请看官文 绑定多种数据库.</td></tr><tr><td>SQLALCHEMY_ECHO</td><td>调试设置为true</td></tr><tr><td>SQLALCHEMY_POOL_SIZE</td><td>数据库池的大小，默认值为5。</td></tr><tr><td>SQLALCHEMY_POOL_TIMEOUT</td><td>连接超时时间</td></tr><tr><td>SQLALCHEMY_POOL_RECYCLE</td><td>自动回收连接的秒数。</td></tr><tr><td>SQLALCHEMY_MAX_OVERFLOW</td><td>控制在连接池达到最大值后可以创建的连接数。当这些额外的连接回收到连接池后将会被断开和抛弃。</td></tr><tr><td>SQLALCHEMY_TRACK_MODIFICATIONS</td><td>如果设置成 True (默认情况)，Flask-SQLAlchemy 将会追踪对象的修改并且发送信号。这需要额外的内存， 如果不必要的可以禁用它。</td></tr></tbody></table><p>dialect+driver://username:password@host:port/database?charset=utf8</p><ul><li> dialect是数据库的实现，比如MySQL、PostgreSQL、SQLite，并且转换成小写</li><li> driver是Python对应的驱动，如果不指定，会选择默认的驱动，比如MySQL的默认驱动是MySQLdb</li><li> username是连接数据库的用户名</li><li> password是连接数据库的密码</li><li> host是连接数据库的域名</li><li> port是数据库监听的端口号</li><li> database是连接哪个数据库的名字。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@file: config.py</span></span><br><span class="line"><span class="string">@author: wenke</span></span><br><span class="line"><span class="string">@software: PyCharm</span></span><br><span class="line"><span class="string">@time: 2022/7/19 11:23</span></span><br><span class="line"><span class="string">@Description: 数据库连接配置</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">DIALCT = <span class="string">"mysql"</span></span><br><span class="line">DRIVER = <span class="string">"pymysql"</span></span><br><span class="line">USERNAME = <span class="string">"root"</span></span><br><span class="line">PASSWORD = <span class="string">"root"</span></span><br><span class="line">HOST = <span class="string">"127.0.0.1"</span></span><br><span class="line">PORT = <span class="string">"3306"</span></span><br><span class="line">DATABASE = <span class="string">"bookdb"</span></span><br><span class="line"><span class="comment"># 定义数据库连接字符串DB_URI</span></span><br><span class="line">DB_URI = <span class="string">"{}+{}://{}:{}@{}:{}/{}?charset=utf8"</span>.<span class="built_in">format</span>(DIALCT,DRIVER,USERNAME,PASSWORD,HOST,PORT,DATABASE)</span><br><span class="line"></span><br><span class="line">SQLALCHEMY_DATABASE_URI = DB_URI</span><br><span class="line">SQLALCHEMY_TRACK_MODIFICATIONS = <span class="literal">False</span></span><br><span class="line">SQLALCHEMY_ECHO = <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><h3 id="model对象循环引用"><a href="#model对象循环引用" class="headerlink" title="model对象循环引用"></a>model对象循环引用</h3><p>循环引用这个问题出现的原因是</p><p>数据库脚本和主视图脚本不写在同一个脚本，数据库对象class一起写在同一个脚本下，主视图脚本调用<br>数据库脚本需要先定义db对象才能创建，因为要继承db.Model和使用db.Column等操作<br>db对象的定义在主视图脚本，因为需要传入的app在主视图脚本，但是主视图脚本在最开始就要导入数据库脚本<br>因此造成主视图脚本在启动一开始就需要数据库脚本，但是数据库脚本在一开始就需要主视图脚本，导致报错<br>解决方案</p><p>将db对象的定义单独放在一个脚本，并且先不指定app<br>数据库定义单独写一个脚本，其中调用db脚本中的空db对象，先保证语法正确，调用合法<br>在主视图函数中调用db和数据库对象，调用db.init_app(app)将app填充给空db<br>代码实现如下：分别创建db脚本exts.py，数据库脚本models.py，主视图脚本app.py</p><h3 id="创建db对象"><a href="#创建db对象" class="headerlink" title="创建db对象"></a>创建db对象</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@file: exts.py</span></span><br><span class="line"><span class="string">@author: wenke</span></span><br><span class="line"><span class="string">@software: PyCharm</span></span><br><span class="line"><span class="string">@time: 2022/7/19 11:34</span></span><br><span class="line"><span class="string">@Description:创建一个第三方文件，来放db对象,因为当db放在app.py时，from models import User,会从models模型中导入模型类User，</span></span><br><span class="line"><span class="string">但是在models模型又需要导入db,这就会导致循环引用，所以把db放在exts.py中</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy()</span><br></pre></td></tr></tbody></table></figure><h3 id="创建ORM模型类-建表-，并映射"><a href="#创建ORM模型类-建表-，并映射" class="headerlink" title="创建ORM模型类(建表)，并映射"></a>创建ORM模型类(建表)，并映射</h3><p>在定义模型的时候，可以不写__tablename__，那么flask_sqlalchemy会默认将类名小写化，然后映射成表名。<br>并且如果这个模型的名字用到了多个单词并且使用了驼峰命名法，那么会在多个单词之间使用下划线来进行连接，但是不推荐使用。（增强代码可读性，提高团队合作效率）app.config[‘SQLALCHEMY_TRACK_MODIFICATIONS’] = False</p><p><strong>映射模型到数据库表</strong>：使用Flask-SQLAlchemy所有的类都是继承自db.Model，并且所有的Column和数据类型也都成为db的一个属性。但是有个好处是不用写表名了，</p><p>Flask-SQLAlchemy会自动将类名小写化，然后映射成表名。写完类模型后，要将模型映射到数据库的表中，使用以下代码创建所有的表：<code>db.create_all()</code></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@file: models.py</span></span><br><span class="line"><span class="string">@author: wenke</span></span><br><span class="line"><span class="string">@software: PyCharm</span></span><br><span class="line"><span class="string">@time: 2022/7/19 11:28 </span></span><br><span class="line"><span class="string">@Description: 模型类</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> exts <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">  <span class="comment"># 表示将类 Student 映射到数据库中的表 students。</span></span><br><span class="line">    __tablename__ = <span class="string">'students'</span></span><br><span class="line">    <span class="comment"># 将属性映射到表的字段</span></span><br><span class="line">    sno = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">255</span>))</span><br><span class="line">    age = db.Column(db.Integer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">"user"</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    username = db.Column(db.String(<span class="number">200</span>),nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserExtension</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">"user_extension"</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    school = db.Column(db.String(<span class="number">100</span>))</span><br><span class="line">    user_id = db.Column(db.Integer,db.ForeignKey(<span class="string">"user.id"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># db.backref</span></span><br><span class="line">    <span class="comment"># 1. 在反向引用的时候，如果需要传递一些其他的参数，那么就需要用到这个函数，否则不需要使用，只要在relationship的backref参数上，设置反向引用的名称就可以了。</span></span><br><span class="line">    <span class="comment"># 2. uselist=False：代表反向引用的时候，不是一个列表，而是一个对象。</span></span><br><span class="line">    user = db.relationship(<span class="string">"User"</span>,backref=db.backref(<span class="string">"extension"</span>,uselist=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">"article"</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer,primary_key=<span class="literal">True</span>,autoincrement=<span class="literal">True</span>)</span><br><span class="line">    title = db.Column(db.String(<span class="number">200</span>),nullable=<span class="literal">False</span>)</span><br><span class="line">    content = db.Column(db.Text,nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 外键：</span></span><br><span class="line">    <span class="comment"># 1. 外键的数据类型一定要看，所引用的字段的类型</span></span><br><span class="line">    <span class="comment"># 2. db.ForeignKey("表名.字段名 ")</span></span><br><span class="line">    <span class="comment"># 3. 外键是属于数据库层面的，不推荐直接在ORM中使用</span></span><br><span class="line">    author_id = db.Column(db.Integer,db.ForeignKey(<span class="string">"user.id"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># relationship：</span></span><br><span class="line">    <span class="comment"># 1. 第一个参数是模型的名字，必须要和模型的名字保持一致</span></span><br><span class="line">    <span class="comment"># 2. backref（back reference）：代表反向引用，代表对方访问我的时候的字段名称</span></span><br><span class="line">    author = db.relationship(<span class="string">"User"</span>,backref=<span class="string">"articles"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将模型映射到数据库</span></span><br><span class="line"><span class="comment">#db.create_all()         # 创建数据库表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#db.drop_all()    # 删除数据库表：</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="主程序中使用"><a href="#主程序中使用" class="headerlink" title="主程序中使用"></a>主程序中使用</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Book, Author</span><br><span class="line"><span class="keyword">from</span> exts <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line">app.config.from_object(config)  <span class="comment"># 导入数据库连接配置</span></span><br><span class="line">db.init_app(app)  <span class="comment"># 初始化db,把db对象放到app中</span></span><br><span class="line"><span class="comment"># app.app_context()上下文</span></span><br><span class="line"><span class="keyword">with</span> app.app_context():</span><br><span class="line">    db.drop_all()  <span class="comment"># 删除表</span></span><br><span class="line">    db.create_all()  <span class="comment"># 创建数据库表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">"/otm"</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_to_many</span>():</span></span><br><span class="line">  <span class="comment"># 插入数据进Article表</span></span><br><span class="line">    article1 = Article(title=<span class="string">"111"</span>,content=<span class="string">"xxx"</span>)</span><br><span class="line">    article2 = Article(title=<span class="string">"222"</span>, content=<span class="string">"yyy"</span>)</span><br><span class="line">    <span class="comment"># 插入数据进User表</span></span><br><span class="line">    user = User(username=<span class="string">"zhiliao"</span>)</span><br><span class="line"></span><br><span class="line">    article1.author = user</span><br><span class="line">    article2.author = user</span><br><span class="line">    db.session.add(article1,article2)</span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(user.articles)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"one to many数据操作成功"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">"/oto"</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_to_one</span>():</span></span><br><span class="line">   <span class="comment"># 插入数据进User表</span></span><br><span class="line">    user = User(username=<span class="string">"zhiliao"</span>)</span><br><span class="line">     <span class="comment"># 插入数据进UserExtension表</span></span><br><span class="line">    extension = UserExtension(school=<span class="string">"清华大学"</span>)</span><br><span class="line"></span><br><span class="line">    user.extension = extension</span><br><span class="line">    db.session.add(user)</span><br><span class="line">    db.session.commit()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"one to one"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">"/article"</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">article_view</span>():</span></span><br><span class="line">    <span class="comment"># 1. 添加数据进Article表</span></span><br><span class="line">    article = Article(title=<span class="string">"钢铁是怎样炼成的"</span>,content=<span class="string">"xxx"</span>)</span><br><span class="line">    db.session.add(article)</span><br><span class="line">    <span class="comment"># 做一个提交操作</span></span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 查询数据</span></span><br><span class="line">    <span class="comment"># filter_by：返回一个类列表的对象</span></span><br><span class="line">    article = Article.query.filter_by(<span class="built_in">id</span>=<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(article.title)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 修改数据</span></span><br><span class="line">    article = Article.query.filter_by(<span class="built_in">id</span>=<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    article.content = <span class="string">"yyy"</span></span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 删除数据</span></span><br><span class="line">    Article.query.filter_by(<span class="built_in">id</span>=<span class="number">1</span>).delete()</span><br><span class="line">    db.session.commit()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"数据操作成功"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">'/'</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="comment"># 写一个测试代码来验证是否连接成功</span></span><br><span class="line">    engine = db.get_engine()</span><br><span class="line">    <span class="keyword">with</span> engine.connect() <span class="keyword">as</span> conn:</span><br><span class="line">        result = conn.execute(<span class="string">"select 1"</span>)</span><br><span class="line">        <span class="built_in">print</span>(result.fetchone())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="flask-migrate-数据库迁移"><a href="#flask-migrate-数据库迁移" class="headerlink" title="flask-migrate(数据库迁移)"></a>flask-migrate(数据库迁移)</h2><p>flask-migrate是基于Alembic进行的一个封装，并集成到Flask中，而所有的迁移操作其实都是Alembic做的，在开发过程中，需要修改数据库模型，比如新增字段，修改字段类型，重命名等,而且还要在修改之后更新数据库。由于db.create_all()只能在表不存在时生效，所以必须删除原表，创建新表从头开始，但这样会丢失数据。更好的解决办法是使用数据库迁移框架，它可以追踪数据库模式的变化，然后把变动应用到数据库中。</p><p>多数情况下 Flask-Migrate <code>pip install flask-migrate</code>是会和命令行工具插件 Flask-Script<code>pip install Flask-Script</code> 和数据库插件 flask_sqlalchemy 一起使用的</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p><strong>linux下</strong><br>flask db init  #创建迁移仓库<br>flask db migrate  # 创建迁移脚本<br>flask db upgrade  #更新数据库</p><p><strong>window下</strong>需要重写迁移脚本文件<br>(1) 编写数据库迁移脚本manager.py<br>(2) 准备好数据模型<br>(3) 执行迁移命名<br>首先编写迁移脚本manager.py，这个是固定写法</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_migrate <span class="keyword">import</span> Migrate, MigrateCommand</span><br><span class="line"><span class="keyword">from</span> flask_script <span class="keyword">import</span> Manager</span><br><span class="line"><span class="keyword">from</span> main <span class="keyword">import</span> app, db</span><br><span class="line"></span><br><span class="line">migrate = Migrate(app, db)  <span class="comment"># 指定迁移的app和db</span></span><br><span class="line">manager = Manager(app)</span><br><span class="line">manager.add_command(<span class="string">'db'</span>, MigrateCommand)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></tbody></table></figure><h3 id="创建迁移仓库和迁移脚本"><a href="#创建迁移仓库和迁移脚本" class="headerlink" title="创建迁移仓库和迁移脚本"></a>创建迁移仓库和迁移脚本</h3><p>数据库迁移时，初始化命令只需要执行一次，如果在一开始发现执行有问题，需要重新初始化，要先删除 migrations 目录才行。如果已经执行迁移命令，需要重新初始化，要先删除 migrations 目录和到数据库中删除 alembic_version 表。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">第一次运行迁移需要执行init命令，会在目录下新生成migrations目录，在目录下versions子目录下的py脚本记录了每次迁移的变化，</span></span><br><span class="line"><span class="meta">#</span><span class="bash">migrations 里面有一个 versions 文件夹，这个文件夹用于存放迁移脚本，执行迁移命令后会自动生成迁移脚本保存在里面。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">env.py 是迁移环境的相关信息。</span></span><br><span class="line">python manager.py db init    #创建迁移仓库</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">python manage.py db migrate -m "first commit"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash">执行 upgrade 命令后，会在数据库中创建一张 alembic_version 表，这张表是 Alembic 自动创建的，里面保存的是当前数据库的版本 id ，alembic_version 表不能删除，删除后就不能继续执行数据库迁移操作了，除非重新初始化。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同时，执行 upgrade 命令后，会根据代码中定义的模型类创建对应的表，表的字段与模型类中定义的一致。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果数据库中有其他表(没有对应模型类的表)，会被删除。，数据库迁移时最好使用一个新的数据库(不要与其他项目用同一个数据库)，避免造成数据丢失。</span></span><br><span class="line">python manager.py db upgrade #更新数据库</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="回退数据库"><a href="#回退数据库" class="headerlink" title="回退数据库"></a>回退数据库</h3><p>回退数据库时，需要指定回退版本号，由于版本号是随机字符串，为避免出错，建议先使用python3 db_database.py db history命令查看历史版本的具体版本号，然后复制具体版本号执行回退。</p><p>python3 db_database.py db downgrade 版本号</p><h2 id="Flask-WTF表单验证"><a href="#Flask-WTF表单验证" class="headerlink" title="Flask-WTF表单验证"></a>Flask-WTF表单验证</h2><p>在 Web 页面中，表单是一种常见的元素，表单包含有多个字段，通常字段的取值需要在一定的范围内，例如：QQ 注册时，名称不可以为空，密码的长度至少是 8 个字符,将表单提交给服务端处理时，服务端需要验证表单中的字段的取值是否符合要求。<br>Flask-WTF是简化了WTForms操作的一个第三方库。WTForms表单的两个主要功能是验证用户提交数据的合法性以及渲染模板。当然还包括一些其他的功能：CSRF保护，文件上传等。安装Flask-WTF默认也会安装WTForms，因此使用以下命令来安装Flask-WTF:</p><p><code>pip install flask-wtf</code></p><h1 id="flask-email邮箱使用"><a href="#flask-email邮箱使用" class="headerlink" title="flask-email邮箱使用"></a>flask-email邮箱使用</h1><h1 id="登录注册模块"><a href="#登录注册模块" class="headerlink" title="登录注册模块"></a>登录注册模块</h1><h2 id="flask-login"><a href="#flask-login" class="headerlink" title="flask-login"></a>flask-login</h2><p>管理已登录用户的用户会话</p><h2 id="werkzeug"><a href="#werkzeug" class="headerlink" title="werkzeug"></a>werkzeug</h2><p>计算密码散列值并进行核对</p><h2 id="itsdangerous"><a href="#itsdangerous" class="headerlink" title="itsdangerous"></a>itsdangerous</h2><p>生成并核对加密安全令牌</p><h1 id="部署到云服务器"><a href="#部署到云服务器" class="headerlink" title="部署到云服务器"></a>部署到云服务器</h1><p> 在pycharm中项目虚拟环境的终端运行<code>pip freeze &gt;requirements.txt</code></p><h1 id="出错"><a href="#出错" class="headerlink" title="出错"></a>出错</h1><p>AttributeError: module ‘time‘ has no attribute ‘clock‘的解决方法</p><p>主要原因是因为python3.8之后不支持clock了, 需要替换成 time.pref_counter() 替换就可以了</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cpmpat.py文件：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> win32 <span class="keyword">or</span> jython:</span><br><span class="line">    time_func = time.clock</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    time_func = time.time</span><br><span class="line"></span><br><span class="line"><span class="comment">#改为：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> win32 <span class="keyword">or</span> jython:</span><br><span class="line">    time_func = time.perf_counter()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    time_func = time.time</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.w3cschool.cn/flask/&quot;&gt;https://www.w3cschoo</summary>
      
    
    
    
    <category term="python" scheme="https://wenkex.gitee.io/categories/python/"/>
    
    
    <category term="flask" scheme="https://wenkex.gitee.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>matlab学习</title>
    <link href="https://wenkex.gitee.io/2022/031551719.html"/>
    <id>https://wenkex.gitee.io/2022/031551719.html</id>
    <published>2022-03-15T07:15:30.000Z</published>
    <updated>2022-03-15T07:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.w3cschool.cn/matlab/matlab-5use28gb.html">https://www.w3cschool.cn/matlab/matlab-5use28gb.html</a></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p><a href="https://www.w3cschool.cn/matlab/matlab-by7428gf.html">matlab常用命令</a></p><p>% 这是一行注释  ,ctrl +r  快捷注释</p><p>在命令行中，以逗号或分号分隔多条命令</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量名长度不超过63位<br>区分大小写<br>在使用变量之前，必须进行赋值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MATLAB可以多个赋值</span><br><span class="line">`a = 2; b = 7; c = a * b`</span><br><span class="line"></span><br><span class="line">显示所有已经使用的变量名。</span><br><span class="line">who</span><br><span class="line"></span><br><span class="line">显示变量信息</span><br><span class="line">whos</span><br><span class="line"></span><br><span class="line">删除所有（或指定）从内存中的变量（S）。</span><br><span class="line">clear</span><br><span class="line">clear s</span><br></pre></td></tr></tbody></table></figure><h1 id="matlab数据类型"><a href="#matlab数据类型" class="headerlink" title="matlab数据类型"></a>matlab数据类型</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><p>单引号括起来</p><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p>Matlab中结构体数组与python中字典概念差不多，使用方法也类似</p><h3 id="直接定义"><a href="#直接定义" class="headerlink" title="直接定义"></a>直接定义</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">students.name = 'John';</span><br><span class="line">students.sex = 'Boy';</span><br><span class="line"></span><br><span class="line">%输出结果为 包含以下字段的 struct:</span><br><span class="line"></span><br><span class="line">name: 'John'</span><br><span class="line">sex: 'Boy'</span><br></pre></td></tr></tbody></table></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p><a href="https://blog.csdn.net/weixin_49167174/article/details/119939748">https://blog.csdn.net/weixin_49167174/article/details/119939748</a></p><h3 id="矩阵的规则"><a href="#矩阵的规则" class="headerlink" title="矩阵的规则"></a>矩阵的规则</h3><p>矩阵元素必须在”[ ]”内；</p><p>矩阵的同行元素之间用空格（或”,”）隔开；</p><p>矩阵的行与行之间用”;”（或回车符）隔开；</p><p>矩阵的元素可以是数值、变量、表达式或函数；</p><h3 id="利用函数创建矩阵"><a href="#利用函数创建矩阵" class="headerlink" title="利用函数创建矩阵"></a>利用函数创建矩阵</h3><p>(1) ones()函数：产生全为1的矩阵，ones(n)：产生n<em>n维的全1矩阵，ones(m,n)：产生m</em>n维的全1矩阵；</p><p>(2) zeros()函数：产生全为0的矩阵；</p><p>(3) rand()函数：产生在（0，1）区间均匀分布的随机阵；</p><p>(4) eye()函数：产生单位阵；</p><p>(5) randn()函数：产生均值为0，方差为1的标准正态分布随机矩阵。</p><p>冒号表达式<br>(初始值：步长：终止值）</p><p>linspace(a, b, n)产生行向量<br>（a：第一个元素, b：最后一个元素, n：元素总数）<br>若元素总数n省略，则自动默认产生100个元素</p><h3 id="矩阵元素的引用"><a href="#矩阵元素的引用" class="headerlink" title="矩阵元素的引用"></a>矩阵元素的引用</h3><p>1.通过下标引用矩阵元素：第几行，第几列</p><p>2.通过序号引用矩阵元素<br>在matlab中，矩阵的元素是按列存储的即首先存储第一列元素、第二列…一直到最后一列。</p><p>矩阵元素的序号就是矩阵元素在内存中的排列顺序。</p><h3 id="矩阵拆分"><a href="#矩阵拆分" class="headerlink" title="矩阵拆分"></a>矩阵拆分</h3><p>利用冒号表达式获得子矩阵：</p><p>(1) A(:,j)表示取A矩阵的第j列全部元素；A(i,:)表示A矩阵第i行的全部元素；A(i,j)表示取A矩阵第i行、第j列的元素。</p><p>(2) A(i:i+m,:)表示取A矩阵第i<del>i+m行的全部元素；A(:,k:k+m)表示取A矩阵第k</del>k+m列的全部元素，A(i:i+m,k:k+m)表示取A矩阵第i<del>i+m行内，并在第k</del>k+m列中的所有元素。此外，还可利用一般向量和end运算符来表示矩阵下标，从而获得子矩阵。end表示某一维的末尾元素下标。</p><p>利用空矩阵[]删除矩阵的元素：</p><p>在MATLAB中，定义[]为空矩阵。给变量X赋空矩阵的语句为X=[]。注意，X=[]与clear X不同，clear是将X从工作空间中删除，而空矩阵则存在于工作空间中，只是维数为0。</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><p>求矩阵的大小<br>size()</p><p>求矩阵某个元素的下标<br>[row,col]=find(a==5)</p><p>(下标变序号)<br>D=sub2ind(size(a),[I],[J])  I是行下标，J是列下标   </p><p>(序号变下标)<br>[I,J]=ind2sub(S,D)<br>D是序号   </p><h3 id="结构矩阵"><a href="#结构矩阵" class="headerlink" title="结构矩阵"></a>结构矩阵</h3><p>结构矩阵名.成员名=表达式</p><h2 id="元胞数组-cell"><a href="#元胞数组-cell" class="headerlink" title="元胞数组(cell)"></a>元胞数组(cell)</h2><p>是由可以包括任何数据类型的元胞组成的数组。也叫单元矩阵通过元胞数组的使用，可以在同一个变量中存储不同数据类型的数据。<br>单元矩阵元素用大括号括起来</p><p>当要将数据放入一个元胞数组中时，请使用元胞数组构造运算符 {} 创建该数组。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>function [输出参数列表] = 函数名（输入参数列表）</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h2 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h2><p>文件第一行必须以function开头，文件名字必须以函数名.m命名<br>function 应变量名= 函数名(自变量名)</p><h1 id="基本绘图函数"><a href="#基本绘图函数" class="headerlink" title="基本绘图函数"></a>基本绘图函数</h1><h2 id="点运算"><a href="#点运算" class="headerlink" title="点运算"></a>点运算</h2><p>点运算是处理元素之间的运算<br>矩阵计算和作图都是点运算</p><h2 id="plot"><a href="#plot" class="headerlink" title="plot()"></a>plot()</h2><p>plot(xn,yn,sn,…)<br>s参数为线型</p><p>如果 X 和 Y 均为矩阵，则它们的大小必须相同。plot 函数绘制 Y 的列对 X 的列的图。 </p><h2 id="subplot"><a href="#subplot" class="headerlink" title="subplot()"></a>subplot()</h2><p>分割figure，创建子坐标系<br>subplot（m,n,p）<br>m表示是图排成m行，n表示图排成n列，</p><h2 id="ezplot-f"><a href="#ezplot-f" class="headerlink" title="ezplot(f)"></a>ezplot(f)</h2><p>ezplot(f)  在默认区间[-2pi,2pi]上绘制函数f=f(x)     f 可以是定义函数的M文件名或者一个匿名函数或者一个字符串</p><h2 id="图形标注"><a href="#图形标注" class="headerlink" title="图形标注"></a>图形标注</h2><h3 id="1-title设置图像标题"><a href="#1-title设置图像标题" class="headerlink" title="1.title设置图像标题"></a>1.title设置图像标题</h3><h3 id="2-annotate标注文字"><a href="#2-annotate标注文字" class="headerlink" title="2.annotate标注文字"></a>2.annotate标注文字</h3><h3 id="3-text设置文字说明"><a href="#3-text设置文字说明" class="headerlink" title="3.text设置文字说明"></a>3.text设置文字说明</h3><p>在绘制图形时，可以对图形加上一些说明，如图形的名称、坐标轴说明以及图形某一部分的含义等，这些操作称为添加图形标注。<br>title(‘图的题目’)<br>xlabel(‘横轴的名称’)<br>ylabel(‘纵轴的名称’)<br>text(0.5,25,’说明示例’)</p><h2 id="坐标、图形和图层窗口控制"><a href="#坐标、图形和图层窗口控制" class="headerlink" title="坐标、图形和图层窗口控制"></a>坐标、图形和图层窗口控制</h2><p>在绘制图形时，Matlab可以自动根据要绘制曲线数据的范围选择合适的坐标刻度，使得曲线能够尽可能清晰的显示出来。所以，一般情况下用户不必选择坐标轴的刻度范围。但是，如果用户对坐标不满意，可以利用axis函数对其重新设定。</p><p>axis equal  %纵横坐标轴采用等长刻度<br>axis square %产生正方形坐标系（默认为矩形）<br>axis auto   %使用默认设置<br>axis off    %取消坐标轴<br>axis on     %显示坐标轴<br>grid on     %显示网格<br>grid off    %不显示网格<br>box on      %显示其他轴(上、右)<br>box off     %不显示其他轴(上、右)<br>hold on     %继续在同一图层绘图<br>figure(1)   %新生成一个图层</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.w3cschool.cn/matlab/matlab-5use28gb.html&quot;&gt;https://www.w3cschool.cn/matlab/matlab-5use28gb.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;常用命令&quot;</summary>
      
    
    
    
    <category term="学习" scheme="https://wenkex.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="matlab" scheme="https://wenkex.gitee.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>深度学习</title>
    <link href="https://wenkex.gitee.io/2022/030811061.html"/>
    <id>https://wenkex.gitee.io/2022/030811061.html</id>
    <published>2022-03-08T10:41:51.000Z</published>
    <updated>2022-03-08T10:41:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人工智能、机器学习、深度学习的关系"><a href="#人工智能、机器学习、深度学习的关系" class="headerlink" title="人工智能、机器学习、深度学习的关系"></a>人工智能、机器学习、深度学习的关系</h1><p>人工智能 &gt; 机器学习 &gt; 深度学习。</p><h2 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h2><p>神经网络需要用数据来训练，它从数据中获得信息，进而把它们转换成相应的权重。这些权重能够被提取出来，迁移到其他的神经网络中，我们“迁移”了这些学来的特征，就不需要从零开始训练一个神经网络了 </p><h2 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h2><p>预训练模型(pre-trained model)是前人为了解决类似问题所创造出来的模型。你在解决问题的时候，不用从零开始训练一个新模型，可以从在类似问题中训练过的模型入手。</p><p>当在训练经网络的时候我们的目标是什么？我们希望网络能够在多次正向反向迭代的过程中，找到合适的权重。</p><p>通过使用之前在大数据集上经过训练的预训练模型，我们可以直接使用相应的结构和权重，将它们应用到我们正在面对的问题上。这被称作是“迁移学习”，即将预训练的模型“迁移”到我们正在应对的特定问题中。</p><h2 id="实践平台"><a href="#实践平台" class="headerlink" title="实践平台"></a>实践平台</h2><p>如果学员想了解更多关于飞桨、深度学习、机器学习或Python课程，可以通过如下三个途径获取。</p><p>AI Studio：<a href="https://aistudio.baidu.com/">https://aistudio.baidu.com/</a><br>飞桨官网：<a href="https://www.paddlepaddle.org.cn/">https://www.paddlepaddle.org.cn/</a><br>百度技术学院：<a href="http://bit.baidu.com/index">http://bit.baidu.com/index</a></p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>机器学习是专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构，使之不断改善自身的性能。</p><p>机器学习的实现<br>机器学习的实现可以分成两步：训练和预测，类似于归纳和演绎：</p><p>归纳： 从具体案例中抽象一般规律，机器学习中的“训练”亦是如此。从一定数量的样本（已知模型输入XXX和模型输出YYY）中，学习输出YYY与输入XXX的关系（可以想象成是某种表达式）。<br>演绎： 从一般规律推导出具体案例的结果，机器学习中的“预测”亦是如此。基于训练得到的YYY与XXX之间的关系，如出现新的输入XXX，计算出输出YYY。通常情况下，如果通过模型计算的输出和真实场景的输出一致，则说明模型是有效的。</p><h1 id="预测问题"><a href="#预测问题" class="headerlink" title="预测问题"></a>预测问题</h1><p>对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。下面我们尝试用最简单的线性回归模型解决这个问题，并用神经网络来实现这个模型。</p><h1 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h1><p><img src="https://gitee.com/wenkex/blogimage/raw/master/img/%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B5%E6%AD%A5-2022-3-1813:21:11.png"></p><p>模型结构三要素<br>（模型假设、评价函数和优化算法）</p><h1 id="paddleHub工具"><a href="#paddleHub工具" class="headerlink" title="paddleHub工具"></a>paddleHub工具</h1><p>端到端的预训练模型管理与迁移学习工具<br>模型一键下载、管理、预测,十行代码完成迁移学习,一键自动超参搜索,一键模型服务化部署</p><p>精选效果优秀的算法，提供了百亿级大数据训练的预训练模型，方便用户不用花费大量精力从头开始训练<br>一个模型。</p><p>#安装 -i指定镜像源<br>pip install paddlehub -i <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br>#更新<br>pip install –upgrade paddlehub -i <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p><h1 id="自然语言处理-NLP"><a href="#自然语言处理-NLP" class="headerlink" title="自然语言处理(NLP)"></a>自然语言处理(NLP)</h1><h2 id="NLP-的4个典型应用"><a href="#NLP-的4个典型应用" class="headerlink" title="NLP 的4个典型应用"></a>NLP 的4个典型应用</h2><p>情感分析</p><p>聊天机器人</p><p>语音识别</p><p>机器翻译</p><h2 id="paddlenlp"><a href="#paddlenlp" class="headerlink" title="paddlenlp"></a>paddlenlp</h2><p>安装<br>pip install –upgrade paddlenlp<br><a href="https://aistudio.baidu.com/aistudio/projectdetail/3696243?channelType=0&amp;channel=0">https://aistudio.baidu.com/aistudio/projectdetail/3696243?channelType=0&amp;channel=0</a></p><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><p>分词作为许多NLP任务的第一道工序,Taskflow提供了多种中文分词模式供大家选择</p><h4 id="文档级输入"><a href="#文档级输入" class="headerlink" title="文档级输入"></a>文档级输入</h4><p>支持超长文本输入，无需担心『文本截断』问题</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次调用会有模型下载的额外时间开销</span></span><br><span class="line">seg = Taskflow(<span class="string">"word_segmentation"</span>)</span><br><span class="line"></span><br><span class="line">doc = <span class="string">"苏锦一直记得那个午后，明晃晃的光线穿过教室的窗玻璃洒到自己脸上，有种特别暖和的感觉。那阳光仿佛是能够钻进人的"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"1. 输入长度："</span>, <span class="built_in">len</span>(doc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"2. 分词结果："</span>, seg(doc))</span><br></pre></td></tr></tbody></table></figure><h4 id="快速模式分词"><a href="#快速模式分词" class="headerlink" title="快速模式分词"></a>快速模式分词</h4><p>示例如何通过快速模式分词对数据集进行词频统计、构建词表</p><h4 id="精确模式分词"><a href="#精确模式分词" class="headerlink" title="精确模式分词"></a>精确模式分词</h4><h4 id="用户词典"><a href="#用户词典" class="headerlink" title="用户词典"></a>用户词典</h4><p>快速配置用户词典来对分词结果进行干预</p><h3 id="词性标注，，依存句法分析"><a href="#词性标注，，依存句法分析" class="headerlink" title="词性标注，，依存句法分析"></a>词性标注，，依存句法分析</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于百度词法分析工具LAC，训练语料包含近2200万句子，覆盖多种场景</span></span><br><span class="line"><span class="comment"># 词性标注</span></span><br><span class="line">tag = Taskflow(<span class="string">"pos_tagging"</span>)</span><br><span class="line"><span class="built_in">print</span>(tag(<span class="string">"第十四届全运会在西安举办"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="命名实体识别"><a href="#命名实体识别" class="headerlink" title="命名实体识别"></a>命名实体识别</h3><p>基于百度解语的精确模式：最全中文实体标签的命名实体识别工具</p><h4 id="精确模式"><a href="#精确模式" class="headerlink" title="精确模式"></a>精确模式</h4><p>基于百度解语的精确模式：最全中文实体标签的命名实体识别工具，不仅适用于通用领域，也适用于生物医疗、教育等垂类领域。包含66种词性及专名类别标签（同类产品的标签数是15个左右）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line">ner = Taskflow(<span class="string">"ner"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ner([<span class="string">"李伟拿出具有科学性、可操作性的《陕西省高校管理体制改革实施方案》"</span>, <span class="string">"诺戴商务咨询（上海）有限公司于2016年08月22日成立"</span>]))</span><br></pre></td></tr></tbody></table></figure><h4 id="快速模式"><a href="#快速模式" class="headerlink" title="快速模式"></a>快速模式</h4><p>基于百度词法分析工具LAC，训练语料包含近2200万句子，覆盖多种场景</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line">ner_fast = Taskflow(<span class="string">"ner"</span>, mode=<span class="string">"fast"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ner_fast(<span class="string">"三亚是一个美丽的城市"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="依存句法分析"><a href="#依存句法分析" class="headerlink" title="依存句法分析"></a>依存句法分析</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用BiLSTM作为编码器，速度最快</span></span><br><span class="line">ddp = Taskflow(<span class="string">"dependency_parsing"</span>)</span><br><span class="line"><span class="built_in">print</span>(ddp(<span class="string">"2月8日谷爱凌夺得北京冬奥会第三金"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 编码器部分将BiLSTM替换为ERNIE，模型准确率更高！</span></span><br><span class="line"><span class="comment"># ddp = Taskflow("dependency_parsing", model="ddparser-ernie-1.0")</span></span><br><span class="line"><span class="comment"># print(ddp("2月8日谷爱凌夺得北京冬奥会第三金"))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出概率值和词性标签</span></span><br><span class="line">ddp = Taskflow(<span class="string">"dependency_parsing"</span>, prob=<span class="literal">True</span>, use_pos=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ddp(<span class="string">"2月8日谷爱凌夺得北京冬奥会第三金"</span>))</span><br></pre></td></tr></tbody></table></figure><h3 id="定制化训练"><a href="#定制化训练" class="headerlink" title="定制化训练"></a>定制化训练</h3><p>利用自己的数据训练/微调模型，通过Taskflow一键装载并使用</p><h4 id="数据准备和训练"><a href="#数据准备和训练" class="headerlink" title="数据准备和训练"></a>数据准备和训练</h4><p><a href="https://github.com/PaddlePaddle/PaddleNLP/tree/develop/examples/sentiment_analysis/skep">参考PaddleNLP SKEP情感分析训练示例</a>完成数据准备和模型训练。</p><h4 id="使用定制化模型"><a href="#使用定制化模型" class="headerlink" title="使用定制化模型"></a>使用定制化模型</h4><p>通过task_path指定自定义模型路径一键加载即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line">my_senta = Taskflow(<span class="string">"sentiment_analysis"</span>, model=<span class="string">"skep_ernie_1.0_large_ch"</span>, task_path=<span class="string">"/home/aistudio/custom_model"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_senta(<span class="string">"不错的酒店,服务还可以,下次还会入住的~"</span>))</span><br></pre></td></tr></tbody></table></figure><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>人工神经网络包括多个神经网络层，如：卷积层、全连接层、LSTM等，每一层又包括很多神经元，超过三层的非线性神经网络都可以被称为深度神经网络。通俗的讲，深度学习的模型可以视为是输入到输出的映射函数，如图像到高级语义（美女）的映射，足够深的神经网络理论上可以拟合任何复杂的函数。因此神经网络非常适合学习样本数据的内在规律和表示层次，对文字、图像和语音任务有很好的适用性。这几个领域的任务是人工智能的基础模块，因此深度学习被称为实现人工智能的基础也就不足为奇了。</p><p>神经元： 神经网络中每个节点称为神经元，由两部分组成：<br>  加权和：将所有输入加权求和。<br>  非线性变换（激活函数）：加权和的结果经过一个非线性函数变换，让神经元计算具备非线性的能力。</p><p>多层连接： 大量这样的节点按照不同的层次排布，形成多层的结构连接起来，即称为神经网络。</p><p>前向计算： 从输入计算输出的过程，顺序从网络前至后。</p><p>计算图： 以图形化的方式展现神经网络的计算逻辑又称为计算图，也可以将神经网络的计算图以公式的方式表达：<br>Y=f3(f2(f1(w1⋅x1+w2⋅x2+w3⋅x3+b)+…)…)…)<br>​神经网络并没有那么神秘，它的本质是一个含有很多参数的“大公式”</p><h2 id="构建神经网络-深度学习模型的基本步骤"><a href="#构建神经网络-深度学习模型的基本步骤" class="headerlink" title="构建神经网络/深度学习模型的基本步骤"></a>构建神经网络/深度学习模型的基本步骤</h2><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>数据导入、</p><p>数据形状变换、</p><p>数据集划分、</p><p>数据归一化处理</p><p>封装load data函数</p><h4 id="图像和文本数据处理"><a href="#图像和文本数据处理" class="headerlink" title="图像和文本数据处理"></a>图像和文本数据处理</h4><h3 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h3><p>（模型要素1）网络结构设计，相当于模型假设空间，即模型能够表达的关系集合。</p><h3 id="训练配置"><a href="#训练配置" class="headerlink" title="训练配置"></a>训练配置</h3><p>模型要素2）设定模型采用的寻解方法，即优化器，并指定计算资源。<br>PS：神经网络学习的目的是寻找合适的参数，使得损失函数的值尽可能小。解决这个问题的过程为称为最优化。解决这个问题使用的算法叫做优化器。接触到的优化器有：随机梯度下降法（Stachastic gradient desent 简称 SGD）和AdaGrad </p><p>AdaGard主要是为了解决 SGD 遇到鞍点或者极小值点后学习变慢的问题。我们知道超参数学习率是一个很重要的参数，不同的参数对学习结果的影响很大，如果设置的值较小，会导致学习花费较多的时间，学习率大了就会导致学习发散而不能正常的进行。所以我们可以考虑避免人为的介入，根据需要让程序自己动态地设置学习率。例如对于遇到鞍点的情况，参数变化很小，基本不会改变，那么这个方法就会设置一个较大的学习率，跨过鞍点。</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>模型要素3）循环调用训练过程，每轮都包括前向计算、损失函数（优化目标）和后向传播三个步骤。</p><p>PS：前向计算是指把输入数据传入模型，然后得到输出；后向传播是指根据前向计算得到的输出通过梯度下降，从后向前优化网络中的参数。（因为梯度下降就是从后向前计算）</p><h3 id="模型保存"><a href="#模型保存" class="headerlink" title="模型保存"></a>模型保存</h3><p>将训练好的模型保存，模型预测是调用。</p><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><h2 id="coco数据集"><a href="#coco数据集" class="headerlink" title="coco数据集"></a>coco数据集</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>train2017、test2017、val2017文件夹中保存的是用于训练、测试、验证的图片，<br>annotations文件夹保存的是这些图片对应的标注信息，分别存在instance_test2017、instance_test2017、instance_val2017三个json文件中。</p><h2 id="VOC数据集"><a href="#VOC数据集" class="headerlink" title="VOC数据集"></a>VOC数据集</h2><h3 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h3><p>Annotations/  #存放xml文件，与JPEGImages中的图片一一对应，解释图片的内容等等<br>JPEGImages/<br>labels.txt<br>train_list.txt<br>test_list.txt<br>val_list.txt</p><h2 id="paddleX划分数据集"><a href="#paddleX划分数据集" class="headerlink" title="paddleX划分数据集"></a>paddleX划分数据集</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用paddleX快速划分数据集</span></span><br><span class="line">!pip install <span class="string">"paddlex&lt;=2.0.0"</span> -i https://mirror.baidu.com/pypi/simple</span><br><span class="line"></span><br><span class="line">!paddlex --split_dataset --<span class="built_in">format</span> VOC --dataset_dir roadsign --val_value <span class="number">0.1</span> --test_value <span class="number">0.1</span></span><br><span class="line"><span class="comment">#--format VOC  VOC格式的数据集</span></span><br><span class="line"><span class="comment">#按照8：1：1的比例划分为训练集，验证集(--val_value)和测试集(--test_value)</span></span><br></pre></td></tr></tbody></table></figure><h1 id="PaddlePaddle"><a href="#PaddlePaddle" class="headerlink" title="PaddlePaddle"></a>PaddlePaddle</h1><p><a href="https://www.paddlepaddle.org.cn/">安装</a></p><p>运行PaddlePaddle需要COCO-API，安装方式如下：</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pip install pycocotools   <span class="comment"># linux安装pycocotools</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若Cython未安装，请安装Cython</span></span><br><span class="line">pip install Cython</span><br><span class="line"><span class="comment">#windows用户安装COCO-API方式：</span></span><br><span class="line"><span class="comment"># 由于原版cocoapi不支持windows，采用第三方实现版本，该版本仅支持Python3</span></span><br><span class="line">pip install git+https://github.com/philferriere/cocoapi.git<span class="comment">#subdirectory=PythonAPI</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>PaddleClas和PaddleDetection分别是PaddlePaddle的两个开源项目，关注不同的技术领域。</p><h1 id="PaddleClas"><a href="#PaddleClas" class="headerlink" title="PaddleClas"></a>PaddleClas</h1><p>以图像识别和图像分类为主，同时关注基础的骨干网络模型；PaddleClas对小样本区分、识别目标不固定等疑难问题效果更好，整体精度上限更高；</p><h1 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h1><h2 id="PaddleX2-1"><a href="#PaddleX2-1" class="headerlink" title="PaddleX2.1"></a>PaddleX2.1</h2><h2 id="PaddleDetection套件"><a href="#PaddleDetection套件" class="headerlink" title="PaddleDetection套件"></a>PaddleDetection套件</h2><p><a href="https://github.com/PaddlePaddle/PaddleDetection">paddledetection的github主页</a><br><a href="https://paddledetection.readthedocs.io/">PaddleDetection套件文档</a></p><p>以检测技术为主，同时关注关键点、跟踪等方向。PaddleDetection在超轻量模型上更有优势，在移动端设备上速度更快。<br><a href="https://blog.smslit.cn/2021/04/15/paddle-detection-train-log/">https://blog.smslit.cn/2021/04/15/paddle-detection-train-log/</a></p><h3 id="选择模型"><a href="#选择模型" class="headerlink" title="选择模型"></a>选择模型</h3><p>模型丰富: 包含目标检测、实例分割、人脸检测、关键点检测、多目标跟踪等250+个预训练模型</p><p>支持现有的RCNN、SSD、YOLO等系列模型，快速的完成不同模型的训练体验，就是需要依靠配置文件的切换。configs文件夹中都是模型文件，模型文件内可选择骨架网络</p><h3 id="安装PaddleDetection"><a href="#安装PaddleDetection" class="headerlink" title="安装PaddleDetection"></a>安装PaddleDetection</h3><p>在安装PaddleDetection之前要先安装依赖项PaddlePaddle</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装PaddleDetection</span></span><br><span class="line">!git clone https://gitee.com/PaddlePaddle/PaddleDetection.git</span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">%cd PaddleDetection</span><br><span class="line">!pip install -r requirements.txt</span><br><span class="line">!python setup.py install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试是否安装成功</span></span><br><span class="line">!python ppdet/modeling/tests/test_architectures.py</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="数据集准备"><a href="#数据集准备" class="headerlink" title="数据集准备"></a>数据集准备</h3><p>基于标注好的图片生成数据集<br>常用的目标检测数据集有两种格式，分别是VOC和COCO。</p><p>如果使用<strong>COCO格式</strong>，建议使用PaddleDetection中的x2coco将标注好的文件转为COCO格式的数据集。转换代码如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python tools/x2coco.py \</span><br><span class="line">                --dataset_type labelme \</span><br><span class="line">                --json_input_dir ./labelme_annos/ \</span><br><span class="line">                --image_input_dir ./labelme_imgs/ \</span><br><span class="line">                --output_dir ./cocome/ \</span><br><span class="line">                --train_proportion 0.8 \</span><br><span class="line">                --val_proportion 0.2 \</span><br><span class="line">                --test_proportion 0.0</span><br></pre></td></tr></tbody></table></figure><p>如果使用<strong>VOC格式</strong>的数据集，可以使用labelme自带的labelme2voc.py完成，需要先创建labels.txt文件,labels.txt文件的前两行分别为__ignore__和_background_，其余行为类别名称。转换代码如下：</p><p><code>./labelme2voc.py data_annotated data_dataset_voc --labels labels.txt</code></p><h3 id="修改参数配置"><a href="#修改参数配置" class="headerlink" title="修改参数配置"></a>修改参数配置</h3><p>COCO数据集：<br>  dataset:<br>     !COCODataSet<br>     image_dir: val2017 # 图像数据基于数据集根目录的相对路径<br>     anno_path: annotations/instances_val2017.json  # 标注文件基于数据集根目录的相对路径<br>     dataset_dir: dataset/coco  # 数据集根目录<br>     with_background: true  # 背景是否作为一类标签，默认为true。</p><p>选择模型并修改配置文件,<br>属于小物体检测范畴，我们选择Faster-Rcnn系列模型。然后基于configs/faster_rcnn_r50_fpn_1x.yml文件进行修改</p><h3 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h3><p>若是训练过程当中自动下载数据集，那确定是你的yml路径配置错了，写绝对路径。<br>使用PaddleDetection时的配置信息是采用yml文件描述的，这里使用的是yolov3_darknet53_270e_voc.yml文件.</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 设置PYTHONPATH路径</span></span><br><span class="line">export PYTHONPATH=$PYTHONPATH:.</span><br><span class="line"><span class="comment"># GPU训练 支持单卡，多卡训练，通过CUDA_VISIBLE_DEVICES指定卡号</span></span><br><span class="line">export CUDA_VISIBLE_DEVICES=<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span></span><br><span class="line">python tools/train.py -c configs/faster_rcnn_r50_1x.yml --<span class="built_in">eval</span> -o use_gpu=true --use_vdl=<span class="literal">True</span> --vdl_log_dir=./vdl_dir/scalar</span><br></pre></td></tr></tbody></table></figure><p>可选参数列表可以通过–help查看<br><a href="https://paddledetection.readthedocs.io/tutorials/GETTING_STARTED_cn.html#id2">https://paddledetection.readthedocs.io/tutorials/GETTING_STARTED_cn.html#id2</a><br>  -c        指定配置文件<br>  -o        设置配置文件里的参数内容    None    使用-o配置相较于-c选择的配置文件具有更高的优先级。例如：-o use_gpu=False max_iter=10000<br>  -r/–resume_checkpoint    train    从某一检查点恢复训练<br>  –eval  是否边训练边测试    False<br>  –output_eval        编辑评测保存json路径    当前路径    –output_eval ./json_result<br>  –fp16        是否使用混合精度训练模式    False    需使用GPU训练<br>  –loss_scale    设置混合精度训练模式中损失值的缩放比例<br>  –use_vdl    是否使用VisualDL记录数据，进而在VisualDL面板中显示<br>  –vdl_log_dir        指定 VisualDL 记录数据的存储路径 </p><p>-r 模型暂存路径/接着训练的轮数（接着第几轮训练）<br>-r ./output/faster_rcnn_r50_vd_fpn_ssld_2x_coco/5</p><p>预训练模型的参数确实有助于提高训练的准确率<br><strong>加载预训练模型</strong><br>-o pretrain_weights=output/faster_rcnn_r50_1x/model_final \</p><p><strong>加载部分预训练模型</strong><br>-o pretrain_weights=output/faster_rcnn_r50_1x/model_final <br>                        finetune_exclude_pretrained_params=[‘cls_score’,’bbox_pred’]</p><p><strong>训练信息</strong><br>loss_bbox :衡量预测边界框与真实对象的“紧密程度”的损失(通常是回归损失，L1，smoothL1 等)。<br>loss_cls :衡量每个预测边界框分类正确性的损失:每个框可能包含一个对象类，或一个“背景”。这种损失通常称为交叉熵损失。</p><p>FasterRCNN<br>FasterRCNN的训练日志除了通用统计信息外，还包括loss_cls、loss_bbox、loss_rpn_cls和loss_rpn_bbox，这些字段的含义如下:</p><p>字段    含义<br>loss_cls    RCNN子网络中分类损失函数值<br>loss_bbox    RCNN子网络中检测框回归损失函数值<br>loss_rpn_cls    RPN子网络中分类损失函数值<br>loss_rpn_bbox    RPN子网络中检测框回归损失函数值<br>loss    所有子网络损失函数值之和</p><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>评估配置</p><h3 id="预测图像"><a href="#预测图像" class="headerlink" title="预测图像"></a>预测图像</h3><p>使用预训练模型预测图像</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">!python tools/infer.py -c ../configs/yolov3_darknet53_270e_voc.yml \</span><br><span class="line">                    --infer_img=/home/aistudio/fortest.jpg \</span><br><span class="line">                    --output_dir=/home/aistudio/infer_output/ \</span><br><span class="line">                    --draw_threshold=<span class="number">0.1</span> \</span><br><span class="line">                    -o weights=output/yolov3_darknet53_270e_voc/model_final \</span><br><span class="line">                    --use_vdl=Ture</span><br></pre></td></tr></tbody></table></figure><h1 id="Notebook中"><a href="#Notebook中" class="headerlink" title="Notebook中"></a>Notebook中</h1><h2 id="Notebook中使用Shell命令"><a href="#Notebook中使用Shell命令" class="headerlink" title="Notebook中使用Shell命令"></a>Notebook中使用Shell命令</h2><p>!ls /home/aistudio/data/</p><h2 id="Magic命令"><a href="#Magic命令" class="headerlink" title="Magic命令"></a>Magic命令</h2><p>Magic命令是Notebook的高级用法了. 可以运行一些特殊的指令. Magic 命令的前面带有一个或两个百分号（% 或 %%），分别代表行 Magic 命令和单元格 Magic 命令。行 Magic 命令仅应用于编写 Magic 命令时所在的行，而单元格 Magic 命令应用于整个单元格。</p><p>#显示全部可用的Magic命令<br>%lsmagic<br>1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人工智能、机器学习、深度学习的关系&quot;&gt;&lt;a href=&quot;#人工智能、机器学习、深度学习的关系&quot; class=&quot;headerlink&quot; title=&quot;人工智能、机器学习、深度学习的关系&quot;&gt;&lt;/a&gt;人工智能、机器学习、深度学习的关系&lt;/h1&gt;&lt;p&gt;人工智能 &amp;gt; </summary>
      
    
    
    
    <category term="工具" scheme="https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="深度学习" scheme="https://wenkex.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>django学习</title>
    <link href="https://wenkex.gitee.io/2022/030664874.html"/>
    <id>https://wenkex.gitee.io/2022/030664874.html</id>
    <published>2022-03-06T13:02:52.000Z</published>
    <updated>2022-03-06T13:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python 加 Django 是快速开发、设计、部署网站的最佳组合。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>pip install django -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</code></p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>在想要创建的文件夹中，进入终端<br>执行命令创建项目<code>'django-admin startproject 项目名称 </code></p><h1 id="项目文件介绍"><a href="#项目文件介绍" class="headerlink" title="项目文件介绍"></a>项目文件介绍</h1><p>manage.py  项目的管理，启动项目，创建app,数据管理<br>urls.py  url和函数的对应关系<br>asgi.py 和wsgi.py  接受网络请求</p><h1 id="创建一个app"><a href="#创建一个app" class="headerlink" title="创建一个app"></a>创建一个app</h1><p>python manage.py startapp 名称 </p><h1 id="Uvicorn-运行-django"><a href="#Uvicorn-运行-django" class="headerlink" title="Uvicorn 运行 django"></a>Uvicorn 运行 django</h1><p>django 内置的开发服务器在修改代码后的热重载非常缓慢，我发现 uvicorn 的重载速度要快得多，所以新项目第一件事，就是使用在开发环境下使用 uvicorn 运行 django。</p><p>首先当然要安装 uvicorn。<br><code>pip install uvicorn</code></p><p>Uvicorn 安装好后，可以在命令行使用 uvicorn 命令来运行 django。但是，每次输命令启动 django 会非常麻烦！最好的做法是创建一个脚本，启动 django 只需要执行脚本就可以了。</p><p>在 项目根目录 创建一个 run_uvicorn.py 的脚本（脚本名可以自己随便取），代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"mysite.settings"</span>)</span><br><span class="line">    uvicorn.run(</span><br><span class="line">        <span class="string">"mysite.asgi:application"</span>,</span><br><span class="line">        host=<span class="string">"0.0.0.0"</span>,</span><br><span class="line">        port=<span class="number">8000</span>,</span><br><span class="line">        log_level=<span class="string">"debug"</span>,</span><br><span class="line">        reload=<span class="literal">True</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>运行脚本后，应用已在 8000 端口启动，现在访问 localhost:8000，可以看到熟悉的 django 项目初始页面。</p><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>views.py  写函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python 加 Django 是快速开发、设计、部署网站的最佳组合。&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;&lt;code&gt;pip install django -i</summary>
      
    
    
    
    <category term="python" scheme="https://wenkex.gitee.io/categories/python/"/>
    
    
    <category term="web" scheme="https://wenkex.gitee.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://wenkex.gitee.io/2022/022615691.html"/>
    <id>https://wenkex.gitee.io/2022/022615691.html</id>
    <published>2022-02-26T12:50:16.000Z</published>
    <updated>2022-02-26T12:50:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用linux的好处"><a href="#使用linux的好处" class="headerlink" title="使用linux的好处"></a>使用linux的好处</h1><p><a href="https://mp.weixin.qq.com/s/MP6gWfkyKaBLNCpEOHhk_g">使用linux的好处</a><br>在 linux 下，apt install 或者 yum install 之类的命令，就能搞定整个软件安装。</p><p>Linux 不需要选择软件是放 c 盘还是 d 盘，已经定义好了哪些文件该放在哪些地方，<br>不需要杀毒软件，不需要清理垃圾，不需要释放内存，不需要激活系统，它是开源免费的，不需要磁盘优化，没有烦人的弹窗，没有强制更新。</p><h1 id="linux环境"><a href="#linux环境" class="headerlink" title="linux环境"></a>linux环境</h1><h2 id="VMware搭建linux"><a href="#VMware搭建linux" class="headerlink" title="VMware搭建linux"></a>VMware搭建linux</h2><p><strong>安装Vmware Tools工具。</strong><br>可以为虚拟机提供更好的显卡性能（游戏玩家最爱的）<br>同步物理主机时间<br>自动捕获和释放鼠标光标（不用按下Ctrl + Alt键来释放鼠标）<br>实现物理主机和虚拟机或者虚拟机和虚拟机之间进行复制和粘贴操作（文件传输）<br>点击Vmware Workstation 菜单栏的“虚拟机”点击“安装 Vmware Tools（T）</p><p><strong>设置虚拟机快照。</strong><br>虚拟机的快照可以把当前虚拟机的状态保存下来，方便以后可以还原到这个状态，理论上快照可以设置很多个，但是设置过多的快照会影响虚拟机的性能，并在会增大物理磁盘的存储空间，快照的常见的应用是：安装大型专业软件时，害怕安装失败，那么在安装之前设置一个快照，方面以后还原虚拟机的状态，重新测试安装软件，或者是在虚拟机设置一系列很复杂的系统配置，担心设置不成功，那么在设置之前可以做一个快照，万一配置系统不顺，可以还原到快照之前的状态，重新做配置。</p><p><strong>虚拟机网络的使用网络模式：</strong><br><strong>映射网络驱动器</strong><br><strong>虚拟机的克隆</strong><br>克隆虚拟机可以把一个虚拟机复制成多个虚拟机，那么就不用重新安装虚拟机了，克隆虚拟机需要在虚拟机关机的状态下进行，在虚拟机关机的情况下，右键虚拟机》管理》克隆<br><strong>通过Vmware导出虚拟机</strong><br>有时候，我们设置好的虚拟机需要在其他电脑上面使用，那么可以使用虚拟机迁移功能，把自己电脑的虚拟机，导出，再到其他电脑上面使用Vmware Workstation进行导入（版本最好一致） 在菜单栏点击“文件”》点击“导出为OVF（E）…”</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>虚拟机VMware中的CentOS字符命令界面和图形界面切换</strong><br>ctrl+f1   ctrl+f2</p><h3 id="VMWare-和-Hyper-V-共存"><a href="#VMWare-和-Hyper-V-共存" class="headerlink" title="VMWare 和 Hyper-V 共存"></a>VMWare 和 Hyper-V 共存</h3><p>将 Windows 版本升级到 Windows 10 20H1 或更高版本。<br>将 VMWare Workstation/Player 升级到 15.5.5 或更高版本<br>在安装时，勾选“自动安装 Windows Hypervisor Platform (WHP)”。<br>打开虚拟机的设置选项，找到“处理器”，去掉如图所示的三个选项前面的钩，点击“确定”</p><h3 id="网络连接方式"><a href="#网络连接方式" class="headerlink" title="网络连接方式"></a>网络连接方式</h3><p>NAT模式（默认）：网络地址转换方式，linux可以访问外网，不会造成ip冲突</p><p>桥接模式：可以与其它系统进行通信，但可能造成ip冲突</p><p>主机模式：你的Linux是一个独立的主机，不能访问外网</p><h2 id="WSL2搭建Linux"><a href="#WSL2搭建Linux" class="headerlink" title="WSL2搭建Linux"></a>WSL2搭建Linux</h2><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/">官方文档</a><br>WSL2采用在Hyper-V虚拟机中运行的方案,实现了与 windows 的高度集成,wsl2 的开启速度有了非常明显的提升，几乎无需等待。</p><p>启用适用于 Linux 的 Windows 子系统</p><p><code>dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</code></p><p>启用虚拟机平台功能</p><p><code>dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</code></p><p>以管理者模式进入cmd安装<br><code>wsl --install</code> </p><p>切换WSL的默认版本为WSL2。<br><code>wsl --set-default-version 2 </code></p><p>以管理者cmd进行更新操作<br><code>wsl --update</code> </p><p>重启，更新才能生效<br><code>wsl --shutdown</code></p><p>Microsoft Store 中找一个 Linux 发行版进行安装</p><p>查看系统版本<br><code>wsl -l -v</code></p><h3 id="修改默认安装目录"><a href="#修改默认安装目录" class="headerlink" title="修改默认安装目录"></a>修改默认安装目录</h3><p>命令格式：wsl –import <distributionname>  &lt;文件位置&gt; &lt;安装位置&gt;  </distributionname></p><ol><li>查看已安装的linux发行版本<br> <code>wsl -l --all -v</code></li><li> 导出分发版为tar文件到d盘<br><code>wsl --export Ubuntu-20.04 D:\data\WSL2\Ubuntu-20.04.tar</code></li><li>注销当前分发版<br><code>wsl --unregister Ubuntu-20.04</code></li><li>重新导入并安装WSL在D盘<br><code>wsl --import Ubuntu-20.04 D:\data\WSL2\Ubuntu-20.04 D:\data\WSL2\Ubuntu-20.04.tar --version 2 </code></li><li>设置默认登陆用户为安装时用户名<br><code>ubuntu config --default-user USERNAME</code></li><li>删除wsl-ubuntu20.04.tar<br><code>del d:\wsl-ubuntu.tar</code></li></ol><h3 id="设置-Linux-用户名和密码"><a href="#设置-Linux-用户名和密码" class="headerlink" title="设置 Linux 用户名和密码"></a>设置 Linux 用户名和密码</h3><p>若要更改或重置密码，请打开 Linux 发行版并输入命令：<code>passwd</code><br>如果忘记了 Linux 分发版的密码：<br>1.请打开 PowerShell，并使用以下命令进入默认 WSL 分发版的根目录：wsl -u root</p><p>如果需要在非默认分发版中更新忘记的密码，请使用命令：wsl -d Debian -u root，并将 Debian 替换为目标分发版的名称。</p><p>2.在 PowerShell 内的根级别打开 WSL 发行版后，可使用此命令更新密码：passwd <username>，其中 <username> 是发行版中帐户的用户名，而你忘记了它的密码。</username></username></p><h3 id="关闭WSL2"><a href="#关闭WSL2" class="headerlink" title="关闭WSL2"></a>关闭WSL2</h3><p>WSL2实际上是在虚拟机中运行。我们一旦进入WSL2 Linux的命令行，虚拟机会自动启动运行。如果我们查看任务管理器，会发现一个Vmmem进程,它比较占内存。不使用WSL2的时候我们可以关闭它以节省内存。关闭WSL2 Linux的方法如下。使用管理员打开CMD，运行：<code>wsl --shutdown</code></p><h3 id="为发行版linux更换国内源"><a href="#为发行版linux更换国内源" class="headerlink" title="为发行版linux更换国内源"></a>为发行版linux更换国内源</h3><p><a href="https://blog.csdn.net/weixin_41529012/article/details/117226884">https://blog.csdn.net/weixin_41529012/article/details/117226884</a></p><p>打开\wsl.localhost\Ubuntu\etc\apt地址下的sources.list文件，更改国内源<br>中科大</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade  #更新镜像源列表</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="使用vscode操作wsl"><a href="#使用vscode操作wsl" class="headerlink" title="使用vscode操作wsl"></a>使用vscode操作wsl</h3><p>在window的vscode上安装Remote Development扩展包<br>包括Remote - SSH ， Remote - Containers ，Remote - WSL扩展</p><p>Remote - WSL 扩展：使你能够打开容器中、远程计算机上或 WSL 中的任何文件夹。</p><h4 id="打开-WSL-项目"><a href="#打开-WSL-项目" class="headerlink" title="打开 WSL 项目"></a>打开 WSL 项目</h4><p>1.从 WSL 发行版打开项目，请打开发行版的命令行并输入：code .</p><p>2.从 VS Code 中打开项目，通过使用 VS Code 中的快捷方式 CTRL+SHIFT+P 调出命令面板，以访问更多 VS Code 远程选项。 如果随后键入 Remote-WSL，将看到可用的 VS Code 远程选项列表，使你可以在远程会话中重新打开文件夹，指定要在哪个发行版中打开，等等。</p><h3 id="wsl安装Docker"><a href="#wsl安装Docker" class="headerlink" title="wsl安装Docker"></a>wsl安装Docker</h3><p>1.下载 <a href="https://docs.docker.com/desktop/windows/wsl/">Docker Desktop</a> 并按照安装说明进行操作。</p><p>2.安装后，从 Windows 开始菜单启动 Docker Desktop，然后从任务栏的隐藏图标菜单中选择 Docker 图标。 右键单击该图标以显示 Docker 命令菜单，然后选择“设置”。</p><p>3.确保在“设置”“常规”中选中“使用基于 WSL 2 的引擎”。</p><p>4.通过转到“设置”“资源”“WSL 集成”，从要启用 Docker 集成的已安装 WSL 2 发行版中进行选择。</p><p>5.若要确认已安装 Docker，请打开 WSL 发行版（例如 Ubuntu），并通过输入 docker –version 来显示版本和内部版本号</p><h2 id="linux云服务器"><a href="#linux云服务器" class="headerlink" title="linux云服务器"></a>linux云服务器</h2><p><a href="https://developer.aliyun.com/article/767041">云服务器可以做什么</a></p><p>云服务器（Elastic Compute Service, 简称ECS），是一种简单高效，处理能力可以弹性伸缩的计算服务。ECS的相关术语说明如下：</p><p>实例（Instance）：是一个虚拟的计算环境，由CPU、内存、系统盘和运行的操作系统组成；ECS实例作为云服务器最为核心的概念，其他资源，比如磁盘、IP、镜像、快照等，只有与ECS结合后才具有使用意义。</p><p>地域（Region）：指ECS实例所在的物理位置。地域内的ECS实例内网是互通的，不同的地域之间ECS实例内网不互通。</p><p>可用区（Zone）：指在同一地域内，电力和网络互相独立的物理区域。</p><p>磁盘（Disk）：是为ECS实例提供数据块级别的数据存储。可以分为4类： 普通云盘、SSD云盘、高效云盘和本地SSD磁盘</p><p>快照（Snapshot）：是某一个时间点上某个磁盘的数据拷贝。</p><p>镜像（Image）：是ECS实例运行环境的模板，一般包括操作系统和预装的软件。</p><p>安全组（Security Group）：是一种虚拟防火墙，具备状态检测包过滤功能。每个实例至少属于一个安全组。同一个安全组内的实例之间网络互通，不同安全组的实例之间默认内网不通，但是可以授权两个安全组之间互访。</p><h3 id="虚拟主机、ECS云服务器、VPS区别汇总"><a href="#虚拟主机、ECS云服务器、VPS区别汇总" class="headerlink" title="虚拟主机、ECS云服务器、VPS区别汇总"></a>虚拟主机、ECS云服务器、VPS区别汇总</h3><p>1、虚拟主机</p><p>虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。</p><p>2、VPS</p><p>先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。</p><p>3、ECS云服务器</p><p>现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下：<br><img src="https://gitee.com/wenkex/blogimage/raw/master/img/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E3%80%81ECS%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81VPS%E5%8C%BA%E5%88%AB-2022-3-1809:16:23.png"></p><h3 id="使用VScode连接阿里云远程服务器"><a href="#使用VScode连接阿里云远程服务器" class="headerlink" title="使用VScode连接阿里云远程服务器"></a>使用VScode连接阿里云远程服务器</h3><p>安装Remote-ssh插件<br>在云服务器控制台选择安全组配置，加入ssh(22)的端口</p><h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>常见的 Shell 有 sh、bash、csh、tcsh、ash 等。<br>#!/bin/bash是指此脚本使用/bin/bash来解释执行。<br>脚本文件后缀是.sh<br><a href="https://mp.weixin.qq.com/s/A_K9Uikkq6OHHthj1EIbVQ">100个shell脚本</a></p><h1 id="系统操作篇"><a href="#系统操作篇" class="headerlink" title="系统操作篇"></a>系统操作篇</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p><strong>man 帮助</strong><br>man 是 manual 的缩写</p><p>• # man ls</p><p><strong>help 帮助</strong><br>shell（命令解释器）⾃带的命令称为内部命令，其他的是外部命令<br>• 内部命令使⽤ help 帮助<br>• # help cd<br>• 外部命令使⽤help帮助<br>• # ls –help<br><strong>info 帮助</strong></p><p>info 帮助⽐ help 更详细，作为 help 的补充<br>• # info ls</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="⽂件查看"><a href="#⽂件查看" class="headerlink" title="⽂件查看"></a>⽂件查看</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwd #显示当前的⽬录名称</span><br><span class="line"></span><br><span class="line">ls  #查看当前⽬录下的⽂件</span><br><span class="line">    #参数：</span><br><span class="line">        #-l ⻓格式显示⽂件</span><br><span class="line">        #-a 显示隐藏⽂件</span><br><span class="line">        #-r 逆序显示</span><br><span class="line">        #-t 按照时间顺序显示</span><br><span class="line">        #-R 递归显示</span><br><span class="line"></span><br><span class="line">cd #更改当前的操作⽬录</span><br><span class="line"></span><br><span class="line">cat #⽂本内容显示到终端</span><br><span class="line">head #查看⽂件开头</span><br><span class="line">tail #查看⽂件结尾</span><br><span class="line"></span><br><span class="line">wc #统计⽂件内容信息</span><br></pre></td></tr></tbody></table></figure><h3 id="⽬录⽂件的创建与删除"><a href="#⽬录⽂件的创建与删除" class="headerlink" title="⽬录⽂件的创建与删除"></a>⽬录⽂件的创建与删除</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir #建⽴⽬录</span><br><span class="line">rmdir #删除空⽬录</span><br><span class="line">rm -r #删除⾮空⽬录</span><br></pre></td></tr></tbody></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常⽤通配符</span><br><span class="line">• * 匹配任何字符串</span><br><span class="line">• ？ 匹配1个字符串</span><br><span class="line">• [xyz] 匹配xyz任意⼀个字符</span><br><span class="line">• [a-z] 匹配⼀个范围</span><br><span class="line">• [!xyz] 或 [^xyz]</span><br></pre></td></tr></tbody></table></figure><h3 id="⽂件操作"><a href="#⽂件操作" class="headerlink" title="⽂件操作"></a>⽂件操作</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cp  #复制⽂件和⽬录</span><br><span class="line">    #常⽤参数</span><br><span class="line">        #-r 复制⽬录</span><br><span class="line">        #-p 保留⽤户、权限、时间等⽂件属性</span><br><span class="line">        #-a 等同于 -dpR</span><br><span class="line"></span><br><span class="line">mv [选项] 源⽂件 ⽬标⽂件/⽬录   #移动⽂件</span><br><span class="line"></span><br><span class="line">rm [选项]   #删除⽂件</span><br><span class="line">            #常⽤参数</span><br><span class="line">            #-r 删除⽬录（包括⽬录下的所有⽂件）</span><br><span class="line">            #-f 删除⽂件不进⾏提示</span><br></pre></td></tr></tbody></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux删除文件夹命令</span></span><br><span class="line"></span><br><span class="line">rm -rf /var/log/httpd/access</span><br><span class="line">将会删除/var/log/httpd/access目录以及其下所有文件、文件夹</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux删除文件命令</span></span><br><span class="line"></span><br><span class="line">rm -f /var/log/httpd/access.log</span><br><span class="line">将会强制删除/var/log/httpd/access.log这个文件</span><br></pre></td></tr></tbody></table></figure><h2 id="vim使用"><a href="#vim使用" class="headerlink" title="vim使用"></a>vim使用</h2><p>基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：</p><h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><dl><dt>i 切换到输入模式，以输入字符。<br>x 删除当前光标所在处的字符。</dt><dd>切换到底线命令模式，以在最底一行输入命令。<br>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</dd></dl><p>• i I a A o O 进⼊插⼊模式<br>• v V ctrl+v 进⼊可视化模式<br>• ： 进⼊命令模式<br>• esc 从其他模式回到正常模式</p><p>ggdG</p><h3 id="插入模式（Insert-mode）"><a href="#插入模式（Insert-mode）" class="headerlink" title="插入模式（Insert mode）"></a>插入模式（Insert mode）</h3><p>只有在插入模式下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><p>字符按键以及Shift组合，输入字符<br>ENTER，回车键，换行<br>BACK SPACE，退格键，删除光标前一个字符<br>DEL，删除键，删除光标后一个字符<br>方向键，在文本中移动光标<br>HOME/END，移动光标到行首/行尾<br>Page Up/Page Down，上/下翻页<br>Insert，切换光标为输入/替换模式，光标将变成竖线/下划线<br>ESC，退出输入模式，切换到命令模式</p><h3 id="底行命令模式"><a href="#底行命令模式" class="headerlink" title="底行命令模式"></a>底行命令模式</h3><p>将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>在命令行模式下，按冒号「:」键，进入底行模式</p><p>:w filename 文件以filename为文件名保存</p><p>:wq 文件存盘并退出vim</p><p>:q 文件不存盘并退出vim</p><p>:q! 文件不存盘强制退出vim<br>• :w 写⼊<br>• :q 退出<br>• :! 执⾏ Shell 命令<br>• :s 替换<br>• / 查找<br>• :set 设置命令</p><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p>命令行模式下 ？</p><p>:s 命令来替换字符串<br>    :s/gald/glad/<br>    :s/java/Linux/g </p><p>:X  设置密码</p><h3 id="Vi编辑文件无法保存退出的解决方法"><a href="#Vi编辑文件无法保存退出的解决方法" class="headerlink" title="Vi编辑文件无法保存退出的解决方法"></a>Vi编辑文件无法保存退出的解决方法</h3><p>解决方法：<br>第一种：：w!!直接保存并退出 或者 ：wq!!<br>第二种：强制退出后，用sudo vi +文件重新编辑，此时便是以root权限进行修改文件，可以正常保存并退出<br>第三：用此命令进行:w !sudo tee %进行保存退出</p><h2 id="软件包管理器"><a href="#软件包管理器" class="headerlink" title="软件包管理器"></a>软件包管理器</h2><p>软件包管理器是⽅便软件安装、卸载，解决软件依赖关系的重要⼯具</p><p>linux系统基本上分两大类：</p><ol><li><p>RedHat系列：Redhat、Centos、Fedora等<br>使⽤ yum 包管理器，软件安装包格式为 rpm，安装rpm包的命令是 “rpm -参数”<br>包管理工具 yum<br>支持tar包</p></li><li><p>Debian系列：Debian、Ubuntu等<br>使⽤ apt 包管理器，软件安装包格式为 deb，安装deb包的命令是 “dpkg -参数”<br>包管理工具 apt-get<br>支持tar包</p></li></ol><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><p>yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。<br>yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 列出所有可更新的软件清单命令：yum check-update</span><br><span class="line"></span><br><span class="line">2. 更新所有软件命令：yum update</span><br><span class="line"></span><br><span class="line">3. 仅安装指定的软件命令：yum install &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line">4. 仅更新指定的软件命令：yum update &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line">5. 列出所有可安裝的软件清单命令：yum list</span><br><span class="line"></span><br><span class="line">6. 删除软件包命令：yum remove &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line">7. 查找软件包命令：yum search &lt;keyword&gt;</span><br><span class="line"></span><br><span class="line">8. 清除缓存命令:</span><br><span class="line"></span><br><span class="line">yum clean packages: 清除缓存目录下的软件包</span><br><span class="line">yum clean headers: 清除缓存目录下的 headers</span><br><span class="line">yum clean oldheaders: 清除缓存目录下旧的 headers</span><br><span class="line">yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers</span><br></pre></td></tr></tbody></table></figure><h4 id="配置yum仓库"><a href="#配置yum仓库" class="headerlink" title="配置yum仓库"></a>配置yum仓库</h4><p>yum就是一个硕大的软件仓库，里面保存了几乎所有的常用工具，只需要为系统提供软件包名称即可。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先切换到yum源中的配置目录</span></span><br><span class="line">cd /etc/yum.repos.d/ </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="yum无法使用"><a href="#yum无法使用" class="headerlink" title="yum无法使用"></a>yum无法使用</h4><p>yum服务使用的默认python版本是python2<br>更换yum源</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/bin/yum  #先看下/usr/bin/yum文件内容</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看系统默认安装的yum</span></span><br><span class="line">rpm -qa|grep yum</span><br><span class="line"></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>wget是Linux中的一个下载文件的工具，后来被移植到包括Windows在内的各个平台上。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装wget</span></span><br><span class="line">yum install -y wget</span><br><span class="line"><span class="meta">#</span><span class="bash">查看帮助手册</span></span><br><span class="line">wget --help</span><br></pre></td></tr></tbody></table></figure><h2 id="⼆进制安装"><a href="#⼆进制安装" class="headerlink" title="⼆进制安装"></a>⼆进制安装</h2><h2 id="源代码编译安装"><a href="#源代码编译安装" class="headerlink" title="源代码编译安装"></a>源代码编译安装</h2><h2 id="Linux-的备份压缩"><a href="#Linux-的备份压缩" class="headerlink" title="Linux 的备份压缩"></a>Linux 的备份压缩</h2><h3 id="gzip命令"><a href="#gzip命令" class="headerlink" title="gzip命令"></a>gzip命令</h3><p>gzip是用来压缩和解压.gz文件的命令。<br>gzip命令只能压缩单个文件，而不能把一个文件夹压缩成一个文件（与打包命令的区别）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">会将文件压缩为文件 test.txt.gz，原来的文件则没有了</span></span><br><span class="line">gzip /home/aistudio/work/test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">解压文件,原来的文件则没有了</span></span><br><span class="line">gzip -d /home/aistudio/test.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">参数</span></span><br><span class="line">-r或--recursive：递归压缩指定文件夹下的文件（该文件夹下的所有文件被压缩成单独的.gz文件）；</span><br><span class="line">-v或--verbose：显示指令执行过程。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><p>用来打包或者解包 后缀名为.tar</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">参数</span></span><br><span class="line">    -c或--create：建立新的备份文件；</span><br><span class="line">    -x或--extract或--get：从备份文件中还原文件 (解包)；</span><br><span class="line">    -v：显示指令执行过程；</span><br><span class="line">    -f或--file：指定备份文件；</span><br><span class="line">    -C：指定目的目录；</span><br><span class="line">    -z：通过gzip指令处理备份文件；</span><br><span class="line">    -j：通过bzip2指令处理备份文件。</span><br></pre></td></tr></tbody></table></figure><h3 id="zip和unzip"><a href="#zip和unzip" class="headerlink" title="zip和unzip"></a>zip和unzip</h3><p>zip命令和unzip命令用在在Linux上处理.zip的压缩文件。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">常用参数</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">zip:</span></span><br><span class="line">-v：显示指令执行过程；</span><br><span class="line">-m：不保留原文件；</span><br><span class="line">-r：递归处理。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">unzip:</span></span><br><span class="line">    -v：显示指令执行过程；</span><br><span class="line">    -d：解压到指定目录。</span><br></pre></td></tr></tbody></table></figure><h2 id="用户与权限管理"><a href="#用户与权限管理" class="headerlink" title="用户与权限管理"></a>用户与权限管理</h2><p>多⽤户操作系统的⽬的是隔离<br>• ⽤户权限隔离<br>• 系统资源隔离<br>• root ⽤户与普通⽤户的区别</p><h3 id="⽤户管理常⽤命令"><a href="#⽤户管理常⽤命令" class="headerlink" title="⽤户管理常⽤命令"></a>⽤户管理常⽤命令</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加用户，并创建主目录</span></span><br><span class="line">useradd -m 用户名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除用户所有信息，并删除主目录</span></span><br><span class="line">userdel -r 用户名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">在root 账户修改普通用户的密码</span></span><br><span class="line">passwd [选项] 用户名</span><br><span class="line"></span><br><span class="line">passwd  #修改root密码</span><br><span class="line"></span><br><span class="line">chage #修改⽤户属性</span><br><span class="line"><span class="meta">#</span><span class="bash">使用sudo命令可简单快速禁用用户</span></span><br><span class="line">sudo passwd -l new</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">重新启用用户账户</span></span><br><span class="line">sudo passwd -u new</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">组管理命令</span></span><br><span class="line">groupadd #新建⽤户组</span><br><span class="line">groupdel #删除⽤户组</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="⽤户切换"><a href="#⽤户切换" class="headerlink" title="⽤户切换"></a>⽤户切换</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su #切换⽤户</span><br><span class="line">su root  #切换到 root 用户</span><br><span class="line">sudo #以其他⽤户身份执⾏命令</span><br></pre></td></tr></tbody></table></figure><h3 id="⽤户配置⽂件"><a href="#⽤户配置⽂件" class="headerlink" title="⽤户配置⽂件"></a>⽤户配置⽂件</h3><p>• /etc/passwd ⽤户配置⽂件<br>• /etc/shadow ⽤户密码相关配置⽂件<br>• /etc/group ⽤户组配置⽂件</p><p>-rw-r-xr– 1 userame groupname mtime filename<br>    • rw- ⽂件属主的权限<br>    • r-x ⽂件属组的权限<br>    • r– 其他⽤户的权限</p><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p><strong>⽂件权限的表示⽅法</strong><br>    • r = 4  ：读<br>    • w = 2 ：写<br>    • x(execute)= 1 :执行</p><p><strong>文件调用权限</strong>分为三级 : 文件所有者/属主（Owner）、用户组/属组（Group）、其它用户（Other Users）。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前目录下所有文件权限</span></span><br><span class="line">ls -l      #简写 ll </span><br><span class="line"></span><br><span class="line">ll |grep 文件名  #查看指定文件权限</span><br></pre></td></tr></tbody></table></figure><h3 id="修改权限命令"><a href="#修改权限命令" class="headerlink" title="修改权限命令"></a>修改权限命令</h3><p>要通过su进入到root权限中</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">chmod abc filename #修改⽂件、⽬录权限</span><br><span class="line"></span><br><span class="line">chown #更改属主、属组</span><br></pre></td></tr></tbody></table></figure><p>指令中的a、b、c分别表示一个数字，其中a对应文件所有者权限，b对应文件所有者所在组权限，c对应其他身份权限。<br>    • r = 4  ：读<br>    • w = 2 ：写<br>    • x(execute)= 1 :执行</p><p>chmod 777 xxxx，<br>第1个7表示文件对于文件所有者来说可读可写可执行；<br>第2个7表示文件对于文件所有者所在组来说可读可写可执行；<br>第3个7表示文件对于其他身份的用户来说可读可写可执行。</p><h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h2 id="⽹络管理"><a href="#⽹络管理" class="headerlink" title="⽹络管理"></a>⽹络管理</h2><h3 id="⽹络状态查看"><a href="#⽹络状态查看" class="headerlink" title="⽹络状态查看"></a>⽹络状态查看</h3><p><strong>1. net-tools</strong><br>• ifconfig<br>• route<br>• netstat<br><strong>2. iproute2</strong><br>• ip<br>• ss</p><h3 id="⽹络配置"><a href="#⽹络配置" class="headerlink" title="⽹络配置"></a>⽹络配置</h3><h3 id="路由命令"><a href="#路由命令" class="headerlink" title="路由命令"></a>路由命令</h3><h3 id="⽹络故障排除"><a href="#⽹络故障排除" class="headerlink" title="⽹络故障排除"></a>⽹络故障排除</h3><h3 id="⽹络服务管理"><a href="#⽹络服务管理" class="headerlink" title="⽹络服务管理"></a>⽹络服务管理</h3><h3 id="常⽤⽹络配置⽂件"><a href="#常⽤⽹络配置⽂件" class="headerlink" title="常⽤⽹络配置⽂件"></a>常⽤⽹络配置⽂件</h3><h1 id="linux使用"><a href="#linux使用" class="headerlink" title="linux使用"></a>linux使用</h1><h2 id="linux文件目录理解"><a href="#linux文件目录理解" class="headerlink" title="linux文件目录理解"></a>linux文件目录理解</h2><h3 id="home"><a href="#home" class="headerlink" title="/home"></a>/home</h3><p>存放所有用户文件的根目录，是用户主目录的基点</p><p>比如用户user的主目录就是/home/user，可以用~user表示</p><h3 id="usr"><a href="#usr" class="headerlink" title="/usr"></a>/usr</h3><p>用于存放系统应用程序，可以理解为C:/Windows/ </p><h4 id="usr-local"><a href="#usr-local" class="headerlink" title="/usr/local"></a>/usr/local</h4><p>用户级的程序目录，可以理解为C:/Progrem Files/</p><p>用户自己编译的软件默认会安装到这个目录下</p><p>本地系统管理员软件安装目录（安装系统级的应用）</p><p>这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录</p><p>用的是root的空间。</p><h2 id="Linux开机自动启动软件-可执行程序"><a href="#Linux开机自动启动软件-可执行程序" class="headerlink" title="Linux开机自动启动软件/可执行程序"></a>Linux开机自动启动软件/可执行程序</h2><h3 id="首先关注几个脚本"><a href="#首先关注几个脚本" class="headerlink" title="首先关注几个脚本"></a>首先关注几个脚本</h3><p>/etc/rc.d/rc.local：该脚本在系统启动时被执行一次；<br>/etc/profile:该脚本在所有用户登陆时会被执行一次；<br>~/.bashrc:该脚本在用户登陆时被执行一次，与/etc/profile不同的是，bashrc文件每个用户拥有独立的一个。</p><p>若设置开机启动，应该修改：/etc/rc.d/rc.local文件。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>1、修改 /etc/profile 文件，如果你的计算机仅仅作为开发使用时推存使用这种方法，因为所有用户的shell都有权使用这个环境变量，可能会给系统带来安全性问题。这里是针对所有的用户的，所有的shell</p><p>vi /etc/profile</p><p>在/etc/profile的最下面添加：  export  PATH=”$PATH:/NEW_PATH”</p><p>针对当前特定的用户起作用的环境变量</p><p>2、修改bashrc文件，这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，这里是针对某一特定的用户，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的 .bashrc文件就可以了。</p><p>vi ~/.bashrc</p><p>在下面添加：</p><p>Export  PATH=”$PATH:/NEW_PATH”</p><h2 id="xshell"><a href="#xshell" class="headerlink" title="xshell"></a>xshell</h2><p>XShell是一个强大的安全终端模拟软件,可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。<br><a href="https://xshell.en.softonic.com/">安装</a><br><a href="https://www.jianshu.com/p/4716cc35750f">参考</a></p><h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><p>选择导航菜单的文件 –&gt; 新建，输入名称和主机IP，协议默认SSH，端口默认22，如果不知道主机IP可以登录虚拟机的Linux系统，输入命令ifconfig查看(inet addr)</p><p>然后在左侧用户身份验证中输入用户名和密码，这样下次就可以直接连接了，当然如果为了安全考虑也可以不输入密码，在每次连接时再输入。</p><h3 id="Xshell怎么与云服务器连接"><a href="#Xshell怎么与云服务器连接" class="headerlink" title="Xshell怎么与云服务器连接"></a>Xshell怎么与云服务器连接</h3><p>打开Xshell，新建一个会话</p><p>主机填服务器ip,点击连接</p><p>用户名默认为root,而不是实例名，也不是你服务器中Linux的用户名；<br>密码则为服务器实例密码</p><h2 id="centos内核"><a href="#centos内核" class="headerlink" title="centos内核"></a>centos内核</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  版本信息</span></span><br><span class="line">cat /etc/centos-release </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Linux内核信息</span></span><br><span class="line">uname -a  </span><br></pre></td></tr></tbody></table></figure><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用图形界面配置网络命令</span></span><br><span class="line">nmtui</span><br><span class="line"><span class="meta">#</span><span class="bash">重新启动网络服务命令</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">显示你所有操作的历史命令</span></span><br><span class="line">history</span><br></pre></td></tr></tbody></table></figure><h2 id="NAT配置"><a href="#NAT配置" class="headerlink" title="NAT配置"></a>NAT配置</h2><h3 id="检查环境-能上网，安装了net-tools"><a href="#检查环境-能上网，安装了net-tools" class="headerlink" title="检查环境: 能上网，安装了net-tools."></a>检查环境: 能上网，安装了net-tools.</h3><p>（1）能否上网（ping <a href="http://www.baidu.com/">www.baidu.com</a>)<br>如不能上网。配置/etc/sysconfig/network-scripts/ifcfg-ens33<br>（2）是否安装了 net-tools.  (因为需要使用命令 route )<br>如没有， yum -y install net-tools</p><h3 id="搭建网络"><a href="#搭建网络" class="headerlink" title="搭建网络"></a>搭建网络</h3><p>一台Sever (2张网卡） + 一台 Client（一张网卡）</p><p>安装（或克隆）一台虚拟机名为：Client. 原来那台可改名叫（Server)。<br>Server 上再安装一张网卡，并配成“仅主机模式”。（原来应该那一张应该为NAT模式）。<br>Client 网卡配成 “仅主机模式”</p><h3 id="配置NAT"><a href="#配置NAT" class="headerlink" title="配置NAT"></a>配置NAT</h3><p>（1）开启Server 和 Client, 用 root 登录。<br>（2）在Server 上运行： <code>ip addr</code>记录下 ens37 (也就是Server 的第二张网卡） 的ip：192.168.221.128<br>（3）设置Client网关，在Client 上 运行:<br><code>route add default gw 192.168.221.128  #添加一条默认网关</code><br>（如要查看网关 是否设置成功，可以运行：route -n)</p><p>（4）在Server设置地址伪装 ， 运行：</p><p>(5）重启防火墙<code>systemctl restart firewalld.service</code></p><p>(6)在Client 上ping测试是否成功</p><p>(7)在Client上配置本地DNS:去到目录 /etc 下， 用vi 编辑 文件 “resolv.conf” </p><h1 id="宝塔Linux面板"><a href="#宝塔Linux面板" class="headerlink" title="宝塔Linux面板"></a>宝塔Linux面板</h1><p><a href="https://blog.csdn.net/vpssws/article/details/117136583?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/vpssws/article/details/117136583?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Centos安装命令：</span></span><br><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu/Deepin安装命令：</span></span><br><span class="line">wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">显示面板的使用帮助菜单选项。</span></span><br><span class="line">bt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">卸载面板</span></span><br><span class="line">wget http://download.bt.cn/install/bt-uninstall.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">执行脚本：</span></span><br><span class="line">sh bt-uninstall.sh</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>安装软件时，推荐使用编译安装</p><h2 id="面板特色功能："><a href="#面板特色功能：" class="headerlink" title="面板特色功能："></a>面板特色功能：</h2><p>一键配置服务器环境（LAMP/LNMP）<br>一键安全重启<br>一键创建管理网站、ftp、数据库<br>一键部署SSL证书<br>一键部署源码（discuz、wordpress、dedecms、z-blog、微擎等等）<br>一键配置（定期备份、数据导入、伪静态、301、SSL、子目录、反向代理、切换PHP版本）<br>一键安装常用PHP扩展(fileinfo、intl、opcache、imap、memcache、apc、redis、ioncube、imagick)<br>数据库一键导入导出<br>系统监控（CPU、内存、磁盘IO、网络IO）<br>防火墙端口放行<br>SSH开启与关闭及SSH端口更改<br>禁PING开启或关闭<br>方便高效的文件管理器（上传、下载、压缩、解压、查看、编辑等等）<br>计划任务（定期备份、日志切割、shell脚本）<br>软件管理（一键安装、卸载、版本切换）</p><h2 id="添加站点"><a href="#添加站点" class="headerlink" title="添加站点"></a>添加站点</h2><p>添加站点就是添加一个域名进去，通过这个域名可以访问你的网页，或者直接填写你的ip进去，然后浏览器输入你的ip访问一下就看到结果了</p><h2 id="LNMP-环境"><a href="#LNMP-环境" class="headerlink" title="LNMP 环境"></a>LNMP 环境</h2><p>LNMP 是 Linux、Nginx、MariaDB 和 PHP 的缩写，这个组合是最常见的 Web 服务器的运行环境之一。用宝塔面板一键安装</p><h2 id="ftp服务"><a href="#ftp服务" class="headerlink" title="ftp服务"></a>ftp服务</h2><h1 id="centos搭建dhcp服务器"><a href="#centos搭建dhcp服务器" class="headerlink" title="centos搭建dhcp服务器"></a>centos搭建dhcp服务器</h1><p>DHCP是一种局域网协议，当我们搭建好DHCP服务器后，它可以自动分发IP地址和网关给客户机</p><p>1.准备两台虚拟机就可以，一台做服务器，一台做客户机·。</p><p>2.开始配置服务器，右击打开终端。进入管理员模式（命令为su root），先安装DHCP服务器的软件包（虚拟机要联网），用 yum install dhcp -y 命令安装（-y 表示接下来系统弹出是请求都默认是yes）dhcp-4.2.5-83.el7.centos.1.x86_64 这个软件包一定要有。里面有默认的配置文件。</p><p>然后用vim /etc/dhcp/dhcpd.conf命令进入默认的主配置文件， 复制/usr/share/doc/dhcp*/dhcpd.conf.example这个路径<br>cp /usr/share/doc/dhcp*/dhcpd.conf.example /etc/dhcp/dhcpd.conf</p><h1 id="CentOS7配置本地yum源"><a href="#CentOS7配置本地yum源" class="headerlink" title="CentOS7配置本地yum源"></a>CentOS7配置本地yum源</h1><h2 id="脚本配置本地源"><a href="#脚本配置本地源" class="headerlink" title="脚本配置本地源"></a>脚本配置本地源</h2><p>vim /root/auto_source.sh #创建脚本文件,编辑内容如下</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建本地源文件夹,作为光盘的挂载点</span></span><br><span class="line">mkdir -p /media/centos/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载镜像文件至指定的目录</span></span><br><span class="line">mount /dev/cdrom /media/centos</span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份原本地源</span></span><br><span class="line">cp -rf /etc/yum.repos.d  /etc/yum.repos.d_$(date '+%Y%m%d_%H%M%S')</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除默认原本地源</span></span><br><span class="line">rm -rf /etc/yum.repos.d/*</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置本地源,创建Media.repo文件,并配置如下内容</span></span><br><span class="line">cd /etc/yum.repos.d/</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">Media.repo</span></span><br><span class="line">echo '[iso]'                            &gt;&gt; Media.repo</span><br><span class="line">echo 'name=Media'                       &gt;&gt; Media.repo</span><br><span class="line"><span class="meta">#</span><span class="bash">地址为你自己的光盘挂载地址</span></span><br><span class="line">echo 'baseurl=file:///media/centos/'    &gt;&gt; Media.repo</span><br><span class="line">echo 'gpgcheck=0'                       &gt;&gt; Media.repo</span><br><span class="line"><span class="meta">#</span><span class="bash">enabled=1, 让这个yum源配置文件生效</span></span><br><span class="line">echo 'enabled=1'                        &gt;&gt; Media.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除yum缓存</span></span><br><span class="line">yum clean all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 缓存本地yum源</span></span><br><span class="line">yum makecache</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>chmod +x /root/auto_source.sh # 赋予脚本可执行的权限<br>/root/auto_source.sh   #执行脚本文件，即可</p><h1 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用linux的好处&quot;&gt;&lt;a href=&quot;#使用linux的好处&quot; class=&quot;headerlink&quot; title=&quot;使用linux的好处&quot;&gt;&lt;/a&gt;使用linux的好处&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/MP</summary>
      
    
    
    
    <category term="工具" scheme="https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="linux" scheme="https://wenkex.gitee.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>python数据结构</title>
    <link href="https://wenkex.gitee.io/2022/02191106.html"/>
    <id>https://wenkex.gitee.io/2022/02191106.html</id>
    <published>2022-02-19T04:04:47.000Z</published>
    <updated>2022-02-19T04:04:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.yiibai.com/python/py_data_structure/python_data_structure_introduction.html">https://www.yiibai.com/python/py_data_structure/python_data_structure_introduction.html</a></p><h1 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h1><p>这些是以顺序方式存储数据元素的数据结构。例如 - </p><h2 id="数组-它是与数据元素的索引配对的数据元素的顺序排列。"><a href="#数组-它是与数据元素的索引配对的数据元素的顺序排列。" class="headerlink" title="数组: 它是与数据元素的索引配对的数据元素的顺序排列。"></a>数组: 它是与数据元素的索引配对的数据元素的顺序排列。</h2><h2 id="链表-每个数据元素都包含一个指向另一个元素的链接及其中的数据。"><a href="#链表-每个数据元素都包含一个指向另一个元素的链接及其中的数据。" class="headerlink" title="链表: 每个数据元素都包含一个指向另一个元素的链接及其中的数据。"></a>链表: 每个数据元素都包含一个指向另一个元素的链接及其中的数据。</h2><p>链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据。链表中每一个节点都包含此节点的数据和指向下一节点地址的指针。由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。</p><p>这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点。不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用。</p><p>一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。</p><p>链表和数组对比<br>链表和数组在实际的使用过程中需要根据自身的优劣势进行选择。链表和数组的异同点也是面试中高频的考察点之一。这里对单链表和数组的区别进行了对比和总结。</p><h2 id="堆栈-这是一种仅遵循特定操作顺序的数据结构。LIFO-后进先出-或FILO-先进先出-。"><a href="#堆栈-这是一种仅遵循特定操作顺序的数据结构。LIFO-后进先出-或FILO-先进先出-。" class="headerlink" title="堆栈: 这是一种仅遵循特定操作顺序的数据结构。LIFO(后进先出)或FILO(先进先出)。"></a>堆栈: 这是一种仅遵循特定操作顺序的数据结构。LIFO(后进先出)或FILO(先进先出)。</h2><p>队列: 与堆栈(Stack)类似，但操作顺序仅为FIFO(先进先出)。<br>矩阵: 它是二维数据结构，其中数据元素由一对索引引用。</p><h1 id="非线性数据结构"><a href="#非线性数据结构" class="headerlink" title="非线性数据结构"></a>非线性数据结构</h1><p>这些数据结构中没有数据元素的顺序链接。任何一对或一组数据元素都可以相互关联，并且可以在没有严格顺序的情况下进行访问。</p><p>二叉树:它是一个数据结构，每个数据元素可以连接到最多两个其他数据元素，并以一个根节点开始。<br>堆: 这是树形数据结构的特殊情况，其中父节点中的数据严格大于/等于子节点或严格小于其子节点。<br>哈希表: 它是一个数据结构，它由使用散列函数相互关联的数组构成。它使用键而不是数据元素的索引来检索值。<br>图: 它是顶点和节点的排列，其中一些节点通过链接彼此连接。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组可以说是最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。</p><h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>从上面的对比中可以看出，链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。</p><p>图片</p><p>跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前redis和levelDB都有用到跳表。</p><p>从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查询的目的。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是一种比较简单的数据结构，常用一句话描述其特性，后进先出。栈本身是一个线性表，但是在这个表中只有一个口子允许数据的进出。这种模式可以参考腔肠动物…即进食和排泄都用一个口…</p><p>栈的常用操作包括入栈push和出栈pop，对应于数据的压入和压出。还有访问栈顶数据、判断栈是否为空和判断栈的大小等。由于栈后进先出的特性，常可以作为数据操作的临时容器，对数据的顺序进行调控，与其它数据结构相结合可获得许多灵活的处理。</p><p>图片</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是栈的兄弟结构，与栈的后进先出相对应，队列是一种先进先出的数据结构。顾名思义，队列的数据存储是如同排队一般，先存入的数据先被压出。常与栈一同配合，可发挥最大的实力。</p><p>图片</p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。常见的数的表示形式更接近“倒挂的树”，因为它将根朝上，叶朝下。</p><p>树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。</p><p>这意味着树是具备层次关系的，父子关系清晰，家庭血缘关系明朗；这也是树与图之间最主要的区别。</p><p>图片</p><p>别看树好像很高级，其实可看作是链表的高配版。树的实现就是对链表的指针域进行了扩充，增加了多个地址指向子结点。同时将“链表”竖起来，从而凸显了结点之间的层次关系，更便于分析和理解。</p><p>树可以衍生出许多的结构，若将指针域设置为双指针，那么即可形成最常见的二叉树，即每个结点最多有两个子树的树结构。二叉树根据结点的排列和数量还可进一度划分为完全二叉树、满二叉树、平衡二叉树、红黑树等。</p><p>图片</p><p>完全二叉树：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。</p><p>满二叉树：除了最后一层，其它层的结点都有两个子结点。</p><p>平衡二叉树<br>平衡二叉树又被称为AVL树，它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>二叉排序树：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。</p><p>树的高度：结点层次的最大值</p><p>平衡因子：左子树高度 - 右子树高度</p><p>二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点&lt;根节点&lt;右结点，这表明二叉排序树的中序遍历结果是有序的。（还不懂二叉树四种遍历方式[前序遍历、中序遍历、后序遍历、层序遍历]的同学赶紧补习！）</p><p>图片</p><p>平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。</p><p>图片</p><p>平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。</p><p>在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。</p><p>左旋：S为当前需要左旋的结点，E为当前结点的父节点。</p><p>图片</p><p>左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。可用动画表示：</p><p>图片</p><p>右旋：S为当前需要左旋的结点，E为当前结点的父节点。右单旋是左单旋的镜像旋转。</p><p>图片</p><p>左旋的操作同样可以用一句话简单表示：将当前结点S的左孩子E的右孩子旋转为当前结点S的左孩子，同时将当前结点S旋转为左孩子E的右孩子。可用动画表示：</p><p>图片</p><p>红黑树<br>平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致AVL的插入和删除效率并不高。</p><p>为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。</p><p>红黑树具有五个特性：</p><p>每个结点要么是红的要么是黑的。<br>根结点是黑的。<br>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。<br>如果一个结点是红的，那么它的两个儿子都是黑的。<br>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。<br>图片红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。</p><p>红黑树VS平衡二叉树<br>图片</p><p>除了上面所提及的树结构，还有许多广泛应用在数据库、磁盘存储等场景下的树结构。比如B树、B+树等。这里就先不介绍了诶，下次在讲述相关存储原理的时候将会着重介绍。（其实是因为懒）</p><p> 7  堆<br>了解完二叉树，再来理解堆就不是什么难事了。堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。</p><p>对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此可以直接用数组来表示一个堆。</p><p>不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p><p>图片</p><p>堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如堆排序、topK问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。</p><p> 8  散列表<br>散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射。散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。</p><p>图片</p><p>散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数：</p><p>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。</p><p>数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</p><p>平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</p><p>取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</p><p>除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。</p><p>确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。</p><p>冲突在发生之后，当在对不同的key值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。</p><p>常用的冲突处理方式有很多，常用的包括以下几种：</p><p>开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。</p><p>再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</p><p>链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。</p><p>公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</p><p>目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。</p><p>图片</p><p>左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。<br>考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。</p><p> 9  图<br>图相较于上文的几个结构可能接触的不多，但是在实际的应用场景中却经常出现。比方说交通中的线路图，常见的思维导图都可以看作是图的具体表现形式。</p><p>图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。</p><p>图片</p><p>图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。</p><p>邻接矩阵<br>目前常用的图存储方式为邻接矩阵，通过所有顶点的二维矩阵来存储两个顶点之间是否相连，或者存储两顶点间的边权重。</p><p>图片</p><p>无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，若能从此顶点能够到达彼顶点，那么彼顶点自然也能够达到此顶点。此外，由于顶点本身与本身相连没有意义，所以在邻接矩阵中对角线上皆为0。</p><p>图片</p><p>有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。<br>用邻接矩阵可以直接从二维关系中获得任意两个顶点的关系，可直接判断是否相连。但是在对矩阵进行存储时，却需要完整的一个二维数组。若图中顶点数过多，会导致二维数组的大小剧增，从而占用大量的内存空间。</p><p>而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。</p><p>因此，为了解决上述问题，一种可以只存储相连顶点关系的邻接表应运而生。</p><p>邻接表<br>在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点。相较于无向图，有向图的情况更为复杂，因此这里采用有向图进行实例分析。</p><p>图片在邻接表中，每一个顶点都对应着一条链表，链表中存储的是顶点能够达到的相邻顶点。存储的顺序可以按照顶点的编号顺序进行。比如上图中对于顶点B来说，其通过有向边可以到达顶点A和顶点E，那么其对应的邻接表中的顺序即B-&gt;A-&gt;E，其它顶点亦如此。</p><p>通过邻接表可以获得从某个顶点出发能够到达的顶点，从而省去了对不相连顶点的存储空间。然而，这还不够。对于有向图而言，图中有效信息除了从顶点“指出去”的信息，还包括从别的顶点“指进来”的信息。这里的“指出去”和“指进来”可以用出度和入度来表示。</p><p>入度：有向图的某个顶点作为终点的次数和。</p><p>出度：有向图的某个顶点作为起点的次数和。</p><p>由此看出，在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。</p><p>逆邻接表<br>逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。</p><p>图片</p><p>邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。</p><p>十字链表<br>十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。</p><p>图片</p><p>但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。</p><p>十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）</p><p>data：用于存储该顶点中的数据；</p><p>firstin指针：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点；</p><p>firstout指针：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点；</p><p>边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：</p><p>tailvex：用于存储作为弧尾的顶点的编号；</p><p>headvex：用于存储作为弧头的顶点的编号；</p><p>headlink 指针：用于链接下一个存储作为弧头的顶点的节点；</p><p>taillink 指针：用于链接下一个存储作为弧尾的顶点的节点；</p><p>图片</p><p>以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边AE（即边04）指向顶点E，顶点A的firstout指针需要指向边04的tailvex。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边AB（即边10）指向B，顶点A的firstin指针需要指向边10的弧头，即headlink指针。依次类推。</p><p>十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。</p><p> 10  总结<br>数据结构博大精深，没有高等数学的讳莫如深，也没有量子力学的玄乎其神，但是其在计算机科学的各个领域都具有强大的力量。本文试图采用图解的方式对九种数据结构进行理论上的介绍，但是其实这都是不够的。</p><p>即便是简单的数组、栈、队列等结构，在实际使用以及底层实现上都会有许多优化设计以及使用技巧，这意味着还需要真正把它们灵活的用起来，才能够算是真正意义上的熟悉和精通。但是本文可以作为常见数据结构的一个总结，当你对某些结构有些淡忘的时候，不妨重新回来看看。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="常见的题型"><a href="#常见的题型" class="headerlink" title="常见的题型"></a>常见的题型</h2><p>面试或者白板编程，由于形式的限制，题目的选择范围其实并不大。并不难理解，毕竟面试的时间有限，也不能全拿来做题，而太困难太复杂的问题候选人一点思路也没有，大部分人都做不上来，也完全起不到考察和筛选的意义。</p><p>所以拿来当做面试和白板编程的问题，不会很复杂，至少会保证绝大多数的候选人都听说过。就好像打游戏一样，哪怕是玩家津津乐道的魂游戏，总要有过关的可能。如果上来就考察一个问题，结果你连正解用到的算法都没听说过，一开始就没有做出来的可能，这种问题问了就只能浪费时间。</p><p>根据我的经验，面试当中常问的问题基本上就这几种：<strong>二分、递归、分治、排序、动态规划。</strong></p><p>这几种算法只要是科班出身，基本上都或多或少听说过，理论上来说都应该能做出来。并且这些算法除了比较基础之外，它们的代码量都不大，一般核心代码都不会超过30行，确保编码的时间不会太长。第二是比较考验思维，通过你对这几个算法的理解深度，就足以看出来你的思维能力和算法能力了。</p><h2 id="解题套路"><a href="#解题套路" class="headerlink" title="解题套路"></a>解题套路</h2><p>1.缩小问题规模<br>有可能问题里问的是一个规模很大的问题，比如汉诺塔问题，要移动64个圆盘，这太复杂了，我们根本无法思考。不妨把问题的规模缩小，比如缩小到3个圆盘，然后我们就可以列举一下情况，找找规律和套路了。</p><p>即使是在acm赛场当中，这个方法也非常管用。</p><p>2.确定复杂度<br>在acm赛场上题目当中都会标明数据的大小范围，除了起到限制作用之外也是一个很大的提示。我们可以根据数据的规模反推出正解的复杂度范围，从而排除掉一些不可能的算法。</p><p>比如说要在个数当中寻找某个数，由于计算机每秒的运行次数在这个量级，这么大的规模遍历一遍都有些扛不住，那么显然正解的复杂度一定在及以下。这么一来，我们就可以根据算法的复杂度排除掉一大批达不到要求的算法，排除错误的选项。</p><p>在面试的时候面试官往往不会明确给出数据的规模，我们可以自己结合实际情况分析，当然直接提问也是一个不错的选择。</p><p>3.优化思路<br>面试不是比赛，并不是一定要给出正解。有的时候，我们一时陷入误区没想到解法也是常有的。重要的并不是我们是否想出了解法，而是我们能否展现我们思维的能力，打动面试官。</p><p>所以有的时候一下子没有想到最优解也没有关系，我们可以先易后难，先把一些简单可行的解法说出来，然后再进行优化。</p><p>比如LeetCode第4题，寻找两个有序数组的中位数。我们当然很难一下子想出的正解，但是我们可以先从最简单的方法说起。比如重新排序直接寻找，这样操作的复杂度是。说出这个方法之后，我们接着从不使用排序解决问题的角度继续思考，如此一步步逐渐深入，即使最终没能找到正解，也体现出了我们的思考是有章法的，并且思考和分析问题的能力是有的。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>1.贵精不贵多<br>如果是为了准备面试，就像我前面列举的一样，其实并不会涉及很多内容。相比去研究很多高大上面试的时候用不到的高大上算法，倒不如好好把这几个算法啃扎实。</p><p>就拿排序来说，想要全部搞明白就很不简单。我随便写几个问题，大家不妨对照一下看看能不能回答上来。</p><p>冒泡排序和选择排序有什么区别？</p><p>为什么说快速排序和归并排序都基于分治算法，但它们的最差复杂度不同？</p><p>排序的稳定性是什么？哪些算法是稳定的，哪些不是？</p><p>关于快速排序算法的最差复杂度，有哪些优化？</p><p>如果都能不仅仅满足原理，而是可以深入到细节的方方面面去钻研，那么即使只是准备了几个算法，应付一般的面试都不在话下。</p><p>2.成体系化训练<br>算法的学习过程是比较痛苦的，尤其是如果我们漫无目的地去训练和学习，进展非常缓慢，非常劝退。很多同学都有刷题刷了一堆，但是水平好像没什么提升的情况。</p><p>我个人感觉比较有效的方法是成体系化的训练，不要按照题目顺序刷题，而是以算法划分专题，按照专题刷题。一个算法一个算法的硬啃，一个算法吃透再吃下一个。这样训练下来印象会非常深刻，对于算法的理解也会深刻得多，也不容易忘记。要比题目刷了一堆， 算法也用了一堆， 看起用得多，但也忘得多要好得多。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度<br>有几次循环就有o(n的几次方)</p></li><li><p>空间复杂度<br>用来评估算法内存占用大小的一个式子</p></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>力扣70.爬楼梯</p><p>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。<br>动态规划最<strong>核心的思想</strong>，就在于拆分子问题，记住过往，减少重复计算。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1.划分问题：按照问题的特征，把问题分为若干阶段。注意：划分后的阶段一定是有序的或者可排序的</p><p>2.确定状态和状态变量：将问题发展到各个阶段时所处的各种不同的客观情况表现出来。状态的选择要满足无后续性</p><p>3.写出状态转移方程：状态转移就是根据上一阶段的决策和状态来导出本阶段的状态。根据相邻两个阶段状态之间的联系来确定决策方法和状态转移方程</p><p>4.边界条件：状态转移方程是一个递推式，因此需要找到递推终止的条件   1或2时<br>即：</p><p>【初始状态】→【决策1】→【决策2】→…→【决策n】→【结束状态】</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><h4 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1. 爬楼梯"></a>1. 爬楼梯</h4><p>70. Climbing Stairs (Easy)</p><p><a href="https://leetcode.com/problems/climbing-stairs/description/">Leetcode</a> / <a href="https://leetcode-cn.com/problems/climbing-stairs/description/">力扣</a></p><p>题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。</p><p><strong>思路：</strong><br>当只有1个楼梯时，方法为1<br>当只有2个楼梯，方法为2<br>当有3个楼梯时，方法为3<br>当有4个楼梯时，方法为5</p><p>定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。</p><p>第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。</p><!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=dp[i-1]+dp[i-2]" class="mathjax-pic"/></div> <br>--><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14fe1e71-8518-458f-a220-116003061a83.png" width="200px"> </div><br><p>考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">  <span class="comment">// 临界条件</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>; <span class="comment">// 临界条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">int</span> cur = pre1 + pre2;</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pre1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>在升序数组 nums 中寻找目标值 target，对于特定下标 i，比较nums[i] 和 target 的大小：</p><p>如果 nums[i]=target，则下标 i即为要寻找的下标；</p><p>如果 nums[i]&gt;target，则 target 只可能在下标 i的左侧；</p><p>如果 nums[i]&lt;target，则 target 只可能在下标 i的右侧。</p><p>二分查找的做法是，定义查找的范围 [left,right]，初始查找范围是整个数组。每次取查找范围的中点mid，比较nums[mid] 和 target 的大小，如果相等则mid 即为要寻找的下标，如果不相等则根据nums[mid] 和 target 的大小关系将查找范围缩小一半。</p><p>由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(logn)，其中 n 是数组的长度。</p><p>二分查找的条件是查找范围不为空，即left≤right。如果 target 在数组中，二分查找可以保证找到 target，返回 target 在数组中的下标。如果 target 不在数组中，则当{left} &gt;{right}left&gt;right 时结束查找，返回−1。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPerfectSquare</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">      left, right = <span class="number">0</span>, num <span class="comment">#定义二分查找搜索区间的初始边界。</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">#在移动左侧边界left和右侧边界right时，新的搜索区间都不会包含被检查的下标mid，所以搜索边界始终没有检查过，</span></span><br><span class="line">      <span class="comment">#当left=right时，我们仍需要检查mid=(right+right)//2</span></span><br><span class="line">      <span class="keyword">while</span> left &lt;= right:  <span class="comment">#循环直至区间左右端点相同</span></span><br><span class="line">        <span class="comment">#mid = (left + right) // 2 #设定中间值</span></span><br><span class="line">        <span class="comment">#括号内的值要为0</span></span><br><span class="line">        mid = (right-left)//<span class="number">2</span>+left      <span class="comment">#防止计算时溢出</span></span><br><span class="line">        <span class="keyword">if</span> square &lt; num:</span><br><span class="line">          left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> square &gt; num:</span><br><span class="line">          right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">return</span> mid</span><br><span class="line">      <span class="keyword">return</span> left  <span class="comment">#此时有left==right,区间缩为一个点，即为答案</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间复杂度：)O(logn)，其中 n为正整数 num 的最大值。</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)。</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.yiibai.com/python/py_data_structure/python_data_structure_introduction.html&quot;&gt;https://www.yiibai.com/python/py_data_s</summary>
      
    
    
    
    <category term="pytohn" scheme="https://wenkex.gitee.io/categories/pytohn/"/>
    
    
    <category term="数据结构" scheme="https://wenkex.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
