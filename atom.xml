<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wenke</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://wenkex.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://wenkex.gitee.io/"/>
  <updated>2022-05-31T07:20:41.000Z</updated>
  <id>https://wenkex.gitee.io/</id>
  
  <author>
    <name>wenke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript学习</title>
    <link href="https://wenkex.gitee.io/2022/05319399.html"/>
    <id>https://wenkex.gitee.io/2022/05319399.html</id>
    <published>2022-05-31T07:20:41.000Z</published>
    <updated>2022-05-31T07:20:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><p><a href="https://www.yuque.com/yashujs/bfug6u/ntxhzu#cc4dd1da">https://www.yuque.com/yashujs/bfug6u/ntxhzu#cc4dd1da</a></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>单行注释//<br>块注释/**/</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> item = {</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">addValue</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> item.value + val</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 请使用对象方法的简写方式, 属性不可简写, 方法可以简写  </span></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> item = {</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  addValue (val) {</span><br><span class="line">    <span class="keyword">return</span> item.value + val</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>arr.push()<br>arr.sort()</p><h3 id="数组转字符串"><a href="#数组转字符串" class="headerlink" title="数组转字符串"></a>数组转字符串</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// join() 方法可以把数组转换为字符串，不过它可以指定分隔符。在调用 join() 方法时，可以传递一个参数作为分隔符来连接每个元素。如果省略参数，默认使用逗号作为分隔符</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];  <span class="comment">//定义数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = a.join(<span class="string">""</span>);  <span class="comment">//指定分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s);  <span class="comment">//返回字符串“12345”</span></span><br></pre></td></tr></tbody></table></figure><h3 id="使用数组的多个值时"><a href="#使用数组的多个值时" class="headerlink" title="使用数组的多个值时"></a>使用数组的多个值时</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当需要使用数组的多个值时，请使用解构赋值  </span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> second = arr[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [first, second] = arr</span><br></pre></td></tr></tbody></table></figure><h3 id="调用数组每个元素"><a href="#调用数组每个元素" class="headerlink" title="调用数组每个元素"></a>调用数组每个元素</h3><p>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>{<span class="built_in">console</span>.log(i);})</span><br></pre></td></tr></tbody></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>var 存在变量提升的情况，即 var 声明会被提升至该作用域的顶部，但是他们的赋值并不会。而 const 和 let 并不存在这种情况，</p><p>在作用域顶部声明变量，避免变量声明和赋值引起的相关问题。<br>var的作用域被规定为一个函数作用域，<br>而let则被规定为块作用域，块作用域要比函数作用域小一些<br>但是如果两者既没在函数中，也没在块作用域中定义，那么两者都属于全局作用域。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在 JavaScript 函数内部声明的变量是局部变量，所以只能在函数内部访问它，局部变量生命期从被声明的时间开始。在函数运行以后被删除。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串太长的时候，请不要使用字符串连接符换行 \，而是使用 + </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'牙叔教程 牙叔教程 牙叔教程'</span> +</span><br><span class="line">  <span class="string">'牙叔教程 牙叔教程 牙叔教程'</span> +</span><br><span class="line">  <span class="string">'牙叔教程 牙叔教程'</span></span><br></pre></td></tr></tbody></table></figure><p>编程时使用join而不是字符串连接来构建字符串  </p><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.show();</span><br><span class="line"><span class="keyword">var</span> i = { <span class="attr">name</span>: <span class="string">"小明"</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">height</span>: <span class="number">1.72</span> }; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"大家好, 我叫%s, 今年%d岁, 身高%d米"</span>, i.name, i.age, i.height);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"实际上我是一个对象啦，长这样子: %j"</span>, i);</span><br></pre></td></tr></tbody></table></figure><h3 id="随机字符"><a href="#随机字符" class="headerlink" title="随机字符"></a>随机字符</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Radom</span>(<span class="params">n</span>)</span>{</span><br><span class="line">    <span class="comment">//如果不传参就是n=8</span></span><br><span class="line">    <span class="keyword">var</span> n= n || <span class="number">8</span></span><br><span class="line">    <span class="keyword">var</span> str=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        str+=<span class="built_in">String</span>.fromCharCode(random(<span class="number">0</span>,<span class="number">65535</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">log(Radom(<span class="number">8</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><a href="https://www.yuque.com/yashujs/bfug6u/dy5mld">autojs之递归</a></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历文件夹, 获取文件列表</span></span><br><span class="line"><span class="keyword">let</span> dirPath = <span class="string">"/sdcard/脚本"</span>;</span><br><span class="line"><span class="keyword">let</span> filePathList = getFilePathList(dirPath);</span><br><span class="line">log(filePathList);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFilePathList</span>(<span class="params">dirPath, filePathList</span>) </span>{</span><br><span class="line">  filePathList = filePathList || [];</span><br><span class="line">  <span class="keyword">var</span> fileNameList = files.listDir(dirPath);</span><br><span class="line">  <span class="keyword">var</span> len = fileNameList.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">    <span class="keyword">let</span> filepath = files.join(dirPath, fileNameList[i]);</span><br><span class="line">    <span class="keyword">if</span> (files.isFile(filepath)) {</span><br><span class="line">      filePathList.push(filepath);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 文件夹, 继续向下递  </span></span><br><span class="line">      getFilePathList(filepath, filePathList);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 文件遍历完成, 终止条件, 返回结果</span></span><br><span class="line">  <span class="keyword">return</span> filePathList;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置默认参数</span></span><br><span class="line"><span class="keyword">var</span> n= n || <span class="number">8</span></span><br></pre></td></tr></tbody></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> anonymous = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有名函数表达式(在一个非函数块里声明一个函数)</span></span><br><span class="line"><span class="keyword">if</span> (currentUser) {</span><br><span class="line">  <span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Yup.'</span>);</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自执行匿名函数 </span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet. Please follow me.'</span>);</span><br><span class="line">})();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数(使用函数表达式（传递匿名函数）时)</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> y = x + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> x * y</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>相比于其他面向对象语言，JavaScript对象的构造函数比较特殊，它可以是任何一个普通的函数，而且无需在对象中定义。只有两个约定：<br>构造函数的命名通常以大写开头；<br>构造函数只能由new操作符执行；</p><p>当使用new调用一个函数时，这个函数就会变成构造函数<br>使用new调用函数后，函数是有返回值的，即使在定义函数时没有return语句。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>)</span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = name;}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaoming = <span class="keyword">new</span> People(<span class="string">'xiaoming'</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单独运行一个匿名函数，由于不符合语法要求，报错啦！解决方法只需要给匿名函数包裹一个括号即可：</span></span><br><span class="line"><span class="comment">//匿名函数在其它应用场景括号可以省略</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>{</span><br><span class="line">    <span class="comment">//由于没有执行该匿名函数，所以不会执行匿名函数体内的语句。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"张培跃"</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>如果需要执行匿名函数，在匿名函数后面加上一个括号即可立即执行！</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"张培跃"</span>);</span><br><span class="line">})()</span><br></pre></td></tr></tbody></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.经典格式： 函数名 = ( 参数 ) =&gt; { 方法体 } </span></span><br><span class="line"><span class="keyword">const</span> sum3 = <span class="function">(<span class="params">x,y</span>)=&gt;</span>{ </span><br><span class="line">  <span class="keyword">return</span> x+y; </span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(sum3) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.当方法体只有一行时，花括号可以省略： </span></span><br><span class="line"><span class="keyword">const</span> sum4 = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y;  </span><br><span class="line"><span class="built_in">console</span>.log(sum4) </span><br><span class="line"> </span><br><span class="line"><span class="comment">//当只有一个参数时，括号可以省略： </span></span><br><span class="line"><span class="keyword">const</span> sum4 = <span class="function"><span class="params">x</span> =&gt;</span> x+<span class="number">1</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(sum4) </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。<br>stringObject.split(separator,howmany) 方法用于把一个字符串分割成字符串数组。<br>    separator    必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>1.== 双等号 返回值只有true 和false 类型为布尔型，只比较左右的值，若相等则返回true，反之false<br>2.=== 全等号 返回值为true或false 若左右两边的值和类型均相等，则返回true，反之false<br>3.!= 不相等号 返回值为true或false 不比较类型，只比较值，若左边不等于右边则返回true，反正false</p><p>●  使用 === 和 !== 而非 == 和 !=，eslint: eqeqeq<br>●  条件声明例如 if 会用 ToBoolean 这个抽象方法将表达式转成布尔值并遵循如下规则<br>    Objects 等于 true<br>    Undefined 等于 false<br>    Null 等于 false<br>    Booleans 等于 布尔值<br>    Numbers 在 +0, -0, 或者 NaN 的情况下等于 false, 其他情况是 true<br>    Strings 为 ‘’ 时等于 false, 否则是 true  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果等于 ==</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>==<span class="number">1</span>){toastLog(<span class="string">"正确"</span>)};</span><br><span class="line"><span class="comment">//如果 不等于 !=</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> != <span class="number">2</span>){toastLog(<span class="string">"正确"</span>)};</span><br><span class="line"><span class="comment">//如果 大于小于 &gt; &lt; 不举例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=<span class="literal">true</span>;b=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//如果真判断简写 正常写 if(a == true){ }</span></span><br><span class="line"><span class="keyword">if</span>(a){toastLog(<span class="string">"a=真"</span>)}</span><br><span class="line"><span class="comment">//如果假判断简写 正常写 if(b == false){ }</span></span><br><span class="line"><span class="keyword">if</span>(!b){toastLog(<span class="string">"b=假"</span>)}</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;&amp; = 并且</span></span><br><span class="line"><span class="keyword">if</span>( a==<span class="literal">true</span> &amp;&amp; b==<span class="literal">false</span> ){</span><br><span class="line">toastLog(<span class="string">"a为真-b为假"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// || = 或者</span></span><br><span class="line"><span class="keyword">if</span>( a==<span class="literal">false</span> || b==<span class="literal">false</span> ){</span><br><span class="line">toastLog(<span class="string">"a或者b其中为假"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="多重判断"><a href="#多重判断" class="headerlink" title="多重判断"></a>多重判断</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(){</span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(){</span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(){</span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span>()</span><br></pre></td></tr></tbody></table></figure><p><strong>Switch 语句</strong><br>计算一次 switch 表达式<br>把表达式的值与每个 case 的值进行对比<br>如果存在匹配，则执行关联代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(表达式) {</span><br><span class="line">     <span class="keyword">case</span> n:</span><br><span class="line">        代码块</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> n:</span><br><span class="line">        代码块</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">        默认代码块</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)</span><br><span class="line">{</span><br><span class="line">    当条件 <span class="number">1</span> 为 <span class="literal">true</span> 时执行的代码</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition2)</span><br><span class="line">{</span><br><span class="line">    当条件 <span class="number">2</span> 为 <span class="literal">true</span> 时执行的代码</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">  当条件 <span class="number">1</span> 和 条件 <span class="number">2</span> 都不为 <span class="literal">true</span> 时执行的代码</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p><strong>for语句</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句 <span class="number">1</span>; 语句 <span class="number">2</span>; 语句 <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">    被执行的代码块</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>for/in - 循环遍历对象的属性</p><p><strong>while</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件)</span><br><span class="line">{</span><br><span class="line">    需要执行的代码</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>do/while</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">    需要执行的代码</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (条件);</span><br></pre></td></tr></tbody></table></figure><h2 id="js正则"><a href="#js正则" class="headerlink" title="js正则"></a>js正则</h2><p>autojspro不支持正则前向断言</p><h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><h3 id="CJS模块管理"><a href="#CJS模块管理" class="headerlink" title="CJS模块管理"></a>CJS模块管理</h3><p><strong>模块化</strong>主要是用于管理代码，解决解耦与复用问题<br>命名冲突，全局污染<br>模块内部逻辑的封装性隔离<br>模块之间的通讯（依赖引用、循环引用、引用顺序）</p><p>CJSCommonJS，主要用于服务器端如node.js，主要使用如下：</p><p><strong>CommonJS规范缺点</strong><br>CommonJS加载模块是同步的：同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行。<br>这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在模块文件中导出</span></span><br><span class="line"><span class="keyword">const</span> object = {</span><br><span class="line">    <span class="attr">HaoranOcrClick</span>: HaoranOcrClick,</span><br><span class="line">    <span class="attr">BdOcrClick</span>: BdOcrClick,</span><br><span class="line">};</span><br><span class="line"><span class="built_in">module</span>.exports = object;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在使用文件引入</span></span><br><span class="line"><span class="keyword">const</span> ocr = <span class="built_in">require</span>(<span class="string">"/sdcard/脚本/模块/ocr模块.js"</span>);</span><br><span class="line"><span class="comment">// "/storage/emulated/0/"</span></span><br><span class="line">ocr.HaoranOcrClick(<span class="string">''</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h3><p>ESM是ESModule，是ECMAScript自己的模块体系，于ES6引入，基本上可以完全取代CJS和AMD。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出：export命令</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = {<span class="attr">name</span>: <span class="string">'E1e'</span>}；</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 默认导出 export default命令</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {<span class="attr">name</span>: <span class="string">'E1e'</span>};</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 引入接口：import命令</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 引入普通导出</span></span><br><span class="line"><span class="keyword">import</span> { obj } <span class="keyword">from</span> <span class="string">'./test.js'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 引入默认导出</span></span><br><span class="line"><span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">'./test.js'</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><h3 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h3><p>initXX：初始化相关方法，使用 init 为前缀标识，如初始化布局 initView<br>isXX：方法返回值为 boolean 型的请使用 is 或 check 为前缀标识<br>getXX：返回某个值的方法，使用 get 为前缀标识，例如 getName<br>setXX：设置某个属性值，使用 set 为前缀标识，例如 setName<br>handleXX/processXX：对数据进行处理的方法，例如 handleMessage<br>displayXX/showXX：弹出提示框和提示信息，例如 showDialog<br>updateXX：更新某个东西，例如 updateData<br>saveXX：保存某个东西，例如 saveData<br>resetXX：重置某个东西，例如 resetData<br>clearXX：清除某个东西，例如 clearData<br>removeXX：移除数据或者视图等，例如 removeView<br>drawXX：绘制数据或效果相关的，使用 draw 前缀标识，例如 drawText</p><h3 id="避免单个字符名，让你的变量名有描述意义。"><a href="#避免单个字符名，让你的变量名有描述意义。" class="headerlink" title="避免单个字符名，让你的变量名有描述意义。"></a>避免单个字符名，让你的变量名有描述意义。</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">q</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">// ..stuff..</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="当命名对象、函数和实例时使用驼峰命名规则"><a href="#当命名对象、函数和实例时使用驼峰命名规则" class="headerlink" title="当命名对象、函数和实例时使用驼峰命名规则"></a>当命名对象、函数和实例时使用驼峰命名规则</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> OBJEcttsssss = {};</span><br><span class="line"><span class="keyword">var</span> this_is_my_object = {};</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">this</span>-is-my-object = {};</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>{};</span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> user({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'Bob Parr'</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> thisIsMyObject = {};</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisIsMyFunction</span>(<span class="params"></span>) </span>{};</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User({</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'Bob Parr'</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h1 id="浏览器中运行js"><a href="#浏览器中运行js" class="headerlink" title="浏览器中运行js"></a>浏览器中运行js</h1><p>Chrome浏览器运行环境包括V8引擎，内置API<br>  V8引擎负责解析和执行js代码<br>  内置API是由运行环境提供的特殊接口</p><h1 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h1><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。电脑安装了Node.js后， Node.js 相当于浏览器，也可以在里面运行 JavaScript 了！</p><h2 id="Nodejs的组成："><a href="#Nodejs的组成：" class="headerlink" title="Nodejs的组成："></a>Nodejs的组成：</h2><p>ECMAScript(语言基础，如：语法、数据类型结构以及一些内置对象)</p><p>os(操作系统)</p><p>file(文件系统)</p><p>net(网络系统)</p><p>database(数据库)</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://nodejs.org/en/">Node.js下载地址</a></p><p>打开cmd输入命令检查是否安装成功：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v  #查看node版本</span><br><span class="line">npm -v   #查看npm版本</span><br></pre></td></tr></tbody></table></figure><p>Node.js 安装成功时也默认安装了 npm， npm 是随 Node.js 一起被安装的包管理工具，你可以理解成 Node.js 自带的应用商店。是用来安装/卸载Node.js需要装的东西</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>1.修改全局模块路径和缓存路径<br>当我们在执行<code>npm install express -g</code>命令时，会默认下载到c盘，更改下载盘<br>在nodejs安装目录下创建创建两个文件夹，名称分别为：node_global(全局模块)和node_cache(缓存)，在node_global文件夹下再建一个node_modules文件夹，配置环境变量用</p><p>2.win+R打开运行窗口，输入cmd，再输入以下两条指令<br>npm config set prefix “创建的node_global文件夹所在路径”<br>npm config set cache “创建的node_cache文件夹所在路径”</p><p>3.修改完毕后，再配置环境变量<br>右键此电脑——&gt;高级系统设置——&gt;环境变量<br>在系统变量中，新建，变量名：NODE_PATH<br>变量值：node_global文件夹下的node_modules文件夹。如：E:\develop\nodejs\node_global\node_modules</p><p>修改用户变量中的Path变量，将默认的npm路径修改为新建的node_global路径<br>如：D:\ruanjian\nodejs\node_global</p><h2 id="nodejs执行js代码"><a href="#nodejs执行js代码" class="headerlink" title="nodejs执行js代码"></a>nodejs执行js代码</h2><h3 id="命令行运行nodejs文件"><a href="#命令行运行nodejs文件" class="headerlink" title="命令行运行nodejs文件"></a>命令行运行nodejs文件</h3><p>打开命令行窗口，把当前目录切换到.js所在目录  </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node 文件名.js</span><br></pre></td></tr></tbody></table></figure><h3 id="vscode搭建node开发环境"><a href="#vscode搭建node开发环境" class="headerlink" title="vscode搭建node开发环境"></a>vscode搭建node开发环境</h3><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p><a href="https://yafine-blog.cn/posts/8094.html">参考</a><br>npm (node package manager) 是 JavaScript 世界的包管理工具，是 Node.js 平台的默认包管理工具，简单地说，就是通过 npm 下载模块，复用已有的代码，提高工作效率。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>npm 由三个独立的部分组成：</p><ul><li>网站</li><li>注册表（registry）</li><li>命令行工具 (CLI)</li></ul><p><a href="https://www.npmjs.com/">网站</a> 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。</p><p>注册表 是一个巨大的数据库，保存了每个包（package）的信息。</p><p>CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。<br> <a href="https://www.axihe.com/api/npm/api/api.html">npm中文文档</a> </p><h3 id="切换为-taobao-镜像源"><a href="#切换为-taobao-镜像源" class="headerlink" title="切换为 taobao 镜像源"></a>切换为 taobao 镜像源</h3><p>国内使用 npm 可能很慢。你可以考虑切换为 taobao 镜像源。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></tbody></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">npm uninstall</span><br><span class="line"><span class="comment"># 清理缓存</span></span><br><span class="line">npm cache clean -f</span><br></pre></td></tr></tbody></table></figure><h2 id="cnpm-是什么？"><a href="#cnpm-是什么？" class="headerlink" title="cnpm 是什么？"></a>cnpm 是什么？</h2><p>简单的讲就是中国版的 NPM，因为 npm 安装插件是从国外服务器下载，受网络影响大，可能出现异常，<br>需要安装 cnpm 模块，命令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></tbody></table></figure><p>cnpm 支持可以使用支持 npm 除 publish 之外的所有命令。</p><p>因为 cnpm 的仓库只是 npm 仓库的一个拷贝，它不承担 publish 工作，所以执行 cnpm publish 命令会失败的。</p><h2 id="yarn-是什么？"><a href="#yarn-是什么？" class="headerlink" title="yarn 是什么？"></a>yarn 是什么？</h2><p>Yarn 是一个软件包管理器，还可以作为项目管理工具，你可以通过它使用全世界开发者的代码， 或者分享自己的代码。</p><p>从 npm 安装软件包并保持相同的包管理流程。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1.速度超快。<br>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。</p><p>2.超级安全<br>在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。</p><p>3.超级可靠<br>使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。<br>通过命令安装</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></tbody></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>yarn init：初始化项目，会在根目录下生成一个 package.json，与 npm 类似具体不做解释</p><p>yarn add <package name="">：安装依赖包，会自动安装最新版本，会覆盖指定版本号</package></p><p>yarn add <package name1=""> <package name1="">：一次性添加多个包</package></package></p><p>yarn add <package name="">@version：添加指定版本的包</package></p><p>yarn upgrade <package name="">@version：将包更新到指定版本</package></p><p>yarn upgrade –latest <package name="">：将包更新到最新版本</package></p><p>yarn remove <package name="">：删除包</package></p><p>yarn remove <package name1=""> <package name2="">：一次性删除多个包</package></package></p><p>yarn info <packagename> ：可以用来查看某个模块的最新版本信息</packagename></p><p>yarn install：安装 package.json 里所有包，并将包及它的所有依赖项保存进 yarn.lock</p><p>yarn install –force ：强制重新下载所有包</p><p>yarn install –flat：安装一个包的单一版本</p><p>yarn install –production：只安装 dependencies 里的包</p><p>yarn install –no-lockfile：不读取或生成 yarn.lock</p><p>yarn install –pure-lockfile：不生成 yarn.lock</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>安装npm模块时，没有权限<br>解决方法：打开nodejs安装目录的属性把权限全部勾上 </p><p>npm的包安装分为本地安装（local）、全局安装（global）两种<br> 本地安装: npm install xxx 安装到命令行所在目录的node_module目录。<br> 全局安装: npm install xxx -g 安装到 \AppData\Roaming\npm\node_modules目录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js&quot;&gt;&lt;a href=&quot;#js&quot; class=&quot;headerlink&quot; title=&quot;js&quot;&gt;&lt;/a&gt;js&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/yashujs/bfug6u/ntxhzu#cc4dd1da&quot;&gt;https:/</summary>
      
    
    
    
    <category term="前端" scheme="https://wenkex.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://wenkex.gitee.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>计算机原理</title>
    <link href="https://wenkex.gitee.io/2022/051717870.html"/>
    <id>https://wenkex.gitee.io/2022/051717870.html</id>
    <published>2022-05-17T03:07:09.000Z</published>
    <updated>2022-05-17T03:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><h2 id="二进制、八进制和十六进制向十进制转换"><a href="#二进制、八进制和十六进制向十进制转换" class="headerlink" title="二进制、八进制和十六进制向十进制转换"></a>二进制、八进制和十六进制向十进制转换</h2><p>按权相加<br>将八进制数字 53627 转换成十进制：<br>53627 = 5×84 + 3×83 + 6×82 + 2×81 + 7×80 = 22423（十进制）<br>从右往左看，第1位的位权为 80=1，第2位的位权为 81=8，第3位的位权为 82=64，第4位的位权为 83=512，第5位的位权为 84=4096 …… 第n位的位权就为 8n-1。将各个位的数字乘以位权，然后再相加，就得到了十进制形式。</p><p>注意，这里我们需要以十进制形式来表示位权。</p><h2 id="十进制转二进制、八进制和十六进制"><a href="#十进制转二进制、八进制和十六进制" class="headerlink" title="十进制转二进制、八进制和十六进制"></a>十进制转二进制、八进制和十六进制</h2><p><a href="https://blog.csdn.net/final__static/article/details/89405945">https://blog.csdn.net/final__static/article/details/89405945</a><br>方法为：十进制数除2取余法，即十进制数除2，余数为权位上的数，得到的商值继续除，直到商为0为止。<br>余数从下往上开始读即为所求进制数</p><p>注意16进制A<del>F表示10</del>15</p><h1 id="路径相关"><a href="#路径相关" class="headerlink" title="路径相关"></a>路径相关</h1><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。</p><p>一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实，</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。</p><h1 id="图像相关"><a href="#图像相关" class="headerlink" title="图像相关"></a>图像相关</h1><p>我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。</p><table><thead><tr><th align="center">名称</th><th align="center">RGBA值</th><th align="center">名称</th><th align="center">RGBA值</th></tr></thead><tbody><tr><td align="center">White</td><td align="center">(255, 255, 255, 255)</td><td align="center">Red</td><td align="center">(255, 0, 0, 255)</td></tr><tr><td align="center">Green</td><td align="center">(0, 255, 0, 255)</td><td align="center">Blue</td><td align="center">(0, 0, 255, 255)</td></tr><tr><td align="center">Gray</td><td align="center">(128, 128, 128, 255)</td><td align="center">Yellow</td><td align="center">(255, 255, 0, 255)</td></tr><tr><td align="center">Black</td><td align="center">(0, 0, 0, 255)</td><td align="center">Purple</td><td align="center">(128, 0, 128, 255)</td></tr></tbody></table><ol start="2"><li>像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进制&quot;&gt;&lt;a href=&quot;#进制&quot; class=&quot;headerlink&quot; title=&quot;进制&quot;&gt;&lt;/a&gt;进制&lt;/h1&gt;&lt;h2 id=&quot;二进制、八进制和十六进制向十进制转换&quot;&gt;&lt;a href=&quot;#二进制、八进制和十六进制向十进制转换&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="学习" scheme="https://wenkex.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="知识" scheme="https://wenkex.gitee.io/tags/%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习</title>
    <link href="https://wenkex.gitee.io/2022/050513105.html"/>
    <id>https://wenkex.gitee.io/2022/050513105.html</id>
    <published>2022-05-05T00:53:39.000Z</published>
    <updated>2022-05-05T00:53:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><a href="https://deerchao.net/tutorials/regex/regex.htm">《正则表达式30分钟入门教程》</a></p><p>正则表达式是一种工具<br>验证字符串是否与指定模式匹配(例如，字符串具有电子邮件地址的格式)<br>在字符串中执行替换(例如，将所有美国拼写更改为英国拼写)。</p><p>学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改，</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.匹配除换行符 (\n)以外的任意字符</span><br><span class="line">\w匹配字母或数字或下划线或汉字</span><br><span class="line"></span><br><span class="line">\b匹配单词的开始或结束，只匹配一个位置。</span><br><span class="line"></span><br><span class="line">"/" 是表达式开始和结束的标记</span><br><span class="line"></span><br><span class="line">^ 脱字符表示字符串的开始</span><br><span class="line">$表示字符串的结束</span><br><span class="line">\w匹配字母/数字/下划线</span><br><span class="line">\W匹配非字母/非数字/非下划线</span><br><span class="line">[]匹配来自括号内字符集的任意单一字符</span><br><span class="line">[^]匹配不在字符集中的任意单一字符，^在[]表示取反</span><br><span class="line">\d匹配数字</span><br><span class="line">\s匹配空白字符（包括\r、\n、\t等）</span><br></pre></td></tr></tbody></table></figure><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*重复零次或更多次</span><br><span class="line">+重复一次或更多次</span><br><span class="line">?重复零次或一次</span><br><span class="line">{n}重复n次</span><br><span class="line">{n,}重复n次或更多次</span><br><span class="line">{n,m}重复n到m次</span><br></pre></td></tr></tbody></table></figure><p>当?    字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串<br>而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</p><blockquote><p><strong>说明：</strong> 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则<strong>圆括号被视为正则表达式中的分组。</strong></p></blockquote><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><strong>从高到底</strong><br>\    转义符<br>(), (?:), (?=), []    圆括号和方括号<br>*, +, ?, {n}, {n,}, {n,m}    限定符<br>^, $, \任何元字符、任何字符    定位点和序列（即：位置和顺序）<br>|    替换，”或”操作字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>从浏览器拷贝出来请求头后， 需要手动的一个个加引号和逗号。现在我们利用Pycharm来进行批量替换。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: read_mode=day; default_font=font2; locale=zh-CN; remember_user_token=W1231sxMzYwNzkwMF0sIiQyYSQxMSRnNVl5MWpmZ0JINXJVazFreXlzQ0V1IiwiMTU0MDI1NTAzNS4xMDE5NDAyIl0%3D--10326e210f857747d9a7c9ace127cab6cdf8d947e; Hm_lvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1540276756,1540284104,1540301802,1540371744; _m7e_session=dbf3985c991afa4c90bb79228626ed6e; Hm_lpvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1540453366; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221663393b621590-01c145ebcced4d-8383268-2073600-1663393b62272c%22%2C%22%24device_id%22%3A%221663393b621590-01c145ebcced4d-8383268-2073600-1663393b62272c%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E8%87%AA%E7%84%B6%E6%90%9C%E7%B4%A2%E6%B5%81%E9%87%8F%22%2C%22%24latest_referrer%22%3A%22https%3A%2F%2Fwww.baidu.com%2Flink%22%2C%22%24latest_referrer_host%22%3A%22www.baidu.com%22%2C%22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC%22%2C%22%24latest_utm_source%22%3A%22desktop%22%2C%22%24latest_utm_medium%22%3A%22not-signed-in-like-button%22%2C%22%24latest_utm_campaign%22%3A%22maleskine%22%2C%22%24latest_utm_content%22%3A%22note%22%7D%2C%22first_id%22%3A%22%22%7D</span><br><span class="line">Host: www.jianshu.com</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Referer: https://www.jianshu.com/c/068668542235</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">勾选Regex使用正则来对数据进行匹配批量修改</span><br><span class="line">//利用冒号做分割</span><br><span class="line">正则表达式：(.*?): ?(.*)</span><br><span class="line">//给冒号两边的数据都加上单引号， 并且在末尾增加逗号</span><br><span class="line">//$1表示第一组</span><br><span class="line">需要替换成：'$1':'$2',    </span><br></pre></td></tr></tbody></table></figure><h1 id="js的正则"><a href="#js的正则" class="headerlink" title="js的正则"></a>js的正则</h1><p>exec    一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。</p><p>matchAll    一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。</p><p>search    一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。</p><p>replace    一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。</p><p>split    一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。</p><h2 id="match-方法"><a href="#match-方法" class="headerlink" title="match()方法"></a>match()方法</h2><p>stringObj.match(regExp)<br>一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。<br>    stringObj是必选项，对其进行查找的string对象或字符串文字；<br>    regExp是必选项，为包含正则表达式模式和可用标志的正则表达式对象。</p><h2 id="test-方法"><a href="#test-方法" class="headerlink" title="test()方法"></a>test()方法</h2><p>一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。<br>RegExpObject.test(string)<br>    string是必需。要检测的字符串。</p><h1 id="python的re正则模块"><a href="#python的re正则模块" class="headerlink" title="python的re正则模块"></a>python的re正则模块</h1><p>Python提供了re模块来支持正则表达式相关操作</p><h2 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h2><p>pattern : 一个字符串形式的正则表达式 </p><p>string : 要匹配的内容</p><p>flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：<br>  re.I 忽略大小写<br>  re.L 表示特殊字符集 w, W, 方形, B, s, S 依赖于当前环境<br>  re.M 多行模式<br>  re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）<br>  re.U 表示特殊字符集 w, W,方形, B, d, D, s, S 依赖于 Unicode 字符属性数据库<br>  re.X 为了增加可读性，忽略空格和 # 后面的注释<br>如果需要为flags参数指定多个值，可以使用<a href="http://www.runoob.com/python/python-operators.html#ysf5">按位或运算符</a>进行叠加，如<code>flags=re.I | re.M</code>。</p><h2 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile()"></a>re.compile()</h2><p>re.compile(pattern, flags=0)<br>将正则表达式转化为对象。需要和findall(), search(), match(）搭配使用</p><p>re.search(pattern, string)的调用方式就转换为 pattern.search(string)的调用方式，多次调用一个正则表达式就重复利用这个正则对象，可以实现更有效率的匹配   </p><h2 id="返回Match-object"><a href="#返回Match-object" class="headerlink" title="返回Match object"></a>返回Match object</h2><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search()"></a>re.search()</h3><p>search(pattern, string, flags=0)<br>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象(Match object) 否则返回None<br>    pattern: 匹配的规则,<br>    string : 要匹配的内容<br>    flags : 可选，表示匹配模式，</p><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match()"></a>re.match()</h3><p>必须从字符串开头匹配,如果不是起始位置匹配成功的话，match()就返回none<br>    match函数的第一个参数是正则表达式字符串或正则表达式对象<br>    第二个参数是要跟正则表达式做匹配的字符串对象   </p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户名必须由字母、数字或下划线构成且长度在6~20个字符之间</span></span><br><span class="line">m1 = re.match(<span class="string">r'^[0-9a-zA-Z_]{6,20}$'</span>, username)</span><br><span class="line"><span class="comment"># QQ号是5~12的数字且首位不能为0</span></span><br><span class="line">m2 = re.match(<span class="string">r'^[1-9]\d{4,11}$'</span>, qq)</span><br><span class="line">```   </span><br><span class="line">&gt; **提示：** 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\\\，例如表示数字的\\d得书写成\\\\d，这样不仅写起来不方便，阅读的时候也会很吃力。</span><br><span class="line"></span><br><span class="line"><span class="comment">### re.fullmatch()  </span></span><br><span class="line">re.fullmatch(pattern, string, flags=<span class="number">0</span>)        </span><br><span class="line"> match函数的完全匹配（从字符串开头到结尾）版本   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### .group()</span></span><br><span class="line">```py</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">"abc123def"</span></span><br><span class="line">rex_compile = re.<span class="built_in">compile</span>(<span class="string">"([a-z]*)([0-9]*)([a-z]*)"</span>)</span><br><span class="line">rex = rex_compile.search(content)</span><br><span class="line"><span class="built_in">print</span>(rex.group(<span class="number">0</span>))  <span class="comment"># group()和group(0) 一样匹配的是整体</span></span><br><span class="line"><span class="built_in">print</span>(rex.group(<span class="number">1</span>))  <span class="comment"># 匹配第一个小括号的内容  abc</span></span><br><span class="line"><span class="built_in">print</span>(rex.group(<span class="number">2</span>))  <span class="comment"># 匹配第二个小括号的内容   123</span></span><br></pre></td></tr></tbody></table></figure><h2 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h2><p>findall(pattern, string, flags=0)<br>查找字符串所有与正则表达式匹配的模式 返回字符串的列表  </p><h2 id="finditer-pattern-string-flags-0"><a href="#finditer-pattern-string-flags-0" class="headerlink" title="finditer(pattern, string, flags=0)"></a>finditer(pattern, string, flags=0)</h2><p>函数re.finditer与re.findall做同样的事情，只是它返回一个迭代器，而不是列表。<br>查找字符串所有与正则表达式匹配的模式 返回一个迭代器    </p><h2 id="split-pattern-string-maxsplit-0-flags-0"><a href="#split-pattern-string-maxsplit-0-flags-0" class="headerlink" title="split(pattern, string, maxsplit=0, flags=0)"></a>split(pattern, string, maxsplit=0, flags=0)</h2><p>用正则表达式指定的模式分隔符拆分字符串 返回列表        </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拆分长字符串</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    poem = <span class="string">'窗前明月光，疑是地上霜。举头望明月，低头思故乡。'</span></span><br><span class="line">    sentence_list = re.split(<span class="string">r'[，。, .]'</span>, poem)</span><br><span class="line">    <span class="built_in">print</span>(sentence_list)</span><br><span class="line">        <span class="comment"># 删除列表中的空字符串</span></span><br><span class="line">    <span class="keyword">while</span> <span class="string">''</span> <span class="keyword">in</span> sentence_list:</span><br><span class="line">        sentence_list.remove(<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>(sentence_list)  <span class="comment"># ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>re.sub(pattern, repl, string, count=0, flags=0)<br>用指定的字符串替换原字符串中与正则表达式匹配的模式 </p><p>  pattern : 正则中的模式字符串。<br>  repl : 替换的字符串，也可为一个函数。<br>  string : 要被查找替换的原始字符串。<br>  count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。<br>  flags : 编译时用的匹配模式，数字形式。</p><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><h3 id="查找字符串中有多少个af"><a href="#查找字符串中有多少个af" class="headerlink" title="查找字符串中有多少个af"></a>查找字符串中有多少个af</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找字符串中有多少个af</span></span><br><span class="line"><span class="keyword">import</span> re </span><br><span class="line">s = <span class="string">"asdfjvjadsffvaadfkfasaffdsasdffadsafafsafdadsfaafd"</span></span><br><span class="line"> </span><br><span class="line">ret = re.findall(<span class="string">r'(af)'</span> , s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ret))</span><br><span class="line">```  </span><br><span class="line"><span class="comment">### 提取国内手机号码。</span></span><br><span class="line">```Python, </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字</span></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r'(?&lt;=\D)1[34578]\d{9}(?=\D)'</span>)</span><br><span class="line">    sentence = <span class="string">'''</span></span><br><span class="line"><span class="string">    重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，</span></span><br><span class="line"><span class="string">    不是15600998765，也不是110或119，是不是13512346789，王大锤的手机号才是15600998765。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'查找所有匹配并保存到一个列表中'</span>)</span><br><span class="line">    mylist = re.findall(pattern, sentence)</span><br><span class="line">    <span class="built_in">print</span>(mylist)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'--------通过迭代器取出匹配对象并获得匹配的内容--------'</span>)</span><br><span class="line">    <span class="keyword">for</span> temp <span class="keyword">in</span> pattern.finditer(sentence):</span><br><span class="line">        <span class="built_in">print</span>(temp.group())</span><br><span class="line">    <span class="comment"># 搜索字符串中第一次出现正则表达式的模式 </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'--------通过search函数指定搜索位置找出所有匹配--------'</span>)</span><br><span class="line">    m = pattern.search(sentence)</span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        <span class="built_in">print</span>(m.group())</span><br><span class="line">        m = pattern.search(sentence, m.end())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>说明：</strong> 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：<code>(?&lt;=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)</code>，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。</p></blockquote><h3 id="替换字符串中的不良内容"><a href="#替换字符串中的不良内容" class="headerlink" title="替换字符串中的不良内容"></a>替换字符串中的不良内容</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    sentence = <span class="string">'你丫是傻叉吗? 我操你大爷的. Fuck you.'</span></span><br><span class="line">    purified = re.sub(<span class="string">'[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔'</span>,</span><br><span class="line">                      <span class="string">'*'</span>, sentence, flags=re.IGNORECASE)</span><br><span class="line">    <span class="built_in">print</span>(purified)  <span class="comment"># 你丫是*吗? 我*你大爷的. * you.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h3 id="按规则拆分长字符串"><a href="#按规则拆分长字符串" class="headerlink" title="按规则拆分长字符串"></a>按规则拆分长字符串</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    poem = <span class="string">'窗前明月光，疑是地上霜。举头望明月，低头思故乡。'</span></span><br><span class="line">    sentence_list = re.split(<span class="string">r'[，。, .]'</span>, poem)</span><br><span class="line">    <span class="built_in">print</span>(sentence_list)</span><br><span class="line">        <span class="comment"># 删除列表中的空字符串</span></span><br><span class="line">    <span class="keyword">while</span> <span class="string">''</span> <span class="keyword">in</span> sentence_list:</span><br><span class="line">        sentence_list.remove(<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>(sentence_list)  <span class="comment"># ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h1 id="正则表达式在线工具"><a href="#正则表达式在线工具" class="headerlink" title="正则表达式在线工具"></a>正则表达式在线工具</h1><p><a href="https://c.runoob.com/front-end/854/">https://c.runoob.com/front-end/854/</a></p><p><a href="https://deerchao.cn/tools/wegester/">https://deerchao.cn/tools/wegester/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://deerchao.net/tutorials/regex/regex.htm&quot;&gt;《</summary>
      
    
    
    
    <category term="工具" scheme="https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="正则" scheme="https://wenkex.gitee.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>数据库-SQLite</title>
    <link href="https://wenkex.gitee.io/2022/042334747.html"/>
    <id>https://wenkex.gitee.io/2022/042334747.html</id>
    <published>2022-04-23T08:35:42.000Z</published>
    <updated>2022-04-23T08:35:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h1><p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。</p><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><h3 id="Insert-语句"><a href="#Insert-语句" class="headerlink" title="Insert 语句"></a>Insert 语句</h3><h3 id="Delete-语句"><a href="#Delete-语句" class="headerlink" title="Delete 语句"></a>Delete 语句</h3><h3 id="Update-语句"><a href="#Update-语句" class="headerlink" title="Update 语句"></a>Update 语句</h3><h3 id="Select-语句"><a href="#Select-语句" class="headerlink" title="Select 语句"></a>Select 语句</h3><h2 id="SQLite-Python接口"><a href="#SQLite-Python接口" class="headerlink" title="SQLite - Python接口"></a>SQLite - Python接口</h2><p>SQLite3 可使用 sqlite3 模块与 Python 进行集成</p><h3 id="connection对象"><a href="#connection对象" class="headerlink" title="connection对象"></a>connection对象</h3><p>sqlite3.connect(database [,timeout ,other optional arguments])<br>返回一个连接对象。<br><strong>connection对象方法</strong><br>close()    关闭数据库连接<br>commit()    提交事务<br>rollback()    回滚数据库事务<br>cursor()    获得cursor游标对象</p><h3 id="cursor游标对象"><a href="#cursor游标对象" class="headerlink" title="cursor游标对象"></a>cursor游标对象</h3><p>connection.cursor([cursorClass])</p><p><strong>游标对象方法</strong><br>cursor.execute(sql [, optional parameters])<br>cursor.executemany(sql, seq_of_parameters)<br>cursor.executescript(sql_script)</p><p>cursor.fetchone()<br>返回结果集的下一行(Row对象)，返回一个序列，无数据时，则返回 None。</p><p>cursor.fetchmany([size=cursor.arraysize])<br>返回结果集的多行(Row对象列表)，返回一个列表。无数据时，则返回一个空的列表。该方法尝试获取由 size 参数指定的尽可能多的行。</p><p>cursor.fetchall()<br>返回结果集中所有（剩余）的行(Row对象列表)，返回一个列表。无数据时，则返回一个空的列表。</p><h3 id="创建表-1"><a href="#创建表-1" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">'test.db'</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"数据库打开成功"</span>)</span><br><span class="line">c = conn.cursor()</span><br><span class="line">c.execute(<span class="string">'''CREATE TABLE COMPANY</span></span><br><span class="line"><span class="string">       (ID INT PRIMARY KEY     NOT NULL,</span></span><br><span class="line"><span class="string">       NAME           TEXT    NOT NULL,</span></span><br><span class="line"><span class="string">       AGE            INT     NOT NULL,</span></span><br><span class="line"><span class="string">       ADDRESS        CHAR(50),</span></span><br><span class="line"><span class="string">       SALARY         REAL);'''</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"数据表创建成功"</span>)</span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></tbody></table></figure><h3 id="数据库的增删改查"><a href="#数据库的增删改查" class="headerlink" title="数据库的增删改查"></a>数据库的增删改查</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line">cursor.execute(<span class="string">'CREATE TABLE [exam] ([question] VARCHAR(80)  NULL,[Answer_A] VARCHAR(1)  NULL,[Answer_B] VARCHAR(1)  NULL,[Answer_C] VARCHAR(1)  NULL,[Answer_D] VARCHAR(1)  NULL,[right_Answer] VARCHAR(1)  NULL)'</span>)</span><br><span class="line"><span class="comment">#插入一条数据</span></span><br><span class="line">cursor.execute(<span class="string">"insert into exam (question, Answer_A,Answer_B,Answer_C,Answer_D,right_Answer) values ('哈雷慧星的平均周期为', '54年', '56年', '73年', '83年', 'C')"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入SQLite驱动:</span></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">path=<span class="string">'test.db'</span></span><br><span class="line">conn = sqlite3.connect(path) <span class="comment"># 建立数据库连接，返回一个连接对象。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"连接<span class="subst">{path}</span>数据库成功"</span>)</span><br><span class="line">cursor = conn.cursor()  <span class="comment">#创建游标对象</span></span><br><span class="line"></span><br><span class="line">cursor.close()  <span class="comment"># 关闭Cursor:</span></span><br><span class="line">conn.commit()   <span class="comment"># 提交事务:</span></span><br><span class="line">conn.close()   <span class="comment"># 关闭Connection:</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQLite&quot;&gt;&lt;a href=&quot;#SQLite&quot; class=&quot;headerlink&quot; title=&quot;SQLite&quot;&gt;&lt;/a&gt;SQLite&lt;/h1&gt;&lt;p&gt;SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个</summary>
      
    
    
    
    <category term="数据库" scheme="https://wenkex.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQLite" scheme="https://wenkex.gitee.io/tags/SQLite/"/>
    
  </entry>
  
  <entry>
    <title>web测试</title>
    <link href="https://wenkex.gitee.io/2022/04205354.html"/>
    <id>https://wenkex.gitee.io/2022/04205354.html</id>
    <published>2022-04-20T01:36:28.000Z</published>
    <updated>2022-04-20T01:36:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>抓包（packet capture）就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进行数据截取等。抓包的目的就是为了获取到想要的原始数据，拿到数据以后，我们就可以做以下一些事情:  </p><ol><li><p>分析数据传输协议。 </p></li><li><p>定位网络协议的问题。 </p></li><li><p>从数据包中获取想要的信息。 </p></li><li><p>将截取到的数据包进行修改，伪造，重发。</p><h2 id="为什么抓包？"><a href="#为什么抓包？" class="headerlink" title="为什么抓包？"></a>为什么抓包？</h2></li><li><p>从功能测试角度，通过抓包查看隐藏字段</p></li></ol><p>Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 CRSF 攻击，防网络爬虫，以及一些其他用途。这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。</p><ol start="2"><li>通过抓包工具了解协议内容，方便开展接口和性能测试</li></ol><p>性能测试方面，性能测试其实就是大量模拟用户的请求，所以我们必须要知道请求中的协议内容和特点，才能更好的模拟用户请求，分析协议就需要用到抓包工具；接口测试方面，在接口测试时，虽然我们尽量要求有完善的接口文档。但很多时候接口文档不可能覆盖所有的情况，或者因为文档滞后，在接口测试过程中，还时需要借助抓包工具来辅助我们进行接口测试。</p><ol start="3"><li>需要通过抓包工具，检查数据加密</li></ol><p>安全测试方面，我们需要检查敏感数据在传输过程中是否加密，也需要借助抓包工具才能检查。</p><ol start="4"><li>处理前后端 bug 归属之争</li></ol><p>在我们提交bug的时候，经常会出现前端（客户端展示）和后端（服务端的逻辑）的争议，那么可以通过抓包工具，确实是数据传递问题还是前端显示的问题。如果抓出来的数据就有问题的话，那么一般是后端的问题；如果抓出来的数据是正确的，那么基本上可以断定是前端显示的问题。</p><ol start="5"><li>通过抓包分析，可以更好的理解整个系统</li></ol><p>经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。</p><h2 id="浏览器抓包"><a href="#浏览器抓包" class="headerlink" title="浏览器抓包"></a>浏览器抓包</h2><p>最简单的抓包工具——浏览器开发者工具</p><h1 id="开放api"><a href="#开放api" class="headerlink" title="开放api"></a>开放api</h1><h2 id="API-Hub"><a href="#API-Hub" class="headerlink" title="API Hub"></a>API Hub</h2><h1 id="接口调试工具"><a href="#接口调试工具" class="headerlink" title="接口调试工具"></a>接口调试工具</h1><h2 id="Apifox"><a href="#Apifox" class="headerlink" title="Apifox"></a>Apifox</h2><p>API 文档、API 调试、API Mock、API 自动化测试</p><p>和市面上的老牌调试工具Postman相比，Apifox毫不逊色——Postman支持的功能它都能支持，并且Apifox还提供了支持可视化断言，连接数据库，调用外部函数与脚本，支持多种语言，环境变量设置等功能，调试起来也很快捷方便。</p><h2 id="postman接口测试"><a href="#postman接口测试" class="headerlink" title="postman接口测试"></a>postman接口测试</h2><p>responseCode ：包含请求的返回的状态信息(如：code)<br>responseBody：为接口请求放回的数据内容（类型为字符串）<br>tests ：为键值对形式，用于表示我们的测试结果是成功与否，最终展示在 Test Results 中。<br>key ：（如：code 200）我们可以用来当做结果的一个描述<br>value：其值为布尔型，ture 表示测试通过， false 表示测试失败。<br>所以上述代码应该不难理解了，而有了返回结果的数据以及表示结果成功与否</p><h2 id="预请求脚本-Pre-request-Script"><a href="#预请求脚本-Pre-request-Script" class="headerlink" title="(预请求脚本)Pre-request Script"></a>(预请求脚本)Pre-request Script</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;抓包&quot;&gt;&lt;a href=&quot;#抓包&quot; class=&quot;headerlink&quot; title=&quot;抓包&quot;&gt;&lt;/a&gt;抓包&lt;/h1&gt;&lt;p&gt;抓包（packet capture）就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进</summary>
      
    
    
    
    <category term="web" scheme="https://wenkex.gitee.io/categories/web/"/>
    
    
    <category term="postman" scheme="https://wenkex.gitee.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>数据库-redis</title>
    <link href="https://wenkex.gitee.io/2022/041918402.html"/>
    <id>https://wenkex.gitee.io/2022/041918402.html</id>
    <published>2022-04-19T01:23:48.000Z</published>
    <updated>2022-04-19T01:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p>Redis 是键值对(Key-Value)存储数据库，并提供多种语言的 API。</p><h1 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h1><h2 id="安装-Redis的docker环境"><a href="#安装-Redis的docker环境" class="headerlink" title="安装 Redis的docker环境"></a>安装 Redis的docker环境</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要确保docker环境已经安装成功</span></span><br><span class="line">docker --version</span><br><span class="line"></span><br><span class="line">docker search redis</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">拉取最新版本</span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d：使用指定的镜像在后台运行容器，（使用守护进程运行）通过 docker ps查看不到的。因为在 docker 中，后台服务必须要有一个前台服务才能运行（前台服务即使用 -it 选项启动的服务）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -it 表示已交互模式运行容器,为容器重新分配一个伪输入终端</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 6379:6379 将容器的6379端口映射到主机的6379端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --name=<span class="string">"myredis"</span> 表示自定义容器名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --requirepass <span class="string">"root"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v /docker/redis/data:/data: 将主机中当前目录下的data挂载到容器的/data</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-server : 在容器执行redis-server启动命令，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --appendonly yes  打开redis持久化配置</span></span><br><span class="line">docker run -d redis:latest -p 6379:6379  redis-server --appendonly yes --name="myredis" --requirepass "root"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker start 容器名或容器id</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入redis容器并启动一个redis交互式会话</span></span><br><span class="line">docker exec -it redis容器名 /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在redis交互式会话中连接 redis 服务</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理容器(停止 docker-redis 容器并删除)：</span></span><br><span class="line"></span><br><span class="line">docker stop redis容器名</span><br><span class="line">docker rm redis容器名</span><br></pre></td></tr></tbody></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis-cli  #在redis交互式会话中连接 redis 服务</span><br><span class="line"></span><br><span class="line">config get requirepass  #查看现有的redis密码</span><br><span class="line"></span><br><span class="line">config set requirepass pass_123456 #设置redis密码</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis&quot;&gt;&lt;a href=&quot;#redis&quot; class=&quot;headerlink&quot; title=&quot;redis&quot;&gt;&lt;/a&gt;redis&lt;/h1&gt;&lt;p&gt;Redis 是键值对(Key-Value)存储数据库，并提供多种语言的 API。&lt;/p&gt;
&lt;h1 id=&quot;安装-Re</summary>
      
    
    
    
    <category term="数据库" scheme="https://wenkex.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="redis" scheme="https://wenkex.gitee.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>springboot学习</title>
    <link href="https://wenkex.gitee.io/2022/040423525.html"/>
    <id>https://wenkex.gitee.io/2022/040423525.html</id>
    <published>2022-04-04T10:57:26.000Z</published>
    <updated>2022-04-04T10:57:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习框架首先要先了解它是干什么的，然后了解它的项目结构即每个文件有什么用</p><h1 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h1><p>springboot是一个用来简化spring应用的初始搭建以及开发过程的框架<br>简化依赖配置，简化常用工程相关配置，内置服务器</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>1.通过idea创建，可以更改成阿里云镜像服务：<a href="https://start.aliyun.com/">https://start.aliyun.com</a><br>spring默认服务器：<a href="https://start.spring.io/">https://start.spring.io</a></p><p>2.若idea不能联网，通过spring boot官网创建</p><h2 id="Druid连接池"><a href="#Druid连接池" class="headerlink" title="Druid连接池"></a>Druid连接池</h2><h3 id="数据源与数据库连接池"><a href="#数据源与数据库连接池" class="headerlink" title="数据源与数据库连接池"></a>数据源与数据库连接池</h3><h4 id="什么是数据源？"><a href="#什么是数据源？" class="headerlink" title="什么是数据源？"></a>什么是数据源？</h4><p>JDBC2.0提供了javax.sql.DataSource接口，它负责建立与数据库的连接，当在应用程序中访问数据库时，不必编写连接数据库的代码，直接引用DataSource获取数据库的连接对象即可。用于获取操作数据的Connection对象。</p><h4 id="什么是数据库连接池？"><a href="#什么是数据库连接池？" class="headerlink" title="什么是数据库连接池？"></a>什么是数据库连接池？</h4><p>数据库连接池的思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。可通过设定连接池的最大连接数来防止系统无尽的与数据库连接。更重要的是我们可以通过连接池的管理机制监视数据库的连接的数量、使用情况，为系统开发、测试以及性能调整提供依据。</p><h4 id="数据源和数据库连接池的关系？"><a href="#数据源和数据库连接池的关系？" class="headerlink" title="数据源和数据库连接池的关系？"></a>数据源和数据库连接池的关系？</h4><p>数据源建立多个数据库连接，这些数据库连接将会保存在数据库连接池中，当需要访问数据库时，只需要从数据库连接池中获取空闲的数据库连接，当程序访问数据库结束时，数据库连接会放回数据库连接池中。</p><h4 id="为什么要使用数据库连接池？"><a href="#为什么要使用数据库连接池？" class="headerlink" title="为什么要使用数据库连接池？"></a>为什么要使用数据库连接池？</h4><p>传统的JDBC访问数据库技术，每次访问数据库都需要通过数据库驱动器Driver和数据库名称以及密码等等资源建立数据库连接。</p><p>如此就会存在两大问题：</p><p>频繁的建立与断开数据库连接，会降低执行效率，增加系统资源的开销。<br>数据库的连接需要用户名和密码等资源，这些也需要一定的内存和CPU的开销。<br>而数据库连接池很好地解决了这些问题。</p><h3 id="加载依赖"><a href="#加载依赖" class="headerlink" title="加载依赖"></a>加载依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--log4j--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h2><p>数据库框架：Mybatis Plus &gt; Mybatis<br>代码生成器：Mybatis Plus Generator &gt; Mybatis Generator</p><p>Mybatis Plus 针对单表的基本CRUD操作，只需要创建好实体类，并创建一个继承自BaseMapper的接口即可，可谓非常简洁。并且，我们注意到，User类中的managerId，createTime属性，自动和数据库表中的manager_id，create_time对应了起来，这是因为mp自动做了数据库下划线命名，到Java类的驼峰命名之间的转化。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1.导入依赖<br>2.配置application.yml<br>3.在数据库中创建表<br>4.在entity层根据数据库表创建相应实体类<br>5.在dao层创建对应mapper接口<br>6.在SpringBoot启动类上配置mapper接口的扫描路径<br>7.编写一个SpringBoot测试类</p><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml  </span></span><br><span class="line">   <span class="attr">spring:</span>  </span><br><span class="line">     <span class="attr">datasource:</span>  </span><br><span class="line">       <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span>  </span><br><span class="line">       <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/数据库名?serverTimezone=Asia/Shanghai</span>  </span><br><span class="line">       <span class="attr">username:</span> <span class="string">root</span>  </span><br><span class="line">       <span class="attr">password:</span> <span class="string">root</span>  </span><br><span class="line">         </span><br><span class="line">   <span class="attr">mybatis-plus:</span>  </span><br><span class="line">     <span class="attr">configuration:</span>  </span><br><span class="line">       <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="comment">#开启SQL语句打印</span></span><br></pre></td></tr></tbody></table></figure><h3 id="mybatisplus分页工具类-IPage"><a href="#mybatisplus分页工具类-IPage" class="headerlink" title="mybatisplus分页工具类 IPage"></a>mybatisplus分页工具类 IPage</h3><h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><p>最常用的用法就是在实体类中使用它的@Data注解，这样实体类就不用写set、get、toString等方法</p><p>@Data注解包含了 @ToString、@EqualsAndHashCode、@Getter / @Setter和@RequiredArgsConstructor的功能</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a>REST风格</h2><p>REST(Representational State Transfer),表现形式状态转换。它是一种针对网络应用的设计风格</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.隐藏资源的访问行为，无法通过地址得知对资源是何种操作<br>2.书写简化</p><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>根据REST风格对资源进行访问称为RESTful</p><h6 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h6><p>类型：类注解<br>位置：springMVC控制器类定义上方<br>作用：设置当前控制器类为RESTful风格，等同于@Controller + @ResponseBody两个注解组合功能</p><h6 id="请求动作映射"><a href="#请求动作映射" class="headerlink" title="请求动作映射"></a>请求动作映射</h6><p>名称：@GetMapping   @PostMapping  @PutMapping  @DeleteMapping<br>类型：方法注解<br>位置：基于SpringMVC的RESTful开发控制器方法定义上方<br>作用：设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求</p><h6 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h6><p>类型：形参注解<br>位置：springMVC控制器方法形参定义前面<br>作用：绑定路径参数与处理器方法形参间的关系</p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>区别<br>@RequestParam用于接收url地址传参或表单传参<br>@RequestBody用于接收json数据<br>@PathVariable用于接收路径参数，使用{参数名称）描述路径参数</p><p>应用<br>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody,应用较广<br>如果发送非json格式数据，选用@RequestParam接收请求参数<br>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1.设定http请求动作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = "/users",method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(<span class="meta">@ResponseBody</span> User user)</span></span>{</span><br><span class="line">    System.out.println(<span class="string">"user save"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"{'module':'save'}"</span>;</span><br></pre></td></tr></tbody></table></figure><p>2.设定请求参数(路径变量)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径上要有参数占位{id}</span></span><br><span class="line"><span class="meta">@RequestMapping(value = "/users/{id}",method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// 在形参上加@PathVariable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span></span>{</span><br><span class="line">    System.out.println(<span class="string">"user save"</span>+id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"{'module':'delete'}"</span>;</span><br></pre></td></tr></tbody></table></figure><p>controller调用service,service调用dao</p><h2 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h2><p>DAO(Data Access Object) 是数据访问层，也被称为mapper层。<br>即数据持久层，对数据做持久化操作。dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。</p><p>使用mybatis-plus后不用写mapper.xml文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dao/接口名.java</span></span><br><span class="line"><span class="comment">// 定义数据层接口与映射配置，继承BaseMapper&lt;把实体类作为泛型传入&gt;</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;实体类&gt; </span>{       </span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="entity层"><a href="#entity层" class="headerlink" title="entity层"></a>entity层</h2><p>即数据库实体层，也被称为model层，pojo层，domain层存放的是实体类，属性值与数据库中的属性值保持一致。 实现set和get方法。</p><p>一般数据库一张表对应一个实体类，类属性同表字段一一对应</p><p>使用了 Lombok 简化代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entity:</span></span><br><span class="line"><span class="meta">@TableName(value = "user")</span>  <span class="comment">//value指定表名</span></span><br><span class="line"><span class="meta">@Date</span>     <span class="comment">//使用Lombok插件，这样实体类就不用写set、get、toString等方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//value与数据库主键列名一致，若实体类属性名与表主键列名一致可省略value</span></span><br><span class="line">    <span class="meta">@TableId(value = "id", type = IdType.AUTO)</span>  <span class="comment">//指定自增策略</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">     <span class="comment">//若没有开启驼峰命名，或者表中列名不符合驼峰规则，可通过该注解指定数据库表中的列名，exist标明数据表中有没有对应列</span></span><br><span class="line">    <span class="meta">@TableField(value = "last_name",exist = true)</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">  </span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="业务层-service"><a href="#业务层-service" class="headerlink" title="业务层(service)"></a>业务层(service)</h2><p>业务层，service层的作用为完成功能设计。存放业务逻辑处理，不直接对数据库进行操作，有接口和接口实现类(定义一个接口，然后再一个或多个类去实现),提供controller层调用的方法。调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。（也就是说对于项目中的功能的需求就是在这里完成的）</p><h4 id="快速开发方案"><a href="#快速开发方案" class="headerlink" title="快速开发方案"></a>快速开发方案</h4><p>使用MyBatisPlus提供有业务层通用接口(ISerivce<t>)与业务层通用实现类(ServiceImpl&lt;M,T&gt;)<br>在通用类基础上做功能重载或功能追加<br>注意重载时不要覆盖原始操作，避免原始提供的功能丢失</t></p><h4 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h4><p>在java内的项目包下 新建 service包（一般接口都放在其中） 然后再其中新建XXXService接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于mybatisplus快速开发，ctrl+o查看mp帮你重写或覆盖的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookService</span> <span class="keyword">extends</span> <span class="title">IService</span> &lt;实体类&gt;</span>{ }</span><br></pre></td></tr></tbody></table></figure><h4 id="创建接口实现类"><a href="#创建接口实现类" class="headerlink" title="创建接口实现类"></a>创建接口实现类</h4><p>service 包内 新建 impl 包（实现类全部在impl包内）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// 继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类</span></span><br><span class="line"><span class="comment">// extends ServiceImpl&lt;BookDao,Book&gt;  //传入两个泛型(dao层,实体类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IBookServiceImpl</span>  <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">BookDao</span>,<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">IBookService</span> </span>{}</span><br></pre></td></tr></tbody></table></figure><h4 id="单元测试类"><a href="#单元测试类" class="headerlink" title="单元测试类"></a>单元测试类</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ke.bookm.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wenke</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> BookServiceTestCasde</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/4/7 20:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceTestCase</span> </span>{</span><br><span class="line">    <span class="comment">// 接口有多个实现类时使用@Qualifier注解指定实现类：</span></span><br><span class="line">    <span class="comment">// @Qualifier("qualifierServiceImpl2")</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testGetById</span><span class="params">()</span></span>{</span><br><span class="line">        bookService.getById(<span class="number">4</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="控制器层-controller"><a href="#控制器层-controller" class="headerlink" title="控制器层(controller)"></a>控制器层(controller)</h2><p>表现层，控制器层，controller层的功能为请求和响应控制。controller层负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端。</p><h3 id="Controller和-ResponseBody注解"><a href="#Controller和-ResponseBody注解" class="headerlink" title="@Controller和@ResponseBody注解"></a>@Controller和@ResponseBody注解</h3><p>在一个类上添加@Controller注解，表明了这个类是一个控制器类<br>在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面,若返回json等内容到页面，则需要加@ResponseBody注解</p><p>@ResponseBody表示方法的返回值直接以指定的格式写入Http response body中，而不是解析为跳转路径。<br>格式的转换是通过HttpMessageConverter中的方法实现的，因为它是一个接口，因此由其实现类完成转换。</p><h3 id="RestController-1"><a href="#RestController-1" class="headerlink" title="@RestController"></a>@RestController</h3><p>如果需要返回的是数据（如：JSON、XML或自定义的metatype等数据类型）时，@RestController完全等同于@Controller+@Responsebody<br>如果要求方法返回的是json格式数据，而不是跳转页面，可以直接在类上标注@RestController，而不用在每个方法中标注@ResponseBody，简化了开发过程。但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面</p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>@RequestMapping注解是用来映射请求的，即指明处理器可以处理哪些URL请求，该注解既可以用在类上，也可以用在方法上。</p><p>当使用@RequestMapping标记控制器类时，方法的请求地址是相对类的请求地址而言的；当没有使用@RequestMapping标记类时，方法的请求地址是绝对路径。</p><p>@RequestMapping的地址可以是url变量，并且通过@PathVariable注解获取作为方法的参数。也可以是通配符来筛选请求地址。</p><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>@Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。</p><p>在使用@Autowired时，首先在容器中查询对应类型的bean<br>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据<br>如果查询的结果不止一个，那么@Autowired会根据名称来查找。</p><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p>@Override 注解是用来指定方法重写的，只能修饰方法并且只能用于方法重写，不能修饰其它的元素。它可以强制一个子类必须重写父类方法或者实现接口的方法。</p><h3 id="创建控制器类"><a href="#创建控制器类" class="headerlink" title="创建控制器类"></a>创建控制器类</h3><p>创建控制器类com.controller.UserController.java</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/users")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>{ </span><br><span class="line">    <span class="comment">// 添加业务层对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;        </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="controller-utils"><a href="#controller-utils" class="headerlink" title="controller.utils"></a>controller.utils</h3><p>表现层数据一致性处理</p><h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mp;  </span><br><span class="line">   <span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;  </span><br><span class="line">   <span class="keyword">import</span> org.springframework.boot.SpringApplication;  </span><br><span class="line">   <span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;  </span><br><span class="line">   <span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="comment">//    在SpringBoot启动类上配置mapper接口的扫描路径</span></span><br><span class="line">   <span class="meta">@MapperScan("com.example.mp.mappers")</span>  </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusApplication</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        <span class="comment">//        定义容器对象，并启动</span></span><br><span class="line">     SpringApplication.run(MybatisPlusApplication.class, args);  </span><br><span class="line">    }  </span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目<br>SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean</p><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot04JunitApplicationTests</span> </span>{</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">"two..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><p>在官方文档里找到application.properties文件，可查看可修改的配置<br><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">官方文档</a></p><p>默认是application.properties，我们将application.properties改为application.yaml</p><h2 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h2><p>后缀使用.yml或者.yaml都行</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>易阅读<br>易于脚本语言交互<br>以数据为核心，重数据轻格式</p><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p>大小写敏感<br>属性层级关系使用多行描述，每行结尾使用冒号结束<br>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格(不允许使用Tab键)<br>属性值前面添加空格(属性名与属性值之间使用冒号+空格作为分隔)<br>#表示注释<br>使用” “括住的内容可以使用转义字符</p><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p>用$进行变量引用<br>path: c:\user\bin</p><p>temp: ${path}\temp</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h4><p>键值对的集合，又称为映射(mapping)/ 哈希(hashes) / 字典(dictionary)</p><h4 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h4><p>一组按次序排列的值，又称为序列(sequence) / 列表(list)</p><p>使用一个短横线加一个空格代表一个数组项：<br>hobby:</p><ul><li>Java<br>jdk</li><li>python<br>py<h4 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h4>(scalars)：单个的、不可再分的值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习框架首先要先了解它是干什么的，然后了解它的项目结构即每个文件有什么用&lt;/p&gt;
&lt;h1 id=&quot;springboot&quot;&gt;&lt;a href=&quot;#springboot&quot; class=&quot;headerlink&quot; title=&quot;springboot&quot;&gt;&lt;/a&gt;springboot&lt;/</summary>
      
    
    
    
    <category term="java" scheme="https://wenkex.gitee.io/categories/java/"/>
    
    
    <category term="web" scheme="https://wenkex.gitee.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>前端学习</title>
    <link href="https://wenkex.gitee.io/2022/040312750.html"/>
    <id>https://wenkex.gitee.io/2022/040312750.html</id>
    <published>2022-04-03T14:07:51.000Z</published>
    <updated>2022-04-03T14:07:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="好用的网站"><a href="#好用的网站" class="headerlink" title="好用的网站"></a>好用的网站</h1><h2 id="CODEPEN"><a href="#CODEPEN" class="headerlink" title="CODEPEN"></a>CODEPEN</h2><p>CodePen 是一个基于 Web 的开发平台，允许用户在网页编写 HTML、CSS 和 JavaScript 等前端语言。并且它是实时可见的，这会使故障排除更加容易。开发人员和设计人员还可以与世界其他地方交换代码示例。</p><h2 id="Responsively"><a href="#Responsively" class="headerlink" title="Responsively"></a>Responsively</h2><p>这是一个基于开源项目的网站，它能够将各个设备屏幕展现在同一个页面上，能够让你非常方便的开发响应式网站，大幅提高前端开发的效率。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>HTML:（HyperText Markup Language）【超文本标记语言】<br>狭义的HTML指的是网页；<br>广义的HTML指的是前端技术（html,css,js,以及各种框架）——网页，移动端网页，小程序，公众号，移动端的app，快应用等。</p><p>HTML是一门标记语言，标记语言由一套标记标签组成，学习HTML，就是学习标签。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>HTML注释符号是以 &lt;– 开始以 –&gt; 结束的</p><h2 id="vscode编辑html"><a href="#vscode编辑html" class="headerlink" title="vscode编辑html"></a>vscode编辑html</h2><p>open in brower<br>按下快捷键ALT+B 即可在浏览器运行html</p><p>HTMLHint<br>错误提示</p><p>html snippets<br>常用html代码片段模板</p><p>live server<br>实时预览html文件</p><p>beautify<br>格式化代码工具，美化javascript，JSON，CSS，Sass，和HTML</p><h2 id="HTML文件的规范"><a href="#HTML文件的规范" class="headerlink" title="HTML文件的规范"></a>HTML文件的规范</h2><p>html文件以开始，以结尾，其他任何标签，需要写在和之间；<br>Html标签只包含两个子标签：head和body；<br>和网页设置相关的内容都写在head标签里；<br>需要显示的内容都写在body标签里；</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><code>由尖括号包裹单词构成，如：&lt;html&gt;，所以标签不可能以数字开头。</code><br>标签不区分大小写，但推荐小写。<br>标签也称为元素。</p><h3 id="单标签"><a href="#单标签" class="headerlink" title="单标签"></a>单标签</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单标签有两种写法：</span><br><span class="line">   写法一：只写开标签即可&lt;br&gt;</span><br><span class="line">   写法二：在开标签的结尾写一个/，如&lt;br/&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="双标签："><a href="#双标签：" class="headerlink" title="双标签："></a>双标签：</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开始标签又称开放标签<span class="tag">&lt;<span class="name">a</span>&gt;</span>标签体<span class="tag">&lt;/<span class="name">a</span>&gt;</span>结束标签又称闭合标签或关标签</span><br><span class="line">自闭合标签/单标签，如：<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>，<span class="tag">&lt;<span class="name">br</span>&gt;</span>等</span><br></pre></td></tr></tbody></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>指向 w3school 的超链接：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.w3school.com.cn"</span>  &gt;</span>文字说明<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">rel：规定当前文档与被链接文档之间的关系。</span><br></pre></td></tr></tbody></table></figure><h2 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h2><p>表单数据可以作为 URL 变量（method=”get”）或者 HTTP post （method=”post”）的方式来发送。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一个简单的 HTML 表单，包含两个文本输入框和一个提交按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"form_action.asp"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">  First name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"fname"</span> /&gt;</span></span><br><span class="line">  Last name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"lname"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h3><p>action 属性规定当提交表单时，向何处发送表单数据。<br>method属性规定如何发送表单数据（表单数据发送到 action 属性所规定的页面）。</p><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>input 标签用于搜集用户信息。<br>根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等。<br><code>&lt;input type="表单元素的类型" name="名称" value="默认值" size="宽度"&gt; </code></p><h4 id="type属性"><a href="#type属性" class="headerlink" title="type属性"></a>type属性</h4><p>text    单行文本框    省略时默认就是text<br>password    密码框    输入时以点号显示，安全<br>redio    单选按钮    只能选择其中一个<br>checkbox    复选框    可以同时选择多个<br>submit    提交按钮    提交表单数据<br>reset    重置按钮    重置表单元素的初始值<br>image    图像按钮    可以使用图片作为按钮<br>button    普通按钮    默认情况下无功能<br>file    文件选择器    选择要上传的文件<br>hidden    隐藏域    在页面上不显示，但是会提交，可以用来存储数据</p><h4 id="placeholder属性"><a href="#placeholder属性" class="headerlink" title="placeholder属性"></a>placeholder属性</h4><p>placeholder属性提供可描述输入字段预期值的提示信息</p><h1 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h1><h2 id="div标签中id、class属性的使用与区别"><a href="#div标签中id、class属性的使用与区别" class="headerlink" title="div标签中id、class属性的使用与区别"></a>div标签中id、class属性的使用与区别</h2><p>div用于标示块级元素，而span标示行内元素。</p><p>1、语法区别<br>id对应CSS是用样式选择符“#”（井号）；<br>class对应CSS是用样式选择符“.”(英文半角输入句号)。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"abc"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure><p>对应CSS应该是：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#header</span>{...} </span><br><span class="line"><span class="selector-class">.abc</span>{...} </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>id：在同一个页面，只可以被调用一次，在CSS里用“#”表示。<br>class：是类标签，在同一个页面可以调用无数次（没限制的），在CSS里用“.”表示。</p><h3 id="使用css"><a href="#使用css" class="headerlink" title="使用css"></a>使用css</h3><p>三种使用 CSS 的方法</p><p>外部 CSS<br>内部 CSS<br>行内 CSS</p><h3 id="外部-CSS"><a href="#外部-CSS" class="headerlink" title="外部 CSS"></a>外部 CSS</h3><p>外部样式表可以在任何文本编辑器中编写，并且必须以 .css 扩展名保存。<br>外部样式在 HTML 页面  部分内的 <link> 元素中进行定义：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h2><p>CSS 选择器用于“查找”（或选取）要设置样式的 HTML 元素。</p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器:"></a>id选择器:</h3><p>#id</p><p>id 名称不能以数字开头。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这条CSS 规则将应用于 id="para1" 的 HTML 元素 */</span></span><br><span class="line"><span class="selector-id">#para1</span> {</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器:"></a>类选择器:</h3><p>如需选择拥有特定 class 的元素，请写一个句点（.）字符，后面跟类名。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在此例中，所有带有 class="center" 的 HTML 元素将为红色且居中对齐： */</span></span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="CSS-通用选择器"><a href="#CSS-通用选择器" class="headerlink" title="CSS 通用选择器"></a>CSS 通用选择器</h4><p>通用选择器（*）选择页面上的所有的 HTML 元素。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 下面的 CSS 规则会影响页面上的每个 HTML 元素： */</span></span><br><span class="line"></span><br><span class="line">* {</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="CSS-分组选择器"><a href="#CSS-分组选择器" class="headerlink" title="CSS 分组选择器"></a>CSS 分组选择器</h4><p>分组选择器选取所有具有相同样式定义的 HTML 元素。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">p</span> {</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="组合器选择器（根据它们之间的特定关系来选取元素）"><a href="#组合器选择器（根据它们之间的特定关系来选取元素）" class="headerlink" title="组合器选择器（根据它们之间的特定关系来选取元素）"></a>组合器选择器（根据它们之间的特定关系来选取元素）</h2><h2 id="伪类选择器（根据特定状态选取元素）"><a href="#伪类选择器（根据特定状态选取元素）" class="headerlink" title="伪类选择器（根据特定状态选取元素）"></a>伪类选择器（根据特定状态选取元素）</h2><h2 id="伪元素选择器（选取元素的一部分并设置其样式）"><a href="#伪元素选择器（选取元素的一部分并设置其样式）" class="headerlink" title="伪元素选择器（选取元素的一部分并设置其样式）"></a>伪元素选择器（选取元素的一部分并设置其样式）</h2><h2 id="属性选择器（根据属性或属性值来选取元素）"><a href="#属性选择器（根据属性或属性值来选取元素）" class="headerlink" title="属性选择器（根据属性或属性值来选取元素）"></a>属性选择器（根据属性或属性值来选取元素）</h2><h2 id="css基础属性"><a href="#css基础属性" class="headerlink" title="css基础属性"></a>css基础属性</h2><h3 id="文字类"><a href="#文字类" class="headerlink" title="文字类"></a>文字类</h3><p>color<br>font-size<br>text-decoration<br>text-align</p><h3 id="尺寸类"><a href="#尺寸类" class="headerlink" title="尺寸类"></a>尺寸类</h3><p>width<br>height</p><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>background-color<br>background-image<br>background-size:cover</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="谷歌浏览器"><a href="#谷歌浏览器" class="headerlink" title="谷歌浏览器"></a>谷歌浏览器</h3><h4 id="CSS-Overview"><a href="#CSS-Overview" class="headerlink" title="CSS Overview"></a>CSS Overview</h4><p>在 Chrome 的管理面板中，开启CSS Overview面板之后，就可以查看当前网站的样式信息了，包括颜色信息、字体信息、媒体查询等</p><p>1.在任意页面打开 Chrome 浏览器的 DevTools；<br>2.单击更多选项 -&gt; More tools -&gt; CSS Overview。</p><h4 id="新的字体编辑器工具"><a href="#新的字体编辑器工具" class="headerlink" title="新的字体编辑器工具"></a>新的字体编辑器工具</h4><p>Chrome DevTools 提供了一个实验性的字体编辑器工具，可以用来改变字体设置。可以用它来改变字体、大小、粗细、行高、字符间距，并实时看到变化</p><p>1.在任意页面打开 Chrome 浏览器的 DevTools；<br>2.点击右上角设置图标 -&gt; 选中左侧 Experiments -&gt; 勾选 Enable New Font Editor Tools within Styles Pane；<br>3.重启浏览器的 DevTools；<br>4.选择HTML元素，其中包括想改变的字体，点击字体图标即可。</p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>JavaScript是一种轻量级的脚本语言。</p><p>JavaScript 插入 HTML 页面后，由浏览器执行。JavaScript 控制了网页的行为</p><p>推荐<a href="https://www.w3school.com.cn/js/index.asp">w3school</a>或者<a href="https://www.runoob.com/js/js-tutorial.html">runoob</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">7</span>;                             <span class="comment">// 数字</span></span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">"Gates"</span>;                      <span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">var</span> cars = [<span class="string">"Porsche"</span>, <span class="string">"Volvo"</span>, <span class="string">"BMW"</span>];         <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> x = {<span class="attr">firstName</span>:<span class="string">"Bill"</span>, <span class="attr">lastName</span>:<span class="string">"Gates"</span>};    <span class="comment">// 对象</span></span><br></pre></td></tr></tbody></table></figure><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 [ n, m ) 范围内的随机数（大于等于n，小于m）</span></span><br><span class="line"><span class="comment">// var random = Math.random()*(m-n)+n</span></span><br><span class="line">    a=<span class="built_in">Math</span>.random()*<span class="number">5</span>+<span class="number">1</span></span><br><span class="line">    toastLog (a)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 生成 [ min, max ] 范围内的随机整数（大于等于min，小于等于max）</span></span><br><span class="line"><span class="comment">// var random =Math.floor(Math.random()*(max-min+1))+min</span></span><br><span class="line">    b=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(<span class="number">5</span>))+<span class="number">1</span></span><br><span class="line">    toastLog(b)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><p>在字符串中换行，需要加一个反斜杠(非ECMAScript标准）：</p>  <figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = <span class="string">"Hello \</span></span><br><span class="line"><span class="string">Kitty!"</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>String</code>和<code>Number</code>相加时，会将数字转为字符串；<code>String</code>和<code>Number</code>相减时，会将字符串转为数字；</p></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>JavaScript 对象是变量的容器。但是，我们通常认为 “JavaScript 对象是键值对的容器”。<br>对象也是一个变量，但对象可以包含多个值（多个变量），每个值以 name:value 对呈现。<br>总结：JavaScript 对象是属性和方法的容器。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = {<span class="attr">name</span>:<span class="string">"Fiat"</span>, <span class="attr">model</span>:<span class="number">500</span>, <span class="attr">color</span>:<span class="string">"white"</span>};</span><br></pre></td></tr></tbody></table></figure><ul><li><p><code>null</code>：类型是对象，不存在的事物。</p>  <figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>            <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>             <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h4><p>键值对在 JavaScript 对象通常称为 对象属性。<br>访问对象属性<br>你可以通过两种方式访问对象属性:</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>person.lastName;</span><br><span class="line"><span class="number">2.</span>person[<span class="string">"lastName"</span>];</span><br></pre></td></tr></tbody></table></figure><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><pre><code><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以通过person.firstName="..."的方式初始化</span></span><br><span class="line"><span class="keyword">var</span> person = {</span><br><span class="line"><span class="attr">firstName</span>: <span class="string">"Bill"</span>,</span><br><span class="line"><span class="attr">lastName</span> : <span class="string">"Gates"</span>,</span><br><span class="line"><span class="attr">id</span>       : <span class="number">678</span>,</span><br><span class="line"><span class="attr">fullName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{   <span class="comment">//成员函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">" "</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>脚本放置 HTML 的  或  部分中，或者同时存在于两个部分中。位于<script> 与 </script> 标签之间。</p><p>也可以把脚本保存到外部文件中，在 <script> 标签的 "src" 属性中设置该 .js 文件：</p><h1 id="Thymeleaf模板引擎"><a href="#Thymeleaf模板引擎" class="headerlink" title="Thymeleaf模板引擎"></a>Thymeleaf模板引擎</h1><p><a href="https://developer.aliyun.com/article/769977">https://developer.aliyun.com/article/769977</a></p><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的html文档。</p><p>将模板设计好之后直接填充数据即可而不需要重新设计整个页面。让网站实现界面和数据分离，提高页面、代码的复用性。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎</p><p>特点<br>1.动静分离： Thymeleaf选用html作为模板页，这是任何一款其他模板引擎做不到的！Thymeleaf使用html通过一些特定标签语法代表其含义，但并未破坏html结构，即使无网络、不通过后端渲染也能在浏览器成功打开，大大方便界面的测试和修改。</p><p>2.开箱即用： Thymeleaf提供标准和Spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改JSTL、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</p><p>3.Springboot官方大力推荐和支持，Springboot官方做了很多默认配置，开发者只需编写对应html即可，大大减轻了上手难度和配置复杂度。</p><h2 id="第一个Thymeleaf程序"><a href="#第一个Thymeleaf程序" class="headerlink" title="第一个Thymeleaf程序"></a>第一个Thymeleaf程序</h2><p>步骤</p><h2 id="创建程序，添加依赖"><a href="#创建程序，添加依赖" class="headerlink" title="创建程序，添加依赖"></a>创建程序，添加依赖</h2><p>首先，打开你的IDEA创建新项目，选择Spring Initializr方式创建Springboot项目 ，然后点击next，然后填写项目名</p><p>勾选其中Web 模块的Spring web依赖以及Template 模块的Thymeleaf依赖。finish 即可：</p><p>如果你创建项目时没有勾选依赖也不要紧，在pom.xml中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h2><p>pom.xml：是项目中的Maven依赖，因为Springboot使用Maven来管理外部jar包依赖，我们只需填写依赖名称配置即可引入该依赖，在本系统中引入Spring web模块(Springmvc)和Thymeleaf的依赖.我们不需要自己去招相关jar包。<br>application.properties: 编写Springboot与各框架整合的一些配置内容。<br>controller：用来编写控制器，主要负责处理请求以及和视图(Thymeleaf)绑定。<br>static：用于存放静态资源，例如html、JavaScript、css以及图片等。<br>templates：用来存放模板引擎Thymeleaf(本质依然是.html文件)</p><h2 id="编写Controller"><a href="#编写Controller" class="headerlink" title="编写Controller"></a>编写Controller</h2><p>项目基于Springboot框架，且选了Spring web(Springmvc)作为mvc框架，其中Thymeleaf就是v(view)视图层，我们需要在controller中指定Thymeleaf页面的url，然后再Model中绑定数据。</p><p>我们在com.Thymeleaf文件下创建controller文件夹，在其中创建urlController.java的controller文件，文件内容(代码)为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Thymeleaf.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">urlController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;index&quot;)</span><span class="comment">//页面的url地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getindex</span><span class="params">(Model model)</span><span class="comment">//对应函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;bigsai&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;<span class="comment">//与templates中index.html对应</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分含义如下：<br>@controller 注解的意思就是声明这个java文件为一个controller控制器。<br>@GetMapping(“index”) 其中@GetMapping的意思是请求的方式为get方式(即可通过浏览器直接请求)，而里面的index表示这个页面(接口)的url地址(路径)。即在浏览器对项目网页访问的地址。<br>getindex() 是@GetMapping(“index”)注解对应的函数，其类型为String类型返回一个字符串，参数Model类型即用来储存数据供我们Thymeleaf页面使用。<br>model.addAttribute(“name”,”bigsai”) 就是Model存入数据的书写方式，Model是一个特殊的类，相当于维护一个Map一样，而Model中的数据通过controller层的关联绑定在view层(即Thymeleaf中)可以直接使用。<br>return “hello”：这个index就是在templates目录下对应模板(本次为Thymeleaf模板)的名称，即应该对应hello.html这个Thymeleaf文件(与页面关联默认规则为：templates目录下返回字符串.html)。</p><h2 id="编写Thymeleaf页面"><a href="#编写Thymeleaf页面" class="headerlink" title="编写Thymeleaf页面"></a>编写Thymeleaf页面</h2><p>咱们在项目的resources目录下的templates文件夹下面创建一个叫index.html的文件，咱们在这个html文件中的<html>标签修改为<html xmlns:th="http://www.thymeleaf.org">这样在Thymeleaf中就可以使用Thymeleaf的语法和规范啦。</p><p>对于第一个Thymelaf程序，你只需将index.html文件改成这样即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>  <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello 第一个Thymeleaf程序</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span>name是bigsai(我是离线数据)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Thymeleaf语法详解"><a href="#Thymeleaf语法详解" class="headerlink" title="Thymeleaf语法详解"></a>Thymeleaf语法详解</h2><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><h2 id="链接表达式-…"><a href="#链接表达式-…" class="headerlink" title="链接表达式: @{…}"></a>链接表达式: @{…}</h2><h2 id="变量表达式-…"><a href="#变量表达式-…" class="headerlink" title="变量表达式: ${…}"></a>变量表达式: ${…}</h2><h2 id="选择变量表达式-…"><a href="#选择变量表达式-…" class="headerlink" title="选择变量表达式: *{…}"></a>选择变量表达式: *{…}</h2><h2 id="消息表达-…"><a href="#消息表达-…" class="headerlink" title="消息表达: #{…}"></a>消息表达: #{…}</h2><h1 id="Bootstrap组件库"><a href="#Bootstrap组件库" class="headerlink" title="Bootstrap组件库"></a>Bootstrap组件库</h1><p>Bootstrap:前端页面框架，用于快速开发响应式页面，一套代码就可以适应平板和PC</p><p>Bootstrap 3 是移动设备优先的，在这个意义上，Bootstrap 代码从小屏幕设备（比如移动设备、平板电脑）开始，然后扩展到大屏幕设备（比如笔记本电脑、台式电脑）上的组件和网格。</p><p><a href="https://www.runoob.com/bootstrap/bootstrap-tutorial.html">教程</a></p><p><a href="https://www.runoob.com/try/bootstrap/layoutit/">Bootstrap 可视化布局系统！</a></p><h2 id="引入bootstrap框架"><a href="#引入bootstrap框架" class="headerlink" title="引入bootstrap框架"></a>引入bootstrap框架</h2><p>1、直接引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优点：方便，简单；</p><p>缺点：使网页加载缓慢，需要有网络的情况；</p><p>2.下载好库再进行引入：<br>优点：加载网页会快点，没有网络的情况也可用；</p><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p><a href="https://www.runoob.com/jquery/jquery-tutorial.html">jQuery菜鸟教程</a><br>jQuery ：是一个 JavaScript 函数库。使用选择器（$）选取DOM对象，并对其进行赋值、取值、事件绑定等操作；主要是操作DOM</p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>国内用百度CDN</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="jQuery-语法"><a href="#jQuery-语法" class="headerlink" title="jQuery 语法"></a>jQuery 语法</h2><p>基础语法： $(selector).action()</p><p>美元符号定义 jQuery<br>选择符（selector）”查询”和”查找” HTML 元素<br>jQuery 的 action() 执行对元素的操作</p><h2 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h2><h2 id="jQuery-事件"><a href="#jQuery-事件" class="headerlink" title="jQuery 事件"></a>jQuery 事件</h2><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>可实现页面无刷新更新数据</p><p>Ajax相当于浏览器发送请求与接受响应的代理人，以实现在不重新加载整个页面下，与服务器交换数据并局部更新网页数据</p><h2 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h2><p>open(method,url,async)<br>规定请求的类型、URL 以及是否异步处理请求。<br>参数<br>    method：请求的类型；GET 或 POST<br>    url：文件在服务器上的位置<br>    async：true（异步）或 false（同步）</p><p>send(string)<br>    将请求发送到服务器。</p><pre><code>string：仅用于 POST 请求</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">loadXMLDoc</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript"></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> xmlhttp;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span></span><br><span class="line"><span class="javascript">&#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建 XMLHttpRequest 对象</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">&#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">// IE6, IE5 浏览器执行代码</span></span></span><br><span class="line"><span class="javascript">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript"></span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span></span><br><span class="line"><span class="javascript">&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/ajax_info.txt&quot;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">xmlhttp.send();</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>使用 AJAX 修改该文本内容<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;loadXMLDoc()&quot;</span>&gt;</span>修改内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>axios实现了对ajax的封装。<br>Axios 是可以发出 http 请求的 JavaScript 库，在 浏览器 和 node.js 环境中都可以运行。</p><h2 id="axios与ajax的优缺点"><a href="#axios与ajax的优缺点" class="headerlink" title="axios与ajax的优缺点"></a>axios与ajax的优缺点</h2><p>1.axios优点：<br>（1）从浏览器中创建 XMLHttpRequest；<br>（2）支持 Promise API；<br>（3）从 node.js 创建 http 请求；<br>（4）转换请求和响应数据；<br>（5）自动转换JSON数据。</p><p>1.ajax缺点:<br>（1）基于原生的XHR开发，XHR本身的架构不清晰；<br>（2）JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理；<br>（3）不符合关注分离（Separation of Concerns）的原则；<br>（4）配置和调用方式非常混乱，而且基于事件的异步模型不友好。</p><h2 id="GET-请求和POST-请求"><a href="#GET-请求和POST-请求" class="headerlink" title="GET 请求和POST 请求"></a>GET 请求和POST 请求</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 1、向给定ID的用户发起GET 请求</span></span></span><br><span class="line"><span class="javascript">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 处理成功情况</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 处理错误情况</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(error);</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 总是会执行</span></span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 2.POST 请求</span></span></span><br><span class="line"><span class="javascript">axios.post(<span class="string">&#x27;/user&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(error);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p>官方文档：<a href="http://vuejs.org/v2/guide/syntax.html">http://vuejs.org/v2/guide/syntax.html</a></p><p>中文文档: <a href="https://cn.vuejs.org/v2/guide/syntax.html">https://cn.vuejs.org/v2/guide/syntax.html</a></p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="直接引入"><a href="#直接引入" class="headerlink" title="直接引入"></a>直接引入</h3><h2 id="js表达式与js代码-语句-的区别"><a href="#js表达式与js代码-语句-的区别" class="headerlink" title="js表达式与js代码(语句)的区别"></a>js表达式与js代码(语句)的区别</h2><p>1.表达式：一个表达式会生成一个值<br>  (1)a+b<br>  (2)x===y ‘a’ ? ‘b’</p><p>2.代码<br>  (1)if (){}  </p><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h3><p>功能：用于解析标签体内容<br>写法：容器中的是js表达式，可以自动读取vue实例中data的所有属性 </p><h3 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h3><p>功能：用于解析标签(包括标签属性，标签体内容，绑定事件)</p><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind:"></a>v-bind:</h4><p>v-bind用于单向绑定数据和元素属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可简写为： --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>双向数据绑定,一般用在表单类元素如：input，select</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">双向<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model:value</span>=<span class="string">&quot;school.name&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 因为v-model默认收集的就是value值，所以可简写为 --&gt;</span></span><br><span class="line">双向<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;school.name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义一个容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &#123;&#123; &#125;&#125; 用于输出对象属性和函数返回值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>site : &#123;&#123;site&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>url : &#123;&#123;url&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;details()&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对于制作原型或学习，你可以这样导入最新版本： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// vue实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// el 参数的两种写法</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// vm.$mount(&#x27;#rood&#x27;),</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#rood&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// data参数用于定义属性</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1.data参数的对象式写法</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">site</span>: <span class="string">&quot;菜鸟教程&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">url</span>: <span class="string">&quot;www.runoob.com&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">alexa</span>: <span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2.data参数的函数式写法(vue管理的函数，不能用箭头函数)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// data:function()&#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//   return&#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     name:&#x27;菜鸟&#x27;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// methods参数用于定义函数</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">details</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>  <span class="built_in">this</span>.site + <span class="string">&quot; - 学的不仅是技术，更是梦想！&quot;</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>created() {}<br>VUE对象初始化完成后自动执行</p><h2 id="Element-UI组件库"><a href="#Element-UI组件库" class="headerlink" title="Element UI组件库"></a>Element UI组件库</h2><p>Element UI 是一套采用 Vue 2.0 作为基础框架实现的组件库</p><p><a href="https://element.eleme.cn/#/zh-CN/component/installation">组件</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入组件库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>Layout 布局<br>Container 布局容器<br>Color 色彩<br>Typography 字体<br>Border 边框<br>Icon 图标<br>Button 按钮<br>Link 文字链接<br>Form</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>Radio 单选框<br>Checkbox 多选框<br>Input 输入框<br>InputNumber 计数器<br>Select 选择器<br>Cascader 级联选择器<br>Switch 开关<br>Slider 滑块<br>TimePicker 时间选择器<br>DatePicker 日期选择器<br>DateTimePicker 日期时间选择器<br>Upload 上传<br>Rate 评分<br>ColorPicker 颜色选择器<br>Transfer 穿梭框<br>Form 表单</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>Table 表格<br>Tag 标签<br>Progress 进度条<br>Tree 树形控件<br>Pagination 分页<br>Badge 标记<br>Avatar 头像<br>Skeleton 骨架屏<br>Empty 空状态<br>Descriptions 描述列表<br>Result 结果</p><h3 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h3><p><code>  &lt;el-input v-model=&quot;input1&quot;&gt;&lt;/el-input&gt; 输入内容为：&#123;&#123;input1&#125;&#125;</code></p><h3 id="Table表格组件"><a href="#Table表格组件" class="headerlink" title="Table表格组件"></a>Table表格组件</h3><h4 id="el-table"><a href="#el-table" class="headerlink" title="el-table"></a>el-table</h4><p>:data属性   单向数据绑定</p><p>stripe属性可以创建带斑马纹的表格</p><p>Table 组件提供了单选的支持，只需要配置highlight-current-row属性即可实现单选。之后由current-change事件来管理选中时触发的事件，它会传入currentRow，oldCurrentRow。如果需要显示索引，可以增加一列el-table-column，设置type属性为index即可显示从 1 开始的索引号。</p><h4 id="el-table-column"><a href="#el-table-column" class="headerlink" title="el-table-column"></a>el-table-column</h4><p>prop属性来对应对象中的键名即可填入数据，<br>label属性来定义表格的列名。<br>width属性来定义列宽。<br>align=“center”：设置表格内居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> <span class="attr">current-row-key</span>=<span class="string">&quot;id&quot;</span> <span class="attr">:data</span>=<span class="string">&quot;dataList&quot;</span> <span class="attr">stripe</span> <span class="attr">highlight-current-row</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">&quot;index&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">label</span>=<span class="string">&quot;序号&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;type&quot;</span> <span class="attr">label</span>=<span class="string">&quot;图书类别&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;name&quot;</span> <span class="attr">label</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;description&quot;</span> <span class="attr">label</span>=<span class="string">&quot;描述&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;操作&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpdate(scope.row)&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleDelete(scope.row)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>Alert 警告<br>Loading 加载<br>Message 消息提示<br>MessageBox 弹框<br>Notification 通知<br>Navigation<br>NavMenu 导航菜单<br>Tabs 标签页<br>Breadcrumb 面包屑<br>PageHeader 页头<br>Dropdown 下拉菜单<br>Steps 步骤条</p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Dialog 对话框<br>Tooltip 文字提示<br>Popover 弹出框<br>Popconfirm 气泡确认框<br>Card 卡片<br>Carousel 走马灯<br>Collapse 折叠面板<br>Timeline 时间线<br>Divider 分割线<br>Calendar 日历<br>Image 图片<br>Backtop 回到顶部<br>InfiniteScroll 无限滚动<br>Drawer 抽屉<br>¶Button 按钮</p><h3 id="通过js触发按钮的点击事件"><a href="#通过js触发按钮的点击事件" class="headerlink" title="通过js触发按钮的点击事件"></a>通过js触发按钮的点击事件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpdate(scope.row)&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//弹出编辑窗口</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">handleUpdate</span>(<span class="params">row</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        axios.get(<span class="string">&quot;/books/&quot;</span>+row.id).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(res.data.flag &amp;&amp; res.data.data != <span class="literal">null</span> )&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.dialogFormVisible4Edit = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.formData = res.data.data;</span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$message.error(<span class="string">&quot;数据同步失败，自动刷新&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;).finally(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//2.重新加载数据</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.getAll();</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></script></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;好用的网站&quot;&gt;&lt;a href=&quot;#好用的网站&quot; class=&quot;headerlink&quot; title=&quot;好用的网站&quot;&gt;&lt;/a&gt;好用的网站&lt;/h1&gt;&lt;h2 id=&quot;CODEPEN&quot;&gt;&lt;a href=&quot;#CODEPEN&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="前端" scheme="https://wenkex.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="框架" scheme="https://wenkex.gitee.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>qq机器人</title>
    <link href="https://wenkex.gitee.io/2022/032659541.html"/>
    <id>https://wenkex.gitee.io/2022/032659541.html</id>
    <published>2022-03-26T09:09:00.000Z</published>
    <updated>2022-03-26T09:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h2><p>WebSocket 是HTML5 提供的一种在单个TCP连接上进行全双工通信的协议。</p><p>WebSocket 只需要完成一次握手，客户端和服务器之间就可以创建持久性的连接，并进行双向数据传输。这就使得客户端和服务器之间的数据交换变得更加简单。</p><h1 id="go-cqhttp"><a href="#go-cqhttp" class="headerlink" title="go-cqhttp"></a>go-cqhttp</h1><p><a href="https://onebot.dev/ecosystem.html#onebot-%E5%AE%9E%E7%8E%B0">OneBot</a><br>go-cqhttp（一个 QQ 平台的 OneBot 实现）<br><a href="https://docs.go-cqhttp.org/guide/quick_start.html#%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B"> go-cqhttp 文档</a></p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>建议使用ubuntu服务器<br>下载：64 位 Linux    Not available    go-cqhttp_linux_amd64.tar.gz</p><p>Linux下在命令行中输入 tar -xzvf [文件名] 解压到想要的文件夹内</p><p>进入对应目录 <code>./go-cqhttp</code>启动</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.第一次无法登录，隔了一天再登录又可以了</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进入对应目录 <code>./go-cqhttp</code>前台运行。如果你操作其他命令或者关闭 ssh 工具，程序自然就关闭了</p><h1 id="Nonebot2框架"><a href="#Nonebot2框架" class="headerlink" title="Nonebot2框架"></a>Nonebot2框架</h1><p>是一个可扩展的 Python 异步机器人框架：<a href="https://docs.nonebot.dev/">https://docs.nonebot.dev/</a></p><p>Nonebot2需要先搭建go-cqhttp</p><h2 id="搭建-1"><a href="#搭建-1" class="headerlink" title="搭建"></a>搭建</h2><p>可以使用 pip 安装已发布的最新版本：<br><code>pip install nonebot</code></p><p>在提示选择通信方式时，选择「反向 Websocket 通信」，程序将会自动生成默认配置文件。</p><p>打开 go-cqhttp 默认配置文件 config.yml 进行简单配置，修改 QQ 账号以及密码。再次运行 go-cqhttp，可能需要根据提示进行扫码或滑块验证，如果得到以下提示则登录成功：</p><h3 id="使用脚手架"><a href="#使用脚手架" class="headerlink" title="使用脚手架"></a>使用脚手架</h3><p><a href="https://v2.nonebot.dev/docs/start/nb-cli">https://v2.nonebot.dev/docs/start/nb-cli</a></p><p>pip install nb-cli</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><a href="https://v2.nonebot.dev/store">插件</a><br><a href="https://github.com/nonepkg/nonebot-plugin-manager">https://github.com/nonepkg/nonebot-plugin-manager</a></p><h1 id="Mirai"><a href="#Mirai" class="headerlink" title="Mirai"></a>Mirai</h1><p>使用 Kotlin 编写的高效率 QQ 机器人框架<br><a href="https://github.com/mamoe/mirai">github地址</a></p><p><a href="https://github.com/mamoe/mirai/blob/dev/docs/mirai-ecology.md">mirai官方生态文档</a></p><h2 id="下载-MCL-Installer"><a href="#下载-MCL-Installer" class="headerlink" title="下载 MCL Installer"></a>下载 MCL Installer</h2><p><a href="https://github.com/iTXTech/mcl-installer">MCL Installer</a><br>支持自动下载Java运行环境 和 Mirai Console Loader </p><p>MCL Installer安装时自动下载了 Mirai Console Loader（简称 MCL）。<br>Mirai Console Loader它的工作就是简化 console 启动流程，一键帮你下载 jar 文件，自动更新，文件损坏检查…… 你能在手动启动时担心的问题 mirai-console-loader 都帮你想到了</p><h2 id="了解运行环境"><a href="#了解运行环境" class="headerlink" title="了解运行环境"></a>了解运行环境</h2><p>文件夹名称    用途<br>scripts    存放启动器的脚本，一般不需要在意他们<br>plugins    存放插件<br>data    存放插件的数据，一般不需要在意它们<br>config    存放插件的配置，可以打开并修改配置<br>logs    存放运行时的日志，日志默认保留 7 天</p><h2 id="插件-1"><a href="#插件-1" class="headerlink" title="插件"></a>插件</h2><p>官方(chat-command，mirai-api-http，mirai-native）</p><p>刚刚装好的 Mirai Console 是没有任何功能的。功能将由插件提供。<br><a href="https://mirai.mamoe.net/category/11/%E6%8F%92%E4%BB%B6%E5%8F%91%E5%B8%83">插件发布</a><br>如果是 JAR 文件的插件，放入 plugins 即可。其他插件一般都有特殊说明如何使用，请参考它们的说明。</p><h3 id="Plum"><a href="#Plum" class="headerlink" title="Plum"></a>Plum</h3><p><a href="https://mirai.mamoe.net/topic/241/plum-%E6%A2%85%E8%8A%B1%E5%A8%98-%E6%8A%A5%E6%97%A9%E6%99%9A%E5%AE%89-%E6%99%BA%E8%83%BD%E7%82%B9%E6%AD%8C-%E4%B8%80%E8%A8%80-%E9%9A%8F%E6%9C%BA%E5%8A%A8%E6%BC%AB%E5%A3%81%E7%BA%B8-%E8%81%8A%E5%A4%A9ai/2">Plum</a></p><p>Plum-1.0-SNAPSHOT.mirai.jar<br>功能</p><p>每天5点：每日句子 + 倒计时（可自定义倒计时事件）<br>每天21点：每日诗词<br>戳一戳：随机一言<br>@ + 问题：AI聊天（默认实现是青云客API，可自行修改）<br>点歌：本插件支持3种主流音乐平台 网易云音乐，酷狗音乐，QQ音乐。默认按照 网易云音乐 -&gt; 酷狗音乐 -&gt; QQ音乐 顺序查找。通过“点歌”指令以卡片形式点歌，通过“唱歌”指令以语音条形式唱歌。</p><h3 id="自动定义回复插件"><a href="#自动定义回复插件" class="headerlink" title="自动定义回复插件"></a>自动定义回复插件</h3><p><a href="https://mirai.mamoe.net/topic/636/console-%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%B9%89%E5%9B%9E%E5%A4%8D%E6%8F%92%E4%BB%B6">https://mirai.mamoe.net/topic/636/console-%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%B9%89%E5%9B%9E%E5%A4%8D%E6%8F%92%E4%BB%B6</a></p><p>浏览器进入<a href="http://localhost:20044/index.html">http://localhost:20044/index.html</a></p><h3 id="思知机器人插件"><a href="#思知机器人插件" class="headerlink" title="思知机器人插件"></a>思知机器人插件</h3><p>自己跟自己聊天，不好用<br><a href="https://github.com/thetbw/my-bot">https://github.com/thetbw/my-bot</a> </p><h2 id="滑动验证助手"><a href="#滑动验证助手" class="headerlink" title="滑动验证助手"></a>滑动验证助手</h2><p><a href="https://github.com/mzdluo123/TxCaptchaHelper">https://github.com/mzdluo123/TxCaptchaHelper</a></p><p>下载手机客户端<br>在mcl控制台中使用命令<code>login &lt;qq&gt; [password] [protocol]</code><br>会弹出url,把它复制到滑动验证助手app中</p><p>第二种登录方式（将弹出的链接发送给手机QQ打开，会得到一个二维码，使用手机QQ扫码验证）</p><p>ANDROID_PAD是ipad</p><p>login 3385642151 密码 ANDROID_PAD</p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><h3 id="搭建在Centos-7错误"><a href="#搭建在Centos-7错误" class="headerlink" title="搭建在Centos 7错误"></a>搭建在Centos 7错误</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mcl-installer-d5a51f8-linux-amd64: /lib64/libc.so.6: version `GLIBC_2.25' not found (required by ./mcl-installer-d5a51f8-linux-amd64)</span><br></pre></td></tr></tbody></table></figure><p>根据一些研究，GLIBC_2.25 不能安装在 Centos 7 上</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/411513359">https://zhuanlan.zhihu.com/p/411513359</a></p><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>下载插件：Mirai Console</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;h2 id=&quot;WebSocket协议&quot;&gt;&lt;a href=&quot;#WebSocket协议&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="工具" scheme="https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="qq" scheme="https://wenkex.gitee.io/tags/qq/"/>
    
  </entry>
  
  <entry>
    <title>python高级</title>
    <link href="https://wenkex.gitee.io/2022/03267198.html"/>
    <id>https://wenkex.gitee.io/2022/03267198.html</id>
    <published>2022-03-26T01:55:02.000Z</published>
    <updated>2022-03-26T01:55:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。</p><h2 id="Python中的多进程"><a href="#Python中的多进程" class="headerlink" title="Python中的多进程"></a>Python中的多进程</h2><p>Unix和Linux操作系统上提供了<code>fork()</code>系统调用来创建进程，调用<code>fork()</code>函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。<code>fork()</code>函数非常特殊它会返回两次，父进程中可以通过<code>fork()</code>函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。<br>Python的os模块提供了<code>fork()</code>函数。由于Windows系统没有<code>fork()</code>调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的<code>Process</code>类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（<code>Pool</code>）、用于进程间通信的队列（<code>Queue</code>）和管道（<code>Pipe</code>）等。</p><p>下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_task</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    download_task(<span class="string">'Python从入门到住院.pdf'</span>)</span><br><span class="line">    download_task(<span class="string">'Peking Hot.avi'</span>)</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>下面是运行程序得到的一次运行结果。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开始下载Python从入门到住院.pdf...</span><br><span class="line">Python从入门到住院.pdf下载完成! 耗费了6秒</span><br><span class="line">开始下载Peking Hot.avi...</span><br><span class="line">Peking Hot.avi下载完成! 耗费了7秒</span><br><span class="line">总共耗费了13.01秒.</span><br></pre></td></tr></tbody></table></figure><p>从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getpid</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_task</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'启动下载进程，进程号[%d].'</span> % getpid())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    <span class="comment"># Process类创建了进程对象</span></span><br><span class="line">    <span class="comment"># 通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。</span></span><br><span class="line">    p1 = Process(target=download_task, args=(<span class="string">'Python从入门到住院.pdf'</span>, ))</span><br><span class="line">    p1.start()   <span class="comment">#启动进程</span></span><br><span class="line">    p2 = Process(target=download_task, args=(<span class="string">'Peking Hot.avi'</span>, ))</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()  <span class="comment">#表示等待进程执行结束</span></span><br><span class="line">    p2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>在上面的代码中，我们通过<code>Process</code>类创建了进程对象，通过<code>target</code>参数我们传入一个函数来表示进程启动后要执行的代码，后面的<code>args</code>是一个元组，它代表了传递给函数的参数。<code>Process</code>对象的<code>start</code>方法用来启动进程，而<code>join</code>方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动下载进程，进程号[1530].</span><br><span class="line">开始下载Python从入门到住院.pdf...</span><br><span class="line">启动下载进程，进程号[1531].</span><br><span class="line">开始下载Peking Hot.avi...</span><br><span class="line">Peking Hot.avi下载完成! 耗费了7秒</span><br><span class="line">Python从入门到住院.pdf下载完成! 耗费了10秒</span><br><span class="line">总共耗费了10.01秒.</span><br></pre></td></tr></tbody></table></figure><p>我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_task</span>(<span class="params">string</span>):</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="keyword">while</span> counter &lt; <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(string, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    Process(target=sub_task, args=(<span class="string">'Ping'</span>, )).start()</span><br><span class="line">    Process(target=sub_task, args=(<span class="string">'Pong'</span>, )).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个<code>counter</code>变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的<code>Queue</code>类，它是可以被多个进程共享的队列，底层是通过管道和<a href="">信号量（semaphore）</a>机制来实现的，有兴趣的读者可以自己尝试一下。</p><h2 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h2><p>在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    <span class="comment"># 使用threading模块的Thread类来创建线程</span></span><br><span class="line">    t1 = Thread(target=download, args=(<span class="string">'Python从入门到住院.pdf'</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = Thread(target=download, args=(<span class="string">'Peking Hot.avi'</span>,))</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'总共耗费了%.3f秒'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>我们可以直接使用threading模块的<code>Thread</code>类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承<code>Thread</code>类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'开始下载%s...'</span> % self._filename)</span><br><span class="line">        time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        sleep(time_to_download)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (self._filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    start = time()</span><br><span class="line">    t1 = DownloadTask(<span class="string">'Python从入门到住院.pdf'</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = DownloadTask(<span class="string">'Peking Hot.avi'</span>)</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="comment"># 计算存款后的余额</span></span><br><span class="line">        new_balance = self._balance + money</span><br><span class="line">        <span class="comment"># 模拟受理存款业务需要0.01秒的时间</span></span><br><span class="line">        sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="comment"># 修改账户余额</span></span><br><span class="line">        self._balance = new_balance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, account, money</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="comment"># 创建100个存款的线程向同一个账户中存钱</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account, <span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="comment"># 等所有存款的线程都执行完毕</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'账户余额为: ￥%d元'</span> % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到<code>new_balance = self._balance + money</code>这行代码，多个线程得到的账户余额都是初始状态下的<code>0</code>，所以都是<code>0</code>上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line">        self._lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span>(<span class="params">self, money</span>):</span></span><br><span class="line">        <span class="comment"># 先获取锁才能执行后续的代码</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            new_balance = self._balance + money</span><br><span class="line">            sleep(<span class="number">0.01</span>)</span><br><span class="line">            self._balance = new_balance</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 在finally中执行释放锁的操作保证正常异常锁都能释放</span></span><br><span class="line">            self._lock.release()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, account, money</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account, <span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'账户余额为: ￥%d元'</span> % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。</p><h2 id="多进程还是多线程"><a href="#多进程还是多线程" class="headerlink" title="多进程还是多线程"></a>多进程还是多线程</h2><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。</p><p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。</p><p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到过Python中有嵌入C/C++代码的机制。</p><p>除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。</p><blockquote><p><strong>说明：</strong> 上面的内容和例子来自于<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰官方网站的《Python教程》</a>，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。</p></blockquote><h2 id="单线程-异步I-O"><a href="#单线程-异步I-O" class="headerlink" title="单线程+异步I/O"></a>单线程+异步I/O</h2><p>现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下并发编程的一种流行方案。</p><p>在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，在后续的课程中会进行讲解。</p><h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><h3 id="将耗时间的任务放到线程中以获得更好的用户体验。"><a href="#将耗时间的任务放到线程中以获得更好的用户体验。" class="headerlink" title="将耗时间的任务放到线程中以获得更好的用户体验。"></a>将耗时间的任务放到线程中以获得更好的用户体验。</h3><p>如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验</p><p>如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadTaskHandler</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">            time.sleep(<span class="number">10</span>)</span><br><span class="line">            tkinter.messagebox.showinfo(<span class="string">'提示'</span>, <span class="string">'下载完成!'</span>)</span><br><span class="line">            <span class="comment"># 启用下载按钮</span></span><br><span class="line">            button1.config(state=tkinter.NORMAL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span>():</span></span><br><span class="line">        <span class="comment"># 禁用下载按钮</span></span><br><span class="line">        button1.config(state=tkinter.DISABLED)</span><br><span class="line">        <span class="comment"># 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行)</span></span><br><span class="line">        <span class="comment"># 在线程中处理耗时间的下载任务</span></span><br><span class="line">        DownloadTaskHandler(daemon=<span class="literal">True</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_about</span>():</span></span><br><span class="line">        tkinter.messagebox.showinfo(<span class="string">'关于'</span>, <span class="string">'作者: 骆昊(v1.0)'</span>)</span><br><span class="line"></span><br><span class="line">    top = tkinter.Tk()</span><br><span class="line">    top.title(<span class="string">'单线程'</span>)</span><br><span class="line">    top.geometry(<span class="string">'200x150'</span>)</span><br><span class="line">    top.wm_attributes(<span class="string">'-topmost'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    panel = tkinter.Frame(top)</span><br><span class="line">    button1 = tkinter.Button(panel, text=<span class="string">'下载'</span>, command=download)</span><br><span class="line">    button1.pack(side=<span class="string">'left'</span>)</span><br><span class="line">    button2 = tkinter.Button(panel, text=<span class="string">'关于'</span>, command=show_about)</span><br><span class="line">    button2.pack(side=<span class="string">'right'</span>)</span><br><span class="line">    panel.pack(side=<span class="string">'bottom'</span>)</span><br><span class="line"></span><br><span class="line">    tkinter.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h3 id="使用多进程对复杂任务进行“分而治之”。"><a href="#使用多进程对复杂任务进行“分而治之”。" class="headerlink" title="使用多进程对复杂任务进行“分而治之”。"></a>使用多进程对复杂任务进行“分而治之”。</h3><p>我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    number_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100000001</span>)]</span><br><span class="line">    start = time()</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> number_list:</span><br><span class="line">        total += number</span><br><span class="line">    <span class="built_in">print</span>(total)</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Execution time: %.3fs'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_handler</span>(<span class="params">curr_list, result_queue</span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> curr_list:</span><br><span class="line">        total += number</span><br><span class="line">    result_queue.put(total)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    processes = []</span><br><span class="line">    number_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100000001</span>)]</span><br><span class="line">    result_queue = Queue()</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 启动8个进程将数据切片后进行运算</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        p = Process(target=task_handler,</span><br><span class="line">                    args=(number_list[index:index + <span class="number">12500000</span>], result_queue))</span><br><span class="line">        index += <span class="number">12500000</span></span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="comment"># 开始记录所有进程执行完成花费的时间</span></span><br><span class="line">    start = time()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line">    <span class="comment"># 合并执行结果</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> result_queue.empty():</span><br><span class="line">        total += result_queue.get()</span><br><span class="line">    <span class="built_in">print</span>(total)</span><br><span class="line">    end = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Execution time: '</span>, (end - start), <span class="string">'s'</span>, sep=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过<code>multiprocessing.managers</code>模块中提供的管理器将<code>Queue</code>对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。</p><h1 id="openpyxl模块处理Excel电子表格"><a href="#openpyxl模块处理Excel电子表格" class="headerlink" title="openpyxl模块处理Excel电子表格"></a>openpyxl模块处理Excel电子表格</h1><p><a href="https://zhuanlan.zhihu.com/p/351814769">https://zhuanlan.zhihu.com/p/351814769</a></p><p><a href="https://blog.csdn.net/weixin_44288604/article/details/120731317">https://blog.csdn.net/weixin_44288604/article/details/120731317</a></p><p>Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，由于微软从Office 2007开始使用了新的文件格式，这使得Office Excel和LibreOffice Calc、OpenOffice Calc是完全兼容的，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line">ws[<span class="string">'A1'</span>] = <span class="number">42</span></span><br><span class="line">ws.append([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">ws[<span class="string">'A2'</span>] = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">"sample.xlsx"</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="excel文档和创建对象"><a href="#excel文档和创建对象" class="headerlink" title="excel文档和创建对象"></a>excel文档和创建对象</h2><ol><li>工作薄(workbook):一个EXCEL文件就称为一个工作薄,一个工作薄中可以包含若干张工作表。打开或者创建一个Excel需要创建一个<strong>Workbook对象</strong></li><li>工作表(sheet):工作薄中的每一张表格称为工作表,每张工作表都有一个标签,默认为sheet1\sheet2\sheet3来命名，(一个工作 薄默认为由3个工作表组成)。获取一个表则需要先创建一个Workbook对象，然后使用该对象的方法来得到一个<strong>Worksheet对象</strong></li><li>活动表(active sheet)：指当前正在操作的工作表</li><li>行(row): 工作表中的每一行行首数字(1、2、3、)称为行标题;一张工作表最多有65536行</li><li>列(column): 列标题:工作表中每一列列首的字母(A、B、C)称为列标题;一张工作表最多有256列</li><li>单元格(cell): 工作表的每一个格称为单元格。如果要获取表中的数据，那么得到Worksheet对象以后再从中获取代表单元格的<strong>Cell对象</strong></li></ol><h2 id="Workbook对象"><a href="#Workbook对象" class="headerlink" title="Workbook对象"></a>Workbook对象</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.创建</span></span><br><span class="line"><span class="keyword">from</span>  openpyxl <span class="keyword">import</span>  Workbook </span><br><span class="line"><span class="comment">#实例化Workbook对象</span></span><br><span class="line">wb = Workbook()</span><br><span class="line"><span class="comment"># 激活 worksheet</span></span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.打开已有的excel</span></span><br><span class="line"><span class="keyword">from</span> openpyxl  <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment">#实例化Workbook对象</span></span><br><span class="line">wb2 = load_workbook(<span class="string">'文件名称.xlsx'</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="Workbook对象属性（工作簿操作）"><a href="#Workbook对象属性（工作簿操作）" class="headerlink" title="Workbook对象属性（工作簿操作）"></a>Workbook对象属性（工作簿操作）</h3><p>sheetnames：获取工作簿中的表（列表）<br>active：获取当前活跃的Worksheet<br>worksheets：以列表的形式返回所有的Worksheet(表格)<br>read_only：判断是否以read_only模式打开Excel文档<br>encoding：获取文档的字符集编码<br>properties：获取文档的元数据，如标题，创建者，创建日期等</p><h2 id="Worksheet对象-工作表操作"><a href="#Worksheet对象-工作表操作" class="headerlink" title="Worksheet对象(工作表操作)"></a>Worksheet对象(工作表操作)</h2><p>title：表格的标题<br>max_row：表格的最大行<br>min_row：表格的最小行<br>max_column：表格的最大列<br>min_column：表格的最小列<br>rows：按行获取单元格(Cell对象) - 生成器<br>columns：按列获取单元格(Cell对象) - 生成器<br>values：按行获取表格的内容(数据) - 生成器</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实例化Worksheet对象</span></span><br><span class="line">worksheet = wb[<span class="string">'排序商品信息'</span>]</span><br></pre></td></tr></tbody></table></figure><h2 id="Cell对象（单元格）"><a href="#Cell对象（单元格）" class="headerlink" title="Cell对象（单元格）"></a>Cell对象（单元格）</h2><p>row：单元格所在的行<br>column：单元格坐在的列<br>value：单元格的值<br>coordinate：单元格的坐标</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实例化Cell对象</span></span><br><span class="line">cell = sheet[<span class="string">'B1'</span>]</span><br></pre></td></tr></tbody></table></figure><h1 id="docx模块处理Word文档"><a href="#docx模块处理Word文档" class="headerlink" title="docx模块处理Word文档"></a>docx模块处理Word文档</h1><p><a href="https://blog.csdn.net/weixin_44374471/article/details/100010360">https://blog.csdn.net/weixin_44374471/article/details/100010360</a></p><h2 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h2><h1 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h1><h2 id="Time库"><a href="#Time库" class="headerlink" title="Time库"></a>Time库</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time.time() <span class="comment">#获取当前时间戳（计算机内部时间）</span></span><br><span class="line"><span class="comment"># 1643336568.9237003</span></span><br><span class="line">time.ctime(time.time())  <span class="comment">#可以传入时间戳格式化时间</span></span><br><span class="line"><span class="comment">#'Sat Jan 29 15:21:48 2022'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.loaltime() <span class="comment">#本地时间  Sat Apr 16 22:34:40 2022</span></span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime()))  <span class="comment">#格式化时间</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>获取时间：</p><h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><p>time.strftime(tpl,ts)<br>    tpl：定义输出效果<br>    ts：struct_time元组</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,time.gmtime())</span><br><span class="line"><span class="comment">#'2022-01-28 03:04:00'</span></span><br><span class="line"></span><br><span class="line">time.strftime(<span class="string">"%a %b %d %H:%M:%S"</span>,time.gmtime())</span><br><span class="line"><span class="comment">#'Fri Jan 28 03:07:14'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="将格式化字符串转换为时间戳"><a href="#将格式化字符串转换为时间戳" class="headerlink" title="将格式化字符串转换为时间戳"></a>将格式化字符串转换为时间戳</h3><p>strptime(str,tpl)<br>    str:字符串形式的时间值<br>    tpl：定义输入效果</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timestr = <span class="string">'2022-01-28 03:04:00'</span></span><br><span class="line">                     </span><br><span class="line">time.strptime(timestr,<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">                     </span><br><span class="line"><span class="comment">#time.struct_time(tm_year=2022, tm_mon=1, tm_mday=28, tm_hour=3, tm_min=4, tm_sec=0, #tm_wday=4, tm_yday=28, tm_isdst=-1)</span></span><br></pre></td></tr></tbody></table></figure><h3 id="计时器功能"><a href="#计时器功能" class="headerlink" title="计时器功能"></a>计时器功能</h3><h2 id="datetime库"><a href="#datetime库" class="headerlink" title="datetime库"></a>datetime库</h2><p>datetime 基于 time 进行了封装，提供了更多实用的函数。</p><h3 id="date类"><a href="#date类" class="headerlink" title="date类"></a>date类</h3><p>只关注日期</p><h3 id="time类"><a href="#time类" class="headerlink" title="time类"></a>time类</h3><p>只关注时间</p><h3 id="datetime类"><a href="#datetime类" class="headerlink" title="datetime类"></a>datetime类</h3><p>同时有时间和日期</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">d=datetime.datetime.now()</span><br><span class="line">d.year</span><br><span class="line">d.month</span><br><span class="line">d.day</span><br><span class="line">d.hour</span><br><span class="line">d.minute</span><br><span class="line">d.second</span><br><span class="line">d.microsecond</span><br><span class="line">d.tzinfo</span><br><span class="line"> </span><br><span class="line">d.date() <span class="comment"># 返回 date 对象</span></span><br><span class="line">d.time() <span class="comment"># 返回 time 对象</span></span><br><span class="line">d.replace(name=value) <span class="comment"># 前面所述各项属性是 read-only 的，需要此方法才可更改</span></span><br><span class="line">d.timetuple() <span class="comment"># 返回time.struct_time 对象</span></span><br><span class="line">dattime.strftime(<span class="built_in">format</span>) <span class="comment"># 按照 format 进行格式化输出</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h3 id="timedelta类"><a href="#timedelta类" class="headerlink" title="timedelta类"></a>timedelta类</h3><p>主要用于计算时间跨度</p><h1 id="click命令行模块"><a href="#click命令行模块" class="headerlink" title="click命令行模块"></a>click命令行模块</h1><p>使用@click.command()装饰指定函数，使之成为命令行接口；<br>使用@click.argument()或者@click.option()装饰函数，为其添加命令行选项等。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> click </span><br><span class="line"><span class="comment"># 装饰器@click.command()会将函数包装成 click 对象</span></span><br><span class="line"><span class="meta">@click.command() </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    click.echo(<span class="string">"hello click"</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="打包跨平台可执行程序"><a href="#打包跨平台可执行程序" class="headerlink" title="打包跨平台可执行程序"></a>打包跨平台可执行程序</h2><p>通过click编写了简单的命令行方法后，还需要把.py文件转换成可以在控制台里运行的命令行程序。最简单的方法就是加上如下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == '__main__':</span><br><span class="line">    command()</span><br></pre></td></tr></tbody></table></figure><p>click支持使用setuptools来更好的实现命令行程序打包，把源码文件打包成系统中的可执行程序，并且不限平台。一般可通过在源码根目录下创建setup.py脚本，下面是一段简单的打包代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from setuptools import setup</span><br><span class="line">setup(</span><br><span class="line">    name='hello',</span><br><span class="line">    version='0.1',</span><br><span class="line">    py_modules=['hello'],</span><br><span class="line">    install_requires=[</span><br><span class="line">        'click',</span><br><span class="line">    ],</span><br><span class="line">    entry_points='''</span><br><span class="line">        [console_scripts]</span><br><span class="line">        hello=hello:cli</span><br><span class="line">    ''',</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>)<br>留意entry_points字段，在console_scripts下，每一行都是一个控制台脚本，等号左边的是脚本的名称，右边的是click命令的导入路径。</p><h1 id="PyScript"><a href="#PyScript" class="headerlink" title="PyScript"></a>PyScript</h1><p><a href="https://pyscript.net/">PyScript</a>是 Anaconda 团队开发的一个 Javascipt 库，可以在 HTML 标签里嵌入 Python 代码，无需服务端就可以运行 Python 代码。</p><h2 id="如何使用-PyScript"><a href="#如何使用-PyScript" class="headerlink" title="如何使用 PyScript"></a>如何使用 PyScript</h2><p>PyScript 使用以下三个主要组件在 html 中编写 Python：</p><p>py-env 定义了运行 Python 代码所需的包。<br>py-script 是在网页中编写 Python 代码的地方。<br>py-repl 创建一个 REPL（读取-评估-打印循环）组件，用于评估用户输入的代码并显示结果。</p><h1 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h1><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime   <span class="comment">#导入datetime模块中的datetime类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将时间戳转换为有用的时间格式。</span></span><br><span class="line">time = datetime.fromtimestamp(<span class="string">"传入时间戳"</span>)</span><br></pre></td></tr></tbody></table></figure><p><strong>程序运行时间</strong></p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> b_tuple:</span><br><span class="line">  aa = b_tuple[<span class="number">20000</span>]</span><br><span class="line">end_time = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Lookup time for TUPLE: "</span>, end_time - start_time)</span><br></pre></td></tr></tbody></table></figure><h1 id="random库"><a href="#random库" class="headerlink" title="random库"></a>random库</h1><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( random.randint(<span class="number">1</span>,<span class="number">10</span>) )        <span class="comment"># 产生 1 到 10 的一个整数型随机数  </span></span><br><span class="line"><span class="built_in">print</span>( random.randrange(<span class="number">1</span>,<span class="number">100</span>,<span class="number">2</span>) )   <span class="comment"># 生成从1到100的间隔为2的随机整数</span></span><br><span class="line"><span class="built_in">print</span>( random.random() )             <span class="comment"># 产生 0 到 1 之间的随机浮点数</span></span><br><span class="line"><span class="built_in">print</span>( random.uniform(<span class="number">1.1</span>,<span class="number">5.4</span>) )     <span class="comment"># 产生  1.1 到 5.4 之间的随机浮点数，区间可以不是整数</span></span><br><span class="line"><span class="built_in">print</span>( random.choice(<span class="string">'tomorrow'</span>) )   <span class="comment"># 从序列中随机选取一个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个字符中选取指定数量的字符组成新字符串：</span></span><br><span class="line"><span class="string">''</span>.join(random.sample([<span class="string">'z'</span>,<span class="string">'y'</span>,<span class="string">'x'</span>,<span class="string">'w'</span>,<span class="string">'v'</span>,<span class="string">'u'</span>,<span class="string">'t'</span>,<span class="string">'s'</span>,<span class="string">'r'</span>,<span class="string">'q'</span>,<span class="string">'p'</span>,<span class="string">'o'</span>,<span class="string">'f'</span>,<span class="string">'e'</span>,<span class="string">'d'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>], <span class="number">5</span>))     </span><br><span class="line">random.shuffle([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])  <span class="comment"># 将序列a中的元素顺序打乱</span></span><br></pre></td></tr></tbody></table></figure><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>文本文件：存储的是普通“字符”文本，默认为unicode字符集，可以使用记本事程序打开</p><p>二进制文件：把数据内容用“字节”进行存储，无法用记事本打开，必须使用专用的软件打开，举例：mp3音频文件，jpg图片。doc文档等<br>open(name[, mode[, buffering]])<br>参数：<br>    name : 一个包含了你要访问的文件名称的字符串值。<br>    mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</p><table><thead><tr><th>打开模式</th><th>描述</th></tr></thead><tbody><tr><td>r:</td><td>只读。这是<strong>默认模式</strong>。</td></tr><tr><td>r+:</td><td>用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>w:</td><td>只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>wb:</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>w+:</td><td>打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>wb+:</td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>a:</td><td>追加写入内容。如果该文件已存在，文件指针将会放在文件的结尾。新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>a+:</td><td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p>|ab+:|以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。|<br>|rb: |以二进制格式打开一个文件用于只读,默认模式。|<br>|ab:   | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。|<br>|rb+:|以二进制格式打开一个文件用于读写|</p><p>要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可<br>以二进制的形式读取，禁用encoding编码格式；读取时，不知道读多少</p><h2 id="with-open"><a href="#with-open" class="headerlink" title="with open"></a>with open</h2><p>wth语句可以自动管理上下文资源，不论什么原因跳出with，都能确保文件正确的关闭，以此来达到释放资源的目的</p><p>read()会一次性读取文件的全部内容，如果文件有20G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。<br>调用readline()可以每次读取一行内容，<br>调用readlines()一次读取所有内容并按行返回list。</p><p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：</p><p>file.write(str)   将字符串写入文件<br>file.writelines(strings)   将字符串序列写入文件</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'Hi.text'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">"Hello, there"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># with file.open(encoding='utf-8') as f:</span></span><br></pre></td></tr></tbody></table></figure><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p><strong>glob.glob</strong><br>同时返回所有匹配的文件路径列表。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取指定目录下的所有图片</span></span><br><span class="line"><span class="built_in">print</span> (glob.glob(<span class="string">r"/home/qiaoyunhao/*/*.png"</span>),<span class="string">"\n"</span>)<span class="comment">#加上r让字符串不转义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取上级目录的所有.py文件</span></span><br><span class="line"><span class="built_in">print</span> (glob.glob(<span class="string">r'../*.py'</span>)) <span class="comment">#相对路径</span></span><br></pre></td></tr></tbody></table></figure><h3 id="glob-iglob"><a href="#glob-iglob" class="headerlink" title="glob.iglob"></a>glob.iglob</h3><p>获取一个可编历对象，使用它可以逐个获取匹配的文件路径名。</p><h3 id="os-listdir-path"><a href="#os-listdir-path" class="headerlink" title="os.listdir(path)"></a>os.listdir(path)</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.listdir(path)  <span class="comment">#返回指定路径下所有文件名的列表。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="os-walk"><a href="#os-walk" class="headerlink" title="os.walk"></a>os.walk</h3><p>遍历文件夹后产生三个参数：<br>当前文件夹路径<br>包含文件夹名称[列表形式]<br>包含文件名称[列表形式]</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(<span class="string">r'C:\\Program Files (x86)'</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'打开文件夹<span class="subst">{dirpath}</span>'</span>) <span class="comment"># 当前文件夹路径 </span></span><br><span class="line">    <span class="keyword">if</span> dirnames:</span><br><span class="line">        <span class="built_in">print</span>(dirnames) <span class="comment"># 包含文件夹名称[列表形式] </span></span><br><span class="line">    <span class="keyword">if</span> filenames:</span><br><span class="line">        <span class="built_in">print</span>(filenames) <span class="comment"># 包含文件名称[列表形式]</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'-'</span> * <span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="os-scandir"><a href="#os-scandir" class="headerlink" title="os.scandir"></a>os.scandir</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = <span class="string">'.'</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.scandir(path): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"获取路径下文件名：<span class="subst">{file.name}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"获取路径下文件路径：<span class="subst">{file.path}</span>\n"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#2.</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"获取路径下文件名：<span class="subst">{file}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="目录操作os库"><a href="#目录操作os库" class="headerlink" title="目录操作os库"></a>目录操作os库</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">os.path.join()：  <span class="comment">#按照路径的方式拼接字符串</span></span><br><span class="line">os.rename(<span class="string">"要修改的目录名"</span>, <span class="string">"修改后的目录名"</span>)    <span class="comment">#重命名文件或目录，两个参数都要传入路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件不存在，创建文件</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(folder_path): </span><br><span class="line">    os.mkdir(folder_path)</span><br></pre></td></tr></tbody></table></figure><p><strong>shutil 模块</strong>(拷贝、删除、移动、压缩和解压)<br>shutil可以简单地理解为sh + util，shell工具的意思。shutil模块是对os模块的补充，主要针对文件的拷贝、删除、移动、压缩和解压操作。</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br></pre></td></tr></tbody></table></figure><h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><p>shutil会自动识别拷贝的到底是文件还是文件夹, 如果存在同名的文件将会自动进行覆盖。</p><p>shutil.copy($file_path, $dir_path)</p><h2 id="移动或重命名文件，但如果路径下已有重名的文件，将报错！"><a href="#移动或重命名文件，但如果路径下已有重名的文件，将报错！" class="headerlink" title="移动或重命名文件，但如果路径下已有重名的文件，将报错！"></a>移动或重命名文件，但如果路径下已有重名的文件，将报错！</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil </span><br><span class="line"></span><br><span class="line">shutil.move(<span class="string">r'.\practice.txt'</span>, <span class="string">r'.\文件夹1/'</span>)   <span class="comment"># 移动到另外一个文件夹中</span></span><br><span class="line">shutil.move(<span class="string">r'.\practice.txt'</span>, <span class="string">r'.\文件夹1/new.txt'</span>)    <span class="comment">#移动并重命名</span></span><br></pre></td></tr></tbody></table></figure><h2 id="拷贝文件夹-删除文件夹"><a href="#拷贝文件夹-删除文件夹" class="headerlink" title="拷贝文件夹/删除文件夹"></a>拷贝文件夹/删除文件夹</h2><p>shutil.copytree($file_path, $dir_path) # 拷贝所有文件到新的文件夹下，保持原有的文件结构。<br>shutil.rmtree($dir_path) # 删除此路径的文件夹</p><h2 id="生成压缩文件"><a href="#生成压缩文件" class="headerlink" title="生成压缩文件:"></a>生成压缩文件:</h2><p>shutil.make_archive(base_name, ‘gztar’, root_dir, [base_dir)<br>    base_name : 创建的目标文件名，包括路径，减去任何特定格式的扩展。<br>    format : 压缩包格式。”zip”, “tar”, “bztar”或”gztar”中的一个。<br>    root_dir : 需要打包的文件夹路径。打包完成时存储在上一级目录。<br>    base_dir : 使用后会将base_dir作为路径，解压后有个有层级的文件夹，而仅非只有单独的打包内容。</p><h2 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件:"></a>解压文件:</h2><p>shutil.unpack_archive(filename[, extract_dir[, format]])<br>    filename是压缩文档的完整路径<br>    extract_dir是解压缩路径，默认为当前目录。<br>    format是压缩格式。默认使用文件后缀名代码的压缩格式。”zip”, “tar”, “bztar”或”gztar”中的一个。</p><h2 id="pathlib模块"><a href="#pathlib模块" class="headerlink" title="pathlib模块"></a>pathlib模块</h2><p>多平台使用<br>对于多层文件夹的读取，用os模块只能一层一层读取出文件，要写多个for循环，效率不高，这时我们可以用 Path.glob(**/*) 大法，</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime   <span class="comment">#导入datetime模块中的datetime类</span></span><br><span class="line"></span><br><span class="line">p = Path(<span class="string">'E:\github\python\自动化\打开所有网址.py'</span>)    <span class="comment">#实例化Path对象(可传入绝对路径，当前目录下文件名)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"文件名:<span class="subst">{p.name}</span>"</span>)     </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"文件完整路径:<span class="subst">{p.resolve() }</span>"</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"文件后缀:<span class="subst">{p.suffix}</span>"</span>)     </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"文件前缀:<span class="subst">{p.stem}</span>"</span>)    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------------"</span>)</span><br><span class="line"><span class="built_in">print</span>(p.stat())            <span class="comment"># 获取文件详细信息</span></span><br><span class="line"><span class="built_in">print</span>(p.stat().st_size)    <span class="comment"># 文件的字节大小</span></span><br><span class="line"><span class="built_in">print</span>(p.stat().st_ctime)   <span class="comment"># 文件创建时间戳</span></span><br><span class="line"><span class="built_in">print</span>(p.stat().st_mtime)   <span class="comment"># 上次修改文件的时间戳</span></span><br><span class="line">creat_time = datetime.fromtimestamp(p.stat().st_ctime)</span><br><span class="line">st_mtime = datetime.fromtimestamp(p.stat().st_mtime)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'该文件创建时间：<span class="subst">{creat_time}</span>'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'上次修改该文件的时间：<span class="subst">{st_mtime}</span>'</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">p = Path(<span class="string">'E:\github\python\自动化\整理文件.ipynb'</span>)    <span class="comment">#实例化Path对象(可传入绝对路径，当前目录下文件名)</span></span><br><span class="line">p1 = Path .cwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"上级文件夹路径:<span class="subst">{p.parent}</span>"</span>) </span><br><span class="line"><span class="built_in">print</span>(p.parts)      <span class="comment"># 将路径通过分隔符分割成一个元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------------"</span>)</span><br><span class="line"><span class="comment"># 获取指定文件夹下所有文件和文件夹路径</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p1.iterdir():</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------------"</span>)</span><br><span class="line"><span class="comment"># 返回一个iterable 包含所有父目录</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p.parents:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"-------------------------"</span>)    </span><br><span class="line"><span class="comment"># 获取该文件目录下所有.py文件路径</span></span><br><span class="line">file_name = p1.glob(<span class="string">'**/*.py'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_name:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></tbody></table></figure><h1 id="web自动化selenium"><a href="#web自动化selenium" class="headerlink" title="web自动化selenium"></a>web自动化selenium</h1><h2 id="安装webdriver"><a href="#安装webdriver" class="headerlink" title="安装webdriver"></a>安装webdriver</h2><p>各大浏览器webdriver地址可参见：<a href="https://docs.seleniumhq.org/download/">https://docs.seleniumhq.org/download/</a><br>Firefox：<a href="https://github.com/mozilla/geckodriver/releases/">https://github.com/mozilla/geckodriver/releases/</a><br>Chrome：<a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a><br><strong>webdriver安装路径</strong><br>Win：复制webdriver到Python安装目录下<br>Mac：复制webdriver到/usr/local/bin目录下</p><h2 id="定位页面元素"><a href="#定位页面元素" class="headerlink" title="定位页面元素"></a>定位页面元素</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment">#定位一个元素</span></span><br><span class="line">ele = driver.find_element(By.XPATH,<span class="string">''</span>)</span><br><span class="line"><span class="comment">#表示定位一组元素(元素相同时使用)</span></span><br><span class="line">lis = driver.find_elements(By.XPATH,<span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(lis)&gt;<span class="number">0</span>:</span><br><span class="line">  lis[<span class="number">0</span>].click()</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'没有元素'</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="id-定位"><a href="#id-定位" class="headerlink" title="id 定位"></a>id 定位</h3><h3 id="name-定位"><a href="#name-定位" class="headerlink" title="name 定位"></a>name 定位</h3><h3 id="class-定位"><a href="#class-定位" class="headerlink" title="class 定位"></a>class 定位</h3><h3 id="link定位"><a href="#link定位" class="headerlink" title="link定位"></a>link定位</h3><p>find_element_by_link_text()<br>此种方法是专门用来定位文本链接的，</p><h3 id="partial-link定位："><a href="#partial-link定位：" class="headerlink" title="partial_link定位："></a>partial_link定位：</h3><p>find_element_by_partial_link_text()</p><p>有时候一个超链接的文本很长很长，我们如果全部输入，既麻烦，又显得代码很不美观，这时候我们就可以只截取一部分字符串，用这种方法模糊匹配了。</p><h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><p>xpath定位：find_element_by_xpath()</p><p>前面介绍的几种定位方法都是在理想状态下，有一定使用范围的，那就是：在当前页面中，每个元素都有一个唯一的id或name或class或超链接文本的属性，那么我们就可以通过这个唯一的属性值来定位他们。</p><p>但是在实际工作中并非有这么美好，有时候我们要定位的元素并没有id,name,class属性，或者多个元素的这些属性值都相同，又或者刷新页面，这些属性值都会变化。那么这个时候我们就只能通过xpath或者CSS来定位了。</p><p>xpath 是一种在 XML 文档中定位元素的语言，它拥有多种定位方式</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>...<span class="tag">&lt;<span class="name">head</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"csdn-toolbar"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-inside"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-container"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-container-left"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-container-middle"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-search onlySearch"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbar-search-container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"toolbar-search-input"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">placeholder</span>=<span class="string">"C++难在哪里？"</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>根据上面的标签需要定位 最后一行 input 标签，以下列出了四种方式，xpath 定位的方式多样并不唯一，使用时根据情况进行解析即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绝对路径（层级关系）定位  （绝对路径以/开头）</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"/html/body/div/div/div/div[2]/div/div/input[1]"</span>)</span><br><span class="line"><span class="comment"># 利用元素属性定位     （相对路径以//开头）</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*[@id='toolbar-search-input']"</span>))</span><br><span class="line"><span class="comment"># 层级+元素属性定位</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//div[@id='csdn-toolbar']/div/div/div[2]/div/div/input[1]"</span>)</span><br><span class="line"><span class="comment"># 逻辑运算符定位</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*[@id='toolbar-search-input' and @autocomplete='off']"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>1.相对路径+索引<br>先定位要找的元素，再找它唯一的父标签<br>2.相对路径+属性<br>3.相对路径+通配符定位<br>4.相对路径+部分属性值<br>5.相对路径+文本</p><h3 id="css-定位"><a href="#css-定位" class="headerlink" title="css 定位"></a>css 定位</h3><p>link 定位<br>partial_link 定位</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="下拉框的处理"><a href="#下拉框的处理" class="headerlink" title="下拉框的处理"></a>下拉框的处理</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--select标签--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">size</span>=<span class="string">"5"</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">tabindex</span>=<span class="string">"1"</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span> <span class="attr">tabindex</span>=<span class="string">"2"</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>河南<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line">ele = driver.find_element_by_name(<span class="string">"city"</span>)</span><br><span class="line"><span class="comment">#创建Select类对象</span></span><br><span class="line">sel = Select(ele)</span><br><span class="line">sel.select_by_value(<span class="string">"3"</span>)  </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="select类中的函数列表"><a href="#select类中的函数列表" class="headerlink" title="select类中的函数列表"></a>select类中的函数列表</h4><p>options    返回select元素所有的options<br>all_selected_options    返回select元素中所有已选中的选项<br>first_selected_option    返回select元素中选中的第一个选项<br>select_by_index(index)    通过索引定位，index索引是从“0”开始<br>select_by_value(value)    通过value属性值定位<br>select_by_visible_text(text)t    通过文本值定位，visible_text是在option标签中间的值，即显示在下拉框的值；<br>deselect_all()    取消全部的已选择项<br>deselect_by_index(index)    取消已选中的索引项<br>deselect_by_value(value)    取消已选中的value值<br>deselect_by_visible_text(text)    取消已选中的文本值</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>定位到元素后用.send_keys(r’文件路径’)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_name(<span class="string">"city"</span>).send_keys(<span class="string">r'文件路径'</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="处理弹窗"><a href="#处理弹窗" class="headerlink" title="处理弹窗"></a>处理弹窗</h3><p>alert(只有确定)，confirm(有确认和取消)，prompt(有确认取消还可以输入值)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#alert是一个属性</span></span><br><span class="line"><span class="comment">#创建一个alert对象</span></span><br><span class="line">ale = driver.switch_to.alert</span><br><span class="line"></span><br><span class="line"><span class="comment">#点击确定</span></span><br><span class="line">ale.accept()</span><br><span class="line"><span class="comment">#点击取消</span></span><br><span class="line">ale.dismiss() </span><br><span class="line"><span class="comment">#获得文本</span></span><br><span class="line">ale.text()</span><br><span class="line"><span class="comment">#输入值</span></span><br><span class="line">ale.send_keys()</span><br></pre></td></tr></tbody></table></figure><h2 id="设计模式（封装）"><a href="#设计模式（封装）" class="headerlink" title="设计模式（封装）"></a>设计模式（封装）</h2><p>pom(page object model)页面对象模式</p><p>分三层<br>1.基础层：base 主要放seleni原生的方法<br>2.页面对象层：主要用于放页面的元素和页面的动作<br>3.测试用例层:testcase存放测试用例，测试数据</p><p>页面对象层调用基础层的方法，测试用例层调用页面对象的方法</p><h1 id="UIautomation"><a href="#UIautomation" class="headerlink" title="UIautomation"></a>UIautomation</h1><p><a href="https://blog.csdn.net/MicalChen/article/details/120296341">https://blog.csdn.net/MicalChen/article/details/120296341</a><br>最新版uiautomation2.0目前只支持Python 3版本，依赖comtypes和typing这两个包，但不要使用3.7.6和3.8.1这两个版本，comtypes在这两个版本中不能正常工作。</p><h2 id="UIautomation环境搭建"><a href="#UIautomation环境搭建" class="headerlink" title="UIautomation环境搭建"></a>UIautomation环境搭建</h2><h2 id="界面元素定位"><a href="#界面元素定位" class="headerlink" title="界面元素定位"></a>界面元素定位</h2><p>常用的控件类<br>控件类支持的参数<br>常用方法<br>窗口相关方法<br>程序关闭与打开相关方法<br>组合框相关方法<br>鼠标事件<br>键盘事件<br>延时等待<br>滚动条<br>日志<br>粘贴板<br>控件判断相关方法<br>控件矩形坐标<br>截图方法</p><h1 id="pyautogui"><a href="#pyautogui" class="headerlink" title="# pyautogui"></a># pyautogui</h1><p>是一个非常强大的库，可以操作鼠标和键盘   基于坐标操作</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://mp.weixin.qq.com/s/6OJYwnzC1fHyOj_rBFIGxg</span></span><br><span class="line"><span class="comment"># https://zhuanlan.zhihu.com/p/302592540</span></span><br><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler <span class="comment"># 阻塞当前进程的调度器</span></span><br><span class="line"><span class="comment"># blocking类型调度器会阻塞当前进程，若你想要后台运行的调度器，可以使用以下代码：</span></span><br><span class="line"><span class="comment"># from apscheduler.schedulers.background import BackgroundScheduler</span></span><br><span class="line">pyautogui.PAUSE = <span class="number">1</span> <span class="comment"># 设置每一步操作的间隔（秒），可防止操作太快</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pyautogui.position()) <span class="comment"># 打印坐标，Point(x=148, y=879)</span></span><br><span class="line">icon_position = pyautogui.position() <span class="comment"># Point(x=148, y=879)</span></span><br></pre></td></tr></tbody></table></figure><h1 id="Tkinter库-内置GUI库"><a href="#Tkinter库-内置GUI库" class="headerlink" title="Tkinter库(内置GUI库)"></a>Tkinter库(内置GUI库)</h1><h2 id="窗口的创建和设置"><a href="#窗口的创建和设置" class="headerlink" title="窗口的创建和设置"></a>窗口的创建和设置</h2><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line">root=Tk()<span class="comment">#生成主窗口</span></span><br><span class="line">root.geometry(<span class="string">'250x250'</span>)<span class="comment">#改变窗体大小（‘宽x高’），注意是x不是*</span></span><br><span class="line">root.geometry(<span class="string">'+450+450'</span>)<span class="comment">#改变窗体位置（‘+横坐标+纵坐标’）</span></span><br><span class="line">root.title(<span class="string">'标题'</span>)<span class="comment">#修改框体的名字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root.mainloop()<span class="comment">#显示主窗口</span></span><br><span class="line"></span><br><span class="line">root.resizable(<span class="number">0</span>, <span class="number">0</span>)将窗口大小设置为不可变</span><br><span class="line">root.resizable(<span class="literal">False</span>, <span class="literal">False</span>)将窗口大小设置为不可变</span><br></pre></td></tr></tbody></table></figure><h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><h3 id="控件的共同属性"><a href="#控件的共同属性" class="headerlink" title="控件的共同属性"></a>控件的共同属性</h3><pre><code>cursor    鼠标移动到框架时，光标的形状(参数值：arrow[默认箭头], circle, cross[十字], plus，watch[圈圈转动]等）justify    显示多行文本的时候,设置不同行之间的对齐方式（参数值：LEFT, RIGHT, CENTER）bg (background)    背景颜色bd    加粗（默认 2 像素）    无fg (foreground)    前景颜色(字体颜色)padx    设置按钮文本与按钮边框x轴方向的距离pady    设置按钮文本与按钮边框y轴方向的距离state    设置按钮状态,参数值：NORMAL、ACTIVE、 DISABLED。默认 NORMALanchor    控制按钮文本的位置(参数值：S,W,E,N,SE,SW,NW,NE,CENTER,默认为CENTER)image    显示图像与PhotoImage 一起使用，图片只能为gif格式relief    三维效果 （参数值：FLAT、SUNKEN、RAISED、GROOVE、RIDGE。默认为 FLAT）bitmap    位图anchor    文本起始位置    CENTER(默认)，E,S,W,N,NE,SE,SW,NWbitmap    黑白二值图标    网上查找cursor    鼠标悬停光标    网上查找font    字体    无height    高（文本控件的单位为行，不是像素）    无width    宽(文本控件的单位为行，不是像素)    无</code></pre><h3 id="Label标签"><a href="#Label标签" class="headerlink" title="Label标签"></a>Label标签</h3><p>用来显示文字或图片<br>tkinter.Label(text=”文字”)</p><h3 id="Button按钮"><a href="#Button按钮" class="headerlink" title="Button按钮"></a>Button按钮</h3><p>类似标签,但提供额外的功能,例如鼠标掠过、按下、释放以及键盘操作、事件</p><p><strong>参数</strong><br>command :按钮关联的函数，当按钮被点击时，执行该函数</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">button=Button(root,command=绑定的函数,text=<span class="string">"转换温度"</span>)</span><br><span class="line">button.pack()</span><br></pre></td></tr></tbody></table></figure><h3 id="Entry单行文字域"><a href="#Entry单行文字域" class="headerlink" title="Entry单行文字域"></a>Entry单行文字域</h3><p>单行文字域用来收集键盘输入</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry=Entry(窗口对象)     <span class="comment">#创建Entry对象</span></span><br><span class="line">entry.pack()  <span class="comment">#显示 </span></span><br><span class="line">entry.get()   <span class="comment">#获取输入内容</span></span><br><span class="line">entry.config()   <span class="comment">#修改相应属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eventhandler</span>(<span class="params">event</span>):</span></span><br><span class="line">    entry.focus() <span class="comment">#(聚焦)文本框</span></span><br><span class="line">entry=Entry(root,bd=<span class="number">4</span>)</span><br><span class="line">entry.bind_all(<span class="string">'&lt;Control-f&gt;'</span>, eventhandler ) <span class="comment"># 绑定快捷键Ctrl-f</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Text多行文字区域"><a href="#Text多行文字区域" class="headerlink" title="Text多行文字区域"></a>Text多行文字区域</h3><pre><code>可用来收集(或显示)用户输入的文字</code></pre><h3 id="Listbox列表框："><a href="#Listbox列表框：" class="headerlink" title="Listbox列表框："></a>Listbox列表框：</h3><p>一个选项列表,用户可以从中选择</p><h3 id="Menu菜单"><a href="#Menu菜单" class="headerlink" title="Menu菜单"></a>Menu菜单</h3><p>点下菜单按钮后弹出的一个选项列表,用户可以从中选择<br>菜单栏(menu bar)、菜单(menu)、菜单项(menu item)<br><strong>菜单属性</strong><br>tearoff的作用就是可以将每个菜单分离出去，单独形成一个子窗口。默认是打开的状态1，通常将tearoff设置为0。<br>activebackground设置活动背景色。当鼠标移动到菜单选项上时，该菜单项的背景色。<br>activeforeground设置活动前景色。当鼠标移动到菜单选项上时，该菜单项文字显示的颜色。<br><strong>菜单方法</strong><br>add_command() 通常用于 给菜单添加普通的菜单项。<br>add_cascade() 通常用于 给menu对象添加一个瀑布菜单，点击menu对象就会弹出多个菜单项。<br>add_radiobutton() 给菜单添加radiobutton菜单项。<br>add_checkbutton() 给菜单添加checkbutton菜单项<br>add_separator() 给菜单添加分割线<br>add() 给菜单添加指定类型的菜单项，前面5中添加菜单项的方法其实都是在add函数的基础上做一个封装。<br>type() 查看菜单项的类型。通常菜单项的类型有”cascade”, “checkbutton”, “command”, “radiobutton”, “separator”, “tearoff”。</p><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><h3 id="Frame-框架-包含其他组件的纯容器"><a href="#Frame-框架-包含其他组件的纯容器" class="headerlink" title="Frame    框架    包含其他组件的纯容器"></a>Frame    框架    包含其他组件的纯容器</h3><h3 id="Checkbutton-选择按钮-一组方框-可以选择其中的任意个"><a href="#Checkbutton-选择按钮-一组方框-可以选择其中的任意个" class="headerlink" title="Checkbutton    选择按钮    一组方框,可以选择其中的任意个"></a>Checkbutton    选择按钮    一组方框,可以选择其中的任意个</h3><h3 id="Menubutton-菜单按钮-用来包含菜单的组件-有下拉式、层叠式等等"><a href="#Menubutton-菜单按钮-用来包含菜单的组件-有下拉式、层叠式等等" class="headerlink" title="Menubutton    菜单按钮    用来包含菜单的组件(有下拉式、层叠式等等)"></a>Menubutton    菜单按钮    用来包含菜单的组件(有下拉式、层叠式等等)</h3><h3 id="Message-消息框-类似于标签-但可以显示多行文本"><a href="#Message-消息框-类似于标签-但可以显示多行文本" class="headerlink" title="Message    消息框    类似于标签,但可以显示多行文本"></a>Message    消息框    类似于标签,但可以显示多行文本</h3><h3 id="Radiobutton-单选按钮-一组按钮-其中只有一个可被“按下”-类似-HTML-中的-radio"><a href="#Radiobutton-单选按钮-一组按钮-其中只有一个可被“按下”-类似-HTML-中的-radio" class="headerlink" title="Radiobutton    单选按钮    一组按钮,其中只有一个可被“按下” (类似 HTML 中的 radio)"></a>Radiobutton    单选按钮    一组按钮,其中只有一个可被“按下” (类似 HTML 中的 radio)</h3><h3 id="Scale-进度条-线性“滑块”组件-可设定起始值和结束值-会显示当前位置的精确值"><a href="#Scale-进度条-线性“滑块”组件-可设定起始值和结束值-会显示当前位置的精确值" class="headerlink" title="Scale    进度条    线性“滑块”组件,可设定起始值和结束值,会显示当前位置的精确值"></a>Scale    进度条    线性“滑块”组件,可设定起始值和结束值,会显示当前位置的精确值</h3><h3 id="Scrollbar-滚动条-对其支持的组件-文本域、画布、列表框、文本框-提供滚动功能"><a href="#Scrollbar-滚动条-对其支持的组件-文本域、画布、列表框、文本框-提供滚动功能" class="headerlink" title="Scrollbar    滚动条    对其支持的组件(文本域、画布、列表框、文本框)提供滚动功能"></a>Scrollbar    滚动条    对其支持的组件(文本域、画布、列表框、文本框)提供滚动功能</h3><h3 id="Toplevel-顶级-类似框架-但提供一个独立的窗口容器"><a href="#Toplevel-顶级-类似框架-但提供一个独立的窗口容器" class="headerlink" title="Toplevel    顶级    类似框架,但提供一个独立的窗口容器"></a>Toplevel    顶级    类似框架,但提供一个独立的窗口容器</h3><h3 id="弹窗messagebox"><a href="#弹窗messagebox" class="headerlink" title="弹窗messagebox"></a>弹窗messagebox</h3><p><code>from tkinter import messagebox</code></p><p>消息提示框    messagebox.showinfo(‘弹窗名称’,’弹窗内容 ‘)<br>消息警告框    messagebox.showwarning(‘弹窗名称’,’弹窗内容 ‘)<br>错误消息框    messagebox.showerror(‘弹窗名称’,’弹窗内容 ’ )<br>对话框    messagebox.askokcancel(‘弹窗名称’, ‘弹窗内容 ‘)    确定/取消，返回值true/false<br>对话框    messagebox.askquestion (‘弹窗名称’, ‘弹窗内容 ‘)    是/否，返回值yes/no<br>对话框    messagebox.askyesno (‘弹窗名称’,’弹窗内容 ‘)    是/否， 返回值true/false<br>对话框    messagebox.askretrycancel (‘弹窗名称’,’弹窗内容 ‘)    重试/取消，返回值true/false</p><h2 id="控件几何状态管理方法"><a href="#控件几何状态管理方法" class="headerlink" title="控件几何状态管理方法"></a>控件几何状态管理方法</h2><p>pack和grid请参考：<a href="https://www.jianshu.com/p/91844c5bca78">https://www.jianshu.com/p/91844c5bca78</a></p><h3 id="pack"><a href="#pack" class="headerlink" title="pack()"></a>pack()</h3><p>是一种简单的布局方法，如果不加参数的默认方式，将按布局语句的先后，以最小占用空间的方式自上而下地排列控件实例，并且保持控件本身的最小尺寸。</p><p>使用pack()方法可设置 fill、side 等属性参数。其中，参数fill 可取值：fill=X,fill=Y或fill=BOTH，分别表示允许控件向水平方向、垂直方向或二维伸展填充未被占用控件。参数 side 可取值：side=TOP(默认)，side=LEFT,side=RIGHT,side=BOTTOM,分别表示本控件实例的布局相对于下一个控件实例的方位。</p><p>Button(root,text=’A’).pack(side=LEFT,expand=YES,fill=Y)</p><h3 id="grid"><a href="#grid" class="headerlink" title="grid()"></a>grid()</h3><p>是基于网格的布局。先虚拟一个二维表格，再在该表格中布局控件实例。由于在虚拟表格的单元中所布局的控件实例大小不一，单元格也没有固定或均一的大小，因此其仅用于布局的定位。pack()方法与grid()方法不能混合使用。<br>grid()方法常用布局参数如下：</p><p>column: 控件实例的起始列，最左边为第0列。<br>columnspan: 控件实例所跨越的列数，默认为1列。<br>ipadx,ipady: 控件实例所呈现区域内部的像素数，用来设置控件实例的大小。<br>padx,pady: 控件实例所占据空间像素数，用来设置实例所在单元格的大小。<br>row: 控件实例的起始行，最上面为第0行。<br>rowspan: 控件实例的起始行数，默认为1行。</p><h3 id="place"><a href="#place" class="headerlink" title="place()"></a>place()</h3><p>根据控件实例在父容器中的绝对或相对位置参数进行布局。其常用布局参数如下：</p><p>x,y：控件实例在根窗体中水平和垂直方向上的其实位置（单位为像素）。注意，根窗体左上角为0,0,水平向右，垂直向下为正方向。</p><p>relx,rely：控件实例在根窗体中水平和垂直方向上起始布局的相对位置。即相对于根窗体宽和高的比例位置，取值在0.0~1.0之间。</p><p>height,width：控件实例本身的高度和宽度（单位为像素）。</p><p>relheight,relwidth：控件实例相对于根窗体的高度和宽度比例，取值在0.0~1.0之间。</p><p>利用place()方法配合relx,rely和relheight,relwidth参数所得的到的界面可自适应根窗体尺寸的大小。place()方法与grid()方法可以混合使用。</p><h1 id="图像处理库"><a href="#图像处理库" class="headerlink" title="图像处理库"></a>图像处理库</h1><h2 id="PIL，cv2，plt的使用与区别"><a href="#PIL，cv2，plt的使用与区别" class="headerlink" title="PIL，cv2，plt的使用与区别"></a>PIL，cv2，plt的使用与区别</h2><ol><li>建议使用opencv的库来进行图像处理的基本操作，数据格式为numpy，可以直接进行numpy的处理；</li><li>进行折线图这类图绘制的时候，一般使用matplotlib库。</li><li>Opencv默认为 BGR顺序，而其他软件（PIL、scopy.misc）一般使用RGB。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较三者的打开图片、显示图片、打开图片的类型</span></span><br><span class="line"><span class="comment"># ************PIL************</span></span><br><span class="line">PIL_img = Image.<span class="built_in">open</span>(<span class="string">'D:/images/Rimi.jpg'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(PIL_img))  <span class="comment"># &lt;class 'PIL.JpegImagePlugin.JpegImageFile'&gt;</span></span><br><span class="line"><span class="built_in">print</span>(PIL_img.size)   <span class="comment"># (1152, 720) (w,h)</span></span><br><span class="line"><span class="built_in">print</span>(np.array(PIL_img).shape)  <span class="comment"># (720, 1152, 3) (h,w,c)</span></span><br><span class="line">PIL_img.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ************cv2************</span></span><br><span class="line">cv2_img = cv2.imread(<span class="string">'D:/images/Rimi.jpg'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(cv2_img))  <span class="comment"># &lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line"><span class="built_in">print</span>(cv2_img.shape)  <span class="comment"># (720, 1152, 3) (h,w,c)</span></span><br><span class="line">cv2.imshow(<span class="string">'cv2'</span>, cv2_img)</span><br><span class="line"><span class="comment"># cv2.waitKey()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ************plt***********</span></span><br><span class="line">plt_img = plt.imread(<span class="string">'D:/images/Rimi.jpg'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(plt_img))  <span class="comment"># &lt;class 'numpy.ndarray'&gt;</span></span><br><span class="line"><span class="built_in">print</span>(plt_img.shape)  <span class="comment"># (720, 1152, 3) (h,w,c)</span></span><br><span class="line">plt.imshow(plt_img)  <span class="comment"># PIL_img也可以显示</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><p>OpenCV中已经包含如下应用领域功能：二维和三维特征工具箱、运动估算、人脸识别系统、姿势识别、人机交互、移动机器人、运动理解、对象鉴别、分割与识别、立体视觉、运动跟踪、增强现实（AR技术）。基于上述功能实现需要，OpenCV中还包括以下基于统计学机器学习库：Boosting算法、Decision Tree(决策树)学习、Gradient Boosting算法、EM算法(期望最大化)、KNN算法、朴素贝叶斯分类、人工神经网络、随机森林、支掌向量机。</p><p>cv2默认为 BGR顺序，而其他（PIL、scopy.misc）一般使用RGB</p><p>导入的时候采用 import cv2。</p><h3 id="基本库函数"><a href="#基本库函数" class="headerlink" title="基本库函数"></a>基本库函数</h3><p>cv2.imread(filepath,flags) #读入一张图像</p><p>filepath：要读入图片的完整路径<br>flags：读入图片的标志<br>cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道<br>cv2.IMREAD_GRAYSCALE：读入灰度图片<br>cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道</p><p>cv2.imshow(wname,img) #显示图像</p><p>第一个参数是显示图像的窗口的名字<br>第二个参数是要显示的图像（imread读入的图像），窗口大小自动调整为图片大小<br>cv2.imshow(‘image’,img) cv2.waitKey(0) #等待键盘输入，单位为毫秒，即等待指定的毫秒数看是否有键盘输入，若在等待时间内按下任意键则返回按键的ASCII码，程序继续运行。 #若没有按下任何键，超时后返回-1。参数为0表示无限等待。不调用waitKey的话，窗口会一闪而逝，看不到显示的图片。 cv2.destroyAllWindow() #销毁所有窗口 cv2.destroyWindow(wname) #销毁指定窗口</p><p>cv2.imwrite(file，img，num) #保存一张图像</p><p>第一个参数是要保存的文件名<br>第二个参数是要保存的图像。可选的第三个参数，它针对特定的格式：对于JPEG，其表示的是图像的质量，用0 - 100的整数表示，默认95。<br>第三个参数表示的是压缩级别。默认为3.<br>img.copy() #图像复制</p><p>cv2.cvtColor() #图像颜色空间转换</p><p>img2 = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY) #灰度化：彩色图像转为灰度图像<br>img3 = cv2.cvtColor(img,cv2.COLOR_GRAY2RGB) #彩色化：灰度图像转为彩色图像</p><h3 id="cv2-COLOR-X2Y，其中X-Y-RGB-BGR-GRAY-HSV-YCrCb-XYZ-Lab-Luv-HLS"><a href="#cv2-COLOR-X2Y，其中X-Y-RGB-BGR-GRAY-HSV-YCrCb-XYZ-Lab-Luv-HLS" class="headerlink" title="cv2.COLOR_X2Y，其中X,Y = RGB, BGR, GRAY, HSV, YCrCb, XYZ, Lab, Luv, HLS"></a>cv2.COLOR_X2Y，其中X,Y = RGB, BGR, GRAY, HSV, YCrCb, XYZ, Lab, Luv, HLS</h3><p>cv2.resize(image, image2,dsize) #图像缩放：(输入原始图像，输出新图像，图像的大小)<br>cv2.flip(img,flipcode) #图像翻转，flipcode控制翻转效果。</p><p>flipcode = 0：沿x轴翻转；flipcode &gt; 0：沿y轴翻转；flipcode &lt; 0：x,y轴同时翻转<br>cv2.warpAffine(img, M, (400, 600)) #图像仿射变换 ：平移；裁剪、剪切、旋转、仿射变换，<br>M、M_crop、M_shear、M_rotate</p><p>cv2.putText(img,’text’,(50,150) #图像添加文字：(照片，添加的文字，左上角坐标，字体，字体大小，颜色，字体粗细)</p><p>cv2.putText(image, caption, (b[0], b[1] - 10), cv2.FONT_HERSHEY_PLAIN, 1, (255, 0, 0), 1) cv2.putText(I,’there 0 error(s):’,(50,150),cv2.FONT_HERSHEY_COMPLEX,6,(0,0,255),25)</p><p>cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2) #画出矩行：img原图、(x，y)是矩阵的左上点坐标、(x+w，y+h)是矩阵的右下点坐标、(0,255,0)是画线对应的rgb颜色、2是所画的线的宽度。</p><p>cv2.boundingRect(img) #返回图像的四值属性：img是一个二值图，即是它的参数； 返回四个值，分别是x，y，w，h； x，y是矩阵左上点的坐标，w，h是矩阵的宽和高。</p><h2 id="PIL库"><a href="#PIL库" class="headerlink" title="PIL库"></a>PIL库</h2><p>PIL（Python Imaging Library）是Python常用的图像处理库，而Pillow是PIL的一个友好Fork，提供了了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。相比opencv更为轻巧。Image模块是在Python PIL图像处理中常见的模块，对图像进行基础操作的功能基本都包含于此模块内。如open、save、show等功能。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>#安装pillow<br>pip install pillow</p><p>from PIL import Image<br>Image 是 PIL 库中代表一个图像的类（对象）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1. 剪裁图像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">'./res/guido.jpg'</span>)</span><br><span class="line">rect = <span class="number">80</span>, <span class="number">20</span>, <span class="number">310</span>, <span class="number">360</span></span><br><span class="line">image.crop(rect).show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 生成缩略图</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">'./res/guido.jpg'</span>)</span><br><span class="line">size = <span class="number">128</span>, <span class="number">128</span></span><br><span class="line">image.thumbnail(size)</span><br><span class="line">image.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 缩放和黏贴图像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image1 = Image.<span class="built_in">open</span>(<span class="string">'./res/luohao.png'</span>)</span><br><span class="line">image2 = Image.<span class="built_in">open</span>(<span class="string">'./res/guido.jpg'</span>)</span><br><span class="line">rect = <span class="number">80</span>, <span class="number">20</span>, <span class="number">310</span>, <span class="number">360</span></span><br><span class="line">guido_head = image2.crop(rect)</span><br><span class="line">width, height = guido_head.size</span><br><span class="line">image1.paste(guido_head.resize((<span class="built_in">int</span>(width / <span class="number">1.5</span>), <span class="built_in">int</span>(height / <span class="number">1.5</span>))), (<span class="number">172</span>, <span class="number">40</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 旋转和翻转</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     image = Image.<span class="built_in">open</span>(<span class="string">'./res/guido.png'</span>)</span><br><span class="line">     image.rotate(<span class="number">180</span>).show()</span><br><span class="line">     image.transpose(Image.FLIP_LEFT_RIGHT).show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 操作像素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     image = Image.<span class="built_in">open</span>(<span class="string">'./res/guido.jpg'</span>)</span><br><span class="line">     <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">80</span>, <span class="number">310</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>, <span class="number">360</span>):</span><br><span class="line">          image.putpixel((x, y), (<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line"></span><br><span class="line">     image.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 滤镜效果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">'./res/guido.jpg'</span>)</span><br><span class="line">image.<span class="built_in">filter</span>(ImageFilter.CONTOUR).show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Matplotlib库"><a href="#Matplotlib库" class="headerlink" title="Matplotlib库"></a>Matplotlib库</h2><p>Matplotlib是一个Python 2D绘图库，它可以在不同的平台上以各种硬拷贝格式和交互环境生成发布质量数据。Matplotlib可以用于Python脚本、Python和IPython shell、Jupyter notebook、web应用服务器和四个图形用户界面工具包。对于简单的绘图，pyplot模块提供了一个类似于matlab的接口，特别是与IPython结合使用时。对于power用户，您可以通过面向对象的界面或通过MATLAB用户熟悉的一组函数来完全控制线样式、字体属性、轴属性等.</p><p>matplotlib.pylot是绘制各类可视化图形的命令字库</p><p>更多学习，可参考Matplotlib中文网：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn</a></p><p>#安装<br>pip install matplotlib<br>#导库<br>import matplotlib.pyplot as plt</p><h2 id="pyplot模块方法"><a href="#pyplot模块方法" class="headerlink" title="pyplot模块方法"></a>pyplot模块方法</h2><p>1.plt.imread(fname， format=None)<br>将图像从文件读取到数组中。返回一个numpy.array<br>  fname:<br>    要读取的图像文件：文件名、URL 或以读取二进制模式打开的类似文件的对象。<br>    不推荐传递 URL。请打开URL进行阅读并将结果传递给Pillow<br>  format:<br>    用于读取数据而假定的图像文件格式。如果格式设置为”png”，如果 fname 是扩展名为”.png”的路径或打开的文件，或者如果它是 URL，则图像将作为 PNG 文件加载。在所有其他情况下，格式将被忽略，PIL 会自动检测格式</p><p>2.plt.imshow(numpy.array)<br>将数据显示为图像<br>3.plt.show()<br>显示所有打开的图表</p><h1 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h1><h2 id="数学矩阵知识"><a href="#数学矩阵知识" class="headerlink" title="数学矩阵知识"></a>数学矩阵知识</h2><p><a href="https://paul.pub/the-matrix/#id-%E6%A0%87%E9%87%8F%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BC%A0%E9%87%8F">https://paul.pub/the-matrix/#id-%E6%A0%87%E9%87%8F%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BC%A0%E9%87%8F</a></p><h3 id="矩阵算术"><a href="#矩阵算术" class="headerlink" title="矩阵算术"></a>矩阵算术</h3><h4 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h4><p>矩阵的加减法只在两个矩阵具有相同大小时才有意义。</p><p>两个矩阵的加（减）法通过对应元素相加（减）得到</p><h4 id="标量乘法"><a href="#标量乘法" class="headerlink" title="标量乘法"></a>标量乘法</h4><p>设A为一矩阵，b为一标量，则bA为将A中的每一个元素乘以b而构成的一个矩阵</p><h4 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h4><p>矩阵的转置是以对角线为轴的镜像。</p><p>这条从左上角到右下角的对角线被称之为主对角线</p><h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>第一个矩阵的列要等于第二个矩阵的行，则两矩阵可以相乘。<br>一个m∗n的的A矩阵，和一个n∗p的B矩阵相乘，将得到一个m∗p的矩阵C</p><h3 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h3><p>逆(Inverse)<br>设A为n阶方阵，如果存在一个n阶方阵B，使得<br>AB=BA=In<br>AB=BA=In</p><p>则称A为可逆矩阵，B为A的逆阵，记作 B=A−1B=A−1<br>(A−1)−1=A(A−1)−1=A<br>(kA)−1=1kA−1(k≠0)(kA)−1=1kA−1(k≠0)<br>A、B均是同阶可逆矩阵，则(AB)−1=B−1A−1A、B均是同阶可逆矩阵，则(AB)−1=B−1A−1<br>(A−1)T=(AT)−1(A−1)T=(AT)−1</p><h4 id="求逆矩阵一般有三种方法。"><a href="#求逆矩阵一般有三种方法。" class="headerlink" title="求逆矩阵一般有三种方法。"></a>求逆矩阵一般有三种方法。</h4><p>1、方阵的逆矩阵等于方阵的伴随矩阵与方阵对应的行列式的值的倒数的积；</p><p>即A^-1=A*/(|A|).</p><p>只有当|A|≠0时，方阵A才可逆。</p><p>这种方法并不简便。</p><p>2、利用初等变换求逆矩阵；</p><p>一般是将矩阵(A,E)化为(E,A^-1)的形式；从而得到A逆矩阵；</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>为了创建一个2D（二维）数组，我们传递一个列表的列表（或者是一个序列的序列）给array()函数。如果我们想要一个3D（三维）数组，我们就要传递一个列表的列表的列表，如果是一个4D（四维）数组，那就是列表的列表的列表的列表，以此类推。</p><h3 id="多维数组切片"><a href="#多维数组切片" class="headerlink" title="多维数组切片"></a>多维数组切片</h3><p>通过对每个以逗号分隔的维度执行单独的切片，你可以对多维数组进行切片。因此，对于2D数组，我们的第一片定义了行的切片，第二片定义了列的切片。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>np.zeros():可以创建指定长度或者形状的全0数组</p><p>ones():可以创建指定长度或者形状的全1数组</p><p>empty():创建一个数组，其初始内容是随机的,取决于内存的状态</p><p>为了创建数字组成的数组，NumPy提供了一个类似于range的函数，该函数返回数组而不是列表。<br>array = np.arange( 10, 31,5 )   -&gt;array([10, 15, 20, 25, 30])</p><h3 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h3><p>array = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])</p><p>#数组维度<br>print(array.ndim)</p><p>#数组形状<br>print(array.shape)</p><p>#数组元素个数<br>print(array.size)</p><p>#数组元素类型<br>print(array.dtype)</p><h3 id="数组的计算"><a href="#数组的计算" class="headerlink" title="数组的计算"></a>数组的计算</h3><p>数组很重要，因为它可以使我们不用编写循环即可对数据执行批量运算。这通常叫做矢量化</p><h4 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h4><p>对应位置的数相运算</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">arr1 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">arr2 = np.ones([<span class="number">2</span>,<span class="number">3</span>],dtype=np.int64)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr1 + arr2)</span><br><span class="line"><span class="built_in">print</span>(arr1 - arr2)</span><br><span class="line"><span class="built_in">print</span>(arr1 * arr2)</span><br><span class="line"><span class="built_in">print</span>(arr1 / arr2)</span><br><span class="line"><span class="built_in">print</span>(arr1 ** <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>print(np.dot(arr3,arr4))</p><h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1><p>pandas是python第三方库，提供高性能易用数据类型和分析工具。</p><p>pandas基于numpy实现，常与numpy和matplotlib一同使用</p><p>更多学习，请参考pandas中文网：<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></p><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>Series是一种类似于一维数组的对象，它由一维数组（各种numpy数据类型）以及一组与之相关的数据标签（即索引）组成.</p><p>可理解为带标签的一维数组，可存储整数、浮点数、字符串、Python 对象等类型的数据。</p><p>Seris中可以使用index设置索引列表。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#与字典不同的是：Series允许索引重复</span></span><br><span class="line">s = pd.Series([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>],index=[<span class="number">100</span>,<span class="number">200</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">500</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Series 可以用字典实例化</span></span><br><span class="line">d = {<span class="string">'b'</span>: <span class="number">1</span>, <span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'c'</span>: <span class="number">2</span>}</span><br><span class="line">pd.Series(d)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过Series的values和index属性获取其数组表示形式和索引对象</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(s.values)</span><br><span class="line"><span class="built_in">print</span>(s.index)</span><br></pre></td></tr></tbody></table></figure><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>DataFrame是一个表格型的数据结构，类似于Excel或sql表</p><p>它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）<br>DataFrame可以进行行索引和列索引，它可以被看做由Series组成的字典（共用同一个索引）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用多维数组字典、列表字典生成 DataFrame</span></span><br><span class="line">data = {<span class="string">'state'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>], <span class="string">'year'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>], <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>]}</span><br><span class="line">frame = pd.DataFrame(data) </span><br><span class="line"><span class="built_in">print</span>(frame)</span><br><span class="line"></span><br><span class="line">frame2 = pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>, <span class="string">'debt'</span>], index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>])</span><br><span class="line"><span class="built_in">print</span>(frame2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#列可以通过赋值的方式进行修改,例如，给那个空的“delt”列赋上一个标量值或一组值</span></span><br><span class="line">frame2[<span class="string">'debt'</span>] = <span class="number">16.5</span></span><br><span class="line"><span class="built_in">print</span>(frame2)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程和线程&quot;&gt;&lt;a href=&quot;#进程和线程&quot; class=&quot;headerlink&quot; title=&quot;进程和线程&quot;&gt;&lt;/a&gt;进程和线程&lt;/h1&gt;&lt;p&gt;Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程</summary>
      
    
    
    
    <category term="python" scheme="https://wenkex.gitee.io/categories/python/"/>
    
    
    <category term="python" scheme="https://wenkex.gitee.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫学习</title>
    <link href="https://wenkex.gitee.io/2022/031717083.html"/>
    <id>https://wenkex.gitee.io/2022/031717083.html</id>
    <published>2022-03-16T23:56:59.000Z</published>
    <updated>2022-03-16T23:56:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络数据采集概述"><a href="#网络数据采集概述" class="headerlink" title="网络数据采集概述"></a>网络数据采集概述</h1><p>爬虫（crawler）也经常被称为网络蜘蛛（spider），是按照一定的规则自动浏览网站并获取所需信息的机器人程序（自动化脚本代码），被广泛的应用于互联网搜索引擎和数据采集。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接，网络爬虫正是通过网页中的超链接信息，不断获得网络上其它页面的地址，然后持续的进行数据采集。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为爬虫或者网络蜘蛛。</p><h2 id="爬虫的应用领域"><a href="#爬虫的应用领域" class="headerlink" title="爬虫的应用领域"></a>爬虫的应用领域</h2><p>爬虫的应用领域其实非常广泛，下面我们列举了其中的一部分</p><ol><li>搜索引擎</li><li>新闻聚合</li><li>社交应用</li><li>舆情监控</li><li>行业数据<h2 id="爬虫合法性探讨"><a href="#爬虫合法性探讨" class="headerlink" title="爬虫合法性探讨"></a>爬虫合法性探讨</h2></li></ol><p>经常听人说起“爬虫写得好，牢饭吃到饱”，那么编程爬虫程序是否违法呢？关于这个问题，我们可以从以下几个角度进行解读。</p><ol><li>网络爬虫这个领域目前还属于拓荒阶段，虽然互联网世界已经通过自己的游戏规则建立起了一定的道德规范，即 Robots 协议（全称是“网络爬虫排除标准”），但法律部分还在建立和完善中，也就是说，现在这个领域暂时还是灰色地带。</li><li>“法不禁止即为许可”，如果爬虫就像浏览器一样获取的是前端显示的数据（网页上的公开信息）而不是网站后台的私密敏感信息，就不太担心法律法规的约束，因为目前大数据产业链的发展速度远远超过了法律的完善程度。</li><li>在爬取网站的时候，需要限制自己的爬虫遵守 Robots 协议，同时控制网络爬虫程序的抓取数据的速度；在使用数据的时候，必须要尊重网站的知识产权（从Web 2.0时代开始，虽然Web上的数据很多都是由用户提供的，但是网站平台是投入了运营成本的，当用户在注册和发布内容时，平台通常就已经获得了对数据的所有权、使用权和分发权）。如果违反了这些规定，在打官司的时候败诉几率相当高。</li><li>适当的隐匿自己的身份在编写爬虫程序时必要的，而且最好不要被对方举证你的爬虫有破坏别人动产（例如服务器）的行为。</li><li>不要在公网（如代码托管平台）上去开源或者展示你的爬虫代码，这些行为通常会给自己带来不必要的麻烦。</li></ol><h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><p>下面我们先介绍一些开发爬虫程序的辅助工具，这些工具相信能帮助你事半功倍。</p><ol><li><p>Chrome Developer Tools：谷歌浏览器内置的开发者工具。该工具最常用的几个功能模块是：</p><ul><li>元素（ELements）：用于查看或修改 HTML 元素的属性、CSS 属性、监听事件等。CSS 可以即时修改，即时显示，大大方便了开发者调试页面。</li><li>控制台（Console）：用于执行一次性代码，查看 JavaScript 对象，查看调试日志信息或异常信息。控制台其实就是一个执行 JavaScript 代码的交互式环境。</li><li>源代码（Sources）：用于查看页面的 HTML 文件源代码、JavaScript 源代码、CSS 源代码，此外最重要的是可以调试 JavaScript 源代码，可以给代码添加断点和单步执行。</li><li>网络（Network）：用于 HTTP 请求、HTTP 响应以及与网络连接相关的信息。</li><li>应用（Application）：用于查看浏览器本地存储、后台任务等内容，本地存储主要包括Cookie、Local Storage、Session Storage等。</li></ul><p><img src="https://gitee.com/jackfrued/mypic/raw/master/20210824004034.png" alt="chrome-developer-tools"></p></li><li><p>Postman：功能强大的网页调试与 RESTful 请求工具。Postman可以帮助我们模拟请求，非常方便的定制我们的请求以及查看服务器的响应。</p><p><img src="https://gitee.com/jackfrued/mypic/raw/master/20210824004048.png" alt="postman"></p></li><li><p>HTTPie：命令行HTTP客户端。</p><p>安装。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install httpie</span><br></pre></td></tr></tbody></table></figure><p>使用。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http --header http --header https://movie.douban.com/</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Date: Tue, 24 Aug 2021 16:48:00 GMT</span><br><span class="line">Keep-Alive: timeout=30</span><br><span class="line">Server: dae</span><br><span class="line">Set-Cookie: bid=58h4BdKC9lM; Expires=Wed, 24-Aug-22 16:48:00 GMT; Domain=.douban.com; Path=/</span><br><span class="line">Strict-Transport-Security: max-age=15552000</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-DOUBAN-NEWBID: 58h4BdKC9lM</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>builtwith</code>库：识别网站所用技术的工具。</p><p>安装。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install builtwith</span><br></pre></td></tr></tbody></table></figure><p>使用。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> builtwith</span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line"><span class="built_in">print</span>(builtwith.parse(<span class="string">'http://www.bootcss.com/'</span>))</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>python-whois</code>库：查询网站所有者的工具。</p><p>安装。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install python-whois</span><br></pre></td></tr></tbody></table></figure><p>使用。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> whois</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(whois.whois(<span class="string">'https://www.bootcss.com'</span>))</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="爬虫的基本工作流程"><a href="#爬虫的基本工作流程" class="headerlink" title="爬虫的基本工作流程"></a>爬虫的基本工作流程</h2><h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><p>获取网页源代码</p><h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><p>获取网也源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。</p><p>由于网页的结构有一定的规侧，所以还有一些根据网页节点属性、CSS选择器或XPath来提取网顶信息的库，如Beautifu1Soup、<br>pyquery、1xm1等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。<br>提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。</p><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为TXT文本或json文本，也可以保存到数据库，如MySQL和MongoDB等，也可保存至远程服务器，如借助SFTP进行操作等。</p><h1 id="代理ip"><a href="#代理ip" class="headerlink" title="代理ip"></a>代理ip</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>代理实际上指的就是代理服务器，英文叫作proxy server，它的功能是代理网络用户去取得网络信息。形象地说，它是网络信息的中转站。在我们正常请求一个网站时，是发送了请求给Web服务器，Web服务器把响应传回给我们。如果设置了代理服务器，实际上就是在本机和服务器之间搭建了一个桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发出请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机。这样我们同样可以正常访问网页，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP了，就成功实现了IP伪装，这就是代理的基本原理。</p><h2 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h2><p>突破自身IP访问限制，访问一些平时不能访问的站点。<br>访问一些单位或团体内部资源：比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。<br>提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。<br>隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP，防止自身的IP被封锁。</p><h1 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h1><h2 id="添加请求头"><a href="#添加请求头" class="headerlink" title="添加请求头"></a>添加请求头</h2><p>在发起一个 HTTP 请求的时候，会有一个请求头 Request Headers，<br>如果不设置Request Headers 信息，某些网站会发现这不是一个正常的浏览器发起的请求，网站可能会返回异常的结果，导致网页抓取失败。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用 headers 参数来指定请求头</span><br><span class="line">headers = {</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36'</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">requests.get(url, headers=headers)</span><br></pre></td></tr></tbody></table></figure><h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><p>r = requests.get(url)<br>是构造一个向服务器请求资源的Request对象 ,返回一个包含服务器资源的Response对象。</p><h3 id="Response对象的方法"><a href="#Response对象的方法" class="headerlink" title="Response对象的方法"></a>Response对象的方法</h3><p>r.text()</p><h3 id="Response对象的属性"><a href="#Response对象的属性" class="headerlink" title="Response对象的属性"></a>Response对象的属性</h3><p>r.status_code： HTTP请求的返回状态，200表示连接成功，404表示失败<br>r.text： HTTP响应内容的字符串形式，即，url对应的页面内容</p><p>r.encoding：从HTTP header中猜测的响应内容编码方式</p><p>r.apparent_encoding：从内容中分析出的响应内容编码方式（备选编码方式）</p><p>r.content： HTTP响应内容的二进制形式</p><h2 id="抓取二进制数据"><a href="#抓取二进制数据" class="headerlink" title="抓取二进制数据"></a>抓取二进制数据</h2><p>图片、音频、视频这些文件本质上都是由二进制码组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests r = requests.get(<span class="string">'https://github.com/favicon.ico'</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'favicon.ico'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">   f.write(r.content)</span><br></pre></td></tr></tbody></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">files = {<span class="string">'file'</span>: <span class="built_in">open</span>(<span class="string">'favicon.ico'</span>, <span class="string">'rb'</span>)} </span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, files=files) </span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></tbody></table></figure><h2 id="获取和设置-Cookies"><a href="#获取和设置-Cookies" class="headerlink" title="获取和设置 Cookies"></a>获取和设置 Cookies</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="comment"># 获取</span></span><br><span class="line">r = requests.get(<span class="string">'http://www.baidu.com'</span>) </span><br><span class="line"><span class="comment"># 先调用 cookies 属性即可成功得到 Cookies，可以发现它是 RequestCookieJar 类型</span></span><br><span class="line"><span class="built_in">print</span>(r.cookies) </span><br><span class="line"><span class="comment"># 用 items 方法将其转化为元组组成的列表，遍历输出每一个 Cookie 的名称和值，实现 Cookie 的遍历解析。</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> r.cookies.items(): </span><br><span class="line">   <span class="built_in">print</span>(key + <span class="string">'='</span> + value)</span><br></pre></td></tr></tbody></table></figure><h2 id="Session维持"><a href="#Session维持" class="headerlink" title="Session维持"></a>Session维持</h2><p>在 requests 中，如果直接利用 get 或 post 等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的 Session，相当于你用两个浏览器打开了不同的页面。 设想这样一个场景，第一个请求利用 post 方法登录了某个网站，第二次想获取成功登录后的自己的个人信息，你又用了一次 get 方法去请求个人信息页面。实际上，这相当于打开了两个浏览器，是两个完全不 相关的 Session，能成功获取个人信息吗？当然不能。 有人会问，我在两次请求时设置一样的 Cookies 不就行了？可以，但这样做起来很烦琐，我们有更简单的解决方法。 解决这个问题的主要方法就是维持同一个 Session，相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但我又不想每次设置 Cookies，那该怎么办呢？这时候就有了新的利器 ——Session对象。 利用它，我们可以方便地维护一个 Session，而且不用担心 Cookies 的问题，它会帮我们自动处理好。</p><h1 id="Beautifulsoup"><a href="#Beautifulsoup" class="headerlink" title="Beautifulsoup"></a>Beautifulsoup</h1><p><a href="https://beautifulsoup.cn/">Beautiful Soup 4.4.0 文档</a><br>一个灵活又方便的HTML解析库，处理高效，支持多种解析器，利用它不使用正则表达式也能抓取网页内容。<br>from bs4 import BeautifulSoup</p><h2 id="BeautifulSoup对象"><a href="#BeautifulSoup对象" class="headerlink" title="BeautifulSoup对象"></a>BeautifulSoup对象</h2><p>Tag , NavigableString ,  , Comment .</p><h1 id="urlllib库"><a href="#urlllib库" class="headerlink" title="urlllib库"></a>urlllib库</h1><p>Python urllib 库用于操作网页 URL，并对网页的内容进行抓取处理。、</p><h2 id="request-打开和读取-URL。"><a href="#request-打开和读取-URL。" class="headerlink" title="request - 打开和读取 URL。"></a>request - 打开和读取 URL。</h2><p>urllib.request 定义了一些打开 URL 的函数和类，包含授权验证、重定向、浏览器 cookies等。</p><h3 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h3><p>urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)返回一个响应对象(respose)<br>   url：url 地址。<br>   data：发送到服务器的其他数据对象，默认为 None。<br>   timeout：设置访问超时时间。</p><p>然后使用 read() 函数获取网页的 HTML 实体代码。</p><h2 id="urllib-error-包含-urllib-request-抛出的异常。"><a href="#urllib-error-包含-urllib-request-抛出的异常。" class="headerlink" title="urllib.error - 包含 urllib.request 抛出的异常。"></a>urllib.error - 包含 urllib.request 抛出的异常。</h2><h2 id="urllib-parse-解析-URL。"><a href="#urllib-parse-解析-URL。" class="headerlink" title="urllib.parse - 解析 URL。"></a>urllib.parse - 解析 URL。</h2><h2 id="urllib-robotparser-解析-robots-txt-文件。"><a href="#urllib-robotparser-解析-robots-txt-文件。" class="headerlink" title="urllib.robotparser - 解析 robots.txt 文件。"></a>urllib.robotparser - 解析 robots.txt 文件。</h2><h1 id="json库"><a href="#json库" class="headerlink" title="json库"></a>json库</h1><p>JSON 的本质是字符串。</p><h2 id="json-dumps"><a href="#json-dumps" class="headerlink" title="json.dumps"></a>json.dumps</h2><h2 id="json-dump"><a href="#json-dump" class="headerlink" title="json.dump"></a>json.dump</h2><h2 id="json-loads"><a href="#json-loads" class="headerlink" title="json.loads"></a>json.loads</h2><p>将json字符串转换为python对象如字典</p><h2 id="json-load"><a href="#json-load" class="headerlink" title="json.load"></a>json.load</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络数据采集概述&quot;&gt;&lt;a href=&quot;#网络数据采集概述&quot; class=&quot;headerlink&quot; title=&quot;网络数据采集概述&quot;&gt;&lt;/a&gt;网络数据采集概述&lt;/h1&gt;&lt;p&gt;爬虫（crawler）也经常被称为网络蜘蛛（spider），是按照一定的规则自动浏览网站并获</summary>
      
    
    
    
    <category term="python" scheme="https://wenkex.gitee.io/categories/python/"/>
    
    
    <category term="爬虫" scheme="https://wenkex.gitee.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>matlab学习</title>
    <link href="https://wenkex.gitee.io/2022/031551719.html"/>
    <id>https://wenkex.gitee.io/2022/031551719.html</id>
    <published>2022-03-15T07:15:30.000Z</published>
    <updated>2022-03-15T07:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.w3cschool.cn/matlab/matlab-5use28gb.html">https://www.w3cschool.cn/matlab/matlab-5use28gb.html</a></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p><a href="https://www.w3cschool.cn/matlab/matlab-by7428gf.html">matlab常用命令</a></p><p>% 这是一行注释  ,ctrl +r  快捷注释</p><p>在命令行中，以逗号或分号分隔多条命令</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量名长度不超过63位<br>区分大小写<br>在使用变量之前，必须进行赋值。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MATLAB可以多个赋值</span><br><span class="line">`a = 2; b = 7; c = a * b`</span><br><span class="line"></span><br><span class="line">显示所有已经使用的变量名。</span><br><span class="line">who</span><br><span class="line"></span><br><span class="line">显示变量信息</span><br><span class="line">whos</span><br><span class="line"></span><br><span class="line">删除所有（或指定）从内存中的变量（S）。</span><br><span class="line">clear</span><br><span class="line">clear s</span><br></pre></td></tr></tbody></table></figure><h1 id="matlab数据类型"><a href="#matlab数据类型" class="headerlink" title="matlab数据类型"></a>matlab数据类型</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><p>单引号括起来</p><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p>Matlab中结构体数组与python中字典概念差不多，使用方法也类似</p><h3 id="直接定义"><a href="#直接定义" class="headerlink" title="直接定义"></a>直接定义</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">students.name = 'John';</span><br><span class="line">students.sex = 'Boy';</span><br><span class="line"></span><br><span class="line">%输出结果为 包含以下字段的 struct:</span><br><span class="line"></span><br><span class="line">name: 'John'</span><br><span class="line">sex: 'Boy'</span><br></pre></td></tr></tbody></table></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p><a href="https://blog.csdn.net/weixin_49167174/article/details/119939748">https://blog.csdn.net/weixin_49167174/article/details/119939748</a></p><h3 id="矩阵的规则"><a href="#矩阵的规则" class="headerlink" title="矩阵的规则"></a>矩阵的规则</h3><p>矩阵元素必须在”[ ]”内；</p><p>矩阵的同行元素之间用空格（或”,”）隔开；</p><p>矩阵的行与行之间用”;”（或回车符）隔开；</p><p>矩阵的元素可以是数值、变量、表达式或函数；</p><h3 id="利用函数创建矩阵"><a href="#利用函数创建矩阵" class="headerlink" title="利用函数创建矩阵"></a>利用函数创建矩阵</h3><p>(1) ones()函数：产生全为1的矩阵，ones(n)：产生n<em>n维的全1矩阵，ones(m,n)：产生m</em>n维的全1矩阵；</p><p>(2) zeros()函数：产生全为0的矩阵；</p><p>(3) rand()函数：产生在（0，1）区间均匀分布的随机阵；</p><p>(4) eye()函数：产生单位阵；</p><p>(5) randn()函数：产生均值为0，方差为1的标准正态分布随机矩阵。</p><p>冒号表达式<br>(初始值：步长：终止值）</p><p>linspace(a, b, n)产生行向量<br>（a：第一个元素, b：最后一个元素, n：元素总数）<br>若元素总数n省略，则自动默认产生100个元素</p><h3 id="矩阵元素的引用"><a href="#矩阵元素的引用" class="headerlink" title="矩阵元素的引用"></a>矩阵元素的引用</h3><p>1.通过下标引用矩阵元素：第几行，第几列</p><p>2.通过序号引用矩阵元素<br>在matlab中，矩阵的元素是按列存储的即首先存储第一列元素、第二列…一直到最后一列。</p><p>矩阵元素的序号就是矩阵元素在内存中的排列顺序。</p><h3 id="矩阵拆分"><a href="#矩阵拆分" class="headerlink" title="矩阵拆分"></a>矩阵拆分</h3><p>利用冒号表达式获得子矩阵：</p><p>(1) A(:,j)表示取A矩阵的第j列全部元素；A(i,:)表示A矩阵第i行的全部元素；A(i,j)表示取A矩阵第i行、第j列的元素。</p><p>(2) A(i:i+m,:)表示取A矩阵第i<del>i+m行的全部元素；A(:,k:k+m)表示取A矩阵第k</del>k+m列的全部元素，A(i:i+m,k:k+m)表示取A矩阵第i<del>i+m行内，并在第k</del>k+m列中的所有元素。此外，还可利用一般向量和end运算符来表示矩阵下标，从而获得子矩阵。end表示某一维的末尾元素下标。</p><p>利用空矩阵[]删除矩阵的元素：</p><p>在MATLAB中，定义[]为空矩阵。给变量X赋空矩阵的语句为X=[]。注意，X=[]与clear X不同，clear是将X从工作空间中删除，而空矩阵则存在于工作空间中，只是维数为0。</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><p>求矩阵的大小<br>size()</p><p>求矩阵某个元素的下标<br>[row,col]=find(a==5)</p><p>(下标变序号)<br>D=sub2ind(size(a),[I],[J])  I是行下标，J是列下标   </p><p>(序号变下标)<br>[I,J]=ind2sub(S,D)<br>D是序号   </p><h3 id="结构矩阵"><a href="#结构矩阵" class="headerlink" title="结构矩阵"></a>结构矩阵</h3><p>结构矩阵名.成员名=表达式</p><h2 id="元胞数组-cell"><a href="#元胞数组-cell" class="headerlink" title="元胞数组(cell)"></a>元胞数组(cell)</h2><p>是由可以包括任何数据类型的元胞组成的数组。也叫单元矩阵通过元胞数组的使用，可以在同一个变量中存储不同数据类型的数据。<br>单元矩阵元素用大括号括起来</p><p>当要将数据放入一个元胞数组中时，请使用元胞数组构造运算符 {} 创建该数组。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>function [输出参数列表] = 函数名（输入参数列表）</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h2 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h2><p>文件第一行必须以function开头，文件名字必须以函数名.m命名<br>function 应变量名= 函数名(自变量名)</p><h1 id="基本绘图函数"><a href="#基本绘图函数" class="headerlink" title="基本绘图函数"></a>基本绘图函数</h1><h2 id="点运算"><a href="#点运算" class="headerlink" title="点运算"></a>点运算</h2><p>点运算是处理元素之间的运算<br>矩阵计算和作图都是点运算</p><h2 id="plot"><a href="#plot" class="headerlink" title="plot()"></a>plot()</h2><p>plot(xn,yn,sn,…)<br>s参数为线型</p><p>如果 X 和 Y 均为矩阵，则它们的大小必须相同。plot 函数绘制 Y 的列对 X 的列的图。 </p><h2 id="subplot"><a href="#subplot" class="headerlink" title="subplot()"></a>subplot()</h2><p>分割figure，创建子坐标系<br>subplot（m,n,p）<br>m表示是图排成m行，n表示图排成n列，</p><h2 id="ezplot-f"><a href="#ezplot-f" class="headerlink" title="ezplot(f)"></a>ezplot(f)</h2><p>ezplot(f)  在默认区间[-2pi,2pi]上绘制函数f=f(x)     f 可以是定义函数的M文件名或者一个匿名函数或者一个字符串</p><h2 id="图形标注"><a href="#图形标注" class="headerlink" title="图形标注"></a>图形标注</h2><h3 id="1-title设置图像标题"><a href="#1-title设置图像标题" class="headerlink" title="1.title设置图像标题"></a>1.title设置图像标题</h3><h3 id="2-annotate标注文字"><a href="#2-annotate标注文字" class="headerlink" title="2.annotate标注文字"></a>2.annotate标注文字</h3><h3 id="3-text设置文字说明"><a href="#3-text设置文字说明" class="headerlink" title="3.text设置文字说明"></a>3.text设置文字说明</h3><p>在绘制图形时，可以对图形加上一些说明，如图形的名称、坐标轴说明以及图形某一部分的含义等，这些操作称为添加图形标注。<br>title(‘图的题目’)<br>xlabel(‘横轴的名称’)<br>ylabel(‘纵轴的名称’)<br>text(0.5,25,’说明示例’)</p><h2 id="坐标、图形和图层窗口控制"><a href="#坐标、图形和图层窗口控制" class="headerlink" title="坐标、图形和图层窗口控制"></a>坐标、图形和图层窗口控制</h2><p>在绘制图形时，Matlab可以自动根据要绘制曲线数据的范围选择合适的坐标刻度，使得曲线能够尽可能清晰的显示出来。所以，一般情况下用户不必选择坐标轴的刻度范围。但是，如果用户对坐标不满意，可以利用axis函数对其重新设定。</p><p>axis equal  %纵横坐标轴采用等长刻度<br>axis square %产生正方形坐标系（默认为矩形）<br>axis auto   %使用默认设置<br>axis off    %取消坐标轴<br>axis on     %显示坐标轴<br>grid on     %显示网格<br>grid off    %不显示网格<br>box on      %显示其他轴(上、右)<br>box off     %不显示其他轴(上、右)<br>hold on     %继续在同一图层绘图<br>figure(1)   %新生成一个图层</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.w3cschool.cn/matlab/matlab-5use28gb.html&quot;&gt;https://www.w3cschool.cn/matlab/matlab-5use28gb.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;常用命令&quot;</summary>
      
    
    
    
    <category term="学习" scheme="https://wenkex.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="matlab" scheme="https://wenkex.gitee.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>深度学习</title>
    <link href="https://wenkex.gitee.io/2022/030811061.html"/>
    <id>https://wenkex.gitee.io/2022/030811061.html</id>
    <published>2022-03-08T10:41:51.000Z</published>
    <updated>2022-03-08T10:41:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人工智能、机器学习、深度学习的关系"><a href="#人工智能、机器学习、深度学习的关系" class="headerlink" title="人工智能、机器学习、深度学习的关系"></a>人工智能、机器学习、深度学习的关系</h1><p>人工智能 &gt; 机器学习 &gt; 深度学习。</p><h2 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h2><p>神经网络需要用数据来训练，它从数据中获得信息，进而把它们转换成相应的权重。这些权重能够被提取出来，迁移到其他的神经网络中，我们“迁移”了这些学来的特征，就不需要从零开始训练一个神经网络了 </p><h2 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h2><p>预训练模型(pre-trained model)是前人为了解决类似问题所创造出来的模型。你在解决问题的时候，不用从零开始训练一个新模型，可以从在类似问题中训练过的模型入手。</p><p>当在训练经网络的时候我们的目标是什么？我们希望网络能够在多次正向反向迭代的过程中，找到合适的权重。</p><p>通过使用之前在大数据集上经过训练的预训练模型，我们可以直接使用相应的结构和权重，将它们应用到我们正在面对的问题上。这被称作是“迁移学习”，即将预训练的模型“迁移”到我们正在应对的特定问题中。</p><h2 id="实践平台"><a href="#实践平台" class="headerlink" title="实践平台"></a>实践平台</h2><p>如果学员想了解更多关于飞桨、深度学习、机器学习或Python课程，可以通过如下三个途径获取。</p><p>AI Studio：<a href="https://aistudio.baidu.com/">https://aistudio.baidu.com/</a><br>飞桨官网：<a href="https://www.paddlepaddle.org.cn/">https://www.paddlepaddle.org.cn/</a><br>百度技术学院：<a href="http://bit.baidu.com/index">http://bit.baidu.com/index</a></p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>机器学习是专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构，使之不断改善自身的性能。</p><p>机器学习的实现<br>机器学习的实现可以分成两步：训练和预测，类似于归纳和演绎：</p><p>归纳： 从具体案例中抽象一般规律，机器学习中的“训练”亦是如此。从一定数量的样本（已知模型输入XXX和模型输出YYY）中，学习输出YYY与输入XXX的关系（可以想象成是某种表达式）。<br>演绎： 从一般规律推导出具体案例的结果，机器学习中的“预测”亦是如此。基于训练得到的YYY与XXX之间的关系，如出现新的输入XXX，计算出输出YYY。通常情况下，如果通过模型计算的输出和真实场景的输出一致，则说明模型是有效的。</p><h1 id="预测问题"><a href="#预测问题" class="headerlink" title="预测问题"></a>预测问题</h1><p>对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。下面我们尝试用最简单的线性回归模型解决这个问题，并用神经网络来实现这个模型。</p><h1 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h1><p><img src="https://gitee.com/wenkex/blogimage/raw/master/img/%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B5%E6%AD%A5-2022-3-1813:21:11.png"></p><p>模型结构三要素<br>（模型假设、评价函数和优化算法）</p><h1 id="paddleHub工具"><a href="#paddleHub工具" class="headerlink" title="paddleHub工具"></a>paddleHub工具</h1><p>端到端的预训练模型管理与迁移学习工具<br>模型一键下载、管理、预测,十行代码完成迁移学习,一键自动超参搜索,一键模型服务化部署</p><p>精选效果优秀的算法，提供了百亿级大数据训练的预训练模型，方便用户不用花费大量精力从头开始训练<br>一个模型。</p><p>#安装 -i指定镜像源<br>pip install paddlehub -i <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br>#更新<br>pip install –upgrade paddlehub -i <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p><h1 id="自然语言处理-NLP"><a href="#自然语言处理-NLP" class="headerlink" title="自然语言处理(NLP)"></a>自然语言处理(NLP)</h1><h2 id="NLP-的4个典型应用"><a href="#NLP-的4个典型应用" class="headerlink" title="NLP 的4个典型应用"></a>NLP 的4个典型应用</h2><p>情感分析</p><p>聊天机器人</p><p>语音识别</p><p>机器翻译</p><h2 id="paddlenlp"><a href="#paddlenlp" class="headerlink" title="paddlenlp"></a>paddlenlp</h2><p>安装<br>pip install –upgrade paddlenlp<br><a href="https://aistudio.baidu.com/aistudio/projectdetail/3696243?channelType=0&amp;channel=0">https://aistudio.baidu.com/aistudio/projectdetail/3696243?channelType=0&amp;channel=0</a></p><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><p>分词作为许多NLP任务的第一道工序,Taskflow提供了多种中文分词模式供大家选择</p><h4 id="文档级输入"><a href="#文档级输入" class="headerlink" title="文档级输入"></a>文档级输入</h4><p>支持超长文本输入，无需担心『文本截断』问题</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次调用会有模型下载的额外时间开销</span></span><br><span class="line">seg = Taskflow(<span class="string">"word_segmentation"</span>)</span><br><span class="line"></span><br><span class="line">doc = <span class="string">"苏锦一直记得那个午后，明晃晃的光线穿过教室的窗玻璃洒到自己脸上，有种特别暖和的感觉。那阳光仿佛是能够钻进人的"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"1. 输入长度："</span>, <span class="built_in">len</span>(doc))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"2. 分词结果："</span>, seg(doc))</span><br></pre></td></tr></tbody></table></figure><h4 id="快速模式分词"><a href="#快速模式分词" class="headerlink" title="快速模式分词"></a>快速模式分词</h4><p>示例如何通过快速模式分词对数据集进行词频统计、构建词表</p><h4 id="精确模式分词"><a href="#精确模式分词" class="headerlink" title="精确模式分词"></a>精确模式分词</h4><h4 id="用户词典"><a href="#用户词典" class="headerlink" title="用户词典"></a>用户词典</h4><p>快速配置用户词典来对分词结果进行干预</p><h3 id="词性标注，，依存句法分析"><a href="#词性标注，，依存句法分析" class="headerlink" title="词性标注，，依存句法分析"></a>词性标注，，依存句法分析</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于百度词法分析工具LAC，训练语料包含近2200万句子，覆盖多种场景</span></span><br><span class="line"><span class="comment"># 词性标注</span></span><br><span class="line">tag = Taskflow(<span class="string">"pos_tagging"</span>)</span><br><span class="line"><span class="built_in">print</span>(tag(<span class="string">"第十四届全运会在西安举办"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="命名实体识别"><a href="#命名实体识别" class="headerlink" title="命名实体识别"></a>命名实体识别</h3><p>基于百度解语的精确模式：最全中文实体标签的命名实体识别工具</p><h4 id="精确模式"><a href="#精确模式" class="headerlink" title="精确模式"></a>精确模式</h4><p>基于百度解语的精确模式：最全中文实体标签的命名实体识别工具，不仅适用于通用领域，也适用于生物医疗、教育等垂类领域。包含66种词性及专名类别标签（同类产品的标签数是15个左右）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line">ner = Taskflow(<span class="string">"ner"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ner([<span class="string">"李伟拿出具有科学性、可操作性的《陕西省高校管理体制改革实施方案》"</span>, <span class="string">"诺戴商务咨询（上海）有限公司于2016年08月22日成立"</span>]))</span><br></pre></td></tr></tbody></table></figure><h4 id="快速模式"><a href="#快速模式" class="headerlink" title="快速模式"></a>快速模式</h4><p>基于百度词法分析工具LAC，训练语料包含近2200万句子，覆盖多种场景</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line">ner_fast = Taskflow(<span class="string">"ner"</span>, mode=<span class="string">"fast"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ner_fast(<span class="string">"三亚是一个美丽的城市"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="依存句法分析"><a href="#依存句法分析" class="headerlink" title="依存句法分析"></a>依存句法分析</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用BiLSTM作为编码器，速度最快</span></span><br><span class="line">ddp = Taskflow(<span class="string">"dependency_parsing"</span>)</span><br><span class="line"><span class="built_in">print</span>(ddp(<span class="string">"2月8日谷爱凌夺得北京冬奥会第三金"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 编码器部分将BiLSTM替换为ERNIE，模型准确率更高！</span></span><br><span class="line"><span class="comment"># ddp = Taskflow("dependency_parsing", model="ddparser-ernie-1.0")</span></span><br><span class="line"><span class="comment"># print(ddp("2月8日谷爱凌夺得北京冬奥会第三金"))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出概率值和词性标签</span></span><br><span class="line">ddp = Taskflow(<span class="string">"dependency_parsing"</span>, prob=<span class="literal">True</span>, use_pos=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ddp(<span class="string">"2月8日谷爱凌夺得北京冬奥会第三金"</span>))</span><br></pre></td></tr></tbody></table></figure><h3 id="定制化训练"><a href="#定制化训练" class="headerlink" title="定制化训练"></a>定制化训练</h3><p>利用自己的数据训练/微调模型，通过Taskflow一键装载并使用</p><h4 id="数据准备和训练"><a href="#数据准备和训练" class="headerlink" title="数据准备和训练"></a>数据准备和训练</h4><p><a href="https://github.com/PaddlePaddle/PaddleNLP/tree/develop/examples/sentiment_analysis/skep">参考PaddleNLP SKEP情感分析训练示例</a>完成数据准备和模型训练。</p><h4 id="使用定制化模型"><a href="#使用定制化模型" class="headerlink" title="使用定制化模型"></a>使用定制化模型</h4><p>通过task_path指定自定义模型路径一键加载即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> paddlenlp <span class="keyword">import</span> Taskflow</span><br><span class="line"></span><br><span class="line">my_senta = Taskflow(<span class="string">"sentiment_analysis"</span>, model=<span class="string">"skep_ernie_1.0_large_ch"</span>, task_path=<span class="string">"/home/aistudio/custom_model"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_senta(<span class="string">"不错的酒店,服务还可以,下次还会入住的~"</span>))</span><br></pre></td></tr></tbody></table></figure><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>人工神经网络包括多个神经网络层，如：卷积层、全连接层、LSTM等，每一层又包括很多神经元，超过三层的非线性神经网络都可以被称为深度神经网络。通俗的讲，深度学习的模型可以视为是输入到输出的映射函数，如图像到高级语义（美女）的映射，足够深的神经网络理论上可以拟合任何复杂的函数。因此神经网络非常适合学习样本数据的内在规律和表示层次，对文字、图像和语音任务有很好的适用性。这几个领域的任务是人工智能的基础模块，因此深度学习被称为实现人工智能的基础也就不足为奇了。</p><p>神经元： 神经网络中每个节点称为神经元，由两部分组成：<br>  加权和：将所有输入加权求和。<br>  非线性变换（激活函数）：加权和的结果经过一个非线性函数变换，让神经元计算具备非线性的能力。</p><p>多层连接： 大量这样的节点按照不同的层次排布，形成多层的结构连接起来，即称为神经网络。</p><p>前向计算： 从输入计算输出的过程，顺序从网络前至后。</p><p>计算图： 以图形化的方式展现神经网络的计算逻辑又称为计算图，也可以将神经网络的计算图以公式的方式表达：<br>Y=f3(f2(f1(w1⋅x1+w2⋅x2+w3⋅x3+b)+…)…)…)<br>​神经网络并没有那么神秘，它的本质是一个含有很多参数的“大公式”</p><h2 id="构建神经网络-深度学习模型的基本步骤"><a href="#构建神经网络-深度学习模型的基本步骤" class="headerlink" title="构建神经网络/深度学习模型的基本步骤"></a>构建神经网络/深度学习模型的基本步骤</h2><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>数据导入、</p><p>数据形状变换、</p><p>数据集划分、</p><p>数据归一化处理</p><p>封装load data函数</p><h4 id="图像和文本数据处理"><a href="#图像和文本数据处理" class="headerlink" title="图像和文本数据处理"></a>图像和文本数据处理</h4><h3 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h3><p>（模型要素1）网络结构设计，相当于模型假设空间，即模型能够表达的关系集合。</p><h3 id="训练配置"><a href="#训练配置" class="headerlink" title="训练配置"></a>训练配置</h3><p>模型要素2）设定模型采用的寻解方法，即优化器，并指定计算资源。<br>PS：神经网络学习的目的是寻找合适的参数，使得损失函数的值尽可能小。解决这个问题的过程为称为最优化。解决这个问题使用的算法叫做优化器。接触到的优化器有：随机梯度下降法（Stachastic gradient desent 简称 SGD）和AdaGrad </p><p>AdaGard主要是为了解决 SGD 遇到鞍点或者极小值点后学习变慢的问题。我们知道超参数学习率是一个很重要的参数，不同的参数对学习结果的影响很大，如果设置的值较小，会导致学习花费较多的时间，学习率大了就会导致学习发散而不能正常的进行。所以我们可以考虑避免人为的介入，根据需要让程序自己动态地设置学习率。例如对于遇到鞍点的情况，参数变化很小，基本不会改变，那么这个方法就会设置一个较大的学习率，跨过鞍点。</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>模型要素3）循环调用训练过程，每轮都包括前向计算、损失函数（优化目标）和后向传播三个步骤。</p><p>PS：前向计算是指把输入数据传入模型，然后得到输出；后向传播是指根据前向计算得到的输出通过梯度下降，从后向前优化网络中的参数。（因为梯度下降就是从后向前计算）</p><h3 id="模型保存"><a href="#模型保存" class="headerlink" title="模型保存"></a>模型保存</h3><p>将训练好的模型保存，模型预测是调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;人工智能、机器学习、深度学习的关系&quot;&gt;&lt;a href=&quot;#人工智能、机器学习、深度学习的关系&quot; class=&quot;headerlink&quot; title=&quot;人工智能、机器学习、深度学习的关系&quot;&gt;&lt;/a&gt;人工智能、机器学习、深度学习的关系&lt;/h1&gt;&lt;p&gt;人工智能 &amp;gt; </summary>
      
    
    
    
    <category term="工具" scheme="https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="深度学习" scheme="https://wenkex.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>django学习</title>
    <link href="https://wenkex.gitee.io/2022/030664874.html"/>
    <id>https://wenkex.gitee.io/2022/030664874.html</id>
    <published>2022-03-06T13:02:52.000Z</published>
    <updated>2022-03-06T13:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python 加 Django 是快速开发、设计、部署网站的最佳组合。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>pip install django -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</code></p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>在想要创建的文件夹中，进入终端<br>执行命令创建项目<code>'django-admin startproject 项目名称 </code></p><h1 id="项目文件介绍"><a href="#项目文件介绍" class="headerlink" title="项目文件介绍"></a>项目文件介绍</h1><p>manage.py  项目的管理，启动项目，创建app,数据管理<br>urls.py  url和函数的对应关系<br>asgi.py 和wsgi.py  接受网络请求</p><h1 id="创建一个app"><a href="#创建一个app" class="headerlink" title="创建一个app"></a>创建一个app</h1><p>python manage.py startapp 名称 </p><h1 id="Uvicorn-运行-django"><a href="#Uvicorn-运行-django" class="headerlink" title="Uvicorn 运行 django"></a>Uvicorn 运行 django</h1><p>django 内置的开发服务器在修改代码后的热重载非常缓慢，我发现 uvicorn 的重载速度要快得多，所以新项目第一件事，就是使用在开发环境下使用 uvicorn 运行 django。</p><p>首先当然要安装 uvicorn。<br><code>pip install uvicorn</code></p><p>Uvicorn 安装好后，可以在命令行使用 uvicorn 命令来运行 django。但是，每次输命令启动 django 会非常麻烦！最好的做法是创建一个脚本，启动 django 只需要执行脚本就可以了。</p><p>在 项目根目录 创建一个 run_uvicorn.py 的脚本（脚本名可以自己随便取），代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"mysite.settings"</span>)</span><br><span class="line">    uvicorn.run(</span><br><span class="line">        <span class="string">"mysite.asgi:application"</span>,</span><br><span class="line">        host=<span class="string">"0.0.0.0"</span>,</span><br><span class="line">        port=<span class="number">8000</span>,</span><br><span class="line">        log_level=<span class="string">"debug"</span>,</span><br><span class="line">        reload=<span class="literal">True</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>运行脚本后，应用已在 8000 端口启动，现在访问 localhost:8000，可以看到熟悉的 django 项目初始页面。</p><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>views.py  写函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python 加 Django 是快速开发、设计、部署网站的最佳组合。&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;&lt;code&gt;pip install django -i</summary>
      
    
    
    
    <category term="python" scheme="https://wenkex.gitee.io/categories/python/"/>
    
    
    <category term="web" scheme="https://wenkex.gitee.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://wenkex.gitee.io/2022/022615691.html"/>
    <id>https://wenkex.gitee.io/2022/022615691.html</id>
    <published>2022-02-26T12:50:16.000Z</published>
    <updated>2022-02-26T12:50:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用linux的好处"><a href="#使用linux的好处" class="headerlink" title="使用linux的好处"></a>使用linux的好处</h1><p><a href="https://mp.weixin.qq.com/s/MP6gWfkyKaBLNCpEOHhk_g">使用linux的好处</a><br>在 linux 下，apt install 或者 yum install 之类的命令，就能搞定整个软件安装。</p><p>Linux 不需要选择软件是放 c 盘还是 d 盘，已经定义好了哪些文件该放在哪些地方，<br>不需要杀毒软件，不需要清理垃圾，不需要释放内存，不需要激活系统，它是开源免费的，不需要磁盘优化，没有烦人的弹窗，没有强制更新。</p><h1 id="linux环境"><a href="#linux环境" class="headerlink" title="linux环境"></a>linux环境</h1><h2 id="VMware搭建linux"><a href="#VMware搭建linux" class="headerlink" title="VMware搭建linux"></a>VMware搭建linux</h2><p><strong>安装Vmware Tools工具。</strong><br>可以为虚拟机提供更好的显卡性能（游戏玩家最爱的）<br>同步物理主机时间<br>自动捕获和释放鼠标光标（不用按下Ctrl + Alt键来释放鼠标）<br>实现物理主机和虚拟机或者虚拟机和虚拟机之间进行复制和粘贴操作（文件传输）<br>点击Vmware Workstation 菜单栏的“虚拟机”点击“安装 Vmware Tools（T）</p><p><strong>设置虚拟机快照。</strong><br>虚拟机的快照可以把当前虚拟机的状态保存下来，方便以后可以还原到这个状态，理论上快照可以设置很多个，但是设置过多的快照会影响虚拟机的性能，并在会增大物理磁盘的存储空间，快照的常见的应用是：安装大型专业软件时，害怕安装失败，那么在安装之前设置一个快照，方面以后还原虚拟机的状态，重新测试安装软件，或者是在虚拟机设置一系列很复杂的系统配置，担心设置不成功，那么在设置之前可以做一个快照，万一配置系统不顺，可以还原到快照之前的状态，重新做配置。</p><p><strong>虚拟机网络的使用网络模式：</strong><br><strong>映射网络驱动器</strong><br><strong>虚拟机的克隆</strong><br>克隆虚拟机可以把一个虚拟机复制成多个虚拟机，那么就不用重新安装虚拟机了，克隆虚拟机需要在虚拟机关机的状态下进行，在虚拟机关机的情况下，右键虚拟机》管理》克隆<br><strong>通过Vmware导出虚拟机</strong><br>有时候，我们设置好的虚拟机需要在其他电脑上面使用，那么可以使用虚拟机迁移功能，把自己电脑的虚拟机，导出，再到其他电脑上面使用Vmware Workstation进行导入（版本最好一致） 在菜单栏点击“文件”》点击“导出为OVF（E）…”</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>虚拟机VMware中的CentOS字符命令界面和图形界面切换</strong><br>ctrl+f1   ctrl+f2</p><h3 id="VMWare-和-Hyper-V-共存"><a href="#VMWare-和-Hyper-V-共存" class="headerlink" title="VMWare 和 Hyper-V 共存"></a>VMWare 和 Hyper-V 共存</h3><p>将 Windows 版本升级到 Windows 10 20H1 或更高版本。<br>将 VMWare Workstation/Player 升级到 15.5.5 或更高版本<br>在安装时，勾选“自动安装 Windows Hypervisor Platform (WHP)”。<br>打开虚拟机的设置选项，找到“处理器”，去掉如图所示的三个选项前面的钩，点击“确定”</p><h3 id="网络连接方式"><a href="#网络连接方式" class="headerlink" title="网络连接方式"></a>网络连接方式</h3><p>NAT模式（默认）：网络地址转换方式，linux可以访问外网，不会造成ip冲突</p><p>桥接模式：可以与其它系统进行通信，但可能造成ip冲突</p><p>主机模式：你的Linux是一个独立的主机，不能访问外网</p><h2 id="WSL2搭建Linux"><a href="#WSL2搭建Linux" class="headerlink" title="WSL2搭建Linux"></a>WSL2搭建Linux</h2><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/">官方文档</a><br>WSL2采用在Hyper-V虚拟机中运行的方案,实现了与 windows 的高度集成,wsl2 的开启速度有了非常明显的提升，几乎无需等待。</p><p>启用适用于 Linux 的 Windows 子系统</p><p><code>dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</code></p><p>启用虚拟机平台功能</p><p><code>dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</code></p><p>以管理者模式进入cmd安装<br><code>wsl --install</code> </p><p>切换WSL的默认版本为WSL2。<br><code>wsl --set-default-version 2 </code></p><p>以管理者cmd进行更新操作<br><code>wsl --update</code> </p><p>重启，更新才能生效<br><code>wsl --shutdown</code></p><p>Microsoft Store 中找一个 Linux 发行版进行安装</p><p>查看系统版本<br><code>wsl -l -v</code></p><h3 id="修改默认安装目录"><a href="#修改默认安装目录" class="headerlink" title="修改默认安装目录"></a>修改默认安装目录</h3><p>命令格式：wsl –import <distributionname>  &lt;文件位置&gt; &lt;安装位置&gt;  </distributionname></p><ol><li>查看已安装的linux发行版本<br> <code>wsl -l --all -v</code></li><li> 导出分发版为tar文件到d盘<br><code>wsl --export Ubuntu-20.04 D:\data\WSL2\Ubuntu-20.04.tar</code></li><li>注销当前分发版<br><code>wsl --unregister Ubuntu-20.04</code></li><li>重新导入并安装WSL在D盘<br><code>wsl --import Ubuntu-20.04 D:\data\WSL2\Ubuntu-20.04 D:\data\WSL2\Ubuntu-20.04.tar --version 2 </code></li><li>设置默认登陆用户为安装时用户名<br><code>ubuntu config --default-user USERNAME</code></li><li>删除wsl-ubuntu20.04.tar<br><code>del d:\wsl-ubuntu.tar</code></li></ol><h3 id="设置-Linux-用户名和密码"><a href="#设置-Linux-用户名和密码" class="headerlink" title="设置 Linux 用户名和密码"></a>设置 Linux 用户名和密码</h3><p>若要更改或重置密码，请打开 Linux 发行版并输入命令：<code>passwd</code><br>如果忘记了 Linux 分发版的密码：<br>1.请打开 PowerShell，并使用以下命令进入默认 WSL 分发版的根目录：wsl -u root</p><p>如果需要在非默认分发版中更新忘记的密码，请使用命令：wsl -d Debian -u root，并将 Debian 替换为目标分发版的名称。</p><p>2.在 PowerShell 内的根级别打开 WSL 发行版后，可使用此命令更新密码：passwd <username>，其中 <username> 是发行版中帐户的用户名，而你忘记了它的密码。</username></username></p><h3 id="关闭WSL2"><a href="#关闭WSL2" class="headerlink" title="关闭WSL2"></a>关闭WSL2</h3><p>WSL2实际上是在虚拟机中运行。我们一旦进入WSL2 Linux的命令行，虚拟机会自动启动运行。如果我们查看任务管理器，会发现一个Vmmem进程,它比较占内存。不使用WSL2的时候我们可以关闭它以节省内存。关闭WSL2 Linux的方法如下。使用管理员打开CMD，运行：<code>wsl --shutdown</code></p><h3 id="为发行版linux更换国内源"><a href="#为发行版linux更换国内源" class="headerlink" title="为发行版linux更换国内源"></a>为发行版linux更换国内源</h3><p><a href="https://blog.csdn.net/weixin_41529012/article/details/117226884">https://blog.csdn.net/weixin_41529012/article/details/117226884</a></p><p>打开\wsl.localhost\Ubuntu\etc\apt地址下的sources.list文件，更改国内源<br>中科大</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade  #更新镜像源列表</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="使用vscode操作wsl"><a href="#使用vscode操作wsl" class="headerlink" title="使用vscode操作wsl"></a>使用vscode操作wsl</h3><p>在window的vscode上安装Remote Development扩展包<br>包括Remote - SSH ， Remote - Containers ，Remote - WSL扩展</p><p>Remote - WSL 扩展：使你能够打开容器中、远程计算机上或 WSL 中的任何文件夹。</p><h4 id="打开-WSL-项目"><a href="#打开-WSL-项目" class="headerlink" title="打开 WSL 项目"></a>打开 WSL 项目</h4><p>1.从 WSL 发行版打开项目，请打开发行版的命令行并输入：code .</p><p>2.从 VS Code 中打开项目，通过使用 VS Code 中的快捷方式 CTRL+SHIFT+P 调出命令面板，以访问更多 VS Code 远程选项。 如果随后键入 Remote-WSL，将看到可用的 VS Code 远程选项列表，使你可以在远程会话中重新打开文件夹，指定要在哪个发行版中打开，等等。</p><h3 id="wsl安装Docker"><a href="#wsl安装Docker" class="headerlink" title="wsl安装Docker"></a>wsl安装Docker</h3><p>1.下载 <a href="https://docs.docker.com/desktop/windows/wsl/">Docker Desktop</a> 并按照安装说明进行操作。</p><p>2.安装后，从 Windows 开始菜单启动 Docker Desktop，然后从任务栏的隐藏图标菜单中选择 Docker 图标。 右键单击该图标以显示 Docker 命令菜单，然后选择“设置”。</p><p>3.确保在“设置”“常规”中选中“使用基于 WSL 2 的引擎”。</p><p>4.通过转到“设置”“资源”“WSL 集成”，从要启用 Docker 集成的已安装 WSL 2 发行版中进行选择。</p><p>5.若要确认已安装 Docker，请打开 WSL 发行版（例如 Ubuntu），并通过输入 docker –version 来显示版本和内部版本号</p><h2 id="linux云服务器"><a href="#linux云服务器" class="headerlink" title="linux云服务器"></a>linux云服务器</h2><p><a href="https://developer.aliyun.com/article/767041">云服务器可以做什么</a></p><p>云服务器（Elastic Compute Service, 简称ECS），是一种简单高效，处理能力可以弹性伸缩的计算服务。ECS的相关术语说明如下：</p><p>实例（Instance）：是一个虚拟的计算环境，由CPU、内存、系统盘和运行的操作系统组成；ECS实例作为云服务器最为核心的概念，其他资源，比如磁盘、IP、镜像、快照等，只有与ECS结合后才具有使用意义。</p><p>地域（Region）：指ECS实例所在的物理位置。地域内的ECS实例内网是互通的，不同的地域之间ECS实例内网不互通。</p><p>可用区（Zone）：指在同一地域内，电力和网络互相独立的物理区域。</p><p>磁盘（Disk）：是为ECS实例提供数据块级别的数据存储。可以分为4类： 普通云盘、SSD云盘、高效云盘和本地SSD磁盘</p><p>快照（Snapshot）：是某一个时间点上某个磁盘的数据拷贝。</p><p>镜像（Image）：是ECS实例运行环境的模板，一般包括操作系统和预装的软件。</p><p>安全组（Security Group）：是一种虚拟防火墙，具备状态检测包过滤功能。每个实例至少属于一个安全组。同一个安全组内的实例之间网络互通，不同安全组的实例之间默认内网不通，但是可以授权两个安全组之间互访。</p><h3 id="虚拟主机、ECS云服务器、VPS区别汇总"><a href="#虚拟主机、ECS云服务器、VPS区别汇总" class="headerlink" title="虚拟主机、ECS云服务器、VPS区别汇总"></a>虚拟主机、ECS云服务器、VPS区别汇总</h3><p>1、虚拟主机</p><p>虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。</p><p>2、VPS</p><p>先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。</p><p>3、ECS云服务器</p><p>现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下：<br><img src="https://gitee.com/wenkex/blogimage/raw/master/img/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E3%80%81ECS%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81VPS%E5%8C%BA%E5%88%AB-2022-3-1809:16:23.png"></p><h3 id="使用VScode连接阿里云远程服务器"><a href="#使用VScode连接阿里云远程服务器" class="headerlink" title="使用VScode连接阿里云远程服务器"></a>使用VScode连接阿里云远程服务器</h3><p>安装Remote-ssh插件<br>在云服务器控制台选择安全组配置，加入ssh(22)的端口</p><h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>常见的 Shell 有 sh、bash、csh、tcsh、ash 等。<br>#!/bin/bash是指此脚本使用/bin/bash来解释执行。<br>脚本文件后缀是.sh<br><a href="https://mp.weixin.qq.com/s/A_K9Uikkq6OHHthj1EIbVQ">100个shell脚本</a></p><h1 id="linux使用"><a href="#linux使用" class="headerlink" title="linux使用"></a>linux使用</h1><h2 id="linux文件目录理解"><a href="#linux文件目录理解" class="headerlink" title="linux文件目录理解"></a>linux文件目录理解</h2><h3 id="home"><a href="#home" class="headerlink" title="/home"></a>/home</h3><p>存放所有用户文件的根目录，是用户主目录的基点</p><p>比如用户user的主目录就是/home/user，可以用~user表示</p><h3 id="usr"><a href="#usr" class="headerlink" title="/usr"></a>/usr</h3><p>用于存放系统应用程序，可以理解为C:/Windows/ </p><h4 id="usr-local"><a href="#usr-local" class="headerlink" title="/usr/local"></a>/usr/local</h4><p>用户级的程序目录，可以理解为C:/Progrem Files/</p><p>用户自己编译的软件默认会安装到这个目录下</p><p>本地系统管理员软件安装目录（安装系统级的应用）</p><p>这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录</p><p>用的是root的空间。</p><h2 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">su root  #切换到 root 用户</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加用户，并创建主目录</span></span><br><span class="line">useradd -m 用户名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除用户，并删除主目录</span></span><br><span class="line">userdel -r 用户名</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">在root 账户修改普通用户的密码</span></span><br><span class="line">passwd [选项] 用户名</span><br><span class="line"></span><br><span class="line">passwd  #修改root密码</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">使用sudo命令可简单快速禁用用户</span></span><br><span class="line">sudo passwd -l new</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">重新启用用户账户</span></span><br><span class="line">sudo passwd -u new</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><p>linux区分大小写，使用tab来自动补全命令</p><p>如果想要输入和执行多条命令，用分号分隔命令</p><p>mkdir 创建文件夹<br>touch 创建文件<br>rm -r 强制删除</p><p>cp [选项] 源文件 目标文件<br>    选项：<br>    -a：相当于 -d、-p、-r 选项的集合，这几个选项我们一一介绍；<br>    -d：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接；<br>    -i：询问，如果目标文件已经存在，则会询问是否覆盖；<br>    -l：把目标文件建立为源文件的硬链接文件，而不是复制源文件；<br>    -s：把目标文件建立为源文件的软链接文件，而不是复制源文件；<br>    -p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）；<br>    -r：递归复制，用于复制目录；<br>    -u：若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。</p><h2 id="Linux开机自动启动软件-可执行程序"><a href="#Linux开机自动启动软件-可执行程序" class="headerlink" title="Linux开机自动启动软件/可执行程序"></a>Linux开机自动启动软件/可执行程序</h2><h3 id="首先关注几个脚本"><a href="#首先关注几个脚本" class="headerlink" title="首先关注几个脚本"></a>首先关注几个脚本</h3><p>/etc/rc.d/rc.local：该脚本在系统启动时被执行一次；<br>/etc/profile:该脚本在所有用户登陆时会被执行一次；<br>~/.bashrc:该脚本在用户登陆时被执行一次，与/etc/profile不同的是，bashrc文件每个用户拥有独立的一个。</p><p>若设置开机启动，应该修改：/etc/rc.d/rc.local文件。</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux删除文件夹命令</span></span><br><span class="line"></span><br><span class="line">rm -rf /var/log/httpd/access</span><br><span class="line">将会删除/var/log/httpd/access目录以及其下所有文件、文件夹</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux删除文件命令</span></span><br><span class="line"></span><br><span class="line">rm -f /var/log/httpd/access.log</span><br><span class="line">将会强制删除/var/log/httpd/access.log这个文件</span><br></pre></td></tr></tbody></table></figure><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>linux系统基本上分两大类：</p><ol><li><p>RedHat系列：Redhat、Centos、Fedora等<br>常见的安装包格式 rpm 包，安装rpm包的命令是 “rpm -参数”<br>包管理工具 yum<br>支持tar包</p></li><li><p>Debian系列：Debian、Ubuntu等<br>常见的安装包格式 deb 包，安装deb包的命令是 “dpkg -参数”<br>包管理工具 apt-get<br>支持tar包</p></li></ol><h4 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h4><p>yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。<br>yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 列出所有可更新的软件清单命令：yum check-update</span><br><span class="line"></span><br><span class="line">2. 更新所有软件命令：yum update</span><br><span class="line"></span><br><span class="line">3. 仅安装指定的软件命令：yum install &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line">4. 仅更新指定的软件命令：yum update &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line">5. 列出所有可安裝的软件清单命令：yum list</span><br><span class="line"></span><br><span class="line">6. 删除软件包命令：yum remove &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line">7. 查找软件包命令：yum search &lt;keyword&gt;</span><br><span class="line"></span><br><span class="line">8. 清除缓存命令:</span><br><span class="line"></span><br><span class="line">yum clean packages: 清除缓存目录下的软件包</span><br><span class="line">yum clean headers: 清除缓存目录下的 headers</span><br><span class="line">yum clean oldheaders: 清除缓存目录下旧的 headers</span><br><span class="line">yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers</span><br></pre></td></tr></tbody></table></figure><h5 id="配置yum仓库"><a href="#配置yum仓库" class="headerlink" title="配置yum仓库"></a>配置yum仓库</h5><p>yum就是一个硕大的软件仓库，里面保存了几乎所有的常用工具，只需要为系统提供软件包名称即可。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先切换到yum源中的配置目录</span></span><br><span class="line">cd /etc/yum.repos.d/ </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="yum无法使用"><a href="#yum无法使用" class="headerlink" title="yum无法使用"></a>yum无法使用</h5><p>yum服务使用的默认python版本是python2<br>更换yum源</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/bin/yum  #先看下/usr/bin/yum文件内容</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看系统默认安装的yum</span></span><br><span class="line">rpm -qa|grep yum</span><br><span class="line"></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><p>wget是Linux中的一个下载文件的工具，后来被移植到包括Windows在内的各个平台上。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装wget</span></span><br><span class="line">yum install -y wget</span><br><span class="line"><span class="meta">#</span><span class="bash">查看帮助手册</span></span><br><span class="line">wget --help</span><br></pre></td></tr></tbody></table></figure><h2 id="vim使用"><a href="#vim使用" class="headerlink" title="vim使用"></a>vim使用</h2><p><a href="https://www.jianshu.com/p/8b679b35c9d5">https://www.jianshu.com/p/8b679b35c9d5</a><br>Vim可以分为三种模式，分别为：</p><h3 id="命令行模式（Command-mode）"><a href="#命令行模式（Command-mode）" class="headerlink" title="命令行模式（Command mode）"></a>命令行模式（Command mode）</h3><p>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>进入vim之后，是处于「命令行模式」，要按i切换到「插入模式」才能够输入文字。</p><h3 id="插入模式（Insert-mode）"><a href="#插入模式（Insert-mode）" class="headerlink" title="插入模式（Insert mode）"></a>插入模式（Insert mode）</h3><p>只有在插入模式下，才可以做文字输入，按「ESC」键可回到命令行模式。</p><h3 id="底行模式（Lastline-mode）"><a href="#底行模式（Lastline-mode）" class="headerlink" title="底行模式（Lastline mode）"></a>底行模式（Lastline mode）</h3><p>将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>在命令行模式下，按冒号「:」键，进入底行模式</p><p>:w filename 文件以filename为文件名保存</p><p>:wq 文件存盘并退出vim</p><p>:q 文件不存盘并退出vim</p><p>:q! 文件不存盘强制退出vim</p><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p>命令行模式下 ？</p><p>:s 命令来替换字符串<br>    :s/gald/glad/<br>    :s/java/Linux/g </p><p>:X  设置密码</p><h2 id="linux压缩文件"><a href="#linux压缩文件" class="headerlink" title="linux压缩文件"></a>linux压缩文件</h2><h3 id="gzip命令"><a href="#gzip命令" class="headerlink" title="gzip命令"></a>gzip命令</h3><p>gzip是用来压缩和解压.gz文件的命令。<br>gzip命令只能压缩单个文件，而不能把一个文件夹压缩成一个文件（与打包命令的区别）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">会将文件压缩为文件 test.txt.gz，原来的文件则没有了</span></span><br><span class="line">gzip /home/aistudio/work/test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">解压文件,原来的文件则没有了</span></span><br><span class="line">gzip -d /home/aistudio/test.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">参数</span></span><br><span class="line">-r或--recursive：递归压缩指定文件夹下的文件（该文件夹下的所有文件被压缩成单独的.gz文件）；</span><br><span class="line">-v或--verbose：显示指令执行过程。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><p>用来打包或者解包后缀名为.tar</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">参数</span></span><br><span class="line">-c或--create：建立新的备份文件；</span><br><span class="line">-x或--extract或--get：从备份文件中还原文件；</span><br><span class="line">-v：显示指令执行过程；</span><br><span class="line">-f或--file：指定备份文件；</span><br><span class="line">-C：指定目的目录；</span><br><span class="line">-z：通过gzip指令处理备份文件；</span><br><span class="line">-j：通过bzip2指令处理备份文件。</span><br></pre></td></tr></tbody></table></figure><h3 id="zip和unzip"><a href="#zip和unzip" class="headerlink" title="zip和unzip"></a>zip和unzip</h3><p>zip命令和unzip命令用在在Linux上处理.zip的压缩文件。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">常用参数</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">zip:</span></span><br><span class="line">-v：显示指令执行过程；</span><br><span class="line">-m：不保留原文件；</span><br><span class="line">-r：递归处理。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">unzip:</span></span><br><span class="line">-v：显示指令执行过程；</span><br><span class="line">-d：解压到指定目录。</span><br></pre></td></tr></tbody></table></figure><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前目录下所有文件权限</span></span><br><span class="line">ls -l      #简写 ll </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看指定文件权限</span></span><br><span class="line">ll |grep 文件名</span><br></pre></td></tr></tbody></table></figure><p>在linux下，文件权限分为三种：可读权限(read)、可写权限(write)以及可执行权限(execute)，三者分别对应的字符为r、w和x；</p><p>Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。</p><p>r –&gt; 4<br>w –&gt; 2<br>x –&gt; 1</p><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>要通过su进入到root权限中<br><code>chmod abc filename</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777</span><br></pre></td></tr></tbody></table></figure><p>指令中的a、b、c分别表示一个数字，其中a对应文件所有者权限，b对应文件所有者所在组权限，c对应其他身份权限。</p><p>对于a、b、c各自来讲，它们都是0~7的数字，对应r、w、x三个二进制位按序组成的二进制数，举个例子，如果是只可读，对应的二进制数就是“100”，也就是4；如果是可读可写不可执行，那么对应二进制数为“110”，也就是6……</p><p>再举个最常见的chmod 777 xxxx指令，这里有3个7，但是每个7的含义是不同的。7的二进制形式为111，表示可读可写可执行，第1个7表示文件对于文件所有者来说可读可写可执行；第2个7表示文件对于文件所有者所在组来说可读可写可执行；第3个7表示文件对于其他身份的用户来说可读可写可执行。也就是说，通过chmod 777，文件就没有了读写执行权限限制了。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>1、修改 /etc/profile 文件，如果你的计算机仅仅作为开发使用时推存使用这种方法，因为所有用户的shell都有权使用这个环境变量，可能会给系统带来安全性问题。这里是针对所有的用户的，所有的shell</p><p>vi /etc/profile</p><p>在/etc/profile的最下面添加：  export  PATH=”$PATH:/NEW_PATH”</p><p>针对当前特定的用户起作用的环境变量</p><p>2、修改bashrc文件，这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，这里是针对某一特定的用户，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的 .bashrc文件就可以了。</p><p>vi ~/.bashrc</p><p>在下面添加：</p><p>Export  PATH=”$PATH:/NEW_PATH”</p><h2 id="xshell"><a href="#xshell" class="headerlink" title="xshell"></a>xshell</h2><p>XShell是一个强大的安全终端模拟软件,可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。<br><a href="https://xshell.en.softonic.com/">安装</a><br><a href="https://www.jianshu.com/p/4716cc35750f">参考</a></p><h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><p>选择导航菜单的文件 –&gt; 新建，输入名称和主机IP，协议默认SSH，端口默认22，如果不知道主机IP可以登录虚拟机的Linux系统，输入命令ifconfig查看(inet addr)</p><p>然后在左侧用户身份验证中输入用户名和密码，这样下次就可以直接连接了，当然如果为了安全考虑也可以不输入密码，在每次连接时再输入。</p><h3 id="Xshell怎么与云服务器连接"><a href="#Xshell怎么与云服务器连接" class="headerlink" title="Xshell怎么与云服务器连接"></a>Xshell怎么与云服务器连接</h3><p>打开Xshell，新建一个会话</p><p>主机填服务器ip,点击连接</p><p>用户名默认为root,而不是实例名，也不是你服务器中Linux的用户名；<br>密码则为服务器实例密码</p><h2 id="centos内核"><a href="#centos内核" class="headerlink" title="centos内核"></a>centos内核</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  版本信息</span></span><br><span class="line">cat /etc/centos-release </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看Linux内核信息</span></span><br><span class="line">uname -a  </span><br></pre></td></tr></tbody></table></figure><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用图形界面配置网络命令</span></span><br><span class="line">nmtui</span><br><span class="line"><span class="meta">#</span><span class="bash">重新启动网络服务命令</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">显示你所有操作的历史命令</span></span><br><span class="line">history</span><br></pre></td></tr></tbody></table></figure><h2 id="NAT配置"><a href="#NAT配置" class="headerlink" title="NAT配置"></a>NAT配置</h2><h3 id="检查环境-能上网，安装了net-tools"><a href="#检查环境-能上网，安装了net-tools" class="headerlink" title="检查环境: 能上网，安装了net-tools."></a>检查环境: 能上网，安装了net-tools.</h3><p>（1）能否上网（ping <a href="http://www.baidu.com/">www.baidu.com</a>)<br>如不能上网。配置/etc/sysconfig/network-scripts/ifcfg-ens33<br>（2）是否安装了 net-tools.  (因为需要使用命令 route )<br>如没有， yum -y install net-tools</p><h3 id="搭建网络"><a href="#搭建网络" class="headerlink" title="搭建网络"></a>搭建网络</h3><p>一台Sever (2张网卡） + 一台 Client（一张网卡）</p><p>安装（或克隆）一台虚拟机名为：Client. 原来那台可改名叫（Server)。<br>Server 上再安装一张网卡，并配成“仅主机模式”。（原来应该那一张应该为NAT模式）。<br>Client 网卡配成 “仅主机模式”</p><h3 id="配置NAT"><a href="#配置NAT" class="headerlink" title="配置NAT"></a>配置NAT</h3><p>（1）开启Server 和 Client, 用 root 登录。<br>（2）在Server 上运行： <code>ip addr</code>记录下 ens37 (也就是Server 的第二张网卡） 的ip：192.168.221.128<br>（3）设置Client网关，在Client 上 运行:<br><code>route add default gw 192.168.221.128  #添加一条默认网关</code><br>（如要查看网关 是否设置成功，可以运行：route -n)</p><p>（4）在Server设置地址伪装 ， 运行：</p><p>(5）重启防火墙<code>systemctl restart firewalld.service</code></p><p>(6)在Client 上ping测试是否成功</p><p>(7)在Client上配置本地DNS:去到目录 /etc 下， 用vi 编辑 文件 “resolv.conf” </p><h1 id="搭建云上博客"><a href="#搭建云上博客" class="headerlink" title="搭建云上博客"></a>搭建云上博客</h1><p>不知道教程是不是太旧了，跟着做，都是报错</p><h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><h3 id="安装Apache服务及其扩展包"><a href="#安装Apache服务及其扩展包" class="headerlink" title="安装Apache服务及其扩展包"></a>安装Apache服务及其扩展包</h3><p>跟着官网做发现安装失败</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install httpd httpd-manual mod_ssl mod_perl mod_auth_mysql</span><br><span class="line"></span><br><span class="line">Last metadata expiration check: 0:30:48 ago on Thu 17 Mar 2022 08:21:43 AM CST.</span><br><span class="line">No match for argument: mod_auth_mysql</span><br><span class="line">Error: Unable to find a match: mod_auth_mysql</span><br></pre></td></tr></tbody></table></figure><p>搜索到的解决方案</p><ol><li><p> yum -y install httpd httpd-manual mod_ssl mod_perl</p></li><li><p> yum -y install httpd httpd-devel</p><h3 id="启动Apache服务。"><a href="#启动Apache服务。" class="headerlink" title="启动Apache服务。"></a>启动Apache服务。</h3><p>systemctl start httpd.service</p><h3 id="设置安全组"><a href="#设置安全组" class="headerlink" title="设置安全组"></a>设置安全组</h3><p>教程上没有说清楚</p></li></ol><p>进入实例，点击安全组链接进去</p><p>然后点击快速添加<br>选端口范围为http(80)</p><p>打开浏览器输入ECS服务器的公网IP，显示测试页面表示Apache服务安装成功。</p><h1 id="搭建网盘Cloudreve"><a href="#搭建网盘Cloudreve" class="headerlink" title="搭建网盘Cloudreve"></a>搭建网盘Cloudreve</h1><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p>官网：</p><p>cloudreve.org</p><p>github：</p><p><a href="https://github.com/cloudreve/Cloudreve">https://github.com/cloudreve/Cloudreve</a></p><p>下载：</p><p><a href="https://github.com/cloudreve/Cloudreve/releases">https://github.com/cloudreve/Cloudreve/releases</a></p><p>安装文档：</p><p><a href="https://docs.cloudreve.org/getting-started/install">https://docs.cloudreve.org/getting-started/install</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd /opt #选定/opt作为安装目录</span><br><span class="line">wget https://github.com/cloudreve/Cloudreve/releases/download/3.1.1/cloudreve_3.1.1_linux_amd64.tar.gz</span><br><span class="line">tar -zxvf cloudreve_3.1.1_linux_amd64.tar.gz   #解压获取到的主程序</span><br><span class="line">chmod +x ./cloudreve  #赋予执行权限</span><br><span class="line">./cloudreve   #启动 Cloudreve</span><br></pre></td></tr></tbody></table></figure><p>Cloudreve 在首次启动时，会创建初始管理员账号，请注意保管管理员密码，此密码只会在首次启动时出现。如果您忘记初始管理员密码，需要删除同级目录下的“cloudreve.db”，重新启动主程序以初始化新的管理员账户。</p><p>Cloudreve 默认会监听“5212”端口。你可以在浏览器中访问  http://服务器ip:5212  进入 Cloudreve。如果宝塔面板需要在安全中放行“5212”端口。注意用默认的管理账号和密码登录。</p><h2 id="添加守护进程"><a href="#添加守护进程" class="headerlink" title="添加守护进程"></a>添加守护进程</h2><p>软件商店→系统工具 ，找到Supervisor管理器安装<br>打开Supervisor管理器添加守护进程</p><h2 id="什么是反向代理"><a href="#什么是反向代理" class="headerlink" title="什么是反向代理"></a>什么是反向代理</h2><p>反向代理是充当Web服务器网关的代理服务器。当您将请求发送到使用反向代理的Web服务器时，他们将先转到反向代理，由该代理将确定是将其路由到Web服务器还是将其阻止。</p><p>这意味着有了反向代理，您永远不会与使用它的Web服务器进行直接通信。可以将它们看作web服务器或服务器集群的某种包装器。通过负载平衡和缓存，它们可以保护web免遭攻击，并提供更好的web性能。</p><h1 id="宝塔Linux面板"><a href="#宝塔Linux面板" class="headerlink" title="宝塔Linux面板"></a>宝塔Linux面板</h1><p><a href="https://blog.csdn.net/vpssws/article/details/117136583?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/vpssws/article/details/117136583?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Centos安装命令：</span></span><br><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu/Deepin安装命令：</span></span><br><span class="line">wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">显示面板的使用帮助菜单选项。</span></span><br><span class="line">bt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">卸载面板</span></span><br><span class="line">wget http://download.bt.cn/install/bt-uninstall.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">执行脚本：</span></span><br><span class="line">sh bt-uninstall.sh</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>安装软件时，推荐使用编译安装</p><h2 id="面板特色功能："><a href="#面板特色功能：" class="headerlink" title="面板特色功能："></a>面板特色功能：</h2><p>一键配置服务器环境（LAMP/LNMP）<br>一键安全重启<br>一键创建管理网站、ftp、数据库<br>一键部署SSL证书<br>一键部署源码（discuz、wordpress、dedecms、z-blog、微擎等等）<br>一键配置（定期备份、数据导入、伪静态、301、SSL、子目录、反向代理、切换PHP版本）<br>一键安装常用PHP扩展(fileinfo、intl、opcache、imap、memcache、apc、redis、ioncube、imagick)<br>数据库一键导入导出<br>系统监控（CPU、内存、磁盘IO、网络IO）<br>防火墙端口放行<br>SSH开启与关闭及SSH端口更改<br>禁PING开启或关闭<br>方便高效的文件管理器（上传、下载、压缩、解压、查看、编辑等等）<br>计划任务（定期备份、日志切割、shell脚本）<br>软件管理（一键安装、卸载、版本切换）</p><h2 id="添加站点"><a href="#添加站点" class="headerlink" title="添加站点"></a>添加站点</h2><p>添加站点就是添加一个域名进去，通过这个域名可以访问你的网页，或者直接填写你的ip进去，然后浏览器输入你的ip访问一下就看到结果了</p><h2 id="LNMP-环境"><a href="#LNMP-环境" class="headerlink" title="LNMP 环境"></a>LNMP 环境</h2><p>LNMP 是 Linux、Nginx、MariaDB 和 PHP 的缩写，这个组合是最常见的 Web 服务器的运行环境之一。用宝塔面板一键安装</p><h2 id="ftp服务"><a href="#ftp服务" class="headerlink" title="ftp服务"></a>ftp服务</h2><h1 id="python自动化部署"><a href="#python自动化部署" class="headerlink" title="python自动化部署"></a>python自动化部署</h1><p>Python提供了一个paramiko库，能够支持SSH和SFTP协议，可以取代Xshell和Xftp，下面是把本机的jar文件上传到服务器并运行的Python脚本：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"> </span><br><span class="line">IP = <span class="string">'106.14.19.127'</span></span><br><span class="line">user = <span class="string">'root'</span></span><br><span class="line">password = <span class="string">'server-pwd'</span></span><br><span class="line"> </span><br><span class="line">local_jar = <span class="string">'/target/ser1-1.0.jar'</span></span><br><span class="line">server_jar = <span class="string">'/root/ser1-1.0.jar'</span></span><br><span class="line">server_property = <span class="string">'/root/ser1.properties'</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute_cmds</span>(<span class="params">ip, name, pwd, cmd</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ssh = paramiko.SSHClient()</span><br><span class="line">        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        ssh.connect(ip, <span class="number">22</span>, name, pwd, timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">'连接成功'</span></span><br><span class="line">        sftp = ssh.open_sftp()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">'正在上传...'</span></span><br><span class="line">        sftp.put(local_jar, server_jar)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">'jar上传成功'</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> cmd:</span><br><span class="line">            <span class="built_in">print</span> m</span><br><span class="line">            stdin, stdout, stderr = ssh.exec_command(m)</span><br><span class="line">            out = stdout.readlines()</span><br><span class="line">            <span class="keyword">for</span> o <span class="keyword">in</span> out:</span><br><span class="line">                <span class="built_in">print</span> o,</span><br><span class="line">        <span class="built_in">print</span> <span class="string">'运行成功'</span></span><br><span class="line">        ssh.close()</span><br><span class="line">        <span class="built_in">print</span> <span class="string">'关闭连接'</span></span><br><span class="line">    <span class="keyword">except</span> Exception, error:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">'错误:  %s'</span> % (error)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'Start deploying %s to server %s'</span> % (server_jar, IP)</span><br><span class="line">    cmd = [</span><br><span class="line">        <span class="string">'echo Start spring...'</span>,</span><br><span class="line">        <span class="string">'nohup java -jar -Dspring.config.location='</span> + server_property + <span class="string">' '</span> + server_jar + <span class="string">' &amp;'</span>,</span><br><span class="line">        <span class="string">'echo All done.'</span></span><br><span class="line">    ]</span><br><span class="line">    a = threading.Thread(target=execute_cmds, args=(IP, user, password, cmd))</span><br><span class="line">    a.start()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用linux的好处&quot;&gt;&lt;a href=&quot;#使用linux的好处&quot; class=&quot;headerlink&quot; title=&quot;使用linux的好处&quot;&gt;&lt;/a&gt;使用linux的好处&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/MP</summary>
      
    
    
    
    <category term="工具" scheme="https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="linux" scheme="https://wenkex.gitee.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>python数据结构</title>
    <link href="https://wenkex.gitee.io/2022/02191106.html"/>
    <id>https://wenkex.gitee.io/2022/02191106.html</id>
    <published>2022-02-19T04:04:47.000Z</published>
    <updated>2022-02-19T04:04:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.yiibai.com/python/py_data_structure/python_data_structure_introduction.html">https://www.yiibai.com/python/py_data_structure/python_data_structure_introduction.html</a></p><h1 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h1><p>这些是以顺序方式存储数据元素的数据结构。例如 - </p><h2 id="数组-它是与数据元素的索引配对的数据元素的顺序排列。"><a href="#数组-它是与数据元素的索引配对的数据元素的顺序排列。" class="headerlink" title="数组: 它是与数据元素的索引配对的数据元素的顺序排列。"></a>数组: 它是与数据元素的索引配对的数据元素的顺序排列。</h2><h2 id="链表-每个数据元素都包含一个指向另一个元素的链接及其中的数据。"><a href="#链表-每个数据元素都包含一个指向另一个元素的链接及其中的数据。" class="headerlink" title="链表: 每个数据元素都包含一个指向另一个元素的链接及其中的数据。"></a>链表: 每个数据元素都包含一个指向另一个元素的链接及其中的数据。</h2><p>链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据。链表中每一个节点都包含此节点的数据和指向下一节点地址的指针。由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。</p><p>这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点。不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用。</p><p>一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。</p><p>链表和数组对比<br>链表和数组在实际的使用过程中需要根据自身的优劣势进行选择。链表和数组的异同点也是面试中高频的考察点之一。这里对单链表和数组的区别进行了对比和总结。</p><h2 id="堆栈-这是一种仅遵循特定操作顺序的数据结构。LIFO-后进先出-或FILO-先进先出-。"><a href="#堆栈-这是一种仅遵循特定操作顺序的数据结构。LIFO-后进先出-或FILO-先进先出-。" class="headerlink" title="堆栈: 这是一种仅遵循特定操作顺序的数据结构。LIFO(后进先出)或FILO(先进先出)。"></a>堆栈: 这是一种仅遵循特定操作顺序的数据结构。LIFO(后进先出)或FILO(先进先出)。</h2><p>队列: 与堆栈(Stack)类似，但操作顺序仅为FIFO(先进先出)。<br>矩阵: 它是二维数据结构，其中数据元素由一对索引引用。</p><h1 id="非线性数据结构"><a href="#非线性数据结构" class="headerlink" title="非线性数据结构"></a>非线性数据结构</h1><p>这些数据结构中没有数据元素的顺序链接。任何一对或一组数据元素都可以相互关联，并且可以在没有严格顺序的情况下进行访问。</p><p>二叉树:它是一个数据结构，每个数据元素可以连接到最多两个其他数据元素，并以一个根节点开始。<br>堆: 这是树形数据结构的特殊情况，其中父节点中的数据严格大于/等于子节点或严格小于其子节点。<br>哈希表: 它是一个数据结构，它由使用散列函数相互关联的数组构成。它使用键而不是数据元素的索引来检索值。<br>图: 它是顶点和节点的排列，其中一些节点通过链接彼此连接。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组可以说是最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。</p><h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>从上面的对比中可以看出，链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。</p><p>图片</p><p>跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前redis和levelDB都有用到跳表。</p><p>从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查询的目的。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是一种比较简单的数据结构，常用一句话描述其特性，后进先出。栈本身是一个线性表，但是在这个表中只有一个口子允许数据的进出。这种模式可以参考腔肠动物…即进食和排泄都用一个口…</p><p>栈的常用操作包括入栈push和出栈pop，对应于数据的压入和压出。还有访问栈顶数据、判断栈是否为空和判断栈的大小等。由于栈后进先出的特性，常可以作为数据操作的临时容器，对数据的顺序进行调控，与其它数据结构相结合可获得许多灵活的处理。</p><p>图片</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是栈的兄弟结构，与栈的后进先出相对应，队列是一种先进先出的数据结构。顾名思义，队列的数据存储是如同排队一般，先存入的数据先被压出。常与栈一同配合，可发挥最大的实力。</p><p>图片</p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。常见的数的表示形式更接近“倒挂的树”，因为它将根朝上，叶朝下。</p><p>树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。</p><p>这意味着树是具备层次关系的，父子关系清晰，家庭血缘关系明朗；这也是树与图之间最主要的区别。</p><p>图片</p><p>别看树好像很高级，其实可看作是链表的高配版。树的实现就是对链表的指针域进行了扩充，增加了多个地址指向子结点。同时将“链表”竖起来，从而凸显了结点之间的层次关系，更便于分析和理解。</p><p>树可以衍生出许多的结构，若将指针域设置为双指针，那么即可形成最常见的二叉树，即每个结点最多有两个子树的树结构。二叉树根据结点的排列和数量还可进一度划分为完全二叉树、满二叉树、平衡二叉树、红黑树等。</p><p>图片</p><p>完全二叉树：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。</p><p>满二叉树：除了最后一层，其它层的结点都有两个子结点。</p><p>平衡二叉树<br>平衡二叉树又被称为AVL树，它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>二叉排序树：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。</p><p>树的高度：结点层次的最大值</p><p>平衡因子：左子树高度 - 右子树高度</p><p>二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点&lt;根节点&lt;右结点，这表明二叉排序树的中序遍历结果是有序的。（还不懂二叉树四种遍历方式[前序遍历、中序遍历、后序遍历、层序遍历]的同学赶紧补习！）</p><p>图片</p><p>平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。</p><p>图片</p><p>平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。</p><p>在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。</p><p>左旋：S为当前需要左旋的结点，E为当前结点的父节点。</p><p>图片</p><p>左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。可用动画表示：</p><p>图片</p><p>右旋：S为当前需要左旋的结点，E为当前结点的父节点。右单旋是左单旋的镜像旋转。</p><p>图片</p><p>左旋的操作同样可以用一句话简单表示：将当前结点S的左孩子E的右孩子旋转为当前结点S的左孩子，同时将当前结点S旋转为左孩子E的右孩子。可用动画表示：</p><p>图片</p><p>红黑树<br>平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致AVL的插入和删除效率并不高。</p><p>为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。</p><p>红黑树具有五个特性：</p><p>每个结点要么是红的要么是黑的。<br>根结点是黑的。<br>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。<br>如果一个结点是红的，那么它的两个儿子都是黑的。<br>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。<br>图片红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。</p><p>红黑树VS平衡二叉树<br>图片</p><p>除了上面所提及的树结构，还有许多广泛应用在数据库、磁盘存储等场景下的树结构。比如B树、B+树等。这里就先不介绍了诶，下次在讲述相关存储原理的时候将会着重介绍。（其实是因为懒）</p><p> 7  堆<br>了解完二叉树，再来理解堆就不是什么难事了。堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。</p><p>对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此可以直接用数组来表示一个堆。</p><p>不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</p><p>图片</p><p>堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如堆排序、topK问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。</p><p> 8  散列表<br>散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射。散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。</p><p>图片</p><p>散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数：</p><p>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。</p><p>数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</p><p>平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</p><p>取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</p><p>除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。</p><p>确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。</p><p>冲突在发生之后，当在对不同的key值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。</p><p>常用的冲突处理方式有很多，常用的包括以下几种：</p><p>开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。</p><p>再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</p><p>链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。</p><p>公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</p><p>目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。</p><p>图片</p><p>左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。<br>考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。</p><p> 9  图<br>图相较于上文的几个结构可能接触的不多，但是在实际的应用场景中却经常出现。比方说交通中的线路图，常见的思维导图都可以看作是图的具体表现形式。</p><p>图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。</p><p>图片</p><p>图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。</p><p>邻接矩阵<br>目前常用的图存储方式为邻接矩阵，通过所有顶点的二维矩阵来存储两个顶点之间是否相连，或者存储两顶点间的边权重。</p><p>图片</p><p>无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，若能从此顶点能够到达彼顶点，那么彼顶点自然也能够达到此顶点。此外，由于顶点本身与本身相连没有意义，所以在邻接矩阵中对角线上皆为0。</p><p>图片</p><p>有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。<br>用邻接矩阵可以直接从二维关系中获得任意两个顶点的关系，可直接判断是否相连。但是在对矩阵进行存储时，却需要完整的一个二维数组。若图中顶点数过多，会导致二维数组的大小剧增，从而占用大量的内存空间。</p><p>而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。</p><p>因此，为了解决上述问题，一种可以只存储相连顶点关系的邻接表应运而生。</p><p>邻接表<br>在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点。相较于无向图，有向图的情况更为复杂，因此这里采用有向图进行实例分析。</p><p>图片在邻接表中，每一个顶点都对应着一条链表，链表中存储的是顶点能够达到的相邻顶点。存储的顺序可以按照顶点的编号顺序进行。比如上图中对于顶点B来说，其通过有向边可以到达顶点A和顶点E，那么其对应的邻接表中的顺序即B-&gt;A-&gt;E，其它顶点亦如此。</p><p>通过邻接表可以获得从某个顶点出发能够到达的顶点，从而省去了对不相连顶点的存储空间。然而，这还不够。对于有向图而言，图中有效信息除了从顶点“指出去”的信息，还包括从别的顶点“指进来”的信息。这里的“指出去”和“指进来”可以用出度和入度来表示。</p><p>入度：有向图的某个顶点作为终点的次数和。</p><p>出度：有向图的某个顶点作为起点的次数和。</p><p>由此看出，在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。</p><p>逆邻接表<br>逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。</p><p>图片</p><p>邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。</p><p>十字链表<br>十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。</p><p>图片</p><p>但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。</p><p>十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端）</p><p>data：用于存储该顶点中的数据；</p><p>firstin指针：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点；</p><p>firstout指针：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点；</p><p>边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接：</p><p>tailvex：用于存储作为弧尾的顶点的编号；</p><p>headvex：用于存储作为弧头的顶点的编号；</p><p>headlink 指针：用于链接下一个存储作为弧头的顶点的节点；</p><p>taillink 指针：用于链接下一个存储作为弧尾的顶点的节点；</p><p>图片</p><p>以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边AE（即边04）指向顶点E，顶点A的firstout指针需要指向边04的tailvex。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边AB（即边10）指向B，顶点A的firstin指针需要指向边10的弧头，即headlink指针。依次类推。</p><p>十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。</p><p> 10  总结<br>数据结构博大精深，没有高等数学的讳莫如深，也没有量子力学的玄乎其神，但是其在计算机科学的各个领域都具有强大的力量。本文试图采用图解的方式对九种数据结构进行理论上的介绍，但是其实这都是不够的。</p><p>即便是简单的数组、栈、队列等结构，在实际使用以及底层实现上都会有许多优化设计以及使用技巧，这意味着还需要真正把它们灵活的用起来，才能够算是真正意义上的熟悉和精通。但是本文可以作为常见数据结构的一个总结，当你对某些结构有些淡忘的时候，不妨重新回来看看。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。<br>动态规划最<strong>核心的思想</strong>，就在于拆分子问题，记住过往，减少重复计算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.yiibai.com/python/py_data_structure/python_data_structure_introduction.html&quot;&gt;https://www.yiibai.com/python/py_data_s</summary>
      
    
    
    
    <category term="pytohn" scheme="https://wenkex.gitee.io/categories/pytohn/"/>
    
    
    <category term="数据结构" scheme="https://wenkex.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序</title>
    <link href="https://wenkex.gitee.io/2022/012435506.html"/>
    <id>https://wenkex.gitee.io/2022/012435506.html</id>
    <published>2022-01-24T09:33:43.000Z</published>
    <updated>2022-01-24T09:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>pages用来存放所有小程序的页面<br>utils用来存放工具性质的模块(例如：格式化时间的自定义模块)<br>app. js小程序项目的入口文件<br>app.json小程序项目的全局配置文件<br>app.Wxss小程序项目的全局样式文件<br>project. config. json项目的配置文件<br>sitemap json用来配置小程序及其页面是否允许被微信索引 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h1&gt;&lt;p&gt;pages用来存放所有小程序的页面&lt;br&gt;utils用来存放工具性质的模块(例如：格式化时间的自定义模块)&lt;br&gt;app. </summary>
      
    
    
    
    <category term="知识" scheme="https://wenkex.gitee.io/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="小程序" scheme="https://wenkex.gitee.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>window使用</title>
    <link href="https://wenkex.gitee.io/2022/012246677.html"/>
    <id>https://wenkex.gitee.io/2022/012246677.html</id>
    <published>2022-01-22T01:09:49.000Z</published>
    <updated>2022-01-22T01:09:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h1><h2 id="不认识的汉字怎么打"><a href="#不认识的汉字怎么打" class="headerlink" title="不认识的汉字怎么打"></a>不认识的汉字怎么打</h2><p>u+汉字各部分的拼音</p><h1 id="扩展屏幕"><a href="#扩展屏幕" class="headerlink" title="扩展屏幕"></a>扩展屏幕</h1><p>如何在笔记本盖上盖子时，扩展显示屏也能显示。<br>在设置中搜索打开控制面板，然后找到电源选项打开，找到选择关闭笔记本计算机盖的功能<br><img src="https://gitee.com/wenkex/blogimage/raw/master/Quicker_20220122_091908.png"></p><h1 id="文件无法删除"><a href="#文件无法删除" class="headerlink" title="文件无法删除"></a>文件无法删除</h1><p>解决Windows10中“其中文件夹或文件已在另一程序中打开”引起的文件删不掉问题</p><h2 id="打开任务管理器"><a href="#打开任务管理器" class="headerlink" title="打开任务管理器"></a>打开任务管理器</h2><h2 id="打开资源监视器"><a href="#打开资源监视器" class="headerlink" title="打开资源监视器"></a>打开资源监视器</h2><p>1.切换任务管理器到“性能”选项页，点击最下方的“打开资源监视器”字。<br><img src="https://gitee.com/wenkex/blogimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220104192240.png"><br>2.搜索与该文件关联的程序并关闭</p><p>以删除word文件“文件123.docx”为例：删除桌面上“文件123.docx”文件，显示该文件已被其他程序打开，暂时无法删除。</p><p>此时在资源监视器搜索句柄处填上文件123，即可搜索与这个文件相关联的应用程序句柄。<br><img src="https://gitee.com/wenkex/blogimage/raw/master/v2-48385ce4a09d453981e9b06b1202065d_r.jpg"><br>点击与文件123相关联的句柄，然后点击鼠标右键，选择结束进程<br>此时会弹出结束进程确认对话框。<br>点击“结束进程”关闭与“文件123.docx”关联的进程。</p><p>怎样关闭Win10安装软件、改变设置时的弹窗？<br>打开更改用户账户设置  </p><p>Windows系统hosts文件路径为：C:\Windows\System32\drivers\etc</p><p>Win10电脑设置定时关机命令：<br>Win +r  输入：shutdown -s -t 3600            一小时后关机</p><p>Win10进入开机自启文件夹<br>Win+r进入运行，输入shell:startup</p><h1 id="快捷键汇总"><a href="#快捷键汇总" class="headerlink" title="快捷键汇总"></a>快捷键汇总</h1><p>win+上下箭头键：【最大化】【还原】【最小化】当前窗口</p><p>win+左右箭头键：将窗口靠左、靠右。如果有两个窗口则并列</p><p>按住ctrl 可多选文件</p><p>Win+Shift+S 截图、</p><p>Win+g  截图录屏</p><p>在英文输入状态下，按住shift输入字母可以大写</p><p>按住alt双击文件   快速打开属性</p><p>Ctrl+shift+Esc 一键打开任务管理器</p><p>Ctrl +shift+n 快速新建文件夹</p><p>按住ctrl拖动文件 就是复制</p><p>Alt+F4键：关闭当前窗口，如果没有活动窗口就带开【关闭计算机】对话框</p><p>win+A键：快速打开【系统通知和控制中心】</p><p>Win+E键：快速打开【资源管理器】</p><p>win+G键：快速打开【Xbox工具】，这个工具非常实用，包含了截图、录屏等功能</p><p>win+I键：快速打开【计算机设置】</p><p>win+K键：快速打开【无线连接】</p><p>win+L键：快速【锁定屏幕】，如果你要暂时离开电脑，这个快捷键一定要知道</p><p>win+P键：快速打开【投影】，如果你要连接第二块屏幕或投影，这是最快捷的方法</p><p>win+Q键或者win+S键：快速打开【搜索】</p><p>win+R键：快速打开【运行】</p><p>win+T键：在【任务栏程序】中进行切换</p><p>win+V键：快速打开【剪贴板】</p><p>win+W键：快速打开【全屏截图】</p><p>win+X键：打开【系统快捷菜单】，这个菜单继承了巨大部分的系统功能。</p><p>win+数字键：打开【任务栏】上相应顺序的应用程序</p><p>win+加号：启动【放大镜】，加号放大，减号缩小</p><p>win+Tab键：打开【任务视图】，还可以按时间线查看近期任务</p><p>Alt+Tab键：在打开的程序间进行切换，这是笔者最常用的快捷键</p><h2 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h2><p>ctrl + w      关闭一个网页<br>Ctrl + Tab    切换网页<br>Ctrl+h 打开历史记录</p><h1 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h1><h2 id="微软自带的远程连接"><a href="#微软自带的远程连接" class="headerlink" title="微软自带的远程连接"></a>微软自带的远程连接</h2><p>联想小新pro16<br>win10专业版<br>两台设备都连着校园网，测试时，控制端不能连着电脑的热点。<br>控制端要下载：RDclient<br>成功后，你就可以不用带上你的电脑去机房上课了，直接在机房控制你的电脑，体验感翻倍</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1.window要用微软账号登录<br>2.用户名是自己设置的，可以是中文，打开图二密码中的更新安全问题选项也可以看到<br>3. 密码是你的账户密码，不是PIN码哦<br>4. 显示屏关闭后，微软远程就连接不上的原因</p><ul><li>联想小新pro16可能是因为开了智能感知功能的原因，因此显示屏关闭或者盖上屏幕，控制端就无法连接上电脑</li></ul><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>打开远程桌面，win+r 输入mstsc<br>查询ip地址：win+r进入cmd,输入ipconfig</p><h2 id="ToDesk"><a href="#ToDesk" class="headerlink" title="ToDesk"></a>ToDesk</h2><p>ToDesk目前还是免费的且支持三台设备，而且界面简洁大气。</p><h2 id="向日葵"><a href="#向日葵" class="headerlink" title="向日葵"></a>向日葵</h2><p>特点<br>1.控制端和被控制端使用同一账号即可<br>2.可以实时查看远程主机摄像头周围的情况<br>3.方便快捷的让远程文件或本地文件互相传输和同步，安全稳定。<br>4.无需内网穿透即可实现外网连接。<br>需求<br>①是在需要被控的电脑上安装被控端;<br>②在手机上安装向日葵主控端<br>③注册一个向日葵账号。在两端同时登录就可以远程控制了。</p><h1 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h1><p>是管理各种命令行的工具，它把目前 Windows 上的 PowerShell、CMD 以及 Windows Linux 子系统（WSL）三大环境实现了统一。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开系统自带的 Microsoft Store，搜索 Windows Terminal 直接安装就可以了。</p><h1 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h1><p>是命令行程序，真正执行指令的程序，</p><h2 id="在-Windows-上安装-PowerShell"><a href="#在-Windows-上安装-PowerShell" class="headerlink" title="在 Windows 上安装 PowerShell"></a>在 Windows 上安装 PowerShell</h2><p><a href="https://docs.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.1">https://docs.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.1</a></p><h2 id="安装-oh-my-posh-和-posh-git"><a href="#安装-oh-my-posh-和-posh-git" class="headerlink" title="安装 oh-my-posh 和 posh-git"></a>安装 oh-my-posh 和 posh-git</h2><p>oh-my-posh 是 PowerShell 主题管理工具<br>posh-git 可以实现类似 oh-my-zsh 一样的 Git 命令增强工具（命令别名和显示分支信息等）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Install-Module posh-git</span><br><span class="line">Install-Module oh-my-posh</span><br></pre></td></tr></tbody></table></figure><h2 id="配置-PowerShell"><a href="#配置-PowerShell" class="headerlink" title="配置 PowerShell"></a>配置 PowerShell</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 这是开启默认配置的</span><br><span class="line">Set-Prompt</span><br><span class="line"># 设置主题，Agnoster 是主题名</span><br><span class="line">Set-Theme Agnoster</span><br></pre></td></tr></tbody></table></figure><h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><h2 id="安装Scoop"><a href="#安装Scoop" class="headerlink" title="安装Scoop"></a>安装Scoop</h2><p>强大的 Windows 包管理工具 Scoop<br>Scoop 可以帮你一行命令安装 git 工具、java 环境、chrome 浏览器、vscode 等等，统一目录管理，而且自动配置环境变量，卸载也只需要一行命令，方便的不能在方便了<br>设置安装路径（可选）。默认 Scoop 是安装在 C 盘的，以及通过 Scoop 安装的软件也是在 C 盘的。如果你的 C 盘空间不够或想安装到其他盘，可以执行以下操作。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 设置 scoop 安装路径为 D:\scoop</span><br><span class="line">$env:SCOOP='D:\scoop'</span><br><span class="line">[environment]::setEnvironmentVariable('SCOOP',$env:SCOOP,'User')</span><br></pre></td></tr></tbody></table></figure><p>安装 Scoop</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将执行权限改为本地无需签名</span><br><span class="line">Set-ExecutionPolicy RemoteSigned -scope CurrentUser</span><br><span class="line"># 下载并执行脚本</span><br><span class="line">iwr -useb get.scoop.sh | iex</span><br></pre></td></tr></tbody></table></figure><h1 id="git-bash"><a href="#git-bash" class="headerlink" title="git bash"></a>git bash</h1><p>是Windows下的命令行工具。有git分布式版本控制工具，也主要用于git。</p><p>1 在windows下使用linux命令操作</p><p>2 登陆远程linux服务器&nbsp;ssh</p><h2 id="在window-terminal中添加git-bash"><a href="#在window-terminal中添加git-bash" class="headerlink" title="在window terminal中添加git bash"></a>在window terminal中添加git bash</h2><p><a href="https://www.cnblogs.com/cong-wang/p/15026535.html">https://www.cnblogs.com/cong-wang/p/15026535.html</a><br>打开设置文件settings.json，在profiles的list中添加一项：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"guid"</span> : <span class="string">"{5D1F95DF-36E8-56AD-C203-EA75CE06422C}"</span>,</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"Git Bash"</span>,</span><br><span class="line">  <span class="attr">"commandline"</span> : <span class="string">"D:\\ruanjian\\Git\\bin\\bash.exe --login -i"</span>,</span><br><span class="line">  <span class="attr">"icon"</span> : <span class="string">"D:\\ruanjian\\Git\\git-bash.png"</span></span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>guid：唯一标识本命令行配置，可以使用在线guid工具随机生成一个和list中其他配置不一样的guid即可<br>name：本命令行配置的名字，会显示在菜单中<br>commandline：表示怎么启动一个命令行，这里填的是”E:\Git\bin\bash.exe –login -i”，需要找到你的Git的安装目录，将E:\Git\bin\bash.exe替换成你自己的路径<br>icon：显示在菜单中的图标</p><h1 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h1><p>控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能</p><p>打开沙盒（在开始菜单中）,直接将要运行的程序，不确定安全性的程序复制粘贴进去就行,关机就清空数据了</p><h1 id="Win10家庭版升级成专业版"><a href="#Win10家庭版升级成专业版" class="headerlink" title="Win10家庭版升级成专业版"></a>Win10家庭版升级成专业版</h1><p>首先用360c盘搬家软件，转移大文件，然后用dism制作系统镜像，进行备份。</p><p>最后用HEU软件更改win10版本信息为专业版 ，再上这个网站进行kms服务器激活<br>果核剥壳KMS激活服务器 - 果核剥壳 (ghxi.com)</p><p>win10版本有哪些_w10版本区别是什么_win10版本号大全－系统城 (xitongcheng.com)</p><p>Consumer editions零售版本包括：家庭版、教育版、专业版<br>Business editionsVOL 版本包括：企业版、教育版、专业版   ，KMS方式激活 请用business_editions！</p><p>密钥网站：<a href="https://pkeytools.azurewebsites.net/ShareKeys">https://pkeytools.azurewebsites.net/ShareKeys</a></p><p>成功经验<br>在下面网址找密钥，输入了专业工作站版密钥，然后重启电脑，再输入专业版密钥</p><p><a href="https://mp.weixin.qq.com/s/Cpi41y4vh4IvHOKKCLDWvw">https://mp.weixin.qq.com/s/Cpi41y4vh4IvHOKKCLDWvw</a></p><p>查看密钥情况：cmd 中slmgr.vbs -dlv</p><h1 id="Win10进入开机自启文件夹"><a href="#Win10进入开机自启文件夹" class="headerlink" title="Win10进入开机自启文件夹"></a>Win10进入开机自启文件夹</h1><p>Win+r进入运行，输入shell:startup</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;输入法&quot;&gt;&lt;a href=&quot;#输入法&quot; class=&quot;headerlink&quot; title=&quot;输入法&quot;&gt;&lt;/a&gt;输入法&lt;/h1&gt;&lt;h2 id=&quot;不认识的汉字怎么打&quot;&gt;&lt;a href=&quot;#不认识的汉字怎么打&quot; class=&quot;headerlink&quot; title=&quot;不认识</summary>
      
    
    
    
    <category term="知识" scheme="https://wenkex.gitee.io/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="window" scheme="https://wenkex.gitee.io/tags/window/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://wenkex.gitee.io/2022/010947193.html"/>
    <id>https://wenkex.gitee.io/2022/010947193.html</id>
    <published>2022-01-09T03:24:32.000Z</published>
    <updated>2022-01-09T03:24:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://markdown.com.cn/basic-syntax/">官方文档</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。</p><p>Markdown 是 HTML 的一种简写，在显示时会『解压缩』成 HTML。理论上你可以在 Markdown 里直接插入合法的 HTML 块，他们会成为最终的 HTML 的一部分，做到 Markdown 本身做不到的事。<br>Markdown 的格式可以由 CSS 描述</p><h1 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h1><p>要创建标题，请在单词或短语前面添加# 。#的数量代表了标题的级别<br>用一个空格在#和标题之间进行分隔。</p><h1 id="强调语法"><a href="#强调语法" class="headerlink" title="强调语法"></a>强调语法</h1><p>粗体（Bold）加斜体（Italic）</p><p>要加粗文本，请在单词或短语的前后各添加三个星号（asterisks）</p><h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p>删除线就是给文本加上删除线，在文本两端使用两个波浪线~</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~文本~~</span><br></pre></td></tr></tbody></table></figure><p><del>文本</del></p><h1 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h1><p>要创建块引用，请在段落前添加一个&gt;符号。</p><h1 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h1><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p><h1 id="围栏代码块"><a href="#围栏代码块" class="headerlink" title="围栏代码块"></a>围栏代码块</h1><p>在代码块之前和之后的行上使用三个反引号（(```）或三个波浪号（~~~）。</p><p>在反引号后面加上语言的名字就可以享受到对应语言的语法高亮。</p><p>用反引号括起来，反引号是英文输入下，tab的上一个键</p><h1 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h1><p>在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。为了兼容性，请在分隔线的前后均添加空白行</p><h1 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h1><p>超链接Markdown语法代码：[超链接显示名](超链接地址 “超链接title”)<br>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p><h1 id="转义字符语法"><a href="#转义字符语法" class="headerlink" title="转义字符语法"></a>转义字符语法</h1><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p><h1 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![ddfdfd](图片链接 "图片title")</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p><a href="https://tableconvert.com/zh-CN/">Markdown表格工具</a><br>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><h2 id="hexo文章"><a href="#hexo文章" class="headerlink" title="hexo文章"></a>hexo文章</h2><p>表格要与正文空两行才可以渲染</p><h2 id="表格的对齐方式"><a href="#表格的对齐方式" class="headerlink" title="表格的对齐方式"></a>表格的对齐方式</h2><p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></tbody></table></figure><h1 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h1><p>任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。</p><ul><li><input checked="" disabled="" type="checkbox"> Write the press release</li><li><input disabled="" type="checkbox"> Update the website</li><li><input disabled="" type="checkbox"> Contact the media<h1 id="使用-Emoji-表情"><a href="#使用-Emoji-表情" class="headerlink" title="使用 Emoji 表情"></a>使用 Emoji 表情</h1>复制使用<br><a href="https://emojipedia.org/">https://emojipedia.org/</a></li></ul><p><a href="https://gist.github.com/rxaviers/7360908">https://gist.github.com/rxaviers/7360908</a></p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><h2 id="微信Markdown编辑器"><a href="#微信Markdown编辑器" class="headerlink" title="微信Markdown编辑器"></a>微信Markdown编辑器</h2><p>这个项目名doocs-md，在编写时，Markdown 文档自动即时渲染为微信图文，让你不再为微信文章排版而发愁！<br>项目地址：<a href="https://github.com/doocs/md">https://github.com/doocs/md</a></p><p>在线体验地址：</p><p>• Gitee Pages：<a href="https://doocs.gitee.io/md">https://doocs.gitee.io/md</a></p><p>• GitHub Pages：<a href="https://doocs.github.io/md">https://doocs.github.io/md</a></p><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><p>• 支持自定义 CSS 样式</p><p>• 支持 Markdown 所有基础语法</p><p>• 支持浅色、暗黑两种主题模式</p><p>• 支持 Ctrl + F 快速格式化文档</p><p>• 支持色盘取色，快速替换文章整体色调</p><p>• 支持多图上传，可自定义配置图床</p><p>• 支持自定义上传逻辑</p><p>• 支持在编辑框右键弹出功能选项卡</p><p>• 支持批量转换本地图片为线上图片</p><h3 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像"></a>使用 Docker 镜像</h3><p><code>docker run -d -p 8080:80 doocs/md:latest</code><br>容器运行起来之后，打开浏览器，访问 <a href="http://localhost:8080/">http://localhost:8080</a> 即可。</p><h3 id="使用-npm-cli"><a href="#使用-npm-cli" class="headerlink" title="使用 npm cli"></a>使用 npm cli</h3><p>通过我们的 npm cli 你可以轻易搭建属于自己的微信 Markdown 编辑器。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm i -g @doocs/md-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">md-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">open http://127.0.0.1:8800/md/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动并指定端口</span></span><br><span class="line">md-cli port=8899</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">open http://127.0.0.1:8899/md/</span><br></pre></td></tr></tbody></table></figure><h2 id="Marktext"><a href="#Marktext" class="headerlink" title="Marktext"></a>Marktext</h2><p><a href="https://github.com/marktext/marktext">项目地址</a><br>适用于 Linux、MacOS 和 Windows。</p><p>支持实时预览和干净简单的界面，以获得无干扰的写作体验；</p><p>支持 Markdown 扩展，例如：数学表达式（KaTeX）、表情符号等；</p><p>支持段落和内联样式快捷方式，从而提高写作效率；</p><p>支持导出 HTML 和 PDF 格式的文件；</p><p>支持多种主题，例如：Cadmium Light、Dark、Graphite Light、Material Dark、One Dark、UIysses Light；</p><p>支持多种模式，例如：源代码模式、打字机模式、专注模式；</p><p>支持可直接从剪贴板粘贴图像；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://markdown.com.cn/basic-syntax/&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Markdo</summary>
      
    
    
    
    <category term="知识" scheme="https://wenkex.gitee.io/categories/%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="markdown" scheme="https://wenkex.gitee.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>IDE配置及使用</title>
    <link href="https://wenkex.gitee.io/2022/01093653.html"/>
    <id>https://wenkex.gitee.io/2022/01093653.html</id>
    <published>2022-01-09T03:18:05.000Z</published>
    <updated>2022-01-09T03:18:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h1><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="保存后格式化"><a href="#保存后格式化" class="headerlink" title="保存后格式化"></a>保存后格式化</h3><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    vscode保存后的动作</span></span><br><span class="line">    <span class="string">"editor.codeActionsOnSave"</span>: {</span><br><span class="line">        <span class="comment">// 保存后自动格式化js,css代码，需要安装插件(ESLint,StyleLint)</span></span><br><span class="line">        <span class="attr">"source.fixAll.eslint"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"source.fixAll.stylelint"</span>: <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    },</span><br></pre></td></tr></tbody></table></figure><h3 id="括号对着色"><a href="#括号对着色" class="headerlink" title="括号对着色"></a>括号对着色</h3><p>Editor › Bracket Pair Colorization: Enabled<br>控制是否已启用括号对着色。使用 Workbench: Color Customizations 替代括号高亮颜色。</p><h2 id="vscode快捷键"><a href="#vscode快捷键" class="headerlink" title="vscode快捷键"></a>vscode快捷键</h2><p>F1 或 Ctrl+Shift+P（俗称万能键）  ：打开命令面板</p><p>ctrl+y 取消撤销</p><p>1.查看函数或者类的定义<br>Ctrl+鼠标左键点击函数名或者类名即可跳转到定义处，在函数名或者类名上按F12也可以实现同样功能</p><p>重命名变量：f2</p><p>单行注释&nbsp; Ctrl +/<br>块注释:Alt + Shift + A</p><h3 id="编辑器与窗口管理"><a href="#编辑器与窗口管理" class="headerlink" title="编辑器与窗口管理"></a>编辑器与窗口管理</h3><p>新建文件:   Ctrl+N</p><p>文件之间切换:   Ctrl+Tab</p><p>打开一个新的VS Code编辑器:    Ctrl+Shift+N</p><p>关闭当前窗口:   Ctrl+W</p><p>关闭当前的VS Code编辑器:   Ctrl+Shift+W</p><p>切出一个新的编辑器窗口(分屏–最多3个):   Ctrl+\</p><p>切换左中右3个编辑器窗口的快捷键:   Ctrl+1  Ctrl+2  Ctrl+3</p><p>##3 格式调整</p><p>代码行向左或向右缩进:   Ctrl+[ 、 Ctrl+] </p><p>复制或剪切当前行/当前选中内容:   Ctrl+C 、 Ctrl+V</p><p>代码格式化:   Shift+Alt+F</p><p>向上或向下移动一行:   Alt+Up 或 Alt+Down</p><p>向上或向下复制一行:   Shift+Alt+上键 或 Shift+Alt+下键</p><p>在当前行下方插入一行:   Ctrl+Enter</p><p>在当前行上方插入一行:   Ctrl+Shift+Enter</p><h3 id="光标相关"><a href="#光标相关" class="headerlink" title="光标相关"></a>光标相关</h3><p>移动到行首:   Home<br>移动到行尾:   End</p><p>移动到文件结尾:   Ctrl+End</p><p>移动到文件开头:   Ctrl+Home</p><p>移动到定义处:   F12</p><p>查看定义处缩略图(只看一眼而不跳转过去):    Alt+F12</p><p>选择从光标到行尾的内容:   Shift+End</p><p>选择从光标到行首的内容： Shift+Home</p><p>删除光标右侧的所有内容(当前行):   Ctrl+Delete</p><p>扩展/缩小选取范围： Shift+Alt+Right 和 Shift+Alt+Left</p><p>多行编辑(列编辑):   Alt+Shift+鼠标左键 或 Ctrl+Alt+Down/Up</p><p>同时选中所有匹配编辑(与当前行或选定内容匹配):   Ctrl+Shift+L</p><p>下一个匹配的也被选中:   Ctrl+D</p><p>回退上一个光标操作:   Ctrl+U</p><p>撤销上一步操作: Ctrl+Z</p><p>手动保存:   Ctrl+S</p><h3 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h3><p>找到所有的引用:   Shift+F12</p><p>重命名变量:   Ctrl+F2</p><p>跳转到下一个 Error 或 Warning:   当有多个错误时可以按 F8 逐个跳转</p><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><p>查找:   Ctrl+F</p><p>查找替换:   Ctrl+H</p><h3 id="显示相关"><a href="#显示相关" class="headerlink" title="显示相关"></a>显示相关</h3><p>全屏显示(再次按则恢复):   F11</p><p>放大或缩小(以编辑器左上角为基准):   Ctrl +/-</p><p>侧边栏显示或隐藏： Ctrl+B</p><p>显示资源管理器(光标切到侧边栏中才有效):   Ctrl+Shift+E</p><p>显示搜索(光标切到侧边栏中才有效):   Ctrl+Shift+F</p><p>显示源代码管理(光标切到侧边栏中才有效):    Ctrl+Shift+G+G</p><p>显示 Debug:    Ctrl+Shift+D</p><p>显示 Output:    Ctrl+Shift+U</p><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><h3 id="Code-runner"><a href="#Code-runner" class="headerlink" title="Code-runner"></a>Code-runner</h3><p>在设置中搜索Code-runner: File Directory As Cwd<br>这个选项的作用是将我们运行的py文件所在目录设置为当前工作目录</p><h2 id="Beautify"><a href="#Beautify" class="headerlink" title="Beautify"></a>Beautify</h2><p>搜索Beautify，点击Beautify file美化整个文件。代码被自动换行，也进行了格式化。这个美化操作支持多种格式的源代码。</p><h2 id="管理-ignore-files文件"><a href="#管理-ignore-files文件" class="headerlink" title="管理.ignore files文件"></a>管理.ignore files文件</h2><p>AnGitIgnored</p><h2 id="图像编辑器"><a href="#图像编辑器" class="headerlink" title="图像编辑器"></a>图像编辑器</h2><p>Luna Paint — Image Editor<br>一个内置在 VS Code 中的图像编辑器，支持 png，jpg，webp，bmp 和 ico 格式。</p><h2 id="缩进带颜色"><a href="#缩进带颜色" class="headerlink" title="缩进带颜色"></a>缩进带颜色</h2><p>Indent-Rainbow</p><h2 id="可视化模块依赖关系"><a href="#可视化模块依赖关系" class="headerlink" title="可视化模块依赖关系"></a>可视化模块依赖关系</h2><p>Dependency Cruiser Extension</p><h2 id="删除空行"><a href="#删除空行" class="headerlink" title="删除空行"></a>删除空行</h2><p>Remove empty lines</p><h2 id="change-case"><a href="#change-case" class="headerlink" title="change-case"></a>change-case</h2><p>ctrl + shift + p 调出命令面板:搜索change-case snack</p><p>更改当前选择的单词的格式, 比如<br>  大小写,<br>  js的驼峰camel,<br>  python的蛇形snake,<br>  css的串式kebab,<br>  java的匈牙利HN</p><h2 id="AI辅助-单元测试"><a href="#AI辅助-单元测试" class="headerlink" title="AI辅助-单元测试"></a>AI辅助-单元测试</h2><p>Ponicode</p><h2 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h2><p>koroFileHeader</p><p>用于生成文件头部注释和函数注释</p><p><strong>文件头部注释快捷键</strong><br>记录文件信息/文件的传参/出参，设置个性签名、留下QQ、微信联系方式、输入空行等等<br>支持用户高度自定义注释选项, 适配各种需求的注释形式。<br>保存文件的时候，自动更新最后的编辑时间和编辑人<br>    window：ctrl+win+i,<br>    mac：ctrl+cmd+i,<br>    linux: ctrl+meta+i,<br>    Ubuntu: ctrl+super+i</p><p><strong>函数注释注释快捷键</strong><br>更多关于函数参数自动请查阅配置-函数注释自动提取函数的参数文档<br>将光标放在函数行或者将光标放在函数上方的空白行。<br>自动解析函数参数，生成函数参数注释。<br>快捷键：<br>    window：ctrl+win+t,<br>    mac：ctrl+cmd+t,<br>    linux: ctrl+meta+t,<br>    Ubuntu: ctrl+super+t</p><p>快捷键不生效<br>在vscode界面输入 ctrl+shift+p ， 搜索找到键盘快捷方式,再搜索 cursortip （函数注释快捷键）</p><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>加入设置的setting.json</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="string">"background.enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"background.useDefault"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"background.customImages"</span>: [</span><br><span class="line">    <span class="string">"file:///E:/wenke_source/my picture/壁纸.jpg"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"background.style"</span>: {</span><br><span class="line">    <span class="attr">"content"</span>: <span class="string">"''"</span>,</span><br><span class="line">    <span class="attr">"pointer-events"</span>: <span class="string">"none"</span>,</span><br><span class="line">    <span class="attr">"position"</span>: <span class="string">"absolute"</span>,</span><br><span class="line">    <span class="attr">"top"</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="attr">"right"</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="attr">"background-size"</span>: <span class="string">"cover"</span>,</span><br><span class="line">    <span class="attr">"opacity"</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="attr">"z-index"</span>: <span class="string">"99999"</span>,</span><br><span class="line">    <span class="attr">"width"</span>: <span class="string">"100%"</span>,</span><br><span class="line">    <span class="attr">"height"</span>: <span class="string">"100%"</span>,</span><br><span class="line">    <span class="attr">"background-repeat"</span>: <span class="string">"no-repeat"</span>,</span><br><span class="line">},</span><br><span class="line"><span class="string">"bracketPairColorizer.depreciation-notice"</span>: <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><h2 id="同步配置。"><a href="#同步配置。" class="headerlink" title="同步配置。"></a>同步配置。</h2><p>Settings Sync</p><p>1.用Github账户登录<br>2.创建一个新的GIST或选择存在的GIST<br>3.上传配置<br>按下 Shift + Alt + U</p><p>4.下载配置<br>按下 Shift + Alt + D</p><h2 id="美化文件图标"><a href="#美化文件图标" class="headerlink" title="美化文件图标"></a>美化文件图标</h2><p>Material Icon Theme：</p><h2 id="实时预览图片"><a href="#实时预览图片" class="headerlink" title="实时预览图片"></a>实时预览图片</h2><p>Image Preview </p><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><p>Project Manager</p><p>用来快速打开项目</p><h2 id="路径补充"><a href="#路径补充" class="headerlink" title="路径补充"></a>路径补充</h2><p>Path Intellisense ,模块导入, 智能提示</p><h2 id="绘图工具"><a href="#绘图工具" class="headerlink" title="绘图工具"></a>绘图工具</h2><p>vscode-drawio</p><h2 id="展示数据结构形成过程"><a href="#展示数据结构形成过程" class="headerlink" title="展示数据结构形成过程"></a>展示数据结构形成过程</h2><p>debug-visualizer</p><h2 id="database-client"><a href="#database-client" class="headerlink" title="database-client"></a>database-client</h2><p>支持MySQL/MariaDB, PostgreSQL, SQLite, Redis, ClickHouse, 达梦以及ElasticSearch的管理, 且可以作为一个SSH客户端, 最大程度地提高你的生产力!</p><h2 id="CodeTour"><a href="#CodeTour" class="headerlink" title="CodeTour"></a>CodeTour</h2><p>CodeTour 允许我们为代码添加备注，并且将这些备注串联起来，动态地展示我们的思路以及代码逻辑。</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="用户代码片段-snippets-语法"><a href="#用户代码片段-snippets-语法" class="headerlink" title="用户代码片段  snippets 语法"></a>用户代码片段  snippets 语法</h3><p><a href="https://mp.weixin.qq.com/s/abJg5w1XtWxo42qIfweIFg">原文</a></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"alpha"</span>: {</span><br><span class="line">        <span class="attr">"prefix"</span>: [<span class="string">"a"</span>, <span class="string">"z"</span>],</span><br><span class="line">        <span class="attr">"body"</span>: [</span><br><span class="line">            <span class="string">"abcdefghijklmnopqrstuvwxyz"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"字母"</span>,</span><br><span class="line">        <span class="attr">"scope"</span>: <span class="string">"javascript"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>prefix 是触发的前缀，可以指定多个<br>body 是插入到编辑器中的内容，支持很多语法<br>description 是描述<br>scope 是生效的语言，不指定的话就是所有语言都生效</p><h4 id="vscode代码片段生成器"><a href="#vscode代码片段生成器" class="headerlink" title="vscode代码片段生成器"></a>vscode代码片段生成器</h4><p>utools插件</p><h2 id="python环境"><a href="#python环境" class="headerlink" title="python环境"></a>python环境</h2><h3 id="运行python代码"><a href="#运行python代码" class="headerlink" title="运行python代码"></a>运行python代码</h3><p>在终端中运行python代码:在VSCode终端显示运行结果，它会默认显示当前环境和被执行文件的路径</p><p>在python终端中运行选定内容：在python交互窗口执行文件，执行的过程中我们可以通过输入框进行输入交互。它类似Jupyter, 每次运行都是独立的单元格，方便观察结果</p><h3 id="python代码输出中文乱码"><a href="#python代码输出中文乱码" class="headerlink" title="python代码输出中文乱码"></a>python代码输出中文乱码</h3><p>在”文件”－“首选项”－”用户设置”中搜索code-runner.executorMap选项，提示需要在setting.json中修改<br>“code-runner.executorMap”: {<br>“python”: “set PYTHONIOENCODING=utf8 &amp;&amp; python -u”<br>}</p><h3 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h3><p>关闭 vscode 的自动导入包功能，经常导错<br>设置搜索Python › Analysis: Auto Import Completions，并关闭</p><h3 id="用户代码片段"><a href="#用户代码片段" class="headerlink" title="用户代码片段"></a>用户代码片段</h3><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"python"</span>:{</span><br><span class="line">        <span class="attr">"prefix"</span>: <span class="string">"!py"</span>,</span><br><span class="line">        <span class="attr">"body"</span>: [</span><br><span class="line">        <span class="string">"#!/usr/bin/env python3.8.8"</span>,</span><br><span class="line">        <span class="string">"# -*- encoding: utf-8 -*-"</span>,</span><br><span class="line">        <span class="string">"'''"</span>,</span><br><span class="line">        <span class="string">"@File    :   $TM_FILENAME"</span>,</span><br><span class="line">        <span class="string">"@Time    :   $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND"</span>,</span><br><span class="line">        <span class="string">"@Author  :   wenke "</span>,</span><br><span class="line">        <span class="string">"@Version :   1.0"</span>,</span><br><span class="line">        <span class="string">"@Contact :   1184664659@qq.com"</span>,</span><br><span class="line"><span class="string">"@WebSite :   https://wenkexia.github.io"</span>,</span><br><span class="line">        <span class="string">"@Desc    :   None"</span>,</span><br><span class="line">        <span class="string">"'''"</span>,</span><br><span class="line">    </span><br><span class="line">        <span class="string">""</span>,</span><br><span class="line">        <span class="string">"if __name__ == '__main__':"</span>,</span><br><span class="line">    </span><br><span class="line">        <span class="string">""</span>,</span><br><span class="line">        <span class="string">"$0"</span></span><br><span class="line">    ],</span><br><span class="line">    }   </span><br><span class="line">}</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure><h3 id="python插件"><a href="#python插件" class="headerlink" title="python插件"></a>python插件</h3><p>AI Doc write:ai帮你写注释<br>只要选中函数代码，然后按一个快捷键就会自动生成该方法的注释，可用来生成函数文档，</p><p>Sourcegraph<br>你可以直接从 VS Code IDE 免费搜索数百万个开源存储库。从有用的代码示例中学习，搜索最佳实践，并从开源宇宙中数百万个存储库中重用代码。</p><p>Krinql<br>如果你看不懂代码，可以让 Krinql 来回答，或者让它编写文档字符串：</p><h1 id="JetBrains系列"><a href="#JetBrains系列" class="headerlink" title="JetBrains系列"></a>JetBrains系列</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>安装目录下的bin目录，可以看到一个idea.properties文件，核心配置文件<br>参数：<br>    1.idea.config.path<br>    这个目录是我们在File\settings标签下做的一些配置，例如CodeStyle、KeyMaps等。</p><pre><code>2.idea.system.path这个目录下的配置很关键，编译工具、本地历史、工作空间配置等都在这里。3.idea.plugins.path这里放的是我们安装的一些插件，如果你需要增加插件，除了在IDEA的操作界面添加，把插件移动到这个目录然后重启也可以安装成功，这就是离线安装。4.idea.log.path这个目录保存了IDEA产生的log。如果你觉得占用空间过大，也可以删掉部分过期的log。</code></pre><h2 id="jetbrains系列产品激活"><a href="#jetbrains系列产品激活" class="headerlink" title="jetbrains系列产品激活"></a>jetbrains系列产品激活</h2><p>使用服务器激活方式，不过不稳定</p><h1 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h1><h2 id="备份配置"><a href="#备份配置" class="headerlink" title="备份配置"></a>备份配置</h2><p>配置信息导出到文件：点击file，选择export settings<br>配置文件的导入：点击file，选择import settings</p><h2 id="插件下载位置更改"><a href="#插件下载位置更改" class="headerlink" title="插件下载位置更改"></a>插件下载位置更改</h2><p>原来的配置和下载的插件:C:\Users\wenke\AppData\Roaming\JetBrains\PyCharm2022.1</p><p>找到如下图所示关系配置项。修改为自己设定的文件位置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idea.config.path=D:/data/pycharm/config</span><br><span class="line">idea.system.path=D:/data/pycharm/system</span><br><span class="line">idea.plugins.path=D:/data/pycharm/plugins</span><br><span class="line">idea.log.path=D:/data/pycharm/log</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果你需要安装一个新的pycharm，把配置好的目录以及bin下的idea.properties文件，直接copy到新的pycharm的配置文件目录就可以了。</p><h2 id="多个版本冲突"><a href="#多个版本冲突" class="headerlink" title="多个版本冲突"></a>多个版本冲突</h2><p>打开C盘用户名下的文件夹，按图中步骤打开Roaming，找到JetBrains，将JetBrains目录删除，然后PyChram就可以打开了。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>ctrl + alt + L  ：一键格式化代码<br>ctrl +shift +f :全局查找<br>ctrl +shift +f ：全局替换<br>shift +f10:运行<br>shift + Enter :换行<br>CTRL + SHIFT + F10    运行当前编辑区的程序文件    </p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p>PyCharm”→“File”→“Settings”→“Editor”→“File and Code Templates</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@author: ${USER}</span></span><br><span class="line"><span class="string">@software: ${PRODUCT_NAME}</span></span><br><span class="line"><span class="string">@file: ${NAME}.py</span></span><br><span class="line"><span class="string">@time: ${DATE} ${TIME}</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><h2 id="设置-2"><a href="#设置-2" class="headerlink" title="设置"></a>设置</h2><p>设置-&gt;编辑器-&gt;常规-&gt;自动导入   (开启自动导包，删包)</p><h2 id="更改用户保存目录"><a href="#更改用户保存目录" class="headerlink" title="更改用户保存目录"></a>更改用户保存目录</h2><p>原来的配置和下载的插件，可以将原来C盘（C:\Users\xxx.IntelliJIdea）对应的文件<br>或者在C:\Users\wenke\AppData\Roaming\JetBrains\PyCharm2022.1</p><p>在你的IDEA安装目录下的bin目录，可以看到一个idea.properties文件，这个文件是IDEA的核心配置文件<br>找到如下图所示关系配置项。修改为自己设定的文件位置</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idea.system.path=D:/data/IDEA/system</span><br><span class="line"># 配置</span><br><span class="line">idea.config.path=D:/data/IDEA/config</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>maven<br>用户设置文件：C:\Users\wenke.m2\settings.xml<br>本地仓库：C:\Users\wenke.m2\repository</p><p>我设置成<br>用户设置文件：D:\data\IDEA.IntelliJIdea.m2\settings.xml<br>本地仓库：D:\data\IDEA.IntelliJIdea.m2\repository</p><h2 id="快捷键-1"><a href="#快捷键-1" class="headerlink" title="快捷键"></a>快捷键</h2><p>ctrl + d 快速复制这行到下一行</p><p>alt + insert ：自动生成get,set方法</p><p>注释<br>行注释Ctrl+/、<br>块注释Ctrl+Shift+/<br>文档注释  /**+enter</p><h3 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h3><p>按住ctrl选中多个文件，右击选比较文件或者ctrl+d</p><h2 id="自动生成"><a href="#自动生成" class="headerlink" title="自动生成"></a>自动生成</h2><p>psvm:main()方法</p><p>“内容”.sout :输出语句</p><p>fori:for循环语句</p><p>flag.whil + 回车：while语句</p><p>flag.if + 回车 ：if语句</p><p>new 类名.var + 回车 ：自动生成对象</p><h2 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h2><p>Alibaba Java Coding Guidelines（阿里巴巴Java开发规范）</p><p>Key Promoter X（IDEA快捷键提示）</p><p>Save Actions（当程序员将代码保存后，插件会自动进行格式化）</p><p>Codota AI Autocomplete（代码自动提示和推荐）</p><p>Auto filling Java call arguments（自动填充调用方法参数）<br>在调用函数时，通过alt+enter键，触发联想功能，选择”auto fill call parameters”自动填充调用的函数的形参名。</p><p>GenerateAllSetter（自动生成调用对象的set方法）</p><p>Maven Helper（Maven依赖分析工具）<br>该插件可以查看maven的依赖树，分析版本冲突，并提供maven常用命令模板。</p><h2 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h2><h3 id="自定义代码模板"><a href="#自定义代码模板" class="headerlink" title="自定义代码模板"></a>自定义代码模板</h3><p>第一个是代码模板快捷输入语句，第二个是说明，第三个就是我们自己定义的代码模板，$END$是回车后光标自动跳转的地方。</p><h3 id="创建类模板"><a href="#创建类模板" class="headerlink" title="创建类模板"></a>创建类模板</h3><p>1.按照顺序打开File–&gt;settings–&gt;Editor–&gt;File and Code Templates–&gt;Includes-&gt;File Header<br>2.输入类注释模板</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> ${NAME}</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> ${DATE} ${TIME}</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ${USER}</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="创建方法模板"><a href="#创建方法模板" class="headerlink" title="创建方法模板"></a>创建方法模板</h3><p>1.按照顺序打开File–&gt;Settings–&gt;Editor–&gt;Live Templates<br>2.点击右边的”+“号,选择Template Group,创建自己的组名<br>3.选择自己的组名，点击”+”号，选择Live Template<br>4.填写Abbreviation(你设定的关键字)，Description(对模板的描述，会在调用时提示;)<br>5.点击 Define(模板作用的位置) 选择java</p><p>6.Template text(要显示的完整代码;)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span>: $date$-$time$</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: $USER$</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params</span>: $params$</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: $return$</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 描述</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>7.编辑模板变量,然后将每一行最后的“Skip if defined”勾选。<br>data:data()<br>time:time()<br>USER:user()</p><p>param默认可选择的方法<br><code>groovyScript("def result = '';def params = \"${_1}\".replaceAll('[\\\\[|\\\\]|\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++) {if(params[i] != '')result+='* @param ' + params[i] + ' ' +((i &lt; params.size() - 1) ? '\\r\\n ' : '')}; return result == '' ? null : result", methodParameters()) </code></p><p>return默认可选择的方法<br><code>groovyScript("def returnType = \"${_1}\"; def result ='';if(returnType=='null'||returnType=='void'){return;}else{result += '* @return ';cls = returnType.split('&lt;');for(i = 0; i &lt; cls.size(); i++){temp = cls[i].tokenize('.');result += temp[temp.size() - 1] + ((i &lt; cls.size() - 1) ? '&lt;' : '');};return result + ' ';}", methodReturnType()); </code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vscode&quot;&gt;&lt;a href=&quot;#vscode&quot; class=&quot;headerlink&quot; title=&quot;vscode&quot;&gt;&lt;/a&gt;vscode&lt;/h1&gt;&lt;h2 id=&quot;设置&quot;&gt;&lt;a href=&quot;#设置&quot; class=&quot;headerlink&quot; title=&quot;设置&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="工具" scheme="https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="vscode" scheme="https://wenkex.gitee.io/tags/vscode/"/>
    
  </entry>
  
</feed>
