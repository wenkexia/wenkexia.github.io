{"meta":{"title":"wenke","subtitle":"个人博客","description":"专注于编程,分享生活,分享知识","author":"wenke","url":"https://wenkexia.github.io","root":"/"},"pages":[{"title":"404","date":"2021-11-01T11:37:13.000Z","updated":"2021-11-01T11:38:12.585Z","comments":true,"path":"404/index.html","permalink":"https://wenkexia.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2021-11-01T11:29:40.000Z","updated":"2022-01-08T12:59:04.203Z","comments":true,"path":"about/index.html","permalink":"https://wenkexia.github.io/about/index.html","excerpt":"","text":"“&nbsp;免责声明” 大部分资源来源于网络，仅供学习和交流使用，严禁商用，如有侵权，请联系我删除。 所有资源都有时效性，如果遇到失效的，请私信我。"},{"title":"分类","date":"2021-11-01T11:27:35.000Z","updated":"2021-12-21T11:53:24.702Z","comments":true,"path":"categories/index.html","permalink":"https://wenkexia.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-11-01T11:31:07.000Z","updated":"2021-11-01T11:34:49.609Z","comments":true,"path":"contact/index.html","permalink":"https://wenkexia.github.io/contact/index.html","excerpt":"","text":""},{"title":"相册集","date":"2020-04-21T10:44:23.000Z","updated":"2022-01-06T10:15:44.567Z","comments":true,"path":"gallery/index.html","permalink":"https://wenkexia.github.io/gallery/index.html","excerpt":"","text":"虾虾 关于虾虾"},{"title":"友链","date":"2021-12-21T11:51:03.000Z","updated":"2021-12-21T11:51:03.000Z","comments":true,"path":"link/index.html","permalink":"https://wenkexia.github.io/link/index.html","excerpt":"","text":"申请友链在评论区留言即可，但需先添加本站友链（申请格式如下文所述） ‘name: wenke’ ‘link: https://wenkex.top/'‘avatar: https://gitee.com/wenkex/blogimage/raw/master/favicon.png' ‘descr: wenke’"},{"title":"标签","date":"2021-11-01T11:27:35.000Z","updated":"2021-12-21T11:53:03.522Z","comments":true,"path":"tags/index.html","permalink":"https://wenkexia.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-06T10:26:36.009Z","updated":"2022-01-06T10:26:36.009Z","comments":true,"path":"gallery/虾虾/index.html","permalink":"https://wenkexia.github.io/gallery/%E8%99%BE%E8%99%BE/index.html","excerpt":"","text":""}],"posts":[{"title":"python-图像处理","slug":"python-图像处理","date":"2022-03-22T14:44:39.000Z","updated":"2022-03-22T14:44:39.000Z","comments":true,"path":"2022/032217173.html","link":"","permalink":"https://wenkexia.github.io/2022/032217173.html","excerpt":"","text":"PIL，cv2，plt的使用与区别 建议使用opencv的库来进行图像处理的基本操作，数据格式为numpy，可以直接进行numpy的处理； 进行折线图这类图绘制的时候，一般使用matplotlib库。 Opencv默认为 BGR顺序，而其他软件（PIL、scopy.misc）一般使用RGB。 1234567891011121314151617181920212223242526272829from PIL import Imageimport cv2import matplotlib.pyplot as pltimport numpy as np# 比较三者的打开图片、显示图片、打开图片的类型# ************PIL************PIL_img = Image.open('D:/images/Rimi.jpg')print(type(PIL_img)) # &lt;class 'PIL.JpegImagePlugin.JpegImageFile'&gt;print(PIL_img.size) # (1152, 720) (w,h)print(np.array(PIL_img).shape) # (720, 1152, 3) (h,w,c)PIL_img.show()# ************cv2************cv2_img = cv2.imread('D:/images/Rimi.jpg')print(type(cv2_img)) # &lt;class 'numpy.ndarray'&gt;print(cv2_img.shape) # (720, 1152, 3) (h,w,c)cv2.imshow('cv2', cv2_img)# cv2.waitKey()# ************plt***********plt_img = plt.imread('D:/images/Rimi.jpg')print(type(plt_img)) # &lt;class 'numpy.ndarray'&gt;print(plt_img.shape) # (720, 1152, 3) (h,w,c)plt.imshow(plt_img) # PIL_img也可以显示plt.show() OpenCVOpenCV中已经包含如下应用领域功能：二维和三维特征工具箱、运动估算、人脸识别系统、姿势识别、人机交互、移动机器人、运动理解、对象鉴别、分割与识别、立体视觉、运动跟踪、增强现实（AR技术）。基于上述功能实现需要，OpenCV中还包括以下基于统计学机器学习库：Boosting算法、Decision Tree(决策树)学习、Gradient Boosting算法、EM算法(期望最大化)、KNN算法、朴素贝叶斯分类、人工神经网络、随机森林、支掌向量机。 cv2默认为 BGR顺序，而其他（PIL、scopy.misc）一般使用RGB 导入的时候采用 import cv2。 基本库函数cv2.imread(filepath,flags) #读入一张图像 filepath：要读入图片的完整路径flags：读入图片的标志cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道cv2.IMREAD_GRAYSCALE：读入灰度图片cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道 cv2.imshow(wname,img) #显示图像 第一个参数是显示图像的窗口的名字第二个参数是要显示的图像（imread读入的图像），窗口大小自动调整为图片大小cv2.imshow(‘image’,img) cv2.waitKey(0) #等待键盘输入，单位为毫秒，即等待指定的毫秒数看是否有键盘输入，若在等待时间内按下任意键则返回按键的ASCII码，程序继续运行。 #若没有按下任何键，超时后返回-1。参数为0表示无限等待。不调用waitKey的话，窗口会一闪而逝，看不到显示的图片。 cv2.destroyAllWindow() #销毁所有窗口 cv2.destroyWindow(wname) #销毁指定窗口 cv2.imwrite(file，img，num) #保存一张图像 第一个参数是要保存的文件名第二个参数是要保存的图像。可选的第三个参数，它针对特定的格式：对于JPEG，其表示的是图像的质量，用0 - 100的整数表示，默认95。第三个参数表示的是压缩级别。默认为3.img.copy() #图像复制 cv2.cvtColor() #图像颜色空间转换 img2 = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY) #灰度化：彩色图像转为灰度图像img3 = cv2.cvtColor(img,cv2.COLOR_GRAY2RGB) #彩色化：灰度图像转为彩色图像 cv2.COLOR_X2Y，其中X,Y = RGB, BGR, GRAY, HSV, YCrCb, XYZ, Lab, Luv, HLScv2.resize(image, image2,dsize) #图像缩放：(输入原始图像，输出新图像，图像的大小)cv2.flip(img,flipcode) #图像翻转，flipcode控制翻转效果。 flipcode = 0：沿x轴翻转；flipcode &gt; 0：沿y轴翻转；flipcode &lt; 0：x,y轴同时翻转cv2.warpAffine(img, M, (400, 600)) #图像仿射变换 ：平移；裁剪、剪切、旋转、仿射变换，M、M_crop、M_shear、M_rotate cv2.putText(img,’text’,(50,150) #图像添加文字：(照片，添加的文字，左上角坐标，字体，字体大小，颜色，字体粗细) cv2.putText(image, caption, (b[0], b[1] - 10), cv2.FONT_HERSHEY_PLAIN, 1, (255, 0, 0), 1) cv2.putText(I,’there 0 error(s):’,(50,150),cv2.FONT_HERSHEY_COMPLEX,6,(0,0,255),25) cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2) #画出矩行：img原图、(x，y)是矩阵的左上点坐标、(x+w，y+h)是矩阵的右下点坐标、(0,255,0)是画线对应的rgb颜色、2是所画的线的宽度。 cv2.boundingRect(img) #返回图像的四值属性：img是一个二值图，即是它的参数； 返回四个值，分别是x，y，w，h； x，y是矩阵左上点的坐标，w，h是矩阵的宽和高。 PIL库PIL（Python Imaging Library）是Python常用的图像处理库，而Pillow是PIL的一个友好Fork，提供了了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。相比opencv更为轻巧。Image模块是在Python PIL图像处理中常见的模块，对图像进行基础操作的功能基本都包含于此模块内。如open、save、show等功能。 使用#安装pillowpip install pillow from PIL import ImageImage 是 PIL 库中代表一个图像的类（对象） Matplotlib库Matplotlib是一个Python 2D绘图库，它可以在不同的平台上以各种硬拷贝格式和交互环境生成发布质量数据。Matplotlib可以用于Python脚本、Python和IPython shell、Jupyter notebook、web应用服务器和四个图形用户界面工具包。对于简单的绘图，pyplot模块提供了一个类似于matlab的接口，特别是与IPython结合使用时。对于power用户，您可以通过面向对象的界面或通过MATLAB用户熟悉的一组函数来完全控制线样式、字体属性、轴属性等. matplotlib.pylot是绘制各类可视化图形的命令字库 更多学习，可参考Matplotlib中文网：https://www.matplotlib.org.cn 使用pip install matplotlibimport matplotlib.pyplot as plt","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"图像","slug":"图像","permalink":"https://wenkexia.github.io/tags/%E5%9B%BE%E5%83%8F/"}]},{"title":"python-pandas","slug":"python-pandas","date":"2022-03-22T13:29:33.000Z","updated":"2022-03-22T13:29:33.000Z","comments":true,"path":"2022/03226351.html","link":"","permalink":"https://wenkexia.github.io/2022/03226351.html","excerpt":"","text":"pandas是python第三方库，提供高性能易用数据类型和分析工具。 pandas基于numpy实现，常与numpy和matplotlib一同使用 更多学习，请参考pandas中文网：https://www.pypandas.cn/ SeriesSeries是一种类似于一维数组的对象，它由一维数组（各种numpy数据类型）以及一组与之相关的数据标签（即索引）组成. 可理解为带标签的一维数组，可存储整数、浮点数、字符串、Python 对象等类型的数据。 Seris中可以使用index设置索引列表。 12345678910111213import pandas as pdimport numpy as np#与字典不同的是：Series允许索引重复s = pd.Series(['a','b','c','d','e'],index=[100,200,100,400,500])#Series 可以用字典实例化d = {'b': 1, 'a': 0, 'c': 2}pd.Series(d)#通过Series的values和index属性获取其数组表示形式和索引对象print(s)print(s.values)print(s.index) DataFrameDataFrame是一个表格型的数据结构，类似于Excel或sql表 它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）DataFrame可以进行行索引和列索引，它可以被看做由Series组成的字典（共用同一个索引） 123456789101112#用多维数组字典、列表字典生成 DataFramedata = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'], 'year': [2000, 2001, 2002, 2001, 2002], 'pop': [1.5, 1.7, 3.6, 2.4, 2.9]}frame = pd.DataFrame(data)print(frame)frame2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'], index=['one', 'two', 'three', 'four', 'five'])print(frame2)#列可以通过赋值的方式进行修改,例如，给那个空的“delt”列赋上一个标量值或一组值frame2['debt'] = 16.5print(frame2)","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"https://wenkexia.github.io/tags/pandas/"}]},{"title":"python-NumPy","slug":"python-NumPy","date":"2022-03-22T06:42:45.000Z","updated":"2022-03-22T06:42:45.000Z","comments":true,"path":"2022/032261592.html","link":"","permalink":"https://wenkexia.github.io/2022/032261592.html","excerpt":"","text":"数学矩阵知识https://paul.pub/the-matrix/#id-%E6%A0%87%E9%87%8F%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BC%A0%E9%87%8F 矩阵算术加减法矩阵的加减法只在两个矩阵具有相同大小时才有意义。 两个矩阵的加（减）法通过对应元素相加（减）得到 标量乘法设A为一矩阵，b为一标量，则bA为将A中的每一个元素乘以b而构成的一个矩阵 转置矩阵的转置是以对角线为轴的镜像。 这条从左上角到右下角的对角线被称之为主对角线 矩阵乘法第一个矩阵的列要等于第二个矩阵的行，则两矩阵可以相乘。一个m∗n的的A矩阵，和一个n∗p的B矩阵相乘，将得到一个m∗p的矩阵C 逆逆(Inverse)设A为n阶方阵，如果存在一个n阶方阵B，使得AB=BA=InAB=BA=In 则称A为可逆矩阵，B为A的逆阵，记作 B=A−1B=A−1(A−1)−1=A(A−1)−1=A(kA)−1=1kA−1(k≠0)(kA)−1=1kA−1(k≠0)A、B均是同阶可逆矩阵，则(AB)−1=B−1A−1A、B均是同阶可逆矩阵，则(AB)−1=B−1A−1(A−1)T=(AT)−1(A−1)T=(AT)−1 求逆矩阵一般有三种方法。1、方阵的逆矩阵等于方阵的伴随矩阵与方阵对应的行列式的值的倒数的积； 即A^-1=A*/(|A|). 只有当|A|≠0时，方阵A才可逆。 这种方法并不简便。 2、利用初等变换求逆矩阵； 一般是将矩阵(A,E)化为(E,A^-1)的形式；从而得到A逆矩阵； 创建数组为了创建一个2D（二维）数组，我们传递一个列表的列表（或者是一个序列的序列）给array()函数。如果我们想要一个3D（三维）数组，我们就要传递一个列表的列表的列表，如果是一个4D（四维）数组，那就是列表的列表的列表的列表，以此类推。 多维数组切片通过对每个以逗号分隔的维度执行单独的切片，你可以对多维数组进行切片。因此，对于2D数组，我们的第一片定义了行的切片，第二片定义了列的切片。 函数np.zeros():可以创建指定长度或者形状的全0数组 ones():可以创建指定长度或者形状的全1数组 empty():创建一个数组，其初始内容是随机的,取决于内存的状态 为了创建数字组成的数组，NumPy提供了一个类似于range的函数，该函数返回数组而不是列表。array = np.arange( 10, 31,5 ) -&gt;array([10, 15, 20, 25, 30]) 数组属性array = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]]) #数组维度print(array.ndim) #数组形状print(array.shape) #数组元素个数print(array.size) #数组元素类型print(array.dtype) 数组的计算数组很重要，因为它可以使我们不用编写循环即可对数据执行批量运算。这通常叫做矢量化 基础运算对应位置的数相运算 12345678910arr1 = np.array([[1,2,3],[4,5,6]])arr2 = np.ones([2,3],dtype=np.int64)print(arr1 + arr2)print(arr1 - arr2)print(arr1 * arr2)print(arr1 / arr2)print(arr1 ** 2) print(np.dot(arr3,arr4))","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://wenkexia.github.io/tags/numpy/"}]},{"title":"python-selenium","slug":"python-selenium","date":"2022-03-18T14:31:09.000Z","updated":"2022-03-18T14:31:09.000Z","comments":true,"path":"2022/031841897.html","link":"","permalink":"https://wenkexia.github.io/2022/031841897.html","excerpt":"","text":"定位页面元素123456789101112from selenium import webdriverfrom selenium.webdriver.common.by import By#定位一个元素ele = driver.find_element(By.XPATH,'')#表示定位一组元素(元素相同时使用)lis = driver.find_elements(By.XPATH,'')if len(lis)&gt;0: lis[0].click()else： print('没有元素') id 定位name 定位class 定位tag 定位xpathxpath 是一种在 XML 文档中定位元素的语言，它拥有多种定位方式 123456789101112&lt;html&gt; &lt;head&gt;...&lt;head/&gt; &lt;body&gt; &lt;div id=\"csdn-toolbar\"&gt; &lt;div class=\"toolbar-inside\"&gt; &lt;div class=\"toolbar-container\"&gt; &lt;div class=\"toolbar-container-left\"&gt;...&lt;/div&gt; &lt;div class=\"toolbar-container-middle\"&gt; &lt;div class=\"toolbar-search onlySearch\"&gt; &lt;div class=\"toolbar-search-container\"&gt; &lt;input id=\"toolbar-search-input\" autocomplete=\"off\" type=\"text\" value=\"\" placeholder=\"C++难在哪里？\"&gt; 根据上面的标签需要定位 最后一行 input 标签，以下列出了四种方式，xpath 定位的方式多样并不唯一，使用时根据情况进行解析即可。 123456789# 绝对路径（层级关系）定位 （绝对路径以/开头）driver.find_element_by_xpath( \"/html/body/div/div/div/div[2]/div/div/input[1]\")# 利用元素属性定位 （相对路径以//开头）driver.find_element_by_xpath(\"//*[@id='toolbar-search-input']\"))# 层级+元素属性定位driver.find_element_by_xpath( \"//div[@id='csdn-toolbar']/div/div/div[2]/div/div/input[1]\")# 逻辑运算符定位driver.find_element_by_xpath(\"//*[@id='toolbar-search-input' and @autocomplete='off']\") 1.相对路径+索引先定位要找的元素，再找它唯一的父标签2.相对路径+属性3.相对路径+通配符定位4.相对路径+部分属性值5.相对路径+文本css 定位link 定位partial_link 定位 常用操作下拉框的处理12345&lt;!--select标签--&gt; &lt;select name=\"city\" size=\"5\" multiple=\"multiple\"&gt; &lt;option value=\"1\" tabindex=\"1\"&gt;北京&lt;/option&gt; &lt;option value=\"2\" tabindex=\"2\" selected=\"selected\"&gt;河南&lt;/option&gt; 1234567from selenium.webdriver.support.select import Selectele = driver.find_element_by_name(\"city\")#创建Select类对象sel = Select(ele)sel.select_by_value(\"3\") select类中的函数列表options 返回select元素所有的optionsall_selected_options 返回select元素中所有已选中的选项first_selected_option 返回select元素中选中的第一个选项select_by_index(index) 通过索引定位，index索引是从“0”开始select_by_value(value) 通过value属性值定位select_by_visible_text(text)t 通过文本值定位，visible_text是在option标签中间的值，即显示在下拉框的值；deselect_all() 取消全部的已选择项deselect_by_index(index) 取消已选中的索引项deselect_by_value(value) 取消已选中的value值deselect_by_visible_text(text) 取消已选中的文本值 文件上传定位到元素后用.send_keys(r’文件路径’) 1driver.find_element_by_name(\"city\").send_keys(r'文件路径') 处理弹窗alert(只有确定)，confirm(有确认和取消)，prompt(有确认取消还可以输入值) 12345678910111213#alert是一个属性#创建一个alert对象ale = driver.switch_to.alert#点击确定ale.accept()#点击取消ale.dismiss() #获得文本ale.text()#输入值ale.send_keys() 设计模式（封装）pom(page object model)页面对象模式 分三层1.基础层：base 主要放seleni原生的方法2.页面对象层：主要用于放页面的元素和页面的动作3.测试用例层:testcase存放测试用例，测试数据 页面对象层调用基础层的方法，测试用例层调用页面对象的方法","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"web自动化","slug":"web自动化","permalink":"https://wenkexia.github.io/tags/web%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"python爬虫学习","slug":"python爬虫学习","date":"2022-03-16T23:56:59.000Z","updated":"2022-03-16T23:56:59.000Z","comments":true,"path":"2022/031717083.html","link":"","permalink":"https://wenkexia.github.io/2022/031717083.html","excerpt":"","text":"网络数据采集概述爬虫（crawler）也经常被称为网络蜘蛛（spider），是按照一定的规则自动浏览网站并获取所需信息的机器人程序（自动化脚本代码），被广泛的应用于互联网搜索引擎和数据采集。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接，网络爬虫正是通过网页中的超链接信息，不断获得网络上其它页面的地址，然后持续的进行数据采集。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为爬虫或者网络蜘蛛。 爬虫的应用领域爬虫的应用领域其实非常广泛，下面我们列举了其中的一部分 搜索引擎 新闻聚合 社交应用 舆情监控 行业数据爬虫合法性探讨 经常听人说起“爬虫写得好，牢饭吃到饱”，那么编程爬虫程序是否违法呢？关于这个问题，我们可以从以下几个角度进行解读。 网络爬虫这个领域目前还属于拓荒阶段，虽然互联网世界已经通过自己的游戏规则建立起了一定的道德规范，即 Robots 协议（全称是“网络爬虫排除标准”），但法律部分还在建立和完善中，也就是说，现在这个领域暂时还是灰色地带。 “法不禁止即为许可”，如果爬虫就像浏览器一样获取的是前端显示的数据（网页上的公开信息）而不是网站后台的私密敏感信息，就不太担心法律法规的约束，因为目前大数据产业链的发展速度远远超过了法律的完善程度。 在爬取网站的时候，需要限制自己的爬虫遵守 Robots 协议，同时控制网络爬虫程序的抓取数据的速度；在使用数据的时候，必须要尊重网站的知识产权（从Web 2.0时代开始，虽然Web上的数据很多都是由用户提供的，但是网站平台是投入了运营成本的，当用户在注册和发布内容时，平台通常就已经获得了对数据的所有权、使用权和分发权）。如果违反了这些规定，在打官司的时候败诉几率相当高。 适当的隐匿自己的身份在编写爬虫程序时必要的，而且最好不要被对方举证你的爬虫有破坏别人动产（例如服务器）的行为。 不要在公网（如代码托管平台）上去开源或者展示你的爬虫代码，这些行为通常会给自己带来不必要的麻烦。 相关工具下面我们先介绍一些开发爬虫程序的辅助工具，这些工具相信能帮助你事半功倍。 Chrome Developer Tools：谷歌浏览器内置的开发者工具。该工具最常用的几个功能模块是： 元素（ELements）：用于查看或修改 HTML 元素的属性、CSS 属性、监听事件等。CSS 可以即时修改，即时显示，大大方便了开发者调试页面。 控制台（Console）：用于执行一次性代码，查看 JavaScript 对象，查看调试日志信息或异常信息。控制台其实就是一个执行 JavaScript 代码的交互式环境。 源代码（Sources）：用于查看页面的 HTML 文件源代码、JavaScript 源代码、CSS 源代码，此外最重要的是可以调试 JavaScript 源代码，可以给代码添加断点和单步执行。 网络（Network）：用于 HTTP 请求、HTTP 响应以及与网络连接相关的信息。 应用（Application）：用于查看浏览器本地存储、后台任务等内容，本地存储主要包括Cookie、Local Storage、Session Storage等。 Postman：功能强大的网页调试与 RESTful 请求工具。Postman可以帮助我们模拟请求，非常方便的定制我们的请求以及查看服务器的响应。 HTTPie：命令行HTTP客户端。 安装。 1pip install httpie 使用。 1234567891011121314http --header http --header https://movie.douban.com/HTTP/1.1 200 OKConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html; charset=utf-8Date: Tue, 24 Aug 2021 16:48:00 GMTKeep-Alive: timeout=30Server: daeSet-Cookie: bid=58h4BdKC9lM; Expires=Wed, 24-Aug-22 16:48:00 GMT; Domain=.douban.com; Path=/Strict-Transport-Security: max-age=15552000Transfer-Encoding: chunkedX-Content-Type-Options: nosniffX-DOUBAN-NEWBID: 58h4BdKC9lM builtwith库：识别网站所用技术的工具。 安装。 1pip install builtwith 使用。 123456import sslimport builtwithssl._create_default_https_context = ssl._create_unverified_contextprint(builtwith.parse('http://www.bootcss.com/')) python-whois库：查询网站所有者的工具。 安装。 1pip3 install python-whois 使用。 123import whoisprint(whois.whois('https://www.bootcss.com')) 爬虫的基本工作流程一个基本的爬虫通常分为数据采集（网页下载）、数据处理（网页解析）和数据存储（将有用的信息持久化）三个部分的内容，当然更为高级的爬虫在数据采集和处理时会使用并发编程或分布式技术，这就需要有调度器（安排线程或进程执行对应的任务）、后台管理程序（监控爬虫的工作状态以及检查数据抓取的结果）等的参与。 一般来说，爬虫的工作流程包括以下几个步骤： 设定抓取目标（种子页面/起始页面）并获取网页。 当服务器无法访问时，按照指定的重试次数尝试重新下载页面。 在需要的时候设置用户代理或隐藏真实IP，否则可能无法访问页面。 对获取的页面进行必要的解码操作然后抓取出需要的信息。 在获取的页面中通过某种方式（如正则表达式）抽取出页面中的链接信息。 对链接进行进一步的处理（获取页面并重复上面的动作）。 将有用的信息进行持久化以备后续的处理。","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://wenkexia.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"CSS基础","slug":"CSS基础","date":"2022-03-16T07:07:30.000Z","updated":"2022-03-16T07:07:30.000Z","comments":true,"path":"2022/031610604.html","link":"","permalink":"https://wenkexia.github.io/2022/031610604.html","excerpt":"","text":"html div标签中id、class属性的使用与区别div用于标示块级元素，而span标示行内元素。 1、语法区别id对应CSS是用样式选择符“#”（井号）；class对应CSS是用样式选择符“.”(英文半角输入句号)。 12&lt;div id=\"header\"&gt;&lt;/div&gt; &lt;div class=\"abc\"&gt;&lt;/div&gt; 对应CSS应该是： 123#header{...} .abc{...} id：在同一个页面，只可以被调用一次，在CSS里用“#”表示。class：是类标签，在同一个页面可以调用无数次（没限制的），在CSS里用“.”表示。 使用css三种使用 CSS 的方法 外部 CSS内部 CSS行内 CSS 外部 CSS外部样式表可以在任何文本编辑器中编写，并且必须以 .css 扩展名保存。外部样式在 HTML 页面 部分内的 元素中进行定义： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS 选择器CSS 选择器用于“查找”（或选取）要设置样式的 HTML 元素。我们可以将 CSS 选择器分为五类： 简单选择器（根据名称、id、类来选取元素）CSS id 选择器元素的 id 在页面中是唯一的，因此 id 选择器用于选择一个唯一的元素！ 要选择具有特定 id 的元素，请写一个井号（＃），后跟该元素的 id。 id 名称不能以数字开头。 12345/* 这条CSS 规则将应用于 id=\"para1\" 的 HTML 元素 */#para1 { text-align: center; color: red;} CSS 类选择器如需选择拥有特定 class 的元素，请写一个句点（.）字符，后面跟类名。 12345/* 在此例中，所有带有 class=\"center\" 的 HTML 元素将为红色且居中对齐： */.center { text-align: center; color: red;} CSS 通用选择器通用选择器（*）选择页面上的所有的 HTML 元素。 123456/* 下面的 CSS 规则会影响页面上的每个 HTML 元素： */* { text-align: center; color: blue;} CSS 分组选择器分组选择器选取所有具有相同样式定义的 HTML 元素。 1234h1, h2, p { text-align: center; color: red;} 组合器选择器（根据它们之间的特定关系来选取元素）伪类选择器（根据特定状态选取元素）伪元素选择器（选取元素的一部分并设置其样式）属性选择器（根据属性或属性值来选取元素）css基础属性文字类colorfont-sizetext-decorationtext-align 尺寸类widthheight 背景：background-colorbackground-imagebackground-size:cover","categories":[{"name":"前端","slug":"前端","permalink":"https://wenkexia.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wenkexia.github.io/tags/css/"}]},{"title":"matlab学习","slug":"matlab学习","date":"2022-03-15T07:15:30.000Z","updated":"2022-03-15T07:15:30.000Z","comments":true,"path":"2022/031551719.html","link":"","permalink":"https://wenkexia.github.io/2022/031551719.html","excerpt":"","text":"https://blog.csdn.net/weixin_49167174/article/details/119939748 矩阵通过序号引用矩阵元素在matlab中，矩阵的元素是按列存储的即首先存储第一列元素、第二列…一直到最后一列。 矩阵元素的序号就是矩阵元素在内存中的排列顺序。","categories":[{"name":"学习","slug":"学习","permalink":"https://wenkexia.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"待分","slug":"待分","permalink":"https://wenkexia.github.io/tags/%E5%BE%85%E5%88%86/"}]},{"title":"深度学习","slug":"深度学习","date":"2022-03-08T10:41:51.000Z","updated":"2022-03-08T10:41:51.000Z","comments":true,"path":"2022/030811061.html","link":"","permalink":"https://wenkexia.github.io/2022/030811061.html","excerpt":"","text":"人工智能、机器学习、深度学习的关系人工智能 &gt; 机器学习 &gt; 深度学习。 迁移学习神经网络需要用数据来训练，它从数据中获得信息，进而把它们转换成相应的权重。这些权重能够被提取出来，迁移到其他的神经网络中，我们“迁移”了这些学来的特征，就不需要从零开始训练一个神经网络了 预训练模型预训练模型(pre-trained model)是前人为了解决类似问题所创造出来的模型。你在解决问题的时候，不用从零开始训练一个新模型，可以从在类似问题中训练过的模型入手。 当在训练经网络的时候我们的目标是什么？我们希望网络能够在多次正向反向迭代的过程中，找到合适的权重。 通过使用之前在大数据集上经过训练的预训练模型，我们可以直接使用相应的结构和权重，将它们应用到我们正在面对的问题上。这被称作是“迁移学习”，即将预训练的模型“迁移”到我们正在应对的特定问题中。 实践平台如果学员想了解更多关于飞桨、深度学习、机器学习或Python课程，可以通过如下三个途径获取。 AI Studio：https://aistudio.baidu.com/飞桨官网：https://www.paddlepaddle.org.cn/百度技术学院：http://bit.baidu.com/index 机器学习机器学习是专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构，使之不断改善自身的性能。 机器学习的实现机器学习的实现可以分成两步：训练和预测，类似于归纳和演绎： 归纳： 从具体案例中抽象一般规律，机器学习中的“训练”亦是如此。从一定数量的样本（已知模型输入XXX和模型输出YYY）中，学习输出YYY与输入XXX的关系（可以想象成是某种表达式）。演绎： 从一般规律推导出具体案例的结果，机器学习中的“预测”亦是如此。基于训练得到的YYY与XXX之间的关系，如出现新的输入XXX，计算出输出YYY。通常情况下，如果通过模型计算的输出和真实场景的输出一致，则说明模型是有效的。 深度学习基础人工神经网络包括多个神经网络层，如：卷积层、全连接层、LSTM等，每一层又包括很多神经元，超过三层的非线性神经网络都可以被称为深度神经网络。通俗的讲，深度学习的模型可以视为是输入到输出的映射函数，如图像到高级语义（美女）的映射，足够深的神经网络理论上可以拟合任何复杂的函数。因此神经网络非常适合学习样本数据的内在规律和表示层次，对文字、图像和语音任务有很好的适用性。这几个领域的任务是人工智能的基础模块，因此深度学习被称为实现人工智能的基础也就不足为奇了。 神经元： 神经网络中每个节点称为神经元，由两部分组成： 加权和：将所有输入加权求和。 非线性变换（激活函数）：加权和的结果经过一个非线性函数变换，让神经元计算具备非线性的能力。 多层连接： 大量这样的节点按照不同的层次排布，形成多层的结构连接起来，即称为神经网络。 前向计算： 从输入计算输出的过程，顺序从网络前至后。 计算图： 以图形化的方式展现神经网络的计算逻辑又称为计算图，也可以将神经网络的计算图以公式的方式表达：Y=f3(f2(f1(w1⋅x1+w2⋅x2+w3⋅x3+b)+…)…)…)​神经网络并没有那么神秘，它的本质是一个含有很多参数的“大公式” 构建神经网络/深度学习模型的基本步骤数据处理数据导入、 数据形状变换、 数据集划分、 数据归一化处理 封装load data函数 模型设计（模型要素1）网络结构设计，相当于模型假设空间，即模型能够表达的关系集合。 训练配置模型要素2）设定模型采用的寻解方法，即优化器，并指定计算资源。PS：神经网络学习的目的是寻找合适的参数，使得损失函数的值尽可能小。解决这个问题的过程为称为最优化。解决这个问题使用的算法叫做优化器。接触到的优化器有：随机梯度下降法（Stachastic gradient desent 简称 SGD）和AdaGrad AdaGard主要是为了解决 SGD 遇到鞍点或者极小值点后学习变慢的问题。我们知道超参数学习率是一个很重要的参数，不同的参数对学习结果的影响很大，如果设置的值较小，会导致学习花费较多的时间，学习率大了就会导致学习发散而不能正常的进行。所以我们可以考虑避免人为的介入，根据需要让程序自己动态地设置学习率。例如对于遇到鞍点的情况，参数变化很小，基本不会改变，那么这个方法就会设置一个较大的学习率，跨过鞍点。 训练过程模型要素3）循环调用训练过程，每轮都包括前向计算、损失函数（优化目标）和后向传播三个步骤。 PS：前向计算是指把输入数据传入模型，然后得到输出；后向传播是指根据前向计算得到的输出通过梯度下降，从后向前优化网络中的参数。（因为梯度下降就是从后向前计算） 模型保存将训练好的模型保存，模型预测是调用。 预测问题对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。下面我们尝试用最简单的线性回归模型解决这个问题，并用神经网络来实现这个模型。 构建模型 模型结构三要素（模型假设、评价函数和优化算法） paddleHub工具端到端的预训练模型管理与迁移学习工具模型一键下载、管理、预测,十行代码完成迁移学习,一键自动超参搜索,一键模型服务化部署 精选效果优秀的算法，提供了百亿级大数据训练的预训练模型，方便用户不用花费大量精力从头开始训练一个模型。 #安装 -i指定镜像源pip install paddlehub -i http://pypi.douban.com/simple/#更新pip install –upgrade paddlehub -i http://pypi.douban.com/simple/","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://wenkexia.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"django学习","slug":"django学习","date":"2022-03-06T13:02:52.000Z","updated":"2022-03-06T13:02:52.000Z","comments":true,"path":"2022/030664874.html","link":"","permalink":"https://wenkexia.github.io/2022/030664874.html","excerpt":"","text":"Python 加 Django 是快速开发、设计、部署网站的最佳组合。 安装pip install django -i http://pypi.douban.com/simple --trusted-host pypi.douban.com 创建项目在想要创建的文件夹中，进入终端执行命令创建项目'django-admin startproject 项目名称 项目文件介绍manage.py 项目的管理，启动项目，创建app,数据管理urls.py url和函数的对应关系asgi.py 和wsgi.py 接受网络请求 创建一个apppython manage.py startapp 名称 Uvicorn 运行 djangodjango 内置的开发服务器在修改代码后的热重载非常缓慢，我发现 uvicorn 的重载速度要快得多，所以新项目第一件事，就是使用在开发环境下使用 uvicorn 运行 django。 首先当然要安装 uvicorn。pip install uvicorn Uvicorn 安装好后，可以在命令行使用 uvicorn 命令来运行 django。但是，每次输命令启动 django 会非常麻烦！最好的做法是创建一个脚本，启动 django 只需要执行脚本就可以了。 在 项目根目录 创建一个 run_uvicorn.py 的脚本（脚本名可以自己随便取），代码如下： 1234567891011121314151617import uvicornimport osdef main(): os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"mysite.settings\") uvicorn.run( \"mysite.asgi:application\", host=\"0.0.0.0\", port=8000, log_level=\"debug\", reload=True, )if __name__ == \"__main__\": main() 运行脚本后，应用已在 8000 端口启动，现在访问 localhost:8000，可以看到熟悉的 django 项目初始页面。 创建views.py 写函数","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"web","slug":"web","permalink":"https://wenkexia.github.io/tags/web/"}]},{"title":"Linux","slug":"Linux","date":"2022-02-26T12:50:16.000Z","updated":"2022-02-26T12:50:16.000Z","comments":true,"path":"2022/022615691.html","link":"","permalink":"https://wenkexia.github.io/2022/022615691.html","excerpt":"","text":"使用linux的好处使用linux的好处在 linux 下，apt install 或者 yum install 之类的命令，就能搞定整个软件安装。 Linux 不需要选择软件是放 c 盘还是 d 盘，已经定义好了哪些文件该放在哪些地方，不需要杀毒软件，不需要清理垃圾，不需要释放内存，不需要激活系统，它是开源免费的，不需要磁盘优化，没有烦人的弹窗，没有强制更新。 WSL2使用Linux官方文档 WSL2安装WSL2采用在Hyper-V虚拟机中运行的方案,实现了与 windows 的高度集成,wsl2 的开启速度有了非常明显的提升，几乎无需等待。 启用适用于 Linux 的 Windows 子系统 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启用虚拟机平台功能 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 以管理者模式进入cmd安装wsl --install 切换WSL的默认版本为WSL2。wsl --set-default-version 2 以管理者cmd进行更新操作wsl --update 重启，更新才能生效wsl --shutdown Microsoft Store 中找一个 Linux 发行版进行安装 查看系统版本wsl -l -v wsl2修改默认安装目录到其他盘 查看已安装的linux发行版本 wsl -l --all -v 导出分发版为tar文件到d盘wsl --export Ubuntu d:\\wsl-ubuntu.tar 注销当前分发版wsl --unregister Ubuntu 重新导入并安装WSL在D盘wsl --import Ubuntu \"d:\\wsl-ubuntu\" \"d:\\wsl-ubuntu.tar\" 设置默认登陆用户为安装时用户名ubuntu config --default-user USERNAME 删除wsl-ubuntu20.04.tardel d:\\wsl-ubuntu.tar 设置 Linux 用户名和密码若要更改或重置密码，请打开 Linux 发行版并输入命令：passwd如果忘记了 Linux 分发版的密码：1.请打开 PowerShell，并使用以下命令进入默认 WSL 分发版的根目录：wsl -u root 如果需要在非默认分发版中更新忘记的密码，请使用命令：wsl -d Debian -u root，并将 Debian 替换为目标分发版的名称。 2.在 PowerShell 内的根级别打开 WSL 发行版后，可使用此命令更新密码：passwd ，其中 是发行版中帐户的用户名，而你忘记了它的密码。 关闭虚拟机WSL2实际上是在虚拟机中运行。我们一旦进入WSL2 Linux的命令行，虚拟机会自动启动运行。如果我们查看任务管理器，会发现一个Vmmem进程,它比较占内存。不使用WSL2的时候我们可以关闭它以节省内存。关闭WSL2 Linux的方法如下。使用管理员打开CMD，运行：wsl --shutdown 为发行版linux更换国内源https://blog.csdn.net/weixin_41529012/article/details/117226884 打开\\wsl.localhost\\Ubuntu\\etc\\apt地址下的sources.list文件，更改国内源中科大 1234567891011deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 更新镜像源列表 12sudo apt update &amp;&amp; sudo apt upgrade wsl2中linux与window间的文件操作使用 Visual Studio Code安装Remote Development扩展包除了 Remote - SSH 和 Remote - Containers 扩展之外，此扩展包还包含 Remote - WSL 扩展，使你能够打开容器中、远程计算机上或 WSL 中的任何文件夹。 在 Visual Studio Code 中打开 WSL 项目1.从 WSL 发行版打开项目，请打开发行版的命令行并输入：code . 从 VS Code 中打开项目，通过使用 VS Code 中的快捷方式 CTRL+SHIFT+P 调出命令面板，以访问更多 VS Code 远程选项。 如果随后键入 Remote-WSL，将看到可用的 VS Code 远程选项列表，使你可以在远程会话中重新打开文件夹，指定要在哪个发行版中打开，等等。 使用数据库安装 MySQL：sudo apt install mysql-server确认安装并获取版本号：mysql --version 若要在 VS Code 中使用 MySQL 数据库，请尝试使用 MySQL 扩展 Docker 远程容器入门1.下载 Docker Desktop 并按照安装说明进行操作。 2.安装后，从 Windows 开始菜单启动 Docker Desktop，然后从任务栏的隐藏图标菜单中选择 Docker 图标。 右键单击该图标以显示 Docker 命令菜单，然后选择“设置”。 3.确保在“设置”“常规”中选中“使用基于 WSL 2 的引擎”。 4.通过转到“设置”“资源”“WSL 集成”，从要启用 Docker 集成的已安装 WSL 2 发行版中进行选择。 5.若要确认已安装 Docker，请打开 WSL 发行版（例如 Ubuntu），并通过输入 docker –version 来显示版本和内部版本号 6.通过使用 docker run hello-world 运行简单的内置 Docker 映像，测试安装是否正常工作 使用 VS Code 在远程容器中开发安装 VS Code Remote-WSL 扩展。 此扩展使你能够在 VS Code 中打开在 WSL 上运行的 Linux 项目（无需担心路径问题、二进制兼容性或其他跨 OS 的难题）。 安装 VS code Remote-Containers 扩展。 此扩展使你能够打开容器内的项目文件夹或存储库，并利用 Visual Studio Code 的完整功能集在容器中执行开发工作。 安装 VS Code Docker 扩展。 此扩展添加了从 VS Code 内生成、管理和部署容器化应用程序的功能。 （需要 Remote-Container 扩展才能实际使用容器作为开发环境。） 安装 Node.jsVMware使用linuxVMWare 和 Hyper-V 共存将 Windows 版本升级到 Windows 10 20H1 或更高版本。将 VMWare Workstation/Player 升级到 15.5.5 或更高版本在安装时，勾选“自动安装 Windows Hypervisor Platform (WHP)”。打开虚拟机的设置选项，找到“处理器”，去掉如图所示的三个选项前面的钩，点击“确定” 网络连接方式NAT模式（默认）：网络地址转换方式，linux可以访问外网，不会造成ip冲突 桥接模式：可以与其它系统进行通信，但可能造成ip冲突 主机模式：你的Linux是一个独立的主机，不能访问外网 云服务器使用linux简介云服务器（Elastic Compute Service, 简称ECS），是一种简单高效，处理能力可以弹性伸缩的计算服务。ECS的相关术语说明如下： 实例（Instance）：是一个虚拟的计算环境，由CPU、内存、系统盘和运行的操作系统组成；ECS实例作为云服务器最为核心的概念，其他资源，比如磁盘、IP、镜像、快照等，只有与ECS结合后才具有使用意义。 地域（Region）：指ECS实例所在的物理位置。地域内的ECS实例内网是互通的，不同的地域之间ECS实例内网不互通。 可用区（Zone）：指在同一地域内，电力和网络互相独立的物理区域。 磁盘（Disk）：是为ECS实例提供数据块级别的数据存储。可以分为4类： 普通云盘、SSD云盘、高效云盘和本地SSD磁盘 快照（Snapshot）：是某一个时间点上某个磁盘的数据拷贝。 镜像（Image）：是ECS实例运行环境的模板，一般包括操作系统和预装的软件。 安全组（Security Group）：是一种虚拟防火墙，具备状态检测包过滤功能。每个实例至少属于一个安全组。同一个安全组内的实例之间网络互通，不同安全组的实例之间默认内网不通，但是可以授权两个安全组之间互访。 云服务器可以做什么https://developer.aliyun.com/article/767041 虚拟主机、ECS云服务器、VPS区别汇总1、虚拟主机 虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。 2、VPS 先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。 3、ECS云服务器 现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下： linux使用Linux常用命令linux区分大小写，使用tab来自动补全命令 如果想要输入和执行多条命令，用分号分隔命令 linux压缩文件gzip命令gzip是用来压缩和解压.gz文件的命令。gzip命令只能压缩单个文件，而不能把一个文件夹压缩成一个文件（与打包命令的区别） 1234567891011#会将文件压缩为文件 test.txt.gz，原来的文件则没有了gzip /home/aistudio/work/test.txt#解压文件,原来的文件则没有了gzip -d /home/aistudio/test.gz#参数-r或--recursive：递归压缩指定文件夹下的文件（该文件夹下的所有文件被压缩成单独的.gz文件）；-v或--verbose：显示指令执行过程。 tar命令用来打包或者解包后缀名为.tar 12345678#参数-c或--create：建立新的备份文件；-x或--extract或--get：从备份文件中还原文件；-v：显示指令执行过程；-f或--file：指定备份文件；-C：指定目的目录；-z：通过gzip指令处理备份文件；-j：通过bzip2指令处理备份文件。 zip和unzipzip命令和unzip命令用在在Linux上处理.zip的压缩文件。 12345678910#常用参数#zip:-v：显示指令执行过程；-m：不保留原文件；-r：递归处理。#unzip:-v：显示指令执行过程；-d：解压到指定目录。 vim使用https://www.jianshu.com/p/8b679b35c9d5Vim可以分为三种模式，分别为： 命令行模式（Command mode）控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。进入vim之后，是处于「命令行模式」，要按i切换到「插入模式」才能够输入文字。 插入模式（Insert mode）只有在插入模式下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式（Lastline mode）将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。在命令行模式下，按冒号「:」键，进入底行模式 :w filename 文件以filename为文件名保存 :wq 文件存盘并退出vim :q 文件不存盘并退出vim :q! 文件不存盘强制退出vim 环境变量1、修改 /etc/profile 文件，如果你的计算机仅仅作为开发使用时推存使用这种方法，因为所有用户的shell都有权使用这个环境变量，可能会给系统带来安全性问题。这里是针对所有的用户的，所有的shell vi /etc/profile 在/etc/profile的最下面添加： export PATH=”$PATH:/NEW_PATH” 针对当前特定的用户起作用的环境变量 2、修改bashrc文件，这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，这里是针对某一特定的用户，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的 .bashrc文件就可以了。 vi ~/.bashrc 在下面添加： Export PATH=”$PATH:/NEW_PATH” xshellXShell是一个强大的安全终端模拟软件,可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。安装参考 远程连接选择导航菜单的文件 –&gt; 新建，输入名称和主机IP，协议默认SSH，端口默认22，如果不知道主机IP可以登录虚拟机的Linux系统，输入命令ifconfig查看(inet addr) 然后在左侧用户身份验证中输入用户名和密码，这样下次就可以直接连接了，当然如果为了安全考虑也可以不输入密码，在每次连接时再输入。 Xshell怎么与云服务器连接打开Xshell，新建一个会话 主机填服务器ip,点击连接 用户名默认为root,密码为服务器实例密码 搭建云上博客不知道教程是不是太旧了，跟着做，都是报错 部署环境安装Apache服务及其扩展包跟着官网做发现安装失败 12345yum -y install httpd httpd-manual mod_ssl mod_perl mod_auth_mysqlLast metadata expiration check: 0:30:48 ago on Thu 17 Mar 2022 08:21:43 AM CST.No match for argument: mod_auth_mysqlError: Unable to find a match: mod_auth_mysql 搜索到的解决方案 yum -y install httpd httpd-manual mod_ssl mod_perl yum -y install httpd httpd-devel 启动Apache服务。systemctl start httpd.service 设置安全组教程上没有说清楚 进入实例，点击安全组链接进去 然后点击快速添加选端口范围为http(80) 打开浏览器输入ECS服务器的公网IP，显示测试页面表示Apache服务安装成功。 搭建网盘安装docker12345678#通过yum源安装dockersudo yum -y install docker#启动dockersudo systemctl start docker#开机自启sudo systemctl enable docker 获取nextcloud镜像, 完成网盘搭建docker run -d -p 8080:80 nextcloud 宝塔Linux面板安装https://www.bt.cn/bbs/thread-19376-1-1.html Centos安装命令：yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh Ubuntu/Deepin安装命令：wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh 查看宝塔面板信息/etc/init.d/bt default 面板特色功能：一键配置服务器环境（LAMP/LNMP）一键安全重启一键创建管理网站、ftp、数据库一键部署SSL证书一键部署源码（discuz、wordpress、dedecms、z-blog、微擎等等）一键配置（定期备份、数据导入、伪静态、301、SSL、子目录、反向代理、切换PHP版本）一键安装常用PHP扩展(fileinfo、intl、opcache、imap、memcache、apc、redis、ioncube、imagick)数据库一键导入导出系统监控（CPU、内存、磁盘IO、网络IO）防火墙端口放行SSH开启与关闭及SSH端口更改禁PING开启或关闭方便高效的文件管理器（上传、下载、压缩、解压、查看、编辑等等）计划任务（定期备份、日志切割、shell脚本）软件管理（一键安装、卸载、版本切换） python自动化部署Python提供了一个paramiko库，能够支持SSH和SFTP协议，可以取代Xshell和Xftp，下面是把本机的jar文件上传到服务器并运行的Python脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243# coding=utf-8import threadingimport paramiko IP = '106.14.19.127'user = 'root'password = 'server-pwd' local_jar = '/target/ser1-1.0.jar'server_jar = '/root/ser1-1.0.jar'server_property = '/root/ser1.properties' def execute_cmds(ip, name, pwd, cmd): try: ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(ip, 22, name, pwd, timeout=5) print '连接成功' sftp = ssh.open_sftp() print '正在上传...' sftp.put(local_jar, server_jar) print 'jar上传成功' for m in cmd: print m stdin, stdout, stderr = ssh.exec_command(m) out = stdout.readlines() for o in out: print o, print '运行成功' ssh.close() print '关闭连接' except Exception, error: print '错误: %s' % (error) if __name__ == '__main__': print 'Start deploying %s to server %s' % (server_jar, IP) cmd = [ 'echo Start spring...', 'nohup java -jar -Dspring.config.location=' + server_property + ' ' + server_jar + ' &amp;', 'echo All done.' ] a = threading.Thread(target=execute_cmds, args=(IP, user, password, cmd)) a.start()","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wenkexia.github.io/tags/linux/"}]},{"title":"数据结构","slug":"数据结构","date":"2022-02-19T04:04:47.000Z","updated":"2022-02-19T04:04:47.000Z","comments":true,"path":"2022/02191106.html","link":"","permalink":"https://wenkexia.github.io/2022/02191106.html","excerpt":"","text":"原文 对于一个成熟的程序员而言，熟悉和掌握数据结构和算法也是基本功之一。数据结构本身其实不过是数据按照特点关系进行存储或者组织的集合，特殊的结构在不同的应用场景中往往会带来不一样的处理效率。 数组数组可以说是最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。 图片 链表链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据。链表中每一个节点都包含此节点的数据和指向下一节点地址的指针。由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。 这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点。不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用。 一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。 图片 链表和数组对比链表和数组在实际的使用过程中需要根据自身的优劣势进行选择。链表和数组的异同点也是面试中高频的考察点之一。这里对单链表和数组的区别进行了对比和总结。 图片 跳表从上面的对比中可以看出，链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。 图片 跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前redis和levelDB都有用到跳表。 从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查询的目的。 栈栈是一种比较简单的数据结构，常用一句话描述其特性，后进先出。栈本身是一个线性表，但是在这个表中只有一个口子允许数据的进出。这种模式可以参考腔肠动物…即进食和排泄都用一个口… 栈的常用操作包括入栈push和出栈pop，对应于数据的压入和压出。还有访问栈顶数据、判断栈是否为空和判断栈的大小等。由于栈后进先出的特性，常可以作为数据操作的临时容器，对数据的顺序进行调控，与其它数据结构相结合可获得许多灵活的处理。 图片 队列队列是栈的兄弟结构，与栈的后进先出相对应，队列是一种先进先出的数据结构。顾名思义，队列的数据存储是如同排队一般，先存入的数据先被压出。常与栈一同配合，可发挥最大的实力。 图片 树树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。常见的数的表示形式更接近“倒挂的树”，因为它将根朝上，叶朝下。 树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。 这意味着树是具备层次关系的，父子关系清晰，家庭血缘关系明朗；这也是树与图之间最主要的区别。 图片 别看树好像很高级，其实可看作是链表的高配版。树的实现就是对链表的指针域进行了扩充，增加了多个地址指向子结点。同时将“链表”竖起来，从而凸显了结点之间的层次关系，更便于分析和理解。 树可以衍生出许多的结构，若将指针域设置为双指针，那么即可形成最常见的二叉树，即每个结点最多有两个子树的树结构。二叉树根据结点的排列和数量还可进一度划分为完全二叉树、满二叉树、平衡二叉树、红黑树等。 图片 完全二叉树：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。 满二叉树：除了最后一层，其它层的结点都有两个子结点。 平衡二叉树平衡二叉树又被称为AVL树，它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 二叉排序树：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。 树的高度：结点层次的最大值 平衡因子：左子树高度 - 右子树高度 二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点&lt;根节点&lt;右结点，这表明二叉排序树的中序遍历结果是有序的。（还不懂二叉树四种遍历方式[前序遍历、中序遍历、后序遍历、层序遍历]的同学赶紧补习！） 图片 平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。 图片 平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。 在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。 左旋：S为当前需要左旋的结点，E为当前结点的父节点。 图片 左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。可用动画表示： 图片 右旋：S为当前需要左旋的结点，E为当前结点的父节点。右单旋是左单旋的镜像旋转。 图片 左旋的操作同样可以用一句话简单表示：将当前结点S的左孩子E的右孩子旋转为当前结点S的左孩子，同时将当前结点S旋转为左孩子E的右孩子。可用动画表示： 图片 红黑树平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致AVL的插入和删除效率并不高。 为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。 红黑树具有五个特性： 每个结点要么是红的要么是黑的。根结点是黑的。每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。如果一个结点是红的，那么它的两个儿子都是黑的。对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。图片红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。 红黑树VS平衡二叉树图片 除了上面所提及的树结构，还有许多广泛应用在数据库、磁盘存储等场景下的树结构。比如B树、B+树等。这里就先不介绍了诶，下次在讲述相关存储原理的时候将会着重介绍。（其实是因为懒） 7 堆了解完二叉树，再来理解堆就不是什么难事了。堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。 对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此可以直接用数组来表示一个堆。 不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 图片 堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如堆排序、topK问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。 8 散列表散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射。散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。 图片 散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数： 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。 数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。 平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。 取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。 除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。 确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。 冲突在发生之后，当在对不同的key值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。 常用的冲突处理方式有很多，常用的包括以下几种： 开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。 再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。 链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。 公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。 目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。 图片 左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。 9 图图相较于上文的几个结构可能接触的不多，但是在实际的应用场景中却经常出现。比方说交通中的线路图，常见的思维导图都可以看作是图的具体表现形式。 图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。 图片 图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。 邻接矩阵目前常用的图存储方式为邻接矩阵，通过所有顶点的二维矩阵来存储两个顶点之间是否相连，或者存储两顶点间的边权重。 图片 无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，若能从此顶点能够到达彼顶点，那么彼顶点自然也能够达到此顶点。此外，由于顶点本身与本身相连没有意义，所以在邻接矩阵中对角线上皆为0。 图片 有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。用邻接矩阵可以直接从二维关系中获得任意两个顶点的关系，可直接判断是否相连。但是在对矩阵进行存储时，却需要完整的一个二维数组。若图中顶点数过多，会导致二维数组的大小剧增，从而占用大量的内存空间。 而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。 因此，为了解决上述问题，一种可以只存储相连顶点关系的邻接表应运而生。 邻接表在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点。相较于无向图，有向图的情况更为复杂，因此这里采用有向图进行实例分析。 图片在邻接表中，每一个顶点都对应着一条链表，链表中存储的是顶点能够达到的相邻顶点。存储的顺序可以按照顶点的编号顺序进行。比如上图中对于顶点B来说，其通过有向边可以到达顶点A和顶点E，那么其对应的邻接表中的顺序即B-&gt;A-&gt;E，其它顶点亦如此。 通过邻接表可以获得从某个顶点出发能够到达的顶点，从而省去了对不相连顶点的存储空间。然而，这还不够。对于有向图而言，图中有效信息除了从顶点“指出去”的信息，还包括从别的顶点“指进来”的信息。这里的“指出去”和“指进来”可以用出度和入度来表示。 入度：有向图的某个顶点作为终点的次数和。 出度：有向图的某个顶点作为起点的次数和。 由此看出，在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。 逆邻接表逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。 图片 邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。 十字链表十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。 图片 但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。 十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端） data：用于存储该顶点中的数据； firstin指针：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点； firstout指针：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点； 边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接： tailvex：用于存储作为弧尾的顶点的编号； headvex：用于存储作为弧头的顶点的编号； headlink 指针：用于链接下一个存储作为弧头的顶点的节点； taillink 指针：用于链接下一个存储作为弧尾的顶点的节点； 图片 以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边AE（即边04）指向顶点E，顶点A的firstout指针需要指向边04的tailvex。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边AB（即边10）指向B，顶点A的firstin指针需要指向边10的弧头，即headlink指针。依次类推。 十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。 10 总结数据结构博大精深，没有高等数学的讳莫如深，也没有量子力学的玄乎其神，但是其在计算机科学的各个领域都具有强大的力量。本文试图采用图解的方式对九种数据结构进行理论上的介绍，但是其实这都是不够的。 即便是简单的数组、栈、队列等结构，在实际使用以及底层实现上都会有许多优化设计以及使用技巧，这意味着还需要真正把它们灵活的用起来，才能够算是真正意义上的熟悉和精通。但是本文可以作为常见数据结构的一个总结，当你对某些结构有些淡忘的时候，不妨重新回来看看。","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"待分","slug":"待分","permalink":"https://wenkexia.github.io/tags/%E5%BE%85%E5%88%86/"}]},{"title":"微信小程序","slug":"微信小程序","date":"2022-01-24T09:33:43.000Z","updated":"2022-01-24T09:33:43.000Z","comments":true,"path":"2022/012435506.html","link":"","permalink":"https://wenkexia.github.io/2022/012435506.html","excerpt":"","text":"目录结构pages用来存放所有小程序的页面utils用来存放工具性质的模块(例如：格式化时间的自定义模块)app. js小程序项目的入口文件app.json小程序项目的全局配置文件app.Wxss小程序项目的全局样式文件project. config. json项目的配置文件sitemap json用来配置小程序及其页面是否允许被微信索引","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://wenkexia.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"window使用","slug":"window使用","date":"2022-01-22T01:09:49.000Z","updated":"2022-01-22T01:09:49.000Z","comments":true,"path":"2022/012246677.html","link":"","permalink":"https://wenkexia.github.io/2022/012246677.html","excerpt":"","text":"输入法不认识的汉字怎么打u+汉字各部分的拼音 扩展屏幕如何在笔记本盖上盖子时，扩展显示屏也能显示。在设置中搜索打开控制面板，然后找到电源选项打开，找到选择关闭笔记本计算机盖的功能 文件无法删除解决Windows10中“其中文件夹或文件已在另一程序中打开”引起的文件删不掉问题 打开任务管理器打开资源监视器1.切换任务管理器到“性能”选项页，点击最下方的“打开资源监视器”字。2.搜索与该文件关联的程序并关闭 以删除word文件“文件123.docx”为例：删除桌面上“文件123.docx”文件，显示该文件已被其他程序打开，暂时无法删除。 此时在资源监视器搜索句柄处填上文件123，即可搜索与这个文件相关联的应用程序句柄。点击与文件123相关联的句柄，然后点击鼠标右键，选择结束进程此时会弹出结束进程确认对话框。点击“结束进程”关闭与“文件123.docx”关联的进程。 怎样关闭Win10安装软件、改变设置时的弹窗？打开更改用户账户设置 Windows系统hosts文件路径为：C:\\Windows\\System32\\drivers\\etc Win10电脑设置定时关机命令：Win +r 输入：shutdown -s -t 3600 一小时后关机 Win10进入开机自启文件夹Win+r进入运行，输入shell:startup 快捷键汇总win+上下箭头键：【最大化】【还原】【最小化】当前窗口 win+左右箭头键：将窗口靠左、靠右。如果有两个窗口则并列 按住ctrl 可多选文件 Win+Shift+S 截图、 Win+g 截图录屏 在英文输入状态下，按住shift输入字母可以大写 按住alt双击文件 快速打开属性 Ctrl+shift+Esc 一键打开任务管理器 Ctrl +shift+n 快速新建文件夹 按住ctrl拖动文件 就是复制 Alt+F4键：关闭当前窗口，如果没有活动窗口就带开【关闭计算机】对话框 win+A键：快速打开【系统通知和控制中心】 Win+E键：快速打开【资源管理器】 win+G键：快速打开【Xbox工具】，这个工具非常实用，包含了截图、录屏等功能 win+I键：快速打开【计算机设置】 win+K键：快速打开【无线连接】 win+L键：快速【锁定屏幕】，如果你要暂时离开电脑，这个快捷键一定要知道 win+P键：快速打开【投影】，如果你要连接第二块屏幕或投影，这是最快捷的方法 win+Q键或者win+S键：快速打开【搜索】 win+R键：快速打开【运行】 win+T键：在【任务栏程序】中进行切换 win+V键：快速打开【剪贴板】 win+W键：快速打开【全屏截图】 win+X键：打开【系统快捷菜单】，这个菜单继承了巨大部分的系统功能。 win+数字键：打开【任务栏】上相应顺序的应用程序 win+加号：启动【放大镜】，加号放大，减号缩小 win+Tab键：打开【任务视图】，还可以按时间线查看近期任务 Alt+Tab键：在打开的程序间进行切换，这是笔者最常用的快捷键 网页ctrl + w 关闭一个网页Ctrl + Tab 切换网页Ctrl+h 打开历史记录 远程微软自带的远程连接联想小新pro16win10专业版两台设备都连着校园网，测试时，控制端不能连着电脑的热点。控制端要下载：RDclient成功后，你就可以不用带上你的电脑去机房上课了，直接在机房控制你的电脑，体验感翻倍 注意1.window要用微软账号登录2.用户名是自己设置的，可以是中文，打开图二密码中的更新安全问题选项也可以看到3. 密码是你的账户密码，不是PIN码哦4. 显示屏关闭后，微软远程就连接不上的原因 联想小新pro16可能是因为开了智能感知功能的原因，因此显示屏关闭或者盖上屏幕，控制端就无法连接上电脑 快捷键打开远程桌面，win+r 输入mstsc查询ip地址：win+r进入cmd,输入ipconfig ToDeskToDesk目前还是免费的且支持三台设备，而且界面简洁大气。 向日葵特点1.控制端和被控制端使用同一账号即可2.可以实时查看远程主机摄像头周围的情况3.方便快捷的让远程文件或本地文件互相传输和同步，安全稳定。4.无需内网穿透即可实现外网连接。需求①是在需要被控的电脑上安装被控端;②在手机上安装向日葵主控端③注册一个向日葵账号。在两端同时登录就可以远程控制了。 Windows Terminal是管理各种命令行的工具，它把目前 Windows 上的 PowerShell、CMD 以及 Windows Linux 子系统（WSL）三大环境实现了统一。 安装打开系统自带的 Microsoft Store，搜索 Windows Terminal 直接安装就可以了。 PowerShell是命令行程序，真正执行指令的程序， 在 Windows 上安装 PowerShellhttps://docs.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.1 安装 oh-my-posh 和 posh-gitoh-my-posh 是 PowerShell 主题管理工具posh-git 可以实现类似 oh-my-zsh 一样的 Git 命令增强工具（命令别名和显示分支信息等） 12Install-Module posh-gitInstall-Module oh-my-posh 配置 PowerShell1234# 这是开启默认配置的Set-Prompt# 设置主题，Agnoster 是主题名Set-Theme Agnoster 美化安装Scoop强大的 Windows 包管理工具 ScoopScoop 可以帮你一行命令安装 git 工具、java 环境、chrome 浏览器、vscode 等等，统一目录管理，而且自动配置环境变量，卸载也只需要一行命令，方便的不能在方便了设置安装路径（可选）。默认 Scoop 是安装在 C 盘的，以及通过 Scoop 安装的软件也是在 C 盘的。如果你的 C 盘空间不够或想安装到其他盘，可以执行以下操作。 123# 设置 scoop 安装路径为 D:\\scoop$env:SCOOP='D:\\scoop'[environment]::setEnvironmentVariable('SCOOP',$env:SCOOP,'User') 安装 Scoop 1234# 将执行权限改为本地无需签名Set-ExecutionPolicy RemoteSigned -scope CurrentUser# 下载并执行脚本iwr -useb get.scoop.sh | iex git bash是Windows下的命令行工具。有git分布式版本控制工具，也主要用于git。 1 在windows下使用linux命令操作 2 登陆远程linux服务器&nbsp;ssh 在window terminal中添加git bashhttps://www.cnblogs.com/cong-wang/p/15026535.html打开设置文件settings.json，在profiles的list中添加一项： 123456{ \"guid\" : \"{5D1F95DF-36E8-56AD-C203-EA75CE06422C}\", \"name\" : \"Git Bash\", \"commandline\" : \"D:\\\\ruanjian\\\\Git\\\\bin\\\\bash.exe --login -i\", \"icon\" : \"D:\\\\ruanjian\\\\Git\\\\git-bash.png\"}, guid：唯一标识本命令行配置，可以使用在线guid工具随机生成一个和list中其他配置不一样的guid即可name：本命令行配置的名字，会显示在菜单中commandline：表示怎么启动一个命令行，这里填的是”E:\\Git\\bin\\bash.exe –login -i”，需要找到你的Git的安装目录，将E:\\Git\\bin\\bash.exe替换成你自己的路径icon：显示在菜单中的图标","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"window","slug":"window","permalink":"https://wenkexia.github.io/tags/window/"}]},{"title":"python自动化办公库","slug":"python自动化办公库","date":"2022-01-21T13:57:05.000Z","updated":"2022-01-21T13:57:05.000Z","comments":true,"path":"2022/012151162.html","link":"","permalink":"https://wenkexia.github.io/2022/012151162.html","excerpt":"","text":"原文 微信自动化库wxpy 库官网：https://wxpy.readthedocs.io/zh/latest/ 特点：微信机器人/可能是最优雅的微信个人号API，wxpy 在 itchat 的基础上，通过大量接口优化提升了模块的易用性，并进行丰富的功能扩展。Excel自动化库 // 1.xlwings 库官网：https://www.xlwings.org/ 特点：xlwings 是开源且免费的，预装了 Anaconda 和 WinPython，可在 Windows 和 macOS 上运行。通过 Python 脚本或 Jupyter notebook 自动化 Excel，通过宏从 Excel 调用 Python，并编写用户定义的函数（UDF 仅适用于 Windows） // 2.openpyxl 库官网：https://openpyxl.readthedocs.io 特点：openpyxl 是一个用于读取 / 编写 Excel 2010 xlsx/xlsm/xltx/xltm 文件的 Python 库。它是由于缺乏从 Python 中读取 / 编写 Office Open XML 格式的现有库而诞生的。 // 3.xlrd 库官网：https://pypi.python.org/pypi/xlrd 特点：在 python 中，xlrd 库是一个很常用的读取 excel 文件的库，其对 excel 文件的读取可以实现比较精细的控制。 // 4.xlwt 库官网：https://pypi.org/project/xlwt/ 特点：类比于 xlrd 的 reader，那么 xlwt 就相对于 writer，而且很纯正的一点就是它只能对 Excel 进行写操作。xlwt 和 xlrd 不光名字像，连很多函数和操作格式也是完全相同。 // 5.xlutils 库官网：https://pypi.org/project/xlutils/ 特点：xlutils（excel utilities）是一个提供了许多操作修改 excel 文件方法的库。xlutils 库也仅仅是通过复制一个副本进行操作后保存一个新文件，xlutils 库就像是 xlrd 库和 xlwt 库之间的一座桥梁，因此，xlutils 库是依赖于 xlrd 和 xlwt 两个库的。 // 6.xlsxwriter 库官网：https://xlsxwriter.readthedocs.io/ 特点：xlsxwriter 是用于创建 Excel XLSX 文件的 Python 模块，可用于将文本、数字、公式和超链接写入 Excel2007 + XLSX 文件中的多个工作表。它支持格式化等功能。可以说除了 Excel 本身，就属这个功能最齐全了。 // 7.pandas 库官网：https://www.pypandas.cn/docs/ 特点：pandas 是基于 NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。 // 8.Marmir 库官网：https://github.com/brianray/mm 特点：Marmir 采用 Python 数据结构并将其转换为电子表格。它是类固醇上的 xlwt 和 google 电子表格。目标是使用最少的配置轻松生成多种类型的有用表文件。 Python Word自动化库 // 9.python-docx 库官网：https://python-docx.readthedocs.io/en/latest/ 特点：python-docx 是一个用于创建和更新 Microsoft Word (.docx) 文件的 Python 库。快速开始、处理文档、处理文本、使用截面、使用页眉和页脚、API基础理、解样式、使用样式理解图片和其他形状。只对 windows 平台有效。 // 10.textract 库官网：https://gitee.com/mirrors/textract 特点：它同时兼顾 “doc” 和 “docx”，但安装过程需要一些依赖。你可以批量的用 python 生成 word 文件，推荐使用 docx，不需要会太多。 Python PPT自动化库 // 11.python-pptx 库官网：https://python-pptx.readthedocs.io 特点：python-pptx 是一个用于创建和更新 PowerPoint (.pptx) 文件的 Python 库。典型用途是从数据库内容生成自定义 PowerPoint 演示文稿，可通过单击 Web 应用程序中的链接下载。 Python ODF自动化库 // 12.Relatorio 库官网：https://pypi.org/project/relatorio/ 特点：Relatorio 是一个模板库，它提供了一种轻松输出多种文件（odt、ods、png、svg 等）的方法。通过为它们创建插件可以轻松添加对更多文件类型的支持。Relatorio 还提供了一个报告存储库，允许您将 python 对象和报告链接在一起，按 mimetype/name/python 对象查找报告。ODF：开放文档格式（外文名：OpenDocument Format，外语简称：ODF）是一种规范，基于 XML（标准通用标记语言的子集）的文件格式，因应试算表、图表、演示稿和文字处理文件等电子文件而设置。 Python PDF自动化库 // 13.PyPDF2 库官网：https://github.com/mstamy2/PyPDF2 特点：PyPDF2 是一个纯 Python PDF 库，能够拆分、合并、裁剪和转换 PDF 文件的页面。它还可以向 PDF 文件添加自定义数据、查看选项和密码。它可以从 PDF 中检索文本和元数据，也可以将整个文件合并在一起。 // 14.ReportLab 库官网：https://www.reportlab.com/opensource/ 特点：ReportLab 是久经考验、超强大的开源引擎，用于创建复杂的、数据驱动的 PDF 文档和自定义矢量图形。它是免费的、开源的，并且是用 Python 编写的。 // 15.PDFminer 库官网：https://github.com/euske/pdfminer 特点：PDFMiner 是一款用于 PDF 文档的文本提取工具。 Python 邮件自动化库 // 16.Django Celery SES 库官网：https://github.com/StreetVoice/django-celery-ses 特点：这个包提供了一个 EmailBackend 来利用 django-celery 发送电子邮件。您可以将 EmailBackend 插入您的项目中，而无需对代码进行任何修改。 // 17.Envelopes 库官网：http://tomekwojcik.github.io/envelopes/ 特点：Envelopes 是 Python 的电子邮件和 smtplib 模块的包装器。它旨在使在 Python 中处理外发电子邮件变得简单而有趣。 // 18.Flanker 库官网：https://github.com/mailgun/flanker 特点：由 mailgun 开源的 Flanker - email address and MIME parsing for Python 是一个解析高效、容错率不错的 python 第三方扩展库。python 3 也可以正常使用，该库包含了邮件地址解析和邮件 mime 格式解析。 // 19.imbox 库官网：https://github.com/martinrusev/imbox 特点：用于读取 IMAP 邮箱并将电子邮件内容转换为机器可读数据的 Python 库 // 20.inbox.py 库官网：https://github.com/billzhong/inbox.py 特点：这是您见过的最简单的 SMTP 服务器。它是异步的。一个实例每秒应该处理一千多封电子邮件。 // 21.sync-engine 库官网：https://github.com/nylas/sync-engine 特点：Nylas 同步引擎在强大的电子邮件同步平台之上提供了一个 RESTful API，可以轻松地在电子邮件之上构建应用程序。 // 22.Lamson 库官网：https://github.com/zedshaw/lamson 特点：Lamson 是一个纯 Python SMTP 服务器，旨在以现代 Web 框架（如 Django）的风格创建强大而复杂的邮件应用程序。 // 23.Marrow Mailer 库官网：https://github.com/marrow/mailer 特点：Marrow Mailer 是一个 Python 库，可以轻松地从您的应用程序发送电子邮件。通过使用 Marrow Mailer，您可以：轻松构建纯文本和 HTML 电子邮件；提高电子邮件传递的可测试性；使用不同的邮件投递管理策略；例如立即，延迟，甚至多服务器等。 // 24.Modoboa 库官网：https://github.com/modoboa/modoboa 特点：Modoboa 是一个邮件托管和管理平台，包括一个现代和简化的 Web 用户界面。它提供了有用的组件，例如管理面板或网络邮件。 // 25.smtplib 库官网：https://docs.python.org/zh-cn/3/library/smtplib.html 特点：smtplib 模块是 python 中 smtp (简单邮件传输协议) 的客户端实现。我们可以使用 smtplib 模块，轻松的发送电子邮件。 Python 文件处理自动化库 // 27.os 库官网：https://docs.python.org/zh-cn/3/library/os.html?highlight=os#module-os 特点：本模块提供了一种使用与操作系统相关的功能的便捷式途径。如果你只是想读写一个文件，请参阅 open()，如果你想操作文件路径，请参阅 os.path 模块，如果你想读取通过命令行给出的所有文件中的所有行，请参阅 fileinput 模块。为了创建临时文件和目录，请参阅 tempfile 模块，对于高级文件和目录处理，请参阅 shutil 模块。 Python 综合功能自动化库 // 28.win32com 库官网：https://pypi.org/project/pywin32/ 特点：win32com 模块主要为 Python 提供调用 windows 底层组件对 word 、Excel、PPT 等进行操作的功能，只能在 Windows 环境下使用，并且需要安装 office 相关软件才行（WPS 也行）。 // 29.unoconv 库官网：https://github.com/unoconv/unoconv 特点：是一个命令行工具，可以将 LibreOffice 可以导入的任何文档格式转换为 LibreOffice 可以导出的任何文档格式。它利用 LibreOffice 的 UNO 绑定进行文档的非交互式转换，也支持 OpenOffice。 // 30.Tablib 库官网：https://www.osgeo.cn/tablib/ 特点：Python tablib 模块是第三方模块，主要作用是将数据导出为各种不同的格式，包括 excel，json，html，yaml，csv，tsv 等格式，怎么样，有点心动了吧，当然这个模块使用起来也是超级简单的。 // 31.SnowNLP 库官网：https://github.com/isnowfy/snownlp 特点：SnowNLP 是一个 python 写的类库，可以方便的处理中文文本内容，是受到了 TextBlob 的启发而写的，由于现在大部分的自然语言处理库基本都是针对英文的，于是写了一个方便处理中文的类库，并且和 TextBlob 不同的是，这里没有用 NLTK，所有的算法都是自己实现的，并且自带了一些训练好的字典。注意本程序都是处理的 unicode 编码，所以使用时请自行 decode 成 unicode。 // 32.TextBlob 库官网：https://textblob.readthedocs.io 特点：TextBlob 是一个用于处理文本数据的 Python（2 和 3）库。它提供了一个简单的 API，用于深入研究常见的自然语言处理 (NLP) 任务，例如词性标注、名词短语提取、情感分析、分类、翻译等。 // 33.TextGrocery 库官网：https://textgrocery.readthedocs.io 特点：TextGrocery 是一个基于 LibLinear 和结巴分词的短文本分类工具，特点是高效易用，同时支持中文和英文语料。 // 34.NumPy 库官网：https://www.numpy.org.cn/ 特点：NumPy 是 Python 中科学计算的基础包。它是一个 Python 库，提供多维数组对象，各种派生对象（如掩码数组和矩阵），以及用于数组快速操作的各种 API，有包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数，基本统计运算和随机模拟等等。","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"https://wenkexia.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"hexo主题配置","slug":"hexo主题配置","date":"2022-01-20T11:19:51.000Z","updated":"2022-01-20T11:19:51.000Z","comments":true,"path":"2022/01208095.html","link":"","permalink":"https://wenkexia.github.io/2022/01208095.html","excerpt":"","text":"butterfly主题配置官方文档 安装插件如果你没有 pug 以及 stylus 的渲染器，请下载安装：npm install hexo-renderer-pug hexo-renderer-stylus --save 升级建议1.在 hexo 的根目录创建一个文件 _config.butterfly.yml，并把主题目录的 _config.yml 内容复製到 _config.butterfly.yml 去。( 注意: 复製的是主题的 _config.yml ,而不是 hexo 的 _config.yml)2.不要把主题目录的 _config.yml 删掉3.以后只需要在 _config.butterfly.yml进行配置就行。4.Hexo会自动合併主题中的_config.yml和 _config.butterfly.yml里的配置，如果存在同名配置，会使用_config.butterfly.yml的配置，其优先度较高。 Inject参考打开主题配置文件（butterfly.yml）定位搜索 inject其中head是用来引入css的。bottom是用来引入js的。 以相对路径引入1.将写好的css文件移动到\\Butterfly\\source\\css\\目录下。2.然后修改配置文件的引入方式 123456inject: head: - &lt;link rel=\"stylesheet\" href=\"/css/name.css\"&gt; bottom: - &lt;script src=\"xxxx\"&gt;&lt;/script&gt; 标签外挂（Tag Plugins）(推荐)参考参考标籤外挂是Hexo独有的功能，并不是标準的Markdown格式。 以下的写法，只适用于Butterfly主题，用在其它主题上不会有效果，甚至可能会报错。使用前请留意 Tabs页面内置小标签使用 123456789101112131415161718192021222324{% tabs Unique name, [index] %}&lt;!-- tab [Tab caption] [@icon] --&gt;Any content (support inline tags too).&lt;!-- endtab --&gt;{% endtabs %}Unique name : Unique name of tabs block tag without comma. Will be used in #id's as prefix for each tab with their index numbers. If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes. Only for current url of post/page must be unique![index] : Index number of active tab. If not specified, first tab (1) will be selected. If index is -1, no tab will be selected. It's will be something like spoiler. Optional parameter.[Tab caption] : Caption of current tab. If not caption specified, unique name with tab index suffix will be used as caption of tab. If not caption specified, but specified icon, caption will empty. Optional parameter.[@icon] : FontAwesome icon name (full-name, look like 'fas fa-font') Can be specified with or without space; e.g. 'Tab caption @icon' similar to 'Tab caption@icon'. Optional parameter. 1234567891011121314{% tabs test4 %}&lt;!-- tab 第一个Tab --&gt;**tab名字为第一个Tab**&lt;!-- endtab --&gt;&lt;!-- tab @fab fa-apple-pay --&gt;**只有图标 没有Tab名字**&lt;!-- endtab --&gt;&lt;!-- tab 炸弹@fas fa-bomb --&gt;**名字+icon**&lt;!-- endtab --&gt;{% endtabs %} 第一个Tab炸弹tab名字为第一个Tab只有图标 没有Tab名字名字+icon Button12345678910111213141516171819{% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %}[url] : 链接[text] : 按钮文字[icon] : [可选] 图标[color] : [可选] 按钮背景顔色(默认style时） 按钮字体和边框顔色(outline时) default/blue/pink/red/purple/orange/green[style] : [可选] 按钮样式 默认实心 outline/留空[layout] : [可选] 按钮佈局 默认为line block/留空[position] : [可选] 按钮位置 前提是设置了layout为block 默认为左边 center/right/留空[size] : [可选] 按钮大小 larger/留空 This is my website, click the button Butterfly gallery 相册图库参考参考 编辑主题导航栏加入相册按钮在站点主题_config.yml文件下menu菜单下新增gallery页面。 12menu: 相册: /gallery/ || fas fa-heart 新建相册页面在站点的source文件夹下面新建一个gallery相册页面。hexo new page gallery打开新建的gallery文件夹，里面会有一个index.md文件，设置index.md文件内容。然后使用标签外挂 galleryGroup，具体用法请查看对应的内容。 123456789101112--- title: gallery date: 2020-10-05 12:00:00 type: \"gallery\"layout: \"gallery\" &lt;div class=\"gallery-group-main\"&gt;{% galleryGroup '壁纸' '收藏的一些壁纸' '/Gallery/wallpaper' https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png %}{% galleryGroup '漫威' '关于漫威的图片' '/Gallery/marvel' https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %}{% galleryGroup 'OH MY GIRL' '关于OH MY GIRL的图片' '/Gallery/ohmygirl' https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg %}&lt;/div&gt;--- name：图库名字description：图库描述link：连接到对应相册的地址img-url：图库封面的地址 新建相册图片展示页面在gallery文件夹（也就是刚才创建的那个文件），可以在里面新建一些文件夹，也就是相册文件夹然后在新建的相册文件夹里，分别在每个文件夹里新建文件index.md ,然后使用标签外挂 gallery，具体用法请查看对应的内容。 1234567891011121314--- {% gallery %}![](https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg)![](https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg)![](https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg)![](https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg)![](https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg)![](https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg)![](https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg)![](https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg){% endgallery %}--- 友情链接创建友情链接页面在博客的根目录输入 hexo new page link修改source/link/index.md这个文件 12345 ---title: 友情链接date: 2018-06-07 22:17:49type: \"link\"--- 友情链接添加在Hexo博客目录中的source/_data（如果没有 _data 文件夹，请自行创建），创建一个文件link.yml 123456789101112131415161718192021222324- class_name: 友情链接 class_desc: 那些人，那些事 link_list: - name: Hexo link: https://hexo.io/zh-tw/ avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg descr: 快速、简单且强大的网誌框架- class_name: 网站 class_desc: 值得推荐的网站 link_list: - name: Youtube link: https://www.youtube.com/ avatar: https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png descr: 视频网站 - name: Weibo link: https://www.weibo.com/ avatar: https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png descr: 中国最大社交分享平台 - name: Twitter link: https://twitter.com/ avatar: https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png descr: 社交分享平台 class_name和class_desc支持html格式书写，如不需要，也可以留空。 评论开启评论需要在comments-use中填写你需要的评论。 支持双评论显示，只需要配置两个评论（第一个为默认显示） 参数 解释 use 使用的评论（填写的评论首字母需要大写。最多支持两个）注意：由于共用 ID,双评论不能是 Disqus 和 Disqusjs text 是否显示评论服务商的名字 lazyload 是否为评论开启lazyload，开启后，只有滚动到评论位置时才会加载评论所需要的资源（开启lazyload后，评论数将不显示） count 是否在文章顶部显示评论数livere 和 utterances 不支持评论数显示 card_post_count 是否在首页文章卡片显示评论数gitalk、livere 和 utterances不支持评论数显示 Pjax当用户点击链接，通过ajax更新页面需要变化的部分，然后使用HTML5的pushState修改浏览器的URL地址。 这样可以不用重复加载相同的资源（css/js）， 从而提升网页的加载速度。 12345pjax: enable: true exclude: - /music/ - /no-pjax/ 对于一些第三方插件，有些并不支持 pjax 。你可以把网页加入到 exclude 里，这个网页会被 pjax 排除在外。点击该网页会重新加载网站 使用pjax后，一些自己DIY的js可能会无效，跳转页面时需要重新调用，请参考Pjax文档使用pjax后，一些个别页面加载的js/css，将会改为所有页面都加载 Butterfly的Pjax目前仍有一些问题，请留意 引用文章参考以_post为根目录定位文件（md文件会被渲染成html）因为使用了abbrlink生成文章永久链接，所以在GitHub仓库中由md渲染成的HTML文件名是日期加abbrlink数字 新建一个页面打开文章&lt;a href=\"/2021/12184010.html\" target=\"_blank\"&gt;显示的文字&lt;/a&gt; 在此页面打开新文章[显示的文字](/2021/12184010.html){% post_link 文章文件名 显示文本 %} 添加 RSS 订阅支持本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下：npm install hexo-generator-feed --save 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明已经安装成功了。 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456789# RSS订阅plugin: - hexo-generator-feed# Feed Atomfeed: type: atom path: atom.xml limit: 20 在主题的配置文件_config.butterfly.yml中的social属性下添加rss的icon配置： 12social: fa fa-rss: /atom.xml 添加emoji表情支持Matery 主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：😄）转变成会跳跃的emoji表情，安装命令如下：npm install hexo-filter-github-emojis --save在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 1234567githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 添加动态诗词参考 采用的是今日诗词，每次返回一句诗词，根据时间、地点、天气、事件智能推荐。官网有API文档，可以去看一下，有多种安装方式，最简单的方式就是从官网获取代码，1.在/themes/matery/layout/_partial/head.ejs添加下面的一行代码： 12&lt;script src=\"https://sdk.jinrishici.com/v2/browser/jinrishici.js\" charset=\"utf-8\"&gt;&lt;/script&gt; 2.然后再将/themes/matery/layout/_partial/bg-cover-content.ejs中的&lt;%= config.description %&gt;修改为&lt;%- '&lt;span id=\"jinrishici-sentence\"&gt;正在加载今日诗词....&lt;/span&gt;' %&gt;3.使用前提是将主题配置文件的subtitle的值改为false。 添加萌萌的动漫人物1.安装插件npm install --save hexo-helper-live2d2.输入以下命令，安装下载动画人物库，将 haruto 更换成你想要的模型名称即可 如：npm install live2d-widget-model-haruto更多模型选择请点击 3.根目录_config.yml配置里面添加： 12345678910111213141516171819live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-haruto #模型选择 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: true #是否在手机端显示 react: opacity: 0.7 动漫人物最好不要和不蒜子一起使用，不然不蒜子会显示不出来。 添加全局吸底Aplayer音乐(不采用)安装hexo-tag-aplayer插件关闭 asset_inject由于需要全局都插入aplayer和meting资源，为了防止插入重复的资源，需要把asset_inject设为false在Hexo的配置文件中 123aplayer: meting: true asset_inject: false 开启主题的aplayerInject在主题的配置文件中，enable设为true和per_page设为true 1234# Inject the css and script (aplayer/meting)aplayerInject: enable: true per_page: true 插入Aplayer html把aplayer代码插入到主题配置文件的inject.bottom去 1234inject: head: bottom: - &lt;div class=\"aplayer no-destroy\" data-id=\"000PeZCQ1i4XVs\" data-server=\"tencent\" data-type=\"artist\" data-fixed=\"true\" data-mini=\"true\" data-listFolded=\"false\" data-order=\"random\" data-preload=\"none\" data-autoplay=\"true\" muted&gt;&lt;/div&gt; id是自己分享的歌曲后由链接得到的idserver可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐）。type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） 如果你想切换页面时，音乐不会中断。请把主题配置文件的pjax设为true，在class里需添加no-destroy，这样防止切换页面时Aplayer被销毁 UI 调整按照上面的步骤设置完成后，浏览器左下角会出现Aplayer。打开文章页面时，你会发现打开Toc目录的按钮被遮挡了。我们需要修改CSS来改变按钮的位置。向上调整 123#toggle-sidebar { bottom: 80px} 在主题配置文件中，添加到inject去 123inject: head: - '&lt;style type=\"text/css\"&gt;#toggle-sidebar {bottom: 80px}&lt;/style&gt;' 参考文章https://butterfly.js.org/https://yangchaoyi.vip/ matery主题配置（不采用）下载主题hexo-theme-matery 是一个采用 Material Design 和响应式设计的 Hexo 博客主题去github下载解压缩后，将 hexo-theme-matery 的文件夹复制到 Hexo 的 themes 文件夹中即可。 切换主题修改 Hexo 根目录下的_config.yml 的 theme 的值：theme: hexo-theme-matery 主题目录结构说明1.matery/layout下的.ejs文件是编写关于主页右上角分类，归档的2.目录样式在：themes\\Matery\\layout_partial\\post-detail-toc.ejs3.如果有多语言支持需求，可以更改 themes/next/languages 下对应语言的翻译。 medias个性化参考 1.我先把banner 和 featureimages里的图片来了个大换血。不过这里我发现一个问题，壁纸尺寸必须和电脑显示屏的分辨率一样才能完美显示。比如我的电脑分辨率是1080*1920，那么我下载的壁纸也得是这个尺寸，不然浏览器渲染显示的时候会不好看。 2.接着我又把网站logo，avatars，favicon 也给换成了自己喜欢的图片免费logo生成网站 代码高亮参考 Hexo的matery主题中的代码块出现代码大小不一，代码键复制，无法高亮等BUG 评论主题中内置了valine, miniValine, livere, gitment, gitalk, changyan评论通过主题文件夹下的_config.yml文件中的相应属性进行设置推荐使用valine和livere这里重点说一下valine评论配置 1234567891011valine: on: true # 是否启用 appid: # 你的appid --&gt; https://valine.js.org/quickstart.html，请阅读这个获取appid和appkey appkey: # 你的key avatar: '' # 匿名者头像选项 https://valine.js.org/avatar.html 访客的头像,最好启用下面的`requiredFields`中的邮箱必填，填写qq邮箱，头像会变成qq头像 placeholder: '客官，说点什么吧' # 评论内容输入框的 placeholder master: 'xxxxxx' # 博主标签识别，博主邮箱md5 可以去md5加密网站，例如 https://md5jiami.51240.com/ ，将自己的邮箱输入， 得到 32位小写 的字符串填入这里 friends: ['xxxxxxx', 'xxxxxx'] # 小伙伴的 邮箱md5， 是个数组 requiredFields: ['nick', 'mail'] # 设置必填项 ['nick', 'mail'] nick为昵称必填， mail为邮箱必填, 空数组，则不校验 backgroundImg: '/medias/comment-bg.gif' # 右下角背景图片, or http://xxx.gif backgroundColor: 'rgba(255,255,255,0.9)' # 背景颜色, 0.9标是透明度 打开腾讯兔小巢后台反馈在主题配置文件更改，加入自己注册后得到的产品Id就可以 1234# 腾讯兔小巢，见https://txc.qq.com/tuxiaochao: enable: true productId: 371566 添加 Tidio 在线聊天功能前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 百度优化登录百度搜索资源平台， 登录成功之后在 用户中心 –&gt; 站点管理 页面中点击添加网站，按提示操作。因为我是部署在gitee上的，刚开始我选择的是文件验证方式，但一直提示验证文件内容不符，因此选择了HTML标签验证复制的标签增加在\\themes\\Chic\\layout\\_partial的head.ejs的&lt;head&gt;与&nbsp;&lt;/head&gt;标签之间经过以上步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。hexo-theme-matery主题已经内置了自动推送的方式， 检查themes/hexo-theme-matery/_config.yml文件中如下配置:# 百度搜索资源平台提交链接baiduPush: true自动推送的JS代码部署在站点的每一个页面源代码中，当页面在每次被浏览时，链接就会被自动推送给百度。 添加百度统计参考 1.注册百度统计账号2.添加博客域名3.获取Baidu Analytics ID然后进入代码管理-&gt;代码获取可以看到如下一段javascript代码，这段代码本来是要手动嵌入到网页中的，但是Hexo已经帮我们嵌入了，所以我们自诩配置Baidu Analytics ID即可，这个ID就是下面代码的hm.js?后面那一串，先复制一下 123456789&lt;script&gt;var _hmt = _hmt || [];(function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?5b6ae75148041557ddd693925322myid\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s);})();&lt;/script&gt; 4.配置Baidu Analytics ID打开主题的配置文件，然后搜索Baidu Analytics ID，找到如下配置项： 12# Baidu Analytics IDbaidu_analytics: 5b6ae75148041557ddd69392532288de 去掉baidu_analytics前面的#号开启百度统计，值设置成刚在百度统计后台复制的Baidu Analytics ID 添加导航页参考 1.首先新建页面，执行下面的命令 1hexo new page navigate 2.修改 navigate 目录下的 index.md 的格式 123456---title: 导航date: 2020-05-09 11:19:14type: \"navigate\"layout: \"navigate\"--- 3.在主题配置文件中添加导航 12345678910111213141516171819202122232425262728293031323334# main menu navigation url and icon# 配置菜单导航的名称、路径和图标icon.menu: Index: url: / icon: fas fa-home 统计: url: / icon: fas fa-sitemap children: - name: 分类 url: /categories icon: fas fa-bookmark - name: 标签 url: /tags icon: fas fa-tags - name: 归档 url: /archives icon: fas fa-archive About: url: /about icon: fas fa-address-card Contact: url: /contact icon: fas fa-comments 友人帐: url: /friends icon: fas fa-share-alt 赞助墙: url: /sponsor icon: fa fa-credit-card 导航: url: /navigate icon: fas fa-location-arrow 4.在 matery/layout 下新建 navigate.ejs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414&lt;div class=\"navi-height bg-cover pd-header \"&gt; &lt;div class=\" link-box container\"&gt; &lt;!-- 搜索框 --&gt; &lt;div class=\"baidu baidu-2 large-screen\"&gt; &lt;form name=\"f\" action=\"https://www.baidu.com/\" target=\"_blank\"&gt; &lt;div id=\"Select-2\"&gt; &lt;div class=\"Select-box-2\" id=\"baidu\"&gt; &lt;ul style=\"height: 46px;\"&gt; &lt;li class=\"this_s\"&gt;百 · 度&lt;/li&gt; &lt;li class=\"bing_s\"&gt;必 · 应&lt;/li&gt; &lt;li class=\"google_s\"&gt;谷 · 歌&lt;/li&gt; &lt;li class=\"baidu_s\"&gt;百 · 度&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input name=\"wd\" id=\"kw-2\" maxlength=\"100\" autocomplete=\"off\" type=\"text\"&gt; &lt;/div&gt; &lt;div class=\"qingkong\" id=\"qingkong\" title=\"清 · 空\" style=\"display: none;\"&gt;x&lt;/div&gt; &lt;input value=\"搜 · 索\" id=\"su-2\" type=\"submit\"&gt; &lt;ul class=\"keylist\"&gt;&lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- 链接 --&gt; &lt;div class=\"row tags-posts \"&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;娱乐 · 影视&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.jd.com/\" class=\"link-3\" target=\"_blank\"&gt;京东&lt;/a&gt; &lt;li&gt;&lt;a href=\"https://www.taobao.com/\" class=\"link-3\" target=\"_blank\"&gt;淘宝&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.tmall.com/\" class=\"link-3\" target=\"_blank\"&gt;天猫&lt;/a&gt;&lt;/li&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"https://v.qq.com/\" class=\"link-3\" target=\"_blank\"&gt;腾讯视频&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.iqiyi.com/\" class=\"link-3\" target=\"_blank\"&gt;爱奇艺&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.bilibili.com/\" class=\"link-3\" target=\"_blank\"&gt;哔哩哔哩&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"https://music.163.com/\" class=\"link-3\" target=\"_blank\"&gt;网易云音乐&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://y.qq.com/\" class=\"link-3\" target=\"_blank\"&gt;QQ音乐&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.kugou.com/\" class=\"link-3\" target=\"_blank\"&gt;酷狗音乐&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;社区 · Code&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.mobaijun.com/contact/\" class=\"link-3\" target=\"_blank\"&gt;留言&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://github.com/\" class=\"link-3\" target=\"_blank\"&gt;GitHub&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://coding.net/\" class=\"link-3\" target=\"_blank\"&gt;Coding&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://juejin.im/\" class=\"link-3\" target=\"_blank\"&gt;掘金&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://gitee.com/\" class=\"link-3\" target=\"_blank\"&gt;码云&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.csdn.net/\" class=\"link-3\" target=\"_blank\"&gt;CSDN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.jianshu.com/\" class=\"link-3\" target=\"_blank\"&gt;简书&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://segmentfault.com/\" class=\"link-3\" target=\"_blank\"&gt;思否&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://cloud.tencent.com/developer/\" class=\"link-3\" target=\"_blank\"&gt;云+社区&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;实用 · 工具&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://mdnice.com/\" class=\"link-3\" target=\"_blank\"&gt;Nice编辑器&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://translate.google.cn/\" class=\"link-3\" target=\"_blank\"&gt;谷歌翻译&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.uupoop.com/\" class=\"link-3\" target=\"_blank\"&gt;在线PS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.processon.com/\" class=\"link-3\" target=\"_blank\"&gt;思维导图&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://wallhaven.cc/\" class=\"link-3\" target=\"_blank\"&gt;超清壁纸&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://cli.im/\" class=\"link-3\" target=\"_blank\"&gt;二维码&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.yinfans.me/\" class=\"link-3\" target=\"_blank\"&gt;音范思&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.52pojie.cn/\" class=\"link-3\" target=\"_blank\"&gt;吾爱破解&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://my.openwrite.cn/\" class=\"link-3\" target=\"_blank\"&gt;OW分发&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;编程 · 学习&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.oschina.net/\" class=\"link-3\" target=\"_blank\"&gt;开源中国&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://htmldog.com/\" class=\"link-3\" target=\"_blank\"&gt;HTML狗&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.icourse163.org/\" class=\"link-3\" target=\"_blank\"&gt;中国大学慕课&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.imooc.com/\" class=\"link-3\" target=\"_blank\"&gt;慕课网&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.wxapp-union.com/\" class=\"link-3\" target=\"_blank\"&gt;小程序&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.runoob.com/\" class=\"link-3\" target=\"_blank\"&gt;菜鸟教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://blog.51cto.com/\" class=\"link-3\" target=\"_blank\"&gt;51CTO&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.shiyanlou.com/library/\" class=\"link-3\" target=\"_blank\"&gt;实验楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://spring.io/\" class=\"link-3\" target=\"_blank\"&gt;Spring&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;资讯 · 趋势&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.huxiu.com/\" class=\"link-3\" target=\"_blank\"&gt;虎嗅&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://insights.stackoverflow.com/\" class=\"link-3\" target=\"_blank\"&gt;技术调查&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.asciiworld.com/\" class=\"link-3\" target=\"_blank\"&gt;摸鱼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://sspai.com/\" class=\"link-3\" target=\"_blank\"&gt;少数派&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://zh.wikihow.com/\" class=\"link-3\" target=\"_blank\"&gt;WikeHom&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.awesomes.cn/rank?sort=hot\" class=\"link-3\" target=\"_blank\"&gt;前端趋势&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://github-trending.com/\" class=\"link-3\" target=\"_blank\"&gt;GitHub趋势&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.tiobe.com/\" class=\"link-3\" target=\"_blank\"&gt;编程趋势&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://trends.google.com/\" class=\"link-3\" target=\"_blank\"&gt;Google趋势&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;搜索 · 其他&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://ac.scmor.com/\" class=\"link-3\" target=\"_blank\"&gt;谷歌镜像&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.pansoso.com/\" class=\"link-3\" target=\"_blank\"&gt;网盘搜索&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://tool.mkblog.cn/music/\" class=\"link-3\" target=\"_blank\"&gt;音乐搜索&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.dytt8.net/\" class=\"link-3\" target=\"_blank\"&gt;电影天堂&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://carbon.now.sh/\" class=\"link-3\" target=\"_blank\"&gt;代码图片&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.zhipin.com/\" class=\"link-3\" target=\"_blank\"&gt;Boos&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://fontawesome.com/\" class=\"link-3\" target=\"_blank\"&gt;图标库&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.qvdv.com/tools/qvdv-guid.html\" class=\"link-3\" target=\"_blank\"&gt;在线工具&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"http://zhongguose.com/\" class=\"link-3\" target=\"_blank\"&gt;中国色&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; /*选择搜索引擎*/ $('.Select-box ul').hover(function () { $(this).css('height', 'auto') }, function () { $(this).css('height', '40px') }); $('.Select-box-2 ul').hover(function () { $(this).css('height', 'auto') }, function () { $(this).css('height', '46px') }); $('.Select-box li').click(function () { var _tihs = $(this).attr('class'); var _html = $(this).html(); if (_tihs == 'baidu_s') { _tihs = 'https://www.baidu.com/s'; _name = 'wd'; } if (_tihs == 'google_s') { _tihs = 'https://www.google.com/search'; _name = 'q'; } if (_tihs == 'bing_s') { _tihs = 'https://www.bing.com/search'; _name = 'q'; } $('.baidu form').attr('action', _tihs); $('.this_s').html(_html); $('#kw').attr('name', _name); $('.Select-box ul').css('height', '40px') }); $('.Select-box-2 li').click(function () { var _tihs = $(this).attr('class'); var _html = $(this).html(); if (_tihs == 'baidu_s') { _tihs = 'https://www.baidu.com/s'; _name = 'wd'; } if (_tihs == 'google_s') { _tihs = 'https://www.google.com/search'; _name = 'q'; } if (_tihs == 'bing_s') { _tihs = 'https://www.bing.com/search'; _name = 'q'; } $('.baidu form').attr('action', _tihs); $('.this_s').html(_html); $('#kw-2').attr('name', _name); $('.Select-box-2 ul').css('height', '48px') }); //清空输入框内容 $('.qingkong').click(function () { cls(); $(this).css('display', 'none') }); function cls() { var sum = 0; var t = document.getElementsByTagName(\"INPUT\"); for (var i = 0; i &lt; t.length; i++) { if (t[i].type == 'text') { ++sum; t[i].value = \"\";//清空 } } } //清空输入框按钮的显示和隐藏 function if_btn() { var btn_obj = document.getElementById(\"kw\") || document.getElementById(\"kw-2\"); var cls_btn = document.getElementById(\"qingkong\"); var btn_obj_val; var times; //当元素获得焦点时 if (btn_obj == '' || btn_obj == null) { return false; //如果没有找到这个元素，则将函数返回，不继续执行 } btn_obj.onfocus = function () { times = setInterval(function () { btn_obj_val = btn_obj.value; if (btn_obj_val != 0) { cls_btn.style.display = \"block\"; } else { cls_btn.style.display = \"none\"; } }, 200); } //元素失去焦点时 btn_obj.onblur = function () { clearInterval(times); } } &lt;/script&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; * { margin: 0; padding: 0; font-family: \"微软雅黑\" } ul,li,h1,h2,h3,h4,h5,h6,p,form,dl,dt,dd { margin: 0px; padding: 0px; font-size: 14px; font-weight: normal; } img { border-style: none; } li { list-style: none; float: left } a { text-decoration: none } .card { background-color: rgba(25, 240, 229, 0); width: 96%; margin-left: 2% } .baidu { float: left; margin-left: 100px; } .baidu form { position: relative } .Select-box ul { height: 40px; position: absolute; left: -1px; top: 0px; z-index: 9999; background: #FFF; border: 1px solid #ccc; border-top: none; overflow: hidden } .Select-box li { width: 60px; line-height: 40px; font-size: 14px; color: #484848; border: 0; cursor: pointer; } .Select-box li:hover { background: #3385ff; color: #FFF; } .Select-box .this_s { color: #317ef3; } .Select-box .this_s:hover { background: #FFF; color: #317ef3; } .qingkong { position: absolute; right: 120px; top: 12px; width: 18px; height: 18px; background: rgba(0, 0, 0, 0.1); border-radius: 18px; line-height: 16px; color: #666666; cursor: pointer; text-align: center; font-size: 14px; display: none; } .qingkong:hover { background: rgba(0, 0, 0, 0.2); } .qingkong:active { background: rgba(0, 0, 0, 0.3); } .baidu-2 { width: 100%; height: 110px; margin: 0 auto; background: none; padding-top: 50px; } .baidu-2 form { width: 520px; margin: 0 auto; } .baidu-2 input { padding: 13px 8px; opacity: 0.9; font-size: 15px; } #Select-2 { float: left; } .Select-box-2 { text-align: center; float: left; position: relative; } .Select-box-2 ul { height: 46px; position: absolute; left: 0px; top: 1px; z-index: 9999; background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; border-top: none; overflow: hidden } .Select-box-2 li { width: 60px; line-height: 46px; font-size: 15px; color: #484848; border: 0; cursor: pointer; } .Select-box-2 li:hover { background: #3385ff; color: #FFF; } .Select-box-2 .this_s { color: #317ef3; } .Select-box-2 .this_s:hover { background: none; color: #317ef3; } #kw-2 { width: 335px; outline: 0; border: 1px solid #ccc; background: rgba(255, 255, 255, 0.2); color: #000000; padding-left: 70px; font-weight: bold; } /*修改搜索框样式*/ #su-2 { width: 90px; background: blue; border: none; border-top: #3385ff 1px solid; border-bottom: 1px solid #2d78f4; color: #FFF; cursor: pointer; /*去轮廓阴影*/ outline: none; } /*光标移动到搜索框颜色*/ #su-2:hover { background: blue; border-bottom: 1px solid blue; } #su-2:active { background: blue; box-shadow: inset 1px 1px 3px blue; -webkit-box-shadow: inset 1px 1px 3px blue; } .jj-list-tit { font-size: 16px; line-height: 25px; color: #ffffff; width: 100%; padding-left: 38.5%; } .jj-list-con { overflow: hidden; margin: 0 auto } /*控制网站列表间距*/ .jj-list-con li { width: 31.333%; margin: 1%; } .link-3 { display: block; background: rgba(0, 0, 0, .35); color: #FFF; font-size: 13px; text-align: center; line-height: 35px; padding: 4px 0; border-radius: 2px; transition: all 0.2s } .link-3:hover { background: rgba(0, 0, 0, .45); font-size: 15px; font-weight: bold } /*1栏 小于584*/ @media only screen and (max-width: 584px) { .navi-height { height: 1300px; } .link-box { margin-top: 5%; } .large-screen { display: none; } } /* 2栏 大于584 小于993px */ @media only screen and (min-width: 584px) and (max-width: 993px) { .navi-height { height: 800px; } .link-box { margin-top: 5%; } .large-screen { display: none; } } /*3栏 大于993px*/ @media only screen and (min-width: 993px) { .navi-height { position: absolute; width: 100%; height: 100%; } } /* 隐藏footer */ .page-footer { display: none; }&lt;/style&gt;&lt;% if (theme.banner.enable) { %&gt;&lt;script&gt; // 每天切换 banner 图. Switch banner image every day. var bannerUrl = \"&lt;%- theme.jsDelivr.url %&gt;&lt;%- url_for('/medias/banner/') %&gt;\" + new Date().getDay() + '.jpg'; $('.bg-cover').css('background-image', 'url(' + bannerUrl + ')');&lt;/script&gt;&lt;% } else { %&gt;&lt;script&gt; $('.bg-cover').css('background-image', 'url(&lt;%- theme.jsDelivr.url %&gt;&lt;%- url_for('/medias/banner/0.jpg') %&gt;)');&lt;/script&gt;&lt;% } %&gt; 修改导航栏颜色以及透明效果打开themes/matery/source/css/matery.css文件，大约在250行，有一个.bg-color属性，修改其属性值即可，代码如下： 1234.bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); //修改成自己喜欢的颜色值 opacity: 0.8; //透明效果 值范围 0~1，看情况自己修改} 新增加载动画参考 1.在 Matery 主题配置文件 _config.yml 中新增配置属性 preloader。 1234# 是否开启页面加载动画 true 开启，false 关闭preloader: enable: true 2.在 Matery 主题目录 /layout/_widget 下新增文件 loading.ejs，将以下内容写入 loading.ejs。 12345678910111213141516171819202122&lt;% if (theme.preloader.enable) { %&gt;&lt;div id=\"loading-box\"&gt; &lt;div class=\"loading-left-bg\"&gt;&lt;/div&gt; &lt;div class=\"loading-right-bg\"&gt;&lt;/div&gt; &lt;div class=\"spinner-box\"&gt; &lt;div class=\"configure-border-1\"&gt; &lt;div class=\"configure-core\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"configure-border-2\"&gt; &lt;div class=\"configure-core\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"loading-word\"&gt;加载中...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; window.addEventListener('load', function(){ document.body.style.overflow = 'auto'; document.getElementById('loading-box').classList.add(\"loaded\") }, false)&lt;/script&gt;&lt;% } %&gt; 3.接着在 Matery 主题目录 /css 下新增 loading.css ，并将以下内容写入 loading.css。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#loading-box .loading-left-bg,#loading-box .loading-right-bg { position: fixed; z-index: 1000; width: 50%; height: 100%; background-color: #37474f; transition: all 0.5s;}#loading-box .loading-right-bg { right: 0;}#loading-box &gt; .spinner-box { position: fixed; z-index: 1001; display: flex; justify-content: center; align-items: center; width: 100%; height: 100vh;}#loading-box .spinner-box .configure-border-1 { position: absolute; padding: 3px; width: 115px; height: 115px; background: #ffab91; animation: configure-clockwise 3s ease-in-out 0s infinite alternate;}#loading-box .spinner-box .configure-border-2 { left: -115px; padding: 3px; width: 115px; height: 115px; background: rgb(63, 249, 220); transform: rotate(45deg); animation: configure-xclockwise 3s ease-in-out 0s infinite alternate;}#loading-box .spinner-box .loading-word { position: absolute; color: #ffffff; font-size: 0.8rem;}#loading-box .spinner-box .configure-core { width: 100%; height: 100%; background-color: #37474f;}div.loaded div.loading-left-bg { transform: translate(-100%, 0);}div.loaded div.loading-right-bg { transform: translate(100%, 0);}div.loaded div.spinner-box { display: none !important; }@keyframes configure-clockwise { 0% { transform: rotate(0); } 25% { transform: rotate(90deg); } 50% { transform: rotate(180deg); } 75% { transform: rotate(270deg); } 100% { transform: rotate(360deg); }}@keyframes configure-xclockwise { 0% { transform: rotate(45deg); } 25% { transform: rotate(-45deg); } 50% { transform: rotate(-135deg); } 75% { transform: rotate(-225deg); } 100% { transform: rotate(-315deg); }} 4.然后找到 Matery 主题目录 /layout/_partial 下找到 head.ejs，并在 &lt;head&gt; 标签中添加以下内容引入 loading.css 文件。&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"&lt;%- theme.jsDelivr.url %&gt;&lt;%- url_for('/css/loading.css') %&gt;\"&gt; 5.再找到 Matery 主题目录 /layout 下找到 layout.ejs，然后在&lt;body&gt; 标签下引入 loading.ejs。&lt;%- partial('_widget/loading') %&gt;","categories":[{"name":"hexo","slug":"hexo","permalink":"https://wenkexia.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wenkexia.github.io/tags/hexo/"}]},{"title":"markdown语法","slug":"markdown语法","date":"2022-01-09T03:24:32.000Z","updated":"2022-01-09T03:24:32.000Z","comments":true,"path":"2022/010947193.html","link":"","permalink":"https://wenkexia.github.io/2022/010947193.html","excerpt":"","text":"官方文档 概述Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。 Markdown 是 HTML 的一种简写，在显示时会『解压缩』成 HTML。理论上你可以在 Markdown 里直接插入合法的 HTML 块，他们会成为最终的 HTML 的一部分，做到 Markdown 本身做不到的事。Markdown 的格式可以由 CSS 描述 标题语法要创建标题，请在单词或短语前面添加# 。#的数量代表了标题的级别用一个空格在#和标题之间进行分隔。 强调语法粗体（Bold）加斜体（Italic） 要加粗文本，请在单词或短语的前后各添加三个星号（asterisks） 删除线删除线就是给文本加上删除线，在文本两端使用两个波浪线~ 1~~文本~~ 文本 引用语法要创建块引用，请在段落前添加一个&gt;符号。 列表语法要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 围栏代码块在代码块之前和之后的行上使用三个反引号（(```）或三个波浪号（~~~）。 在反引号后面加上语言的名字就可以享受到对应语言的语法高亮。 用反引号括起来，反引号是英文输入下，tab的上一个键 分隔线在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。为了兼容性，请在分隔线的前后均添加空白行 链接语法超链接Markdown语法代码：[超链接显示名](超链接地址 “超链接title”)使用尖括号可以很方便地把URL或者email地址变成可点击的链接。 转义字符语法要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 。 图片语法12![ddfdfd](图片链接 \"图片title\") 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 hexo文章表格要与正文空两行才可以渲染 表格的对齐方式-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。 1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 任务列表任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。 Write the press release Update the website Contact the media使用 Emoji 表情复制使用https://emojipedia.org/ https://gist.github.com/rxaviers/7360908","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://wenkexia.github.io/tags/markdown/"}]},{"title":"vscode使用","slug":"vscode使用","date":"2022-01-09T03:18:05.000Z","updated":"2022-01-09T03:18:05.000Z","comments":true,"path":"2022/01093653.html","link":"","permalink":"https://wenkexia.github.io/2022/01093653.html","excerpt":"","text":"vscode快捷键F1 或 Ctrl+Shift+P（俗称万能键） ：打开命令面板 编辑器与窗口管理新建文件: Ctrl+N 文件之间切换: Ctrl+Tab 打开一个新的VS Code编辑器: Ctrl+Shift+N 关闭当前窗口: Ctrl+W 关闭当前的VS Code编辑器: Ctrl+Shift+W 切出一个新的编辑器窗口(分屏–最多3个): Ctrl+\\ 切换左中右3个编辑器窗口的快捷键: Ctrl+1 Ctrl+2 Ctrl+3 格式调整代码行向左或向右缩进: Ctrl+[ 、 Ctrl+] 复制或剪切当前行/当前选中内容: Ctrl+C 、 Ctrl+V 代码格式化: Shift+Alt+F 向上或向下移动一行: Alt+Up 或 Alt+Down 向上或向下复制一行: Shift+Alt+上键 或 Shift+Alt+下键 在当前行下方插入一行: Ctrl+Enter 在当前行上方插入一行: Ctrl+Shift+Enter 光标相关移动到行首: Home 移动到行尾: End 移动到文件结尾: Ctrl+End 移动到文件开头: Ctrl+Home 移动到定义处: F12 查看定义处缩略图(只看一眼而不跳转过去): Alt+F12 选择从光标到行尾的内容: Shift+End 选择从光标到行首的内容： Shift+Home 删除光标右侧的所有内容(当前行): Ctrl+Delete 扩展/缩小选取范围： Shift+Alt+Right 和 Shift+Alt+Left 多行编辑(列编辑): Alt+Shift+鼠标左键 或 Ctrl+Alt+Down/Up 同时选中所有匹配编辑(与当前行或选定内容匹配): Ctrl+Shift+L 下一个匹配的也被选中: Ctrl+D 回退上一个光标操作: Ctrl+U 撤销上一步操作: Ctrl+Z 手动保存: Ctrl+S 重构代码找到所有的引用: Shift+F12 同时修改本文件中所有匹配的: Ctrl+F2 跳转到下一个 Error 或 Warning: 当有多个错误时可以按 F8 逐个跳转 查找替换查找: Ctrl+F 查找替换: Ctrl+H 显示相关全屏显示(再次按则恢复): F11 放大或缩小(以编辑器左上角为基准): Ctrl +/- 侧边栏显示或隐藏： Ctrl+B 显示资源管理器(光标切到侧边栏中才有效): Ctrl+Shift+E 显示搜索(光标切到侧边栏中才有效): Ctrl+Shift+F 显示源代码管理(光标切到侧边栏中才有效): Ctrl+Shift+G+G 显示 Debug: Ctrl+Shift+D 显示 Output: Ctrl+Shift+U 插件推荐Beautify按下f1打开命令，搜索Beautify，点击Beautify file美化整个文件。代码被自动换行，也进行了格式化。这个美化操作支持多种格式的源代码。 Bracket Pair Colorizer：给匹配的括号着色 Indent-Rainbow让缩进带有颜色 Material Icon Theme好看的文件图标 Path Intellisense自动补全文件名 A-super-translate划词翻译。鼠标停留选中几秒就会查看翻译内容。 会了吧打开源码可以自动分析所有包含的英语单词，并显示解释结果，还可以添加已经会的单词。 background加入设置的setting.json 12345678910111213141516171819 \"background.enabled\": true, \"background.useDefault\": false, \"background.customImages\": [ \"file:///E:/wenke_source/my picture/壁纸.jpg\" ], \"background.style\": { \"content\": \"''\", \"pointer-events\": \"none\", \"position\": \"absolute\", \"top\": \"0\", \"right\": \"0\", \"background-size\": \"cover\", \"opacity\": 0.1, \"z-index\": \"99999\", \"width\": \"100%\", \"height\": \"100%\", \"background-repeat\": \"no-repeat\",},\"bracketPairColorizer.depreciation-notice\": false Settings Sync用于同步不同电脑或环境下的配置。 用Github账户登录创建一个新的GIST或选择存在的GIST上传配置按下 Shift + Alt + U 下载配置按下 Shift + Alt + D Material Icon Theme：美化文件图标Image Preview 实时预览图片IntelliCode&nbsp;Extension Visual Studio Code中使用Jupyter NotebookPath Intellisense 可自动填充文件名。小技巧1.查看函数或者类的定义Ctrl+鼠标左键点击函数名或者类名即可跳转到定义处，在函数名或者类名上按F12也可以实现同样功能 2.更改变量名在变量名上按F2即可实现重命名变量 4.添加注释注释有两种形式，单行注释和块注释(在js中，单行注释//,块注释/**/)单行注释&nbsp; Ctrl +/ 开发用户代码片段 snippets 语法原文 12345678910{ \"alpha\": { \"prefix\": [\"a\", \"z\"], \"body\": [ \"abcdefghijklmnopqrstuvwxyz\" ], \"description\": \"字母\", \"scope\": \"javascript\" }} prefix 是触发的前缀，可以指定多个body 是插入到编辑器中的内容，支持很多语法description 是描述scope 是生效的语言，不指定的话就是所有语言都生效","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://wenkexia.github.io/tags/vscode/"}]},{"title":"python基础","slug":"python基础","date":"2022-01-08T14:30:18.000Z","updated":"2022-01-08T14:30:18.000Z","comments":true,"path":"2022/010834543.html","link":"","permalink":"https://wenkexia.github.io/2022/010834543.html","excerpt":"","text":"我的gittee中的python仓库 配置python开发环境Linux下配置pythonlinux安装ancondaAnaconda 是一个用于python/R科学计算和机器学习的开源工具(也称为Python的一种发行版)，支持 Linux, macOS, Windows, 包含了conda等众多工具包及其依赖项，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题 直接使用linux命令行下载 安装anaconda#首先安装wgetsudo apt-get install wget # Ubuntusudo yum install wget # CentOS #然后使用wget从清华源上下载Anaconda3-2021.05-Linux-x86_64.shwget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.05-Linux-x86_64.sh #安装Anaconda：sh Anaconda3-2021.05-Linux-x86_64.sh#查看许可时可输入q来退出 将conda加入环境变量加入环境变量是为了让系统能识别conda命令 #1.在终端中打开~/.bashrc：vim ~/.bashrc #2.在/.bashrc中将conda添加为环境变量：#先按i进入编辑模式在第一行输入：export PATH=”/anaconda3/bin:$PATH”#若安装时自定义了安装位置，则将~/anaconda3/bin改为自定义的安装目录下的bin文件夹 3.修改完成后，先按esc键退出编辑模式，再输入:wq!并回车，以保存退出 4.验证是否能识别conda命令： 在终端中输入source ~/.bash_profile以更新环境变量再在终端输入conda info --envs，若能显示当前有base环境，则conda已加入环境变量 Windows下安装Anaconda下载：https://docs.anaconda.com/anaconda/install/windows/ 环境变量123E:\\anacondaE:\\anaconda\\ScriptsE:\\anaconda\\Library\\bin 浏览器驱动放在D:\\ruanjian\\anaconda\\Scripts conda管理python虚拟环境conda 创建虚拟环境有个好处，它可以换python版本。如果你使用的virtualenv，它虽然也可以创建虚拟环境，但python版本无法换下载anaconda安装的python直接可以使用conda工具 列出系统存在虚拟环境：conda info -econda env list 创建虚拟环境conda create -n xxx python=3.9 切换虚拟环境 1234#on windowsactivate xxx#on linuxsource activate xxx 常用命令 12345678910111213141516171819202122232425262728293031323334353637383940#conda 版本查看conda --version#更新conda：conda update conda#更新第三方所有包：conda upgrade --all#退出虚拟环境#on windowsdeactivate#on linuxsource deactivate#删除虚拟环境conda remove --name xxx --all# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n xxx# 查找package信息conda search numpy# 安装packageconda install -n xxx numpy# 如果不用-n指定环境名称，则被安装在当前激活环境# 也可以通过-c指定通过某个channel安装# 更新packageconda update -n xxx numpy# 删除packageconda remove -n xxx numpy 添加清华源123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 说明 12345678#查看当前channelconda config --show#删除channel：conda config –remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free#增加channel：conda config ‐‐add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ Jupyter Notebook使用Anaconda已经自动为你安装了Jupter Notebook及其他工具 Jupyter Notebook是以网页的形式打开，可以在网页页面中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示的程序。如在编程过程中需要编写说明文档，可在同一个页面中直接,编写支持Markdown语法。 Jupyter Notebook中所有交互计算、编写说明文档、数学公式、图片以及其他富媒体形式的输入和输出，都是以文档的形式体现的。这些文档是保存为后缀名为.ipynb的JSON格式文件，不仅便于版本控制，也方便与他人共享。此外，文档还可以导出为：HTML、LaTeX、PDF等格式。 以富媒体格式展示计算结果。富媒体格式包括：HTML，LaTeX，PNG，SVG等。 支持使用LaTeX编写数学性说明。 命令模式编辑模式下按esc键进入命令模式。命令模式下，单元格边框为灰色，且左侧边框线为蓝色粗线条。 ctrl+回车 运行当前cell dd 删除当前cell y 切换cell类型为Code m 切换cell类型为Markdown b 下方插入cell 编辑模式命令模式下按enter或return键进入编辑模式。编辑模式下，单元格边框和左侧边框线均为绿色。 魔法命令加个‘！’就可以执行shell命令，可以直接在单元格内执行”!pwd”, “!ls” 等Linux里面的命令呢，但是windows环境中，要把”!”改成魔法命令“%”即可执行 单元格内执行shell命令还有一个高频操作就是安装需要的第三方库!pip install you-package==version %who会输出当前notebook中已经存在的变量 %whos除了输出变量外，变量的类型以及当前值也会显示 一个单元格多输出例如我们使用pandas读取一个文件生成dataframe后，想了解这个df的size, columns, 前5行等信息，正常情况下df.head, df.shape, df.info等内容要分成三个单元格来完成。但其实有更好的方法，可以让一个单元格内输出多个内容。具体方法是「增加一个单元格」执行下面两行代码即可： 1from IPython.core.interactiveshell import InteractiveShell InteractiveShell.ast_node_interactivity = \"all\" 标识符和变量标识符第一个字符必须是字母表中字母或下划线 _ 。标识符的其他的部分由字母、数字和下划线组成。标识符对大小写敏感。在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。 变量Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。 为多个变量赋值例如：a = b = c = 1为多个对象指定多个变量。例如：a, b, c = 1, 2, \"runoob\" 运算符Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，运算符的优先级指的是多个运算符同时出现时，先做什么运算然后再做什么运算。除了我们之前已经用过的赋值运算符和算术运算符，我们稍后会陆续讲到其他运算符的使用。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ | 按位异或，按位或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &amp;= ` = ^= &gt;&gt;= &lt;&lt;=` 1236 // 4 = 16 / 4 =1.5 说明： 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。 赋值运算符赋值运算符应该是最为常见的运算符，它的作用是将右边的值赋给左边的变量。下面的例子演示了赋值运算符和复合赋值运算符的使用。 12345678\"\"\"赋值运算符和复合赋值运算符\"\"\"a = 10b = 3a += b # 相当于：a = a + ba *= a + 2 # 相当于：a = a * (a + 2)print(a) # 算一下这里会输出什么 比较运算符和逻辑运算符比较运算符有的地方也称为关系运算符，包括==、!=、&lt;、&gt;、&lt;=、&gt;=，我相信没有什么好解释的，大家一看就能懂，唯一需要提醒的是比较相等用的是==，请注意这个地方是两个等号，因为=是赋值运算符，我们在上面刚刚讲到过，==才是比较相等的比较运算符。比较运算符会产生布尔值，要么是True要么是False。 逻辑运算符有三个，分别是and、or和not。and字面意思是“而且”，所以and运算符会连接两个布尔值，如果两个布尔值都是True，那么运算的结果就是True；左右两边的布尔值有一个是False，最终的运算结果就是False。相信大家已经想到了，如果and左边的布尔值是False，不管右边的布尔值是什么，最终的结果都是False，所以在做运算的时候右边的值会被跳过（短路处理），这也就意味着在and运算符左边为False的情况下，右边的表达式根本不会执行。or字面意思是“或者”，所以or运算符也会连接两个布尔值，如果两个布尔值有任意一个是True，那么最终的结果就是True。当然，or运算符也是有短路功能的，在它左边的布尔值为True的情况下，右边的表达式根本不会执行。not运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值，也就是说，后面的布尔值如果是True运算结果就是False，而后面的布尔值如果是False则运算结果就是True。 123456789101112131415\"\"\"比较运算符和逻辑运算符的使用\"\"\"flag0 = 1 == 1flag1 = 3 &gt; 2flag2 = 2 &lt; 1flag3 = flag1 and flag2flag4 = flag1 or flag2flag5 = not (1 != 2)print('flag0 =', flag0) # flag0 = Trueprint('flag1 =', flag1) # flag1 = Trueprint('flag2 =', flag2) # flag2 = Falseprint('flag3 =', flag3) # flag3 = Falseprint('flag4 =', flag4) # flag4 = Trueprint('flag5 =', flag5) # flag5 = False 说明：比较运算符的优先级高于赋值运算符，所以flag0 = 1 == 1先做1 == 1产生布尔值True，再将这个值赋值给变量flag0。print函数可以输出多个值，多个值之间可以用,进行分隔，输出的内容之间默认以空格分开。 三目运算符（三元表达式）为真时的结果 if 判断条件 else 为假时的结果（注意，没有冒号） 123# 实现一个基础版本（递归版本）的斐波那契数列：def fn(n): return n if n &lt; 2 else fn(n-1)+fn(n-2) 数据类型（8种）字符串string(不可变) Python 中单引号 ‘ 和双引号 “ 使用完全相同。 使用三引号(‘’’ 或 “””)可以指定一个多行字符串。 转义符 ,反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \\n” 则 \\n会显示，并不是换行。 字符串可以用 + 运算符连接在一起，用 * 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量[头下标:尾下标:步长] 12345678910111213141516171819202122232425262728293031323334353637#字符串连接：+a = \"Hello \"b = \"World \"print(a + b)#重复输出字符串：*print(a * 3)#通过索引获取字符串中字符[]print(a[0])#字符串截取[:] 牢记：左闭右开print(a[1:4])#判断字符串中是否包含给定的字符: in, not inprint('e' in a)print('e' not in a)#join():以字符作为分隔符，将字符串中所有的元素合并为一个新的字符串new_str = '-'.join('Hello')print(new_str)H-e-l-l-o字符串单引号、双引号、三引号print('Hello World!')print(\"Hello World!\")Hello World!Hello World!#转义字符 \\print(\"The \\t is a tab\")print('I\\'m going to the movies')#三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，保持一小块字符串的格式是所见即所得print('''I'm going to the movies''') 字符串驻留机制对相同字符串，只保留一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的相同字符串对应的变量 驻留机制的几种情况：字符串长度为0或1时符合标识符的字符串字符串只在编译时进行驻留，而非运行时[-5,256]之间的整数 优缺点当需要值相同的字符串时，可以直接从字符池里拿来用，避免频繁的创建和销毁，提升效率和节约内存 在需要进行字符串拼接时建议使用str类型的join方法，而非+，因为join()是先计算出所有字符中的长度，然后再拷贝，只new一次对象，效率更高 格式化字符串12345678910111213# 1.%做占位符name = \"wenke\"age =21print(\"我的名字是%s,年龄是%d\"%(name,age))# 2.{}做占位符 print(\"我的名字是{0},年龄是{1} \".format(name,age))# 3.f-stringprint(f'我的名字是{name},年龄是{age }') list（列表）List（列表） 是 Python 中使用最频繁的数据类型。类似于栈 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。特点1.查找和插入的时间随着元素的增加而增加；2.占用空间小，浪费内存很少。 列表生成式12345678l=['H','Q']# 将一个列表中所有字符串变小写a = [s.lower() for s in l]# 生成扑克所有组合a =['黑桃','草花','红桃','方块']b=['A','1','2','3','4','5','6','7','8','9','10','J','K','Q']print([m+n for m in a for n in b ]) 截取元素和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。列表截取的语法格式如下：变量[头下标:尾下标]len()函数可以获得list元素的个数用索引来访问list中每一个位置的元素 添加元素list1.append(‘g’) # 在末尾添加元素list1.insert(2, ‘o’) # 在指定位置添加元素，如果指定的下标不存在，就在末尾添加 删除元素删除list末尾的元素，用pop()方法删除指定位置的元素，用pop(i)方法，其中i是索引位置：list1.extend(list2) #合并两个list list2中仍有元素 list.sort()[]代表可选参数[cmp] [key]传递给key参数的是一个函数，它指定可迭代对象中的每一个元素来按照该函数进行排序 [reverse=True] 默认升序，True为降序 12345678910111213141516list = [4,7,3,2,6,9]#降序输出，默认升序list1=list.sort(reverse=True)list1 #key参数的使用li = [[1, 7], [1, 5], [2, 4], [1, 1]]def fun(li): return li[1]# 这时将函数fun传递给参数key 得出结果# 传入了key参数的sort()函数对li中的每个子元素[1,7],[1,5],[2,4],[1,1]都执行了fun()函数，返回它们的第1个数# 分别为7,5,4,1。然后再排序得到1,4,5,7。使的出的结果对本来的li进行排序最后就得到了[[1,1],[2,4],[1,5],[1,7]]。li.sort(key=fun)print(li) join方法。基本公式：’&lt;需要在每个元素中间添加的字符&gt;’.join(&lt;目标list，且所有元素都为str类型&gt;), 返回一个 新的字符串。注意：此方法可以直接跟在return后。 123a = ['j','1','k;sk','lplps']print('***'.join(a)) dict（字典）使用键-值（key-value）存储 特点1.查找和插入的速度极快，不会随着key的增加而变慢；2.需要占用大量的内存，内存浪费多。dict的key必须是不可变对象。这个通过key计算位置的算法称为哈希算法（Hash）。 常用1234#list可以转成字典，但前提是列表中元素都要成对出现lis=[('name','杨超越'),('weight',45)]dic = dict(lis) 字典函数1234567d={1:'a',2:'b'}d.keys() #返回一个包含字典所有KEY的列表d.values() #返回一个包含字典所有 valuel的列表#同时迭代key和valuefor k,v in d.items(): tuple（元组）与列表类似，元祖中的内容不可修改 1234567891011121314151617181920212223242526272829#元组中只有一个元素时，需要在后面加逗号！tuple3 = ('hello',)#元组不能修改，所以不存在往元组里加入元素,可将列表转换成元组list = [14, 10, 9, 15, 6, 10, 12, 5, 15, 8]t = tuple(list)#元组的修改：t1 = (1,2,3)+(4,5) #(1, 2, 3, 4, 5)t2 = (1,2) * 2 #(1, 2, 1, 2)#元组的一些函数：print(max(t))print(min(t))print(sum(t))print(len(t))#统计元组中4的个数print(t1.count(4))#元组中4所对应的下标，如果不存在，则会报错print(t.index(4))#判断元组中是否存在1这个元素print(4 in t)#返回元组中4所对应的下标,不会报错if(4 in t): print(t.index(4)) 元组的拆包与装包123456789101112131415161718#定义一个元组t3 = (1,2,3)#将元组赋值给变量a,b,ca,b,c = t3#打印a,b,cprint(a,b,c)#当元组中元素个数与变量个数不一致时#定义一个元组，包含5个元素t4 = (1,2,3,4,5)#将t4[0],t4[1]分别赋值给a,b;其余的元素装包后赋值给ca,b,*c = t4print(a,b,c)print(c)print(*c) number（数字）Number 数据类型用于存储数值，包括整数、浮点型、复数 int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。float (浮点数), 如 1.23、3E-2complex (复数), 如 1 + 2j、 1.1 + 2.2j 2 / 4 # 除法，得到一个浮点数0.52 // 4 # 除法，得到一个整数017 % 3 # 取余 22 ** 5 # 乘方 32 math 模块Python 中数学运算常用的函数基本都在 math 模块 1234567891011import mathprint(math.ceil(4.1)) #返回数字的上入整数print(math.floor(4.9)) #返回数字的下舍整数print(math.fabs(-10)) #返回数字的绝对值print(math.sqrt(9)) #返回数字的平方根print(math.exp(1)) #返回e的x次幂 Python随机数1234567import random#随机生成[0,1)的实数ran1 = random.random()#从指定范围内，按指定基数递增的集合中 获取一个随机数random.randrange ([start], stop, step]) set（集合）是一个无序不重复的序列,用于成员关系测试，删除重复元素a=set (‘abcd’) #与a={‘a’,’b’,’c’,’d’}等价 Boolean（布尔值）总结一下为假的情况有： None, False数值中的0, 0.0, 0j(虚数), Decimal(0), Fraction(0, 1)空字符串(‘’)、空元组(())、空列表([])空字典({})、空集合(set())对象默认为True，除非它有bool()方法且返回False或len()方法且返回0. 运算 表达式 结果 或运算 x or y 两个变量只要有一个为True则为True。 与运算 x and y 两个变量都为True时结果才为True。 非运算 not x not的优先级比非布尔运算符低，not a == b解释为not (a == b) 循环for-in语句 range(1, 101)：可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。 range(1, 101, 2)：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。 range(100, 0, -2)：可以用来产生100到1的偶数，其中-2是步长，即每次数字递减的值。 while循环如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环。while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True则继续循环；表达式的值为False则结束循环。 123456789#无限循环while True:#while 循环使用 else 语句while (): passelse； pass break结束本层循环 return语句return 语句会终止函数的执行，并且返回函数的值。return语句只能出现在函数体内 for循环与return语句的组合使用当函数体内的程序执行到return这一步时，会退出函数，即使是在一个循环体内，程序也不会再执行 函数模块（module）以.py作为文件后缀。任何py文件都可以作为一个模块。 使用python模块大大提高了代码的可维护性和代码复用性使用模块避免了函数名与变量名冲突。 将整个模块导入，格式为： import a 从某个模块中导入某个函数,格式为： from a import b 基础if name == ‘main‘的意思是：当.py文件被直接运行时，if name == ‘main‘之下的代码块将被运行； 当.py文件以模块形式被导入时，if name == ‘main‘之下的代码块不被运行。 import 与 from…import在 python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 包( package)在比較大型的项目中常常需要编写、用到大量的模块，此时我们可以使用包( Package)来管理这些模块。 里面装了一个_init_.Py文件的文件夹。 1.import 包名[.模块名[as别名] 2.from 包名 import 模块名[as别名] 3.from 包名.模块名 import成员名[as别名] 我们在导入包的时候，实际上是导入了它的 Init.py文件文件。 init.Py文件性质这个模块的模块名不是__init__，而是这个包的名字，也就是装着__init__.py文件的文件夹的名字。 它的作用是将一个文件夹变为一个Python模块 面向对象定义类在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。 123456789101112131415161718class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print('%s正在学习%s.' % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_movie(self): if self.age &lt; 18: print('%s只能观看《熊出没》.' % self.name) else: print('%s正在观看岛国爱情大电影.' % self.name) 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。 创建和使用对象12345678910# 创建学生对象并指定姓名和年龄stu1 = Student('骆昊', 38)# 给对象发study消息stu1.study('Python程序设计')# 给对象发watch_av消息stu1.watch_movie()stu2 = Student('王大锤', 15)stu2.study('思想品德')stu2.watch_movie() 访问可见性在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头 1234567891011121314151617181920class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar')def main(): test = Test('hello') # AttributeError: 'Test' object has no attribute '__bar' test.__bar() # AttributeError: 'Test' object has no attribute '__foo' print(test.__foo)if __name__ == \"__main__\": main() 但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是”We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。 在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻 面向对象进阶@property装饰器之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') def __init__(self, name, age): self._name = name self._age = age # 访问器 - getter方法 @property def name(self): return self._name # 访问器 - getter方法 @property def age(self): return self._age # 修改器 - setter方法 @age.setter def age(self, age): self._age = age def play(self): if self._age &lt;= 16: print('%s正在玩飞行棋.' % self._name) else: print('%s正在玩斗地主.' % self._name)def main(): person = Person('王大锤', 12) person.play() person.age = 22 person.play() # person.name = '白元芳' # AttributeError: can't set attributeif __name__ == '__main__': main() __slots__魔法:Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 静态方法之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839from math import sqrtclass Triangle(object): def __init__(self, a, b, c): self._a = a self._b = b self._c = c @staticmethod def is_valid(a, b, c): return a + b &gt; c and b + c &gt; a and a + c &gt; b def perimeter(self): return self._a + self._b + self._c def area(self): half = self.perimeter() / 2 return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c))def main(): a, b, c = 3, 4, 5 # 静态方法和类方法都是通过给类发消息来调用的 if Triangle.is_valid(a, b, c): t = Triangle(a, b, c) print(t.perimeter()) # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数 # print(Triangle.perimeter(t)) print(t.area()) # print(Triangle.area(t)) else: print('无法构成三角形.')if __name__ == '__main__': main() 类方法和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445from time import time, localtime, sleepclass Clock(object): \"\"\"数字时钟\"\"\" def __init__(self, hour=0, minute=0, second=0): self._hour = hour self._minute = minute self._second = second @classmethod def now(cls): ctime = localtime(time()) return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec) def run(self): \"\"\"走字\"\"\" self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): \"\"\"显示时间\"\"\" return '%02d:%02d:%02d' % \\ (self._hour, self._minute, self._second)def main(): # 通过类方法创建对象并获取系统时间 clock = Clock.now() while True: print(clock.show()) sleep(1) clock.run()if __name__ == '__main__': main() 类之间的关系简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。 is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。 has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。 use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。 继承,重写与多态我们可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person(object): \"\"\"人\"\"\" def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): print('%s正在愉快的玩耍.' % self._name) def watch_av(self): if self._age &gt;= 18: print('%s正在观看爱情动作片.' % self._name) else: print('%s只能观看《熊出没》.' % self._name)class Student(Person): \"\"\"学生\"\"\" def __init__(self, name, age, grade): super().__init__(name, age) self._grade = grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade = grade def study(self, course): print('%s的%s正在学习%s.' % (self._grade, self._name, course))class Teacher(Person): \"\"\"老师\"\"\" def __init__(self, name, age, title): super().__init__(name, age) self._title = title @property def title(self): return self._title @title.setter def title(self, title): self._title = title def teach(self, course): print('%s%s正在讲%s.' % (self._name, self._title, course))def main(): stu = Student('王大锤', 15, '初三') stu.study('数学') stu.watch_av() t = Teacher('骆昊', 38, '砖家') t.teach('Python程序设计') t.watch_av()if __name__ == '__main__': main() 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。 12345678910111213141516171819202122232425262728293031323334353637from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta): \"\"\"宠物\"\"\" def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): \"\"\"发出声音\"\"\" passclass Dog(Pet): \"\"\"狗\"\"\" def make_voice(self): print('%s: 汪汪汪...' % self._nickname)class Cat(Pet): \"\"\"猫\"\"\" def make_voice(self): print('%s: 喵...喵...' % self._nickname)def main(): pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')] for pet in pets: pet.make_voice()if __name__ == '__main__': main() 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。 vscode插件AI Doc write:ai帮你写注释只要选中函数代码，然后按一个快捷键就会自动生成该方法的注释，可用来生成函数文档， Sourcegraph你可以直接从 VS Code IDE 免费搜索数百万个开源存储库。从有用的代码示例中学习，搜索最佳实践，并从开源宇宙中数百万个存储库中重用代码。 Krinql如果你看不懂代码，可以让 Krinql 来回答，或者让它编写文档字符串： 进程和线程今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。 概念进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实，如下图所示。 当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。 Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。 Python中的多进程Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等。 下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。 123456789101112131415161718192021from random import randintfrom time import time, sleepdef download_task(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() download_task('Python从入门到住院.pdf') download_task('Peking Hot.avi') end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 下面是运行程序得到的一次运行结果。 12345开始下载Python从入门到住院.pdf...Python从入门到住院.pdf下载完成! 耗费了6秒开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒总共耗费了13.01秒. 从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。 12345678910111213141516171819202122232425262728from multiprocessing import Processfrom os import getpidfrom random import randintfrom time import time, sleepdef download_task(filename): print('启动下载进程，进程号[%d].' % getpid()) print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() p1 = Process(target=download_task, args=('Python从入门到住院.pdf', )) p1.start() p2 = Process(target=download_task, args=('Peking Hot.avi', )) p2.start() p1.join() p2.join() end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 在上面的代码中，我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。 1234567启动下载进程，进程号[1530].开始下载Python从入门到住院.pdf...启动下载进程，进程号[1531].开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒Python从入门到住院.pdf下载完成! 耗费了10秒总共耗费了10.01秒. 我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。 123456789101112131415161718192021from multiprocessing import Processfrom time import sleepcounter = 0def sub_task(string): global counter while counter &lt; 10: print(string, end='', flush=True) counter += 1 sleep(0.01) def main(): Process(target=sub_task, args=('Ping', )).start() Process(target=sub_task, args=('Pong', )).start()if __name__ == '__main__': main() 看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共享的队列，底层是通过管道和信号量（semaphore）机制来实现的，有兴趣的读者可以自己尝试一下。 Python中的多线程在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。 1234567891011121314151617181920212223242526from random import randintfrom threading import Threadfrom time import time, sleepdef download(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() t1 = Thread(target=download, args=('Python从入门到住院.pdf',)) t1.start() t2 = Thread(target=download, args=('Peking Hot.avi',)) t2.start() t1.join() t2.join() end = time() print('总共耗费了%.3f秒' % (end - start))if __name__ == '__main__': main() 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。 1234567891011121314151617181920212223242526272829303132from random import randintfrom threading import Threadfrom time import time, sleepclass DownloadTask(Thread): def __init__(self, filename): super().__init__() self._filename = filename def run(self): print('开始下载%s...' % self._filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (self._filename, time_to_download))def main(): start = time() t1 = DownloadTask('Python从入门到住院.pdf') t1.start() t2 = DownloadTask('Peking Hot.avi') t2.start() t1.join() t2.join() end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from time import sleepfrom threading import Threadclass Account(object): def __init__(self): self._balance = 0 def deposit(self, money): # 计算存款后的余额 new_balance = self._balance + money # 模拟受理存款业务需要0.01秒的时间 sleep(0.01) # 修改账户余额 self._balance = new_balance @property def balance(self): return self._balanceclass AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money)def main(): account = Account() threads = [] # 创建100个存款的线程向同一个账户中存钱 for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() # 等所有存款的线程都执行完毕 for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__': main() 运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from time import sleepfrom threading import Thread, Lockclass Account(object): def __init__(self): self._balance = 0 self._lock = Lock() def deposit(self, money): # 先获取锁才能执行后续的代码 self._lock.acquire() try: new_balance = self._balance + money sleep(0.01) self._balance = new_balance finally: # 在finally中执行释放锁的操作保证正常异常锁都能释放 self._lock.release() @property def balance(self): return self._balanceclass AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money)def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__': main() 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。 多进程还是多线程无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。 但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。 是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到过Python中有嵌入C/C++代码的机制。 除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。 说明： 上面的内容和例子来自于廖雪峰官方网站的《Python教程》，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。 单线程+异步I/O现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下并发编程的一种流行方案。 在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，在后续的课程中会进行讲解。 应用案例例子1：将耗时间的任务放到线程中以获得更好的用户体验。如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。 123456789101112131415161718192021222324252627282930313233import timeimport tkinterimport tkinter.messageboxdef download(): # 模拟下载任务需要花费10秒钟时间 time.sleep(10) tkinter.messagebox.showinfo('提示', '下载完成!')def show_about(): tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)')def main(): top = tkinter.Tk() top.title('单线程') top.geometry('200x150') top.wm_attributes('-topmost', True) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text='下载', command=download) button1.pack(side='left') button2 = tkinter.Button(panel, text='关于', command=show_about) button2.pack(side='right') panel.pack(side='bottom') tkinter.mainloop()if __name__ == '__main__': main() 如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243import timeimport tkinterimport tkinter.messageboxfrom threading import Threaddef main(): class DownloadTaskHandler(Thread): def run(self): time.sleep(10) tkinter.messagebox.showinfo('提示', '下载完成!') # 启用下载按钮 button1.config(state=tkinter.NORMAL) def download(): # 禁用下载按钮 button1.config(state=tkinter.DISABLED) # 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行) # 在线程中处理耗时间的下载任务 DownloadTaskHandler(daemon=True).start() def show_about(): tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)') top = tkinter.Tk() top.title('单线程') top.geometry('200x150') top.wm_attributes('-topmost', 1) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text='下载', command=download) button1.pack(side='left') button2 = tkinter.Button(panel, text='关于', command=show_about) button2.pack(side='right') panel.pack(side='bottom') tkinter.mainloop()if __name__ == '__main__': main() 例子2：使用多进程对复杂任务进行“分而治之”。我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。 12345678910111213141516from time import timedef main(): total = 0 number_list = [x for x in range(1, 100000001)] start = time() for number in number_list: total += number print(total) end = time() print('Execution time: %.3fs' % (end - start))if __name__ == '__main__': main() 在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839from multiprocessing import Process, Queuefrom random import randintfrom time import timedef task_handler(curr_list, result_queue): total = 0 for number in curr_list: total += number result_queue.put(total)def main(): processes = [] number_list = [x for x in range(1, 100000001)] result_queue = Queue() index = 0 # 启动8个进程将数据切片后进行运算 for _ in range(8): p = Process(target=task_handler, args=(number_list[index:index + 12500000], result_queue)) index += 12500000 processes.append(p) p.start() # 开始记录所有进程执行完成花费的时间 start = time() for p in processes: p.join() # 合并执行结果 total = 0 while not result_queue.empty(): total += result_queue.get() print(total) end = time() print('Execution time: ', (end - start), 's', sep='')if __name__ == '__main__': main() 比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过multiprocessing.managers模块中提供的管理器将Queue对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。 网络编程入门计算机网络基础计算机网络是独立自主的计算机互联而成的系统的总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。今天计算机网络中的设备和计算机网络的用户已经多得不可计数，而计算机网络也可以称得上是一个“复杂巨系统”，对于这样的系统，我们不可能用一两篇文章把它讲清楚，有兴趣的读者可以自行阅读Andrew S.Tanenbaum老师的经典之作《计算机网络》或Kurose和Ross老师合著的《计算机网络:自顶向下方法》来了解计算机网络的相关知识。 TCP/IP模型实现网络通信的基础是网络通信协议，这些协议通常是由互联网工程任务组 （IETF）制定的。所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层，如下图所示。 IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个局域网（LAN）中的内部IP地址，通过网络地址转换（NAT）服务我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“路由器”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。 TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情： 数据不传丢不传错（利用握手、校验和重传机制可以实现）。 流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。 拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。 网络应用模式 C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。 去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。 基于HTTP协议的网络资源访问HTTP（超文本传输协议）HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对HTTP的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是万维网数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，通过HTTP或者HTTPS（超文本传输安全协议）请求的资源由URI（统一资源标识符）来标识。关于HTTP的更多内容，我们推荐阅读阮一峰老师的《HTTP 协议入门》，简单的说，通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。 JSON格式JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和XML一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。 XML的例子： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;message&gt; &lt;from&gt;Alice&lt;/from&gt; &lt;to&gt;Bob&lt;/to&gt; &lt;content&gt;Will you marry me?&lt;/content&gt;&lt;/message&gt; JSON的例子： 12345{ \"from\": \"Alice\", \"to\": \"Bob\", \"content\": \"Will you marry me?\"} requests库requests是一个基于HTTP协议来使用网络的第三库，其官方网站有这样的一句介绍它的话：“Requests是唯一的一个非转基因的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及“重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。前面的文章中我们已经使用过这个库，下面我们还是通过requests来实现一个访问网络数据接口并从中获取美女图片下载链接然后下载美女图片到本地的例子程序，程序中使用了天行数据提供的网络API。 我们可以先通过pip安装requests及其依赖库。 1pip install requests 如果使用PyCharm作为开发工具，可以直接在代码中书写import requests，然后通过代码修复功能来自动下载安装requests。 12345678910111213141516171819202122232425262728293031323334353637from time import timefrom threading import Threadimport requests# 继承Thread类创建自定义的线程类class DownloadHanlder(Thread): def __init__(self, url): super().__init__() self.url = url def run(self): filename = self.url[self.url.rfind('/') + 1:] resp = requests.get(self.url) with open('/Users/Hao/' + filename, 'wb') as f: f.write(resp.content)def main(): # 通过requests模块的get函数获取网络资源 # 下面的代码中使用了天行数据接口提供的网络API # 要使用该数据接口需要在天行数据的网站上注册 # 然后用自己的Key替换掉下面代码的中APIKey即可 resp = requests.get( 'http://api.tianapi.com/meinv/?key=APIKey&amp;num=10') # 将服务器返回的JSON格式的数据解析为字典 data_model = resp.json() for mm_dict in data_model['newslist']: url = mm_dict['picUrl'] # 通过多线程的方式实现图片下载 DownloadHanlder(url).start()if __name__ == '__main__': main() 基于传输层协议的套接字编程套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。 TCP套接字所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。 下面的代码实现了一个提供时间日期的服务器。 12345678910111213141516171819202122232425262728293031323334from socket import socket, SOCK_STREAM, AF_INETfrom datetime import datetimedef main(): # 1.创建套接字对象并指定使用哪种传输服务 # family=AF_INET - IPv4地址 # family=AF_INET6 - IPv6地址 # type=SOCK_STREAM - TCP套接字 # type=SOCK_DGRAM - UDP套接字 # type=SOCK_RAW - 原始套接字 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(端口用于区分不同的服务) # 同一时间在同一个端口上只能绑定一个服务否则报错 server.bind(('192.168.1.2', 6789)) # 3.开启监听 - 监听客户端连接到服务器 # 参数512可以理解为连接队列的大小 server.listen(512) print('服务器启动开始监听...') while True: # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行 # accept方法返回一个元组其中的第一个元素是客户端对象 # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成) client, addr = server.accept() print(str(addr) + '连接到了服务器.') # 5.发送数据 client.send(str(datetime.now()).encode('utf-8')) # 6.断开连接 client.close()if __name__ == '__main__': main() 运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。 1telnet 192.168.1.2 6789 当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。 123456789101112131415from socket import socketdef main(): # 1.创建套接字对象默认使用IPv4和TCP协议 client = socket() # 2.连接到服务器(需要指定IP地址和端口) client.connect(('192.168.1.2', 6789)) # 3.从服务器接收数据 print(client.recv(1024).decode('utf-8')) client.close()if __name__ == '__main__': main() 需要注意的是，上面的服务器并没有使用多线程或者异步I/O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。 服务器端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from socket import socket, SOCK_STREAM, AF_INETfrom base64 import b64encodefrom json import dumpsfrom threading import Threaddef main(): # 自定义线程类 class FileTransferHandler(Thread): def __init__(self, cclient): super().__init__() self.cclient = cclient def run(self): my_dict = {} my_dict['filename'] = 'guido.jpg' # JSON是纯文本不能携带二进制数据 # 所以图片的二进制数据要处理成base64编码 my_dict['filedata'] = data # 通过dumps函数将字典处理成JSON字符串 json_str = dumps(my_dict) # 发送JSON字符串 self.cclient.send(json_str.encode('utf-8')) self.cclient.close() # 1.创建套接字对象并指定使用哪种传输服务 server = socket() # 2.绑定IP地址和端口(区分不同的服务) server.bind(('192.168.1.2', 5566)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print('服务器启动开始监听...') with open('guido.jpg', 'rb') as f: # 将二进制数据处理成base64再解码成字符串 data = b64encode(f.read()).decode('utf-8') while True: client, addr = server.accept() # 启动一个线程来处理客户端的请求 FileTransferHandler(client).start()if __name__ == '__main__': main() 客户端代码： 1234567891011121314151617181920212223242526272829from socket import socketfrom json import loadsfrom base64 import b64decodedef main(): client = socket() client.connect(('192.168.1.2', 5566)) # 定义一个保存二进制数据的对象 in_data = bytes() # 由于不知道服务器发送的数据有多大每次接收1024字节 data = client.recv(1024) while data: # 将收到的数据拼接起来 in_data += data data = client.recv(1024) # 将收到的二进制数据解码成JSON字符串并转换成字典 # loads函数的作用就是将JSON字符串转成字典对象 my_dict = loads(in_data.decode('utf-8')) filename = my_dict['filename'] filedata = my_dict['filedata'].encode('utf-8') with open('/Users/Hao/' + filename, 'wb') as f: # 将base64格式的数据解码成二进制数据并写入文件 f.write(b64decode(filedata)) print('图片已保存.')if __name__ == '__main__': main() 在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从000000到111111的64种状态。维基百科上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。 说明： 上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。 UDP套接字传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。 网络应用开发发送电子邮件在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。 就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。 下面的代码演示了如何在Python发送邮件。 12345678910111213141516171819202122from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextdef main(): # 请自行修改下面的邮件发送者和接收者 sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com', 'uvwxyz@126.com'] message = MIMEText('用Python发送邮件的示例代码.', 'plain', 'utf-8') message['From'] = Header('王大锤', 'utf-8') message['To'] = Header('骆昊', 'utf-8') message['Subject'] = Header('示例代码实验邮件', 'utf-8') smtper = SMTP('smtp.126.com') # 请自行修改下面的登录口令 smtper.login(sender, 'secretpass') smtper.sendmail(sender, receivers, message.as_string()) print('邮件发送完成!')if __name__ == '__main__': main() 如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartimport urllibdef main(): # 创建一个带附件的邮件消息对象 message = MIMEMultipart() # 创建文本内容 text_content = MIMEText('附件中有本月数据请查收', 'plain', 'utf-8') message['Subject'] = Header('本月数据', 'utf-8') # 将文本内容添加到邮件消息对象中 message.attach(text_content) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/hello.txt', 'rb') as f: txt = MIMEText(f.read(), 'base64', 'utf-8') txt['Content-Type'] = 'text/plain' txt['Content-Disposition'] = 'attachment; filename=hello.txt' message.attach(txt) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/汇总数据.xlsx', 'rb') as f: xls = MIMEText(f.read(), 'base64', 'utf-8') xls['Content-Type'] = 'application/vnd.ms-excel' xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx' message.attach(xls) # 创建SMTP对象 smtper = SMTP('smtp.126.com') # 开启安全连接 # smtper.starttls() sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com'] # 登录到SMTP服务器 # 请注意此处不是使用密码而是邮件客户端授权码进行登录 # 对此有疑问的读者可以联系自己使用的邮件服务器客服 smtper.login(sender, 'secretpass') # 发送邮件 smtper.sendmail(sender, receivers, message.as_string()) # 与邮件服务器断开连接 smtper.quit() print('发送完成!')if __name__ == '__main__': main() 发送短信发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了互亿无线短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。 1234567891011121314151617181920212223import urllib.parseimport http.clientimport jsondef main(): host = \"106.ihuyi.com\" sms_send_uri = \"/webservice/sms.php?method=Submit\" # 下面的参数需要填入自己注册的账号和对应的密码 params = urllib.parse.urlencode({'account': '你自己的账号', 'password' : '你自己的密码', 'content': '您的验证码是：147258。请不要把验证码泄露给其他人。', 'mobile': '接收者的手机号', 'format':'json' }) print(params) headers = {'Content-type': 'application/x-www-form-urlencoded', 'Accept': 'text/plain'} conn = http.client.HTTPConnection(host, port=80, timeout=30) conn.request('POST', sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read() jsonstr = response_str.decode('utf-8') print(json.loads(jsonstr)) conn.close()if __name__ == '__main__': main() 图像和办公文档处理用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支持这些操作的模块，但我们可以通过Python生态圈中的第三方模块来完成这些操作。 操作图像计算机图像相关知识 颜色。如果你有使用颜料画画的经历，那么一定知道混合红、黄、蓝三种颜料可以得到其他的颜色，事实上这三种颜色就是被我们称为美术三原色的东西，它们是不能再分解的基本颜色。在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色，所以我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。 名称 RGBA值 名称 RGBA值 White (255, 255, 255, 255) Red (255, 0, 0, 255) Green (0, 255, 0, 255) Blue (0, 0, 255, 255) Gray (128, 128, 128, 255) Yellow (255, 255, 0, 255) Black (0, 0, 0, 255) Purple (128, 0, 128, 255) 像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。 用Pillow操作图像Pillow是由从著名的Python图像处理库PIL发展出来的一个分支，通过Pillow可以实现图像压缩和图像处理等各种操作。可以使用下面的命令来安装Pillow。 1pip install pillow Pillow中最为重要的是Image类，读取和处理图像都要通过这个类来完成。 123456&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt;&gt;&gt;&gt; image = Image.open('./res/guido.jpg')&gt;&gt;&gt; image.format, image.size, image.mode('JPEG', (500, 750), 'RGB')&gt;&gt;&gt; image.show() 剪裁图像 123&gt;&gt;&gt; image = Image.open('./res/guido.jpg')&gt;&gt;&gt; rect = 80, 20, 310, 360&gt;&gt;&gt; image.crop(rect).show() 生成缩略图 1234&gt;&gt;&gt; image = Image.open('./res/guido.jpg')&gt;&gt;&gt; size = 128, 128&gt;&gt;&gt; image.thumbnail(size)&gt;&gt;&gt; image.show() 缩放和黏贴图像 123456&gt;&gt;&gt; image1 = Image.open('./res/luohao.png')&gt;&gt;&gt; image2 = Image.open('./res/guido.jpg')&gt;&gt;&gt; rect = 80, 20, 310, 360&gt;&gt;&gt; guido_head = image2.crop(rect)&gt;&gt;&gt; width, height = guido_head.size&gt;&gt;&gt; image1.paste(guido_head.resize((int(width / 1.5), int(height / 1.5))), (172, 40)) 旋转和翻转 123&gt;&gt;&gt; image = Image.open('./res/guido.png')&gt;&gt;&gt; image.rotate(180).show()&gt;&gt;&gt; image.transpose(Image.FLIP_LEFT_RIGHT).show() 操作像素 123456&gt;&gt;&gt; image = Image.open('./res/guido.jpg')&gt;&gt;&gt; for x in range(80, 310):... for y in range(20, 360):... image.putpixel((x, y), (128, 128, 128))... &gt;&gt;&gt; image.show() 滤镜效果 1234&gt;&gt;&gt; from PIL import Image, ImageFilter&gt;&gt;&gt;&gt;&gt;&gt; image = Image.open('./res/guido.jpg')&gt;&gt;&gt; image.filter(ImageFilter.CONTOUR).show() 处理Excel电子表格Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，由于微软从Office 2007开始使用了新的文件格式，这使得Office Excel和LibreOffice Calc、OpenOffice Calc是完全兼容的，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。 123456789101112import datetimefrom openpyxl import Workbookwb = Workbook()ws = wb.activews['A1'] = 42ws.append([1, 2, 3])ws['A2'] = datetime.datetime.now()wb.save(\"sample.xlsx\") 处理Word文档利用python-docx模块，Python可以创建和修改Word文档，当然这里的Word文档不仅仅是指通过微软的Office软件创建的扩展名为docx的文档，LibreOffice Writer和OpenOffice Writer都是免费的字处理软件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344from docx import Documentfrom docx.shared import Inchesdocument = Document()document.add_heading('Document Title', 0)p = document.add_paragraph('A plain paragraph having some ')p.add_run('bold').bold = Truep.add_run(' and some ')p.add_run('italic.').italic = Truedocument.add_heading('Heading, level 1', level=1)document.add_paragraph('Intense quote', style='Intense Quote')document.add_paragraph( 'first item in unordered list', style='List Bullet')document.add_paragraph( 'first item in ordered list', style='List Number')document.add_picture('monty-truth.png', width=Inches(1.25))records = ( (3, '101', 'Spam'), (7, '422', 'Eggs'), (4, '631', 'Spam, spam, eggs, and spam'))table = document.add_table(rows=1, cols=3)hdr_cells = table.rows[0].cellshdr_cells[0].text = 'Qty'hdr_cells[1].text = 'Id'hdr_cells[2].text = 'Desc'for qty, id, desc in records: row_cells = table.add_row().cells row_cells[0].text = str(qty) row_cells[1].text = id row_cells[2].text = descdocument.add_page_break()document.save('demo.docx') Python正则表达式最强整理正则表达式相关知识在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。 我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。 关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫《正则表达式30分钟入门教程》，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} | 分支 foo|bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?&lt;name&gt;exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\\bdanc)\\w+\\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.*ba.*?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 说明： 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\\进行转义处理，例如想匹配小数点可以写成\\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\\(和\\)，否则圆括号被视为正则表达式中的分组。 Python对正则表达式的支持Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 说明： 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。 下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。 例子例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。12345678910111213141516171819202122232425\"\"\"验证输入用户名和QQ号是否有效并给出对应的提示信息要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0\"\"\"import redef main(): username = input('请输入用户名: ') qq = input('请输入QQ号: ') # match函数的第一个参数是正则表达式字符串或正则表达式对象 # 第二个参数是要跟正则表达式做匹配的字符串对象 m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username) if not m1: print('请输入有效的用户名.') m2 = re.match(r'^[1-9]\\d{4,11}$', qq) if not m2: print('请输入有效的QQ号.') if m1 and m2: print('你输入的信息是有效的!')if __name__ == '__main__': main() 提示： 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\\\，例如表示数字的\\d得书写成\\\\d，这样不仅写起来不方便，阅读的时候也会很吃力。 例子2：从一段文字中提取出国内手机号码。下面这张图是截止到2017年底，国内三家运营商推出的手机号段。 123456789101112131415161718192021222324252627import redef main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern = re.compile(r'(?&lt;=\\D)1[34578]\\d{9}(?=\\D)') sentence = ''' 重要的事情说8130123456789遍，我的手机号是13512346789这个靓号， 不是15600998765，也是110或119，王大锤的手机号才是15600998765。 ''' # 查找所有匹配并保存到一个列表中 mylist = re.findall(pattern, sentence) print(mylist) print('--------华丽的分隔线--------') # 通过迭代器取出匹配对象并获得匹配的内容 for temp in pattern.finditer(sentence): print(temp.group()) print('--------华丽的分隔线--------') # 通过search函数指定搜索位置找出所有匹配 m = pattern.search(sentence) while m: print(m.group()) m = pattern.search(sentence, m.end())if __name__ == '__main__': main() 说明： 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?&lt;=\\D)(1[38]\\d{9}|14[57]\\d{8}|15[0-35-9]\\d{8}|17[678]\\d{8})(?=\\D)，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。 例子3：替换字符串中的不良内容123456789101112import redef main(): sentence = '你丫是傻叉吗? 我操你大爷的. Fuck you.' purified = re.sub('[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔', '*', sentence, flags=re.IGNORECASE) print(purified) # 你丫是*吗? 我*你大爷的. * you.if __name__ == '__main__': main() 说明： re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。 例子4：拆分长字符串12345678910111213import redef main(): poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。' sentence_list = re.split(r'[，。, .]', poem) while '' in sentence_list: sentence_list.remove('') print(sentence_list) # ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡']if __name__ == '__main__': main() 后话如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择Beautiful Soup或Lxml来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍。 一、校验数字的表达式数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d*[1-9]\\d*))|0?.0+|0$ 正浮点数：^[1-9]\\d.\\d|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d.\\d|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0)$ 二、校验字符的表达式汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20} 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\"等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有的字符[^\\x22]+其它： .*匹配除&nbsp;\\n&nbsp;以外的任何字符。/[\\u4E00-\\u9FA5]/&nbsp;汉字/[\\uFF00-\\uFFFF]/&nbsp;全角符号/[\\u0000-\\u00FF]/&nbsp;半角符号 三、特殊需求表达式Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式：1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3}))(.[0-9]{1,2})?$（搜索公众号Java后端，回复“2021”，送你一份Java面试题宝典）备注：这就是最终结果了,别忘了+可以用替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff]&nbsp;(包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r&nbsp;(可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.*? /&gt;&nbsp;(网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$)&nbsp;(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,}&nbsp;(腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d)&nbsp;(中国邮政编码为6位数字) IP地址：\\d+.\\d+.\\d+.\\d+&nbsp;(提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) IP-v4地址：\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b&nbsp;(提取IP地址时有用) 校验IP-v6地址:(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 子网掩码：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 校验日期:^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。) 抽取注释： 查找CSS属性:^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1} 提取页面超链接:(&lt;a\\s*(?!.\\brel=)[^&gt;])(href=”https?:\\/\\/)((?!(?:(?:www\\.)?’.implode(‘|(?:www\\.)?’, $follow_list).’))[^” rel=”external nofollow” ]+)”((?!.\\brel=)[^&gt;])(?:[^&gt;]*)&gt; 提取网页图片:\\&lt; [img][^\\\\&gt;][src] *= [\\“\\‘]{0,1}([^\\“\\‘\\ &gt;]) 提取网页颜色代码:^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 文件扩展名效验:^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)[^\\/:?”&lt;&gt;|]+\\.txt(l)?$ 判断IE版本：^.*MSIE 5-8?(?!.Trident\\/[5-9]\\.0).$","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/tags/python/"}]},{"title":"AutoJS","slug":"AutoJS","date":"2022-01-08T09:17:39.000Z","updated":"2022-01-08T09:17:39.000Z","comments":true,"path":"2022/010827358.html","link":"","permalink":"https://wenkexia.github.io/2022/010827358.html","excerpt":"","text":"小技巧快捷打开无障碍，长按两个音量键三秒 如何打开控制台依次点击 帮助—–切换开发者工具——console 问题查找控件存不存在使用exists ()。一般情况下Autojs生成的代码是：if (text(“刷视频赚”).exists()) {}，不建议这样写，有很多时候找不到或者是有多个文字一样的内容故：let earnVideo= className(“android.widget.TextView”).text(“刷视频赚”).findOnce();这样写准确率更高。 为什么有时候launchApp(‘应用名’);会失效第一,这是因为你手机存在同名软件.找不到你想要的app，要使用launch(‘应用包名’)。第二,是因为你没有给软件(后台弹出界面)权限 auto.waitFor();语句增加是非常必要的这个在你没有无障碍时候会提示你无障碍模式的开启。并且开启之后,会接着继续运行. AutoJs创建项目后打包成Apk后Apk无法运行。 AutoJs单文件打包成Apk说是风险Apk。这个问题现在已经比较好解决了.就是使用AUTO.JS Pro版本即可. https://mp.weixin.qq.com/s/nUgyBkn9kZYamnRuSkzMlg 介绍文档 Appium 和 Airtest 编写的自动化脚本都依赖于 PC 端运行，没有办法直接运行在移动端；无障碍服务需要单独创建一个 Android 项目，没有完整的使用文档，使用起来有一定的门槛 AutoJS 它通过编写 JavaScript 脚本，结合系统的「 无障碍服务 」对 App 进行自动化操作 脚本文件体积小，可以打包成 APK 直接安装 拥有丰富的 UI 组件用于构建 GUI 界面 非 Root 设备也能完成自动化操作，可以摆脱 PC 直接运行 提供多种元素定位方式，可以适配各种机型 官方文档非常详细，学习成本低 vscode插件Auto.js-VSCodeExt Auto.js-VSCodeExt-Fixed对插件 Auto.js-VSCodeExt 进行了部分优化 Autojs Clipboard同步手机剪贴板到电脑剪贴板 然后，使用 VS Code 快捷键「 Ctrl/Command + Shift + P 」，选择「 Auto.js:Start Server 」开启 AutoJS 服务 在同一wifi下无法连接，手机开热点给电脑，即可连接 scrcpy投屏Github地址 使用手机数据线连接电脑后，开启usb调试，自动连接 鼠标右键是返回 要想卸载scrcpy,先在目录下进入cmd,输入adb kill-server,再删除整个scrcpy文件即可 adb功能异常，重启adb（1）把adb服务杀死：adb kill-server（2）重启adb服务：adb reconnect autojs提取软件自带例子通过mt管理器点击autojspro的安装包，然后点击查看，依次打开assets/sample/中文，这就是例子文件。然后长按文件夹解压到任意目录 如果没有mt管理器，可以直接将autojspro.apk的后缀改成.zip,当成压缩包来提取文件。 推送信息到微信12345678910111213141516171819// 通过息知推送信息到微信// https://xz.qqoq.net/#/index// 发送消息支持get,post两种方式// {key}填的是你在息知控制台的单点推送中获取到的let url = \"https://xizhi.qqoq.net/{key}.send?title=标题&amp;content=测试\";let r = http.get(url);log(r.body.string());// let url = \"https://xizhi.qqoq.net/{key}.send\";// let r = http.postJson(url, {// title: \"this is title\",// content: \"this is content\",// });// log(r.body.string()); 基于控件的操作UiSelector（选择器）用于通过各种条件选取屏幕上的控件，再对这些控件进行点击、长按等动作 通常用一个唯一的属性来定位一个控件 UiObjectUiObject表示一个控件，可以通过这个对象获取到控件的属性，也可以对控件进行点击、长按等操作。 获取一个UiObject通常通过选择器的findOne(), findOnce()等函数，也可以通过UiCollection来获取，或者通过UiObject.child(), UiObject.parent()等函数来获取一个控件的子控件或父控件。 1text(\"微信\").findOne() //返回的时一个控件对象，想要操作这个控件，其属性必须为true bounds()返回 Rect返回控件在屏幕上的范围，其值是一个Rect对象。 RectUiObject.bounds(), UiObject.boundsInParent()返回的对象。表示一个长方形(范围)。 Rect.centerX()返回 {number}长方形中点x坐标。 Rect.centerY()返回 {number}长方形中点y坐标。 控件属性className 类名。类名表示一个控件的类型，例如文本控件为”android.widget.TextView”, 图片控件为”android.widget.ImageView”等。 packageName 包名。包名表示控件所在的应用包名，例如QQ界面的控件的包名为”com.tencent.mobileqq”。 bounds 控件在屏幕上的范围。drawingOrder 控件在父控件的绘制顺序。indexInParent 控件在父控件的位置。clickable 控件是否可点击。longClickable 控件是否可长按。checkable 控件是否可勾选。checked 控件是否可已勾选。scrollable 控件是否可滑动。selected 控件是否已选择。editable 控件是否可编辑。visibleToUser 控件是否可见。enabled 控件是否已启用。depth 控件的布局深度。 对选取的控件进行操作click(text[, i])text {string} 要点击的文本i {number} 如果相同的文本在屏幕中出现多次，则i表示要点击第几个文本, i从0开始计算 click() 点击。点击一个控件，前提是这个控件的clickable属性为truelongClick() 长按。长按一个控件，前提是这个控件的longClickable属性为truesetText() 设置文本，用于编辑框控件设置文本。scrollForward();scrollBackward() 滑动。滑动一个控件(列表等), 前提是这个控件的scrollable属性为trueexits() 判断控件是否存在waitFor() 等待控件出现 //确保无障碍服务已启用。auto.waitFor() //直接提示你无障碍模式的开启。 click(text[, i])text {string} 要点击的文本i {number} 如果相同的文本在屏幕中出现多次，则i表示要点击第几个文本, i从0开始计算while(!click(\"扫一扫\")); 免root手机的三种模拟滑动方式开发者模式的指针位置P: X / Y P就是 pointers ; x 是 current number pointers, y 是 max number pointers ，这些都是指在一个完整gesture中的。也就是，当同时用三手指触摸时x=y=3，而当只抬起一根手指时，当前屏幕上只有两根手指了，但是整个手势事件中最大pointers数是3，所以，x=2，y=3。显示为P:2/3 X:640.9 Y:1250.9 X是active pointer的X轴坐标；Y是active pointer的Y轴坐标。当多点触摸时只有一个pointer是激活pointer（ActivePointer），所以X，Y表示的就是这个ActivePointer的X和Y轴坐标。dX和dY分别代表整个手势结束后活动点（ActivePointer）在X轴和Y轴方向上起始点到终止点的差值，其中X轴上从左到右为正值，Y轴上从上到下是正值，否则为负值。 swipe(x1, y1, x2, y2, duration)duration {number} 滑动时长，单位毫秒模拟从坐标(x1, y1)滑动到坐标(x2, y2)，并返回是否成功。只有滑动操作执行完成时脚本才会继续执行。 gesture(duration, [x1, y1], [x2, y2], …) duration {number} 手势的时长 [x, y] … 手势滑动路径的一系列坐标 模拟手势操作。例如gesture(1000, [0, 0], [500, 500], [500, 1000])为模拟一个从(0, 0)到(500, 500)到(500, 100)的手势操作，时长为2秒。 gestures([delay1, duration1, [x1, y1], [x2, y2], …], [delay2, duration2, [x3, y3], [x4, y4], …], …)同时模拟多个手势。每个手势的参数为[delay, duration, 坐标], delay为延迟多久(毫秒)才执行该手势；duration为手势执行时长；坐标为手势经过的点的坐标。 其中delay参数可以省略，默认为0。 例如手指捏合： 12gestures([0, 500, [800, 300], [500, 1000]], [0, 500, [300, 1500], [500, 1000]]); 调用java文件怎么用aj调用java文件，把Java打包成dex或者jar然后runtime.loadDax 踩过的坑如果有界面，那么监听通知需要放在线程里。webview 注入js的js文件需要改后缀，如果还是js,会被加密导致无法使用webview 内页面引用静态文件可以使用相对路径如果多次调用 even.on，event.emit 会触发多次。可以用 even.removeAllListeners进行清除。console.show 调用时范围只是当前线程。不要在UI线程内死循环，要重新开启一个线程，不然会卡死无障碍服务权限申请可以使用auto,直接跳转到设置页。通知使用服务第一次调用后会提示一次之后，如果没有给予权限。大概率不再弹窗，并且不会报错。如果一直没有给权限，而且无法弹窗需要引导用户手动开启，并重启脚本。 支付宝/微信/其他软件https://www.jianshu.com/p/2c7f2c2cbf78在使用autojs时，遇到支付宝和微信以及一些安全意识较强的平台，很难获取到其页面的控件，无论你是使用autojs自带的控件分析或是Android studio的uiautomatorviewer.bat来分析它们的页面控件，都会分析到。但是你在获取的时侯就会发现根本获取不到，能看到却拿不到的痛苦想必是所有autojs的使用者都非常懊恼的一件事情吧。 原因支付宝和微信都把它们的控件藏起来了，可能是封装成某个类型，那个类型的输出就是空行。 我的方法是获取其控件后在其末尾加了个string，使得整个内容强转成string。 12var meId2 = id(\"XXX\").find()+\"\";//找到id为XXX的控件，然后加上空字符串//整个类型现在变成string，现在就可以用字符串截取的方式来获取控件的信息了。 //pro9基本无法使用，低版本可以while(!click(“智慧广工商”)); click(“智慧广工商”) 提示获取不到设备信息2.使用device.getAndroidId()代替device.getIMEI().这是因为安卓10以上限制了获取imei码","categories":[{"name":"自动化","slug":"自动化","permalink":"https://wenkexia.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"autojs","slug":"autojs","permalink":"https://wenkexia.github.io/tags/autojs/"}]},{"title":"鸿蒙开发","slug":"鸿蒙开发","date":"2022-01-08T07:37:55.000Z","updated":"2022-01-08T07:37:55.000Z","comments":true,"path":"2022/010839456.html","link":"","permalink":"https://wenkexia.github.io/2022/010839456.html","excerpt":"","text":"HarmonyOS概述HarmonyOS是一款面向万物互联时代的、全新的分布式操作系统。在传统的单设备系统能力基础上，HarmonyOS提出了基于同一套系统能力、适配多种终端形态的分布式理念，能够支持手机、平板、智能穿戴、智慧屏、车机等多种终端设备，提供全场景（移动办公、运动健康、社交通信、媒体娱乐等）业务能力。 HarmonyOS有三大特征：硬件互助，资源共享分布式软总线分布式软总线是手机、平板、智能穿戴、智慧屏、车机等分布式设备的通信基座，为设备之间的互联互通提供了统一的分布式通信能力， 典型应用场景举例： 智能家居场景：在烹饪时，手机可以通过碰一碰和烤箱连接，并将自动按照菜谱设置烹调参数，控制烤箱来制作菜肴。与此类似，料理机、油烟机、空气净化器、空调、灯、窗帘等都可以在手机端显示并通过手机控制。设备之间即连即用，无需繁琐的配置。多屏联动课堂：老师通过智慧屏授课，与学生开展互动，营造课堂氛围；学生通过平板完成课程学习和随堂问答。统一、全连接的逻辑网络确保了传输通道的高带宽、低时延、高可靠。 分布式设备虚拟化分布式设备虚拟化平台可以实现不同设备的资源融合、设备管理、数据处理，多种设备共同形成一个超级虚拟终端。针对不同类型的任务，为用户匹配并选择能力合适的执行硬件，让业务连续地在不同设备间流转，充分发挥不同设备的能力优势 典型应用场景举例： 视频通话场景：在做家务时接听视频电话，可以将手机与智慧屏连接，并将智慧屏的屏幕、摄像头与音箱虚拟化为本地资源，替代手机自身的屏幕、摄像头、听筒与扬声器，实现一边做家务、一边通过智慧屏和音箱来视频通话。游戏场景：在智慧屏上玩游戏时，可以将手机虚拟化为遥控器，借助手机的重力传感器、加速度传感器、触控能力，为玩家提供更便捷、更流畅的游戏体验。 分布式数据管理分布式数据管理基于分布式软总线的能力，实现应用程序数据和用户数据的分布式管理。用户数据不再与单一物理设备绑定，业务逻辑与数据存储分离，跨设备的数据处理如同本地数据处理一样方便快捷，让开发者能够轻松实现全场景、多设备下的数据存储、共享和访问，为打造一致、流畅的用户体验创造了基础条件。分布式数据管理示意图见图3。 典型应用场景举例： 协同办公场景：将手机上的文档投屏到智慧屏，在智慧屏上对文档执行翻页、缩放、涂鸦等操作，文档的最新状态可以在手机上同步显示。照片分享场景：出游时，使用手机拍摄的照片，可以在登录了同帐号的其他设备，比如平板上更方便地浏览、收藏、保存或编辑，也可以通过家中的智慧屏上同家人一起分享记录下的快乐瞬间。 分布式任务调度分布式任务调度基于分布式软总线、分布式数据管理、分布式Profile等技术特性，构建统一的分布式服务管理（发现、同步、注册、调用）机制，支持对跨设备的应用进行远程启动、远程调用、远程连接以及迁移等操作，能够根据不同设备的能力、位置、业务运行状态、资源使用情况，以及用户的习惯和意图，选择合适的设备运行分布式任务。 图4以应用迁移为例，简要地展示了分布式任务调度能力。 典型应用场景举例： 导航场景：如果用户驾车出行，上车前，在手机上规划好导航路线；上车后，导航自动迁移到车机和车载音箱；下车后，导航自动迁移回手机。如果用户骑车出行，在手机上规划好导航路线，骑行时手表可以接续导航。外卖场景：在手机上点外卖后，可以将订单信息迁移到手表上，随时查看外卖的配送状态。 一次开发，多端部署HarmonyOS通过组件化和小型化等设计方法，支持多种终端设备按需弹性部署，能够适配不同类别的硬件资源和功能需求。支撑通过编译链关系去自动生成组件化的依赖关系，形成组件树依赖图，支撑产品系统的便捷开发，降低硬件设备的开发门槛。 支持各组件的选择（组件可有可无）：根据硬件的形态和需求，可以选择所需的组件。支持组件内功能集的配置（组件可大可小）：根据硬件的资源情况和功能需求，可以选择配置组件中的功能集。例如，选择配置图形框架组件中的部分控件。支持组件间依赖的关联（平台可大可小）：根据编译链关系，可以自动生成组件化的依赖关系。例如，选择图形框架组件，将会自动选择依赖的图形引擎组件等。 统一OS，弹性部署对设备开发者而言，HarmonyOS采用了组件化的设计方案，可根据设备的资源能力和业务特征灵活裁剪，满足不同形态终端设备对操作系统的要求。 技术架构HarmonyOS整体遵从分层设计，从下向上依次为：内核层、系统服务层、框架层和应用层。系统功能按照“系统 &gt; 子系统 &gt; 功能/模块”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的子系统或功能/模块。 内核层内核子系统：HarmonyOS采用多内核设计，支持针对不同资源受限设备选用适合的OS内核。内核抽象层（KAL，Kernel Abstract Layer）通过屏蔽多内核差异，对上层提供基础的内核能力，包括进程/线程管理、内存管理、文件系统、网络管理和外设管理等。驱动子系统：硬件驱动框架（HDF）是HarmonyOS硬件生态开放的基础，提供统一外设访问能力和驱动开发、管理框架。 系统服务层系统服务层是HarmonyOS的核心能力集合，通过框架层对应用程序提供服务。该层包含以下几个部分： 系统基本能力子系统集：为分布式应用在HarmonyOS多设备上的运行、调度、迁移等操作提供了基础能力，由分布式软总线、分布式数据管理、分布式任务调度、方舟多语言运行时、公共基础库、多模输入、图形、安全、AI等子系统组成。其中，方舟运行时提供了C/C++/JS多语言运行时和基础的系统类库，也为使用方舟编译器静态化的Java程序（即应用程序或框架层中使用Java语言开发的部分）提供运行时。基础软件服务子系统集：为HarmonyOS提供公共的、通用的软件服务，由事件通知、电话、多媒体、DFX（Design For X） 、MSDP&amp;DV等子系统组成。增强软件服务子系统集：为HarmonyOS提供针对不同设备的、差异化的能力增强型软件服务，由智慧屏专有业务、穿戴专有业务、IoT专有业务等子系统组成。硬件服务子系统集：为HarmonyOS提供硬件服务，由位置服务、生物特征识别、穿戴专有硬件服务、IoT专有硬件服务等子系统组成。根据不同设备形态的部署环境，基础软件服务子系统集、增强软件服务子系统集、硬件服务子系统集内部可以按子系统粒度裁剪，每个子系统内部又可以按功能粒度裁剪。 框架层框架层为HarmonyOS应用开发提供了Java/C/C++/JS/TS等多语言的用户程序框架和Ability框架，两种UI框架（包括适用于Java语言的Java UI框架、适用于JS/TS语言的方舟开发框架），以及各种软硬件服务对外开放的多语言框架API。根据系统的组件化裁剪程度，HarmonyOS设备支持的API也会有所不同。 应用层应用层包括系统应用和第三方非系统应用。HarmonyOS的应用由一个或多个FA（Feature Ability）或PA（Particle Ability）组成。其中，FA有UI界面，提供与用户交互的能力；而PA无UI界面，提供后台运行任务的能力以及统一的数据访问抽象。FA在进行用户交互时所需的后台数据访问也需要由对应的PA提供支撑。基于FA/PA开发的应用，能够实现特定的业务功能，支持跨设备调度与分发，为用户提供一致、高效的应用体验。 用户应用程序包结构HarmonyOS的用户应用程序包以APP Pack（Application Package）形式发布，它是由一个或多个HAP（HarmonyOS Ability Package）以及描述每个HAP属性的pack.info组成。HAP是Ability的部署包，HarmonyOS应用代码围绕Ability组件展开。 一个HAP是由代码、资源、第三方库及应用配置文件组成的模块包，可分为entry和feature两种模块类型，如图1所示。 entry：应用的主模块。一个APP中，对于同一设备类型，可以有一个或多个entry类型的HAP，来支持该设备类型中不同规格（如API版本、屏幕规格等）的具体设备。如果同一设备类型存在多个entry模块，则必须配置distroFilter分发规则，使得应用市场在做应用的云端分发时，对该设备类型下不同规格的设备进行精确分发。feature：应用的动态特性模块。一个APP可以包含一个或多个feature类型的HAP，也可以不含。只有包含Ability的HAP才能够独立运行。 AbilityAbility是应用所具备的能力的抽象，一个应用可以包含一个或多个Ability。Ability分为两种类型：FA（Feature Ability）和PA（Particle Ability）。FA/PA是应用的基本组成单元，能够实现特定的业务功能。FA有UI界面，而PA无UI界面。 库文件库文件是应用依赖的第三方代码（例如so、jar、bin、har等二进制文件），存放在libs目录。 资源文件应用的资源文件（字符串、图片、音频等）存放于resources目录下，便于开发者使用和维护，详见资源文件的分类。 配置文件配置文件 (config.json) 是应用的Ability信息，用于声明应用的Ability，以及应用所需权限等信息，详见应用配置文件。 pack.info描述应用软件包中每个HAP的属性，由IDE编译生成，应用市场根据该文件进行拆包和HAP的分类存储。HAP的具体属性包括：delivery-with-install: 表示该HAP是否支持随应用安装。“true”表示支持随应用安装；“false”表示不支持随应用安装。name：HAP文件名。module-type：模块类型，entry或feature。device-type：表示支持该HAP运行的设备类型。 HARHAR（HarmonyOS Ability Resources）可以提供构建应用所需的所有内容，包括源代码、资源文件和config.json文件。HAR不同于HAP，HAR不能独立安装运行在设备上，只能作为应用模块的依赖项被引用。","categories":[{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkexia.github.io/categories/%E9%B8%BF%E8%92%99/"}],"tags":[{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkexia.github.io/tags/%E9%B8%BF%E8%92%99/"}]},{"title":"HTML","slug":"HTML","date":"2022-01-08T05:26:58.000Z","updated":"2022-01-08T05:26:58.000Z","comments":true,"path":"2022/010854626.html","link":"","permalink":"https://wenkexia.github.io/2022/010854626.html","excerpt":"","text":"原文 vscode编辑html添加用户代码片段安装插件open in brower按下快捷键ALT+B 即可在浏览器运行html HTMLHint错误提示 html snippets常用html代码片段模板 live server实时预览html文件 beautify格式化代码工具，美化javascript，JSON，CSS，Sass，和HTML HTML框架简介什么是HTML？HTML:（HyperText Markup Language）【超文本标记语言】狭义的HTML指的是网页；广义的HTML指的是前端技术（html,css,js,以及各种框架）——网页，移动端网页，小程序，公众号，移动端的app，快应用等。 详细介绍：HypertText：超文本——超出文本的范畴，简单地说，不仅仅是文本，还可以是图像，音频，视频，flash等等；Markup：标记——网页中会有很多标记，不同的标记有不同的含义和功能，标记也叫标签，Html会包含各种各样的标签，这些标签不能乱写，必须写w3c规范中包含的标签。 怎么学HTML？HTML是一门标记语言，标记语言由一套标记标签组成，学习HTML，就是学习标签。 HTML文件的规范html文件以开始，以结尾，其他任何标签，需要写在和之间；Html标签只包含两个子标签：head和body；和网页设置相关的内容都写在head标签里；需要显示的内容都写在body标签里； 标签由尖括号包裹单词构成，如：&lt;html&gt;，所以标签不可能以数字开头。标签不区分大小写，但推荐小写。标签也称为元素。 标签的使用样式：1234567开始标签又称开放标签&lt;a&gt;标签体&lt;/a&gt;结束标签又称闭合标签或关标签自闭合标签/单标签，如：&lt;meta charset=\"UTF-8\"&gt;，&lt;br&gt;等单标签有两种写法： 写法一：只写开标签即可&lt;br&gt; 写法二：在开标签的结尾写一个/，如&lt;br/&gt; 标签method 属性1.定义和用法method 属性规定如何发送表单数据（表单数据发送到 action 属性所规定的页面）。 表单数据可以作为 URL 变量（method=”get”）或者 HTTP post （method=”post”）的方式来发送。 2.POST 方法和 GET 方法浏览器使用 method 属性设置的方法将表单中的数据传送给服务器进行处理。共有两种方法：POST 方法和 GET 方法。 如果采用 POST 方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器。 在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数。 另一种情况是采用 GET 方法，这时浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔。 一般浏览器通过上述任何一种方法都可以传输表单信息，而有些服务器只接受其中一种方法提供的数据。可以在 标签的 method （方法）属性中指明表单处理服务器要用方法来处理数据，使 POST 还是 GET。 3.POST 还是 GET？如果表单处理服务器既支持 POST 方法又支持 GET 方法，那么你该选择哪种方法呢？下面是有关这方面的一些规律： 如果希望获得最佳表单传输性能，可以采用 GET 方法发送只有少数简短字段的小表单。 一些服务器操作系统在处理可以立即传递给应用程序的命令行参数时，会限制其数目和长度，在这种情况下，对那些有许多字段或是很长的文本域的表单来说，就应该采用 POST 方法来发送。 如果你在编写服务器端的表单处理应用程序方面经验不足，应该选择 GET 方法。如果采用 POST 方法，就要在读取和解码方法做些额外的工作，也许这并不很难，但是也许你不太愿意去处理这些问题。 如果安全性是个问题，那么我们建议选用 POST 方法。GET 方法将表单参数直接放在应用程序的 URL 中，这样网络窥探者可以很轻松地捕获它们，还可以从服务器的日志文件中进行摘录。如果参数中包含了信用卡帐号这样的敏感信息，就会在不知不觉中危及用户的安全。而 POST 应用程序就没有安全方面的漏洞，在将参数作为单独的事务传输给服务器进行处理时，至少还可以采用加密的方法。 如果想在表单之外调用服务器端的应用程序，而且包括向其传递参数的过程，就要采用 GET 方法，因为该方法允许把表单这样的参数包括进来作为 URL 的一部分。而另一方面，使用 POST 样式的应用程序却希望在 URL 后还能有一个来自浏览器额外的传输过程，其中传输的内容不能作为传统 标签的内容。 基础注释1HTML注释符号是以 &lt;-- 开始以 --&gt; 结束的","categories":[{"name":"前端","slug":"前端","permalink":"https://wenkexia.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"学会高效读代码","slug":"学会高效读代码","date":"2022-01-08T01:17:14.000Z","updated":"2022-01-08T01:17:14.000Z","comments":true,"path":"2022/010815003.html","link":"","permalink":"https://wenkexia.github.io/2022/010815003.html","excerpt":"","text":"原文 为什么要会读代码？如果我能比别人看的更远，只因为我站在巨人的肩上。阅读代码，可能和写代码一样重要！学校往往教授的是如何写代码，可能从没有教如何读代码。 然而，理想很丰满，现实很骨感！工作中，你写代码的时间可能只占工作时间很少很少的一部分，大部分时间你可能都是在阅读已有的代码，当然除非这个项目从0到1都是你一个人干，可即便是自己写代码，也是渐进增长、不断迭代的，也需要不断反复阅读自己写的代码。大量阅读别人的代码，也能提升自己的编程水平。阅读代码，有这些好处： 博采众长解决难题开阔视野优秀的源码，就如传世佳作一样，值得反复揣摩，细细品味。其编写技巧、设计范式、架构思想，都具有极大的学习借鉴价值。比如一些优秀的开源项目：Linux内核、lwIP、u-boot等等。这些作品都汇集了全球优秀顶级程序员的思想智慧。都是非常优秀的作品，广为流传，广为应用。如果能花些时间去阅读理解一下其代码，一定是大有裨益的。编程生涯中，总会遇到一些感动束手无策的场景。github，搜索都已无能为力的时候。如果说还没遇到，那一定是机缘未到～比如做Linux编程的时候，遇到某个API出错，或许在网上查找半天，都找不到答案。实在找不到答案了，尝试读一读内核底层相关代码，有时候就能发现问题的原因。很多时候，日常工作内容或许只是很小的领域，修复一些小的bug，修改一些小的功能等。如果只专注这些小的点，个人成长一定会受到局限。 如果能善于发现一些新的感兴趣的领域，并去阅读相关的代码，则一定会提升自己的编程能力的。 总结找bugreview别人的代码学习维护等 如何阅读代码呢？先粗后细善做笔记善用工具多多调试我一般拿到一份别人的代码，会先去找这个项目的入口，先梳理个大概的脉络。如单片机程序，一般会从下面几个角度先扫一遍： main在哪里？ 开了几个任务？ 哪些是关键任务，主要功能链是怎么样的？ 任务间如何协作的？任务的执行周期是如何安排的？ 使用哪些硬件外设？ 使用了哪些中断？中断与哪些任务发生了交互？ 从软件角度看，大致有哪些子系统？ 是否有关键算法？ 是否使用开源组件？ ……先不关心很细的函数具体怎么写，数据结构是如何设计的？这样，我大致能先有一个总体认识，然后在对自己感兴趣的进行细读。当然如果是review别人的代码则就另当别论了。 如果是Linux应用程序，或者C++应用程序，我也大致采用差不多的思路，先读个大概，然后再细读。比如对一个Linux应用程序，会先了解这些方面的概要信息： 入口在哪个文件？一般都是main函数。 是否支持命令行传启动参数？ 是否是守护进程？ 开了哪些线程？ 大致有哪些子系统？ 使用了哪些开源组件？ 是否使用驱动，是否有通讯等？ ……如果项目采用cmake或者makefile进行组织的，那么先阅读下makefile也会是了解项目概要信息的一个比较好的切入点。在阅读代码的概要信息的时候，我比较喜欢做做笔记，画画图。在阅读代码的时候，我比较喜欢先去研究代码中的数据结构。数据结构往往会体现作者抽象问题、对问题建模的一些思路，并使用UML图画出来，刚开始可能都不去看每个函数是怎么实现的，只关心与这些数据结构相关有哪些函数以及数据结构间关系。比如source insght, vs code等工具，都是提高阅读代码效率的好工具。尽量熟悉如何使用键盘控制阅读跳转，用熟了，效率倍增。 另外，还有些工具，可以自动将代码转化成类图等，比如visual studio，可以自动绘制类图，Enterprise Architect也具有根据代码生成类图的功能。具有此类功能的软件还有很多。有兴趣可以搜索一下。如果遇到有的代码，怎么看也理解不了。这时候可以试着加些打印日志，运行调试一下，也可以使用调试工具进行断点、单步调试，观察程序运行的轨迹，数据的变化情况，可能就找到了突破口。 或者尝试对原有的代码，做些小的修改，来印证理解，也是不错的方法。","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://wenkexia.github.io/tags/%E6%95%88%E7%8E%87/"}]},{"title":"内网穿透","slug":"内网穿透","date":"2022-01-08T00:23:00.000Z","updated":"2022-01-08T00:23:58.000Z","comments":true,"path":"2022/01086932.html","link":"","permalink":"https://wenkexia.github.io/2022/01086932.html","excerpt":"","text":"内网穿透是指将内网中的软件服务通过网络代理方式暴露给广域网用户。可以实现内网穿透的方式很多，比如通过防火墙硬件、网络穿透软件来进行实现。先简单解释一下，大多数情况下，我们的个人电脑都处于内网，即没有可公开访问的独立 IP 地址（上网要通过其他网关），因此其他内网用户找不到你，就没办法和你建立连接。 而内网穿透的作用，就是将内网的电脑暴露到公共网络。可以理解为一个中间人，由于他知道你的电脑地址，所以能帮助其他用户访问到你的计算机。「无公网IP实现外网访问内网群晖.docx」链接：https://www.aliyundrive.com/s/ftxwXuv2SAi「开源内网穿透工具 frp 简单使用教程.docx」链接：https://www.aliyundrive.com/s/3K6okzrMght「常见内网穿透工具使用总结.docx」链接：https://www.aliyundrive.com/s/DDhaPQfR6SS「使用内网穿透访问内网ssh图文教程.docx」链接：https://www.aliyundrive.com/s/9U1Migig8yB「内网渗透之内网穿透.docx」链接：https://www.aliyundrive.com/s/Uh88x4GSjz4「内网穿透神器NPS的使用.docx」链接：https://www.aliyundrive.com/s/7XQUhDhPGBm 参考 nps-npc原文 简介nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。 一台有公网IP的服务器（VPS）运行服务端（NPS） 一个或多个运行在内网的服务器或者PC运行客户端（NPC） 特点Go语言编写 支持跨平台 支持多种协议的代理 web管理端 使用方法其官方网站为：https://ehang-io.github.io/nps 其官网文档对软件的安装、使用描述的非常完整，基本根据官方文档就可以进行顺利安装与使用。其官方网站为：https://ehang-io.github.io/nps 其官网文档对软件的安装、使用描述的非常完整，基本根据官方文档就可以进行顺利安装与使用。 NATAPP原文 未整理原文：https://zhuanlan.zhihu.com/p/303175108首先解释一下“内网”与“外网”的概念：内网：即所说的局域网，比如学校的局域网，局域网内每台计算机的IP地址在本局域网内具有互异性，是不可重复的。但两个局域网内的内网IP可以有相同的。外网：即互联网，局域网通过一台服务器或是一个路由器对外连接的网络，这个IP地址是唯一的。也就是说内网里所有的计算机都是连接到这一个外网IP上，通过这一个外网IP对外进行交换数据的。也就是说，一个局域网里所有电脑的内网IP是互不相同的,但共用一个外网IP。（用ipconfig/all查到的IP是你本机的内网IP；在http://www.ip138.com上看到的是你连接互联网所使用的IP，即外网）。 然后解释一下公有 IP 和私有 IP 的区别：公有地址(Public address)：由 Inter NIC(Internet Network Information Center 因特网信息中心)负责。这些 IP 地址分配给注册并向Inter NIC提出申请的组织机构，公有 IP 全球唯一，通过它直接访问因特网(直接能上网)。私有地址(Private address)：属于非注册地址，专门为组织机构内部使用，说白了，私有 IP 不能直接上网。而我们平时通过运营商(电信、移动、联通宽带等)上网，家里面通过路由器分出来的 IP 都是私有 IP(局域网 IP)，大家可能会疑问，我们可以上网啊，怎么会是私有 IP 呢?租用(申请)公有 IP 是需要钱的。 运营商买了一些公有 IP，然后通过这些公有 IP 分出来，再分给一个一个的用户使用。这个过程有点类似于，我们去安装了宽度，通过路由器分出几个 IP，让好几个人都能上网，当然运营商通过公有 IP 分出来的过程肯定比这个复杂多了。所以，我们平时上网用的 IP 是私有 IP，真正拥有公有 IP 的是运营商(当然，我们可以租用一个公有 IP )。所以，A 家庭的局域网 IP 和 B 家庭的局域网 IP 相同很正常，但是，最终 A 和 B 能上网(数据走出去)还是通过运营商的公有 IP，毕竟，公有 IP 的资源有限，这一片区域的用户使用的很有可能(实际上就是这样的)是同一个公有 IP最后需要解释一下端口映射：端口映射是 NAT 的一种，它将外网主机的 IP 地址的一个端口映射到内网中一台机器，提供相应的服务。当用户访问该 IP 的这个端口时，服务器自动将请求映射到对应局域网内部的机器上。之前提到的内网，是不能被外网直接的访问的，只能通过一些中转技术，让内网“假装”成外网。这就平常所说的内网穿透。内网穿透原理 内网穿透的概念 内网穿透，即NAT穿透，网络连接时术语，计算机是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透。就是说映射端口，能让外网的电脑找到处于内网的电脑，提高下载速度。不管是内网穿透还是其他类型的网络穿透，都是网络穿透的统一方法来研究和解决。 内网穿透原理对于内网来说，其不是不能主动访问公网端口，而是不能反过来有效的被公网访问。内网穿透的主要思路就是利用这一点，让在内网的节点主动访问一个拥有公网IP地址的服务器，并由中间服务器搭桥，打通经过该服务器从其他主机到NAT之后节点的隧道。 有哪些应用场景提供内网穿透服务连接内网服务器，在外网演示内网web站点无需服务器部署，快速调试本地程序，微信公众号开发利器支持http、https协议站点，省去证书中间件复杂配置，http协议站点直接升级为https站点支持TCP，UDP协议端口转发。支持数据库、SSH、远程桌面、网络摄像头等等开放到外网 建立隧道的工具 钉钉穿透 工具基于ngrok封装，简单、见效快，新手、个人开发者最佳选择 Ngrok项目主页：https://ngrok.com/项目介绍： 一个通过任何NAT或防火墙为您的本地主机服务器提供即时访问、安全的URL的命令。类似花生壳，分为服务端和客户端，也可以自己搭建服务端。开源，老牌穿透工具，源码很久没有更新了 Ssh&nbsp;配合autossh工具使用，因为autossh会容错项目主页：http://www.harding.motd.ca/autossh/项目介绍：自动重新启动SSH会话和隧道。autossh是一个程序，用于启动ssh的副本并进行监控，在死亡或停止传输流量时根据需要重新启动它。 这个想法来自rstunnel（Reliable SSH Tunnel），但是在C中实现。作者的观点是，它不像匆匆忙忙的工作那么容易。使用端口转发环路或远程回显服务进行连接监视。在遇到连接拒绝等快速故障时，关闭连接尝试的速度。在OpenBSD，Linux，Solaris，Mac OS X，Cygwin和AIX上编译和测试; 应该在其他BSD上工作。免费软件。Natapp项目主页：https://natapp.cn/项目介绍：基于ngrok的国内收费内网穿透工具，4包卫龙辣条的费用可以享有不限流量，自定义域名等好处类似花生壳，有免费版本，比花生壳好。免费版本：提供http,https,tcp全隧道穿透，随机域名/TCP端口，不定时强制更换域名/端口，自定义本地端口 Spike项目主页：https://github.com/slince/spike项目介绍：Spike是一个可以用来将你的内网服务暴露在公网的快速的反向代理，基于ReactPHP，采用IO多路复用模型。采用Php实现。 个人不推荐花生壳项目主页：https://hsk.oray.com/项目介绍：商业化比较成功的内网穿透。个人开发很不推荐，收费贵，企业可以考虑使用。需要建立账号实名认证，支付2包卫龙辣条费用，可自选一个壳域名，注册过程比较麻烦，流量限制Lanproxy项目主页：https://github.com/ffay/lanproxy项目介绍：lanproxy是一个将局域网个人电脑、服务器代理到公网的内网穿透工具，目前仅支持tcp流量转发，可支持任何tcp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面…）。目前市面上提供类似服务的有花生壳、TeamView、GoToMyCloud等等，但要使用第三方的公网服务器就必须为第三方付费，并且这些服务都有各种各样的限制，此外，由于数据包会流经第三方，因此对数据安全也是一大隐患。Frp项目主页：https://github.com/fatedier/frp项目介绍：frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。开源，强大牛逼，适合企业中开发使用，可穿透任意常规合法端口（包含22），需要提供云服务器，自己的域名，宽带上限由你的服务器所决定。 工具选择https://juejin.cn/post/6860694239412649991?share_token=26950be9-39b6-432c-b29a-a26df3e8cae4内网穿透工具比较(ngrok,frp,lanproxy,goproxy,nps)https://blog.csdn.net/a1035434631/article/details/108010819 ngork基本原理是通过客户端与公网服务端建立通道及映射关系，然后服务端提供可访问的公网地址。当外网访问此公网地址时，ngrok服务端根据映射关系找到客户端，然后转发给客户端的服务https://juejin.cn/post/6844903993911558157?share_token=1b8c42ab-1174-48a2-9122-00e008829d45","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"待分","slug":"待分","permalink":"https://wenkexia.github.io/tags/%E5%BE%85%E5%88%86/"}]},{"title":"Javascript","slug":"Javascript","date":"2022-01-07T15:41:55.000Z","updated":"2022-01-07T15:41:55.000Z","comments":true,"path":"2022/01079809.html","link":"","permalink":"https://wenkexia.github.io/2022/01079809.html","excerpt":"","text":"JavaScript是什么JavaScript 是脚本语言，是一种轻量级的编程语言。 JavaScript 是可插入 HTML 页面的编程代码。插入 HTML 页面后，由浏览器执行。 JavaScript的组成：ECMAScript(语言基础，如：语法、数据类型结构以及一些内置对象) DOM（一些操作页面元素的方法） BOM（一些操作浏览器的方法） 为什么学习 JavaScript?JavaScript 是 web 开发人员必须学习的 3 门语言中的一门： HTML 定义了网页的内容CSS 描述了网页的布局JavaScript 控制了网页的行为 用法123HTML 中的脚本必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间。&lt;script&gt; 和 &lt;/script&gt; 会告诉 JavaScript 在何处开始和结束。脚本可被放置在 HTML 页面的 &lt;body&gt; 和 &lt;head&gt; 部分中。 在 或者 的JavaScript您可以在 HTML 文档中放入不限数量的脚本。 脚本可位于 HTML 的 或 部分中，或者同时存在于两个部分中。 通常的做法是把函数放入 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。 外部的 JavaScript也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。 外部 JavaScript 文件的文件扩展名是 .js。 12345如需使用外部文件，请在 &lt;script&gt; 标签的 \"src\" 属性中设置该 .js 文件：你可以将脚本放置于 &lt;head&gt; 或者 &lt;body&gt;中，放在 &lt;script&gt; 标签中的脚本与外部引用的脚本运行效果完全一致。外部脚本不能包含 &lt;script&gt; 标签。 基础注释12//单行注释多行注释以 /* 开始，以 */ 结尾。 变量变量必须以字母开头变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）变量名称对大小写敏感（y 和 Y 是不同的变量）1.声明（创建） JavaScript 变量我们使用 var 关键词来声明变量： 2.一条语句，多个变量您可以在一条语句中声明很多变量。该语句以 var 开头，并使用逗号分隔变量即可： var lastname=”Doe”, age=30, job=”carpenter”; 局部变量在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它 局部变量生命期从被声明的时间开始。在函数运行以后被删除。 JavaScript 对象JavaScript 对象是变量的容器。但是，我们通常认为 “JavaScript 对象是键值对的容器”。对象也是一个变量，但对象可以包含多个值（多个变量），每个值以 name:value 对呈现。总结：JavaScript 对象是属性和方法的容器。 1var car = {name:\"Fiat\", model:500, color:\"white\"}; 对象属性键值对在 JavaScript 对象通常称为 对象属性。访问对象属性你可以通过两种方式访问对象属性: 121.person.lastName;2.person[\"lastName\"]; 对象方法JavaScript 函数函数就是包裹在花括号中的代码块，前面使用了关键词 function：当您声明函数时，请把参数作为变量来声明： 1234function myFunction(var1,var2){代码} 条件语句123456789101112if (condition1){ 当条件 1 为 true 时执行的代码}else if (condition2){ 当条件 2 为 true 时执行的代码}else{ 当条件 1 和 条件 2 都不为 true 时执行的代码} 循环语句for - 循环代码块一定的次数 1234for (语句 1; 语句 2; 语句 3){ 被执行的代码块} for/in - 循环遍历对象的属性while - 当指定的条件为 true 时循环指定的代码块 1234while (条件){ 需要执行的代码} do/while - 同样当指定的条件为 true 时循环指定的代码块 12345do{ 需要执行的代码}while (条件); 模块系统module.exports 对象是由模块系统创建的。在我们自己写模块的时候，需要在模块最后写好模块接口，声明这个模块对外暴露什么内容，module.exports 提供了暴露接口的方法。第一种：返回一个实例对象 12345678910//CLASS.jsvar CLASS = function(){ this.name = \"class\";}CLASS .prototype.func = function(){ alert(this.name);}module.exports = new CLASS(); 1234//调用var c = require('./CLASS.js');c.func();//\"class\" ES6箭头函数123456789101112131415//经典格式： 函数名 = ( 参数 ) =&gt; { 方法体 } const sum3 = (x,y)=&gt;{ return x+y; }console.log(sum3) //当方法体只有一行时，花括号可以省略： const sum4 = (x,y) =&gt; x+y; console.log(sum4) //当只有一个参数时，括号可以省略：","categories":[{"name":"前端","slug":"前端","permalink":"https://wenkexia.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wenkexia.github.io/tags/JavaScript/"}]},{"title":"Docker入门","slug":"Docker入门","date":"2022-01-05T01:02:52.000Z","updated":"2022-01-05T01:02:52.000Z","comments":true,"path":"2022/010511205.html","link":"","permalink":"https://wenkexia.github.io/2022/010511205.html","excerpt":"","text":"Docker简介Docker 是一个开源的应用容器引擎，基于 GO 语言开发，开发者可以打包应用及依赖包到一个可移植的容器中，然后发布到任何操作系统的机器上，也可以实现虚拟化。 特点容器是完全使用沙箱机制,相互之间不会有任何接口。特点随处运行：容器可以将代码与配置文件和相关依赖库进行打包，从而确保在任何环境下的运行都是一致的。 高资源利用率：容器提供进程级的隔离，因此可以更加精细地设置 CPU 和内存的使用率，进而更好地利用服务器的计算资源。 快速扩展：每个容器都可作为单独的进程予以运行，并且可以共享底层操作系统的系统资源，这样一来可以加快容器的启动和停止效率。 与虚拟机的区别容器与容器之间只是进程隔离，而虚拟机是完全的资源隔离； 运行空间，虚拟机一般要几 GB 到 几十 GB 的空间，而容器只需要 MB 级甚至 KB 级。 虚拟机的启动需要分钟级别，Docker 启动是秒级或者更短； 虚拟机虽然可以隔离出很多「子电脑」，但占用空间更大，启动更慢。虚拟机软件可能还要花钱，例如 VMWare。 容器技术不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境，类似「沙箱」。 组成部分Docker Client：客户端，命令行Docker Daemon：服务端守护进程，接受并处理来自客户端的消息Docker Image：镜像，相当于面向对象编程 类 的概念一个只读层被称为镜像，一个镜像是永久不会变的。因为 Docker 使用统一文件系统，Docker 进程认为整个文件系统是以读写方式挂载的，由于所有的变更都发生在顶层的可写层，所以下层的原始的只读镜像文件并未发生变化。 每一个镜像都可能依赖一个或者由多个下层镜像组成的另一个镜像。 Docker Container：容器，相当于面向对象编程 对象 的概念镜像运行后的进程。因为 Docker 的容器实在太轻量级了，很多时候用户都是随用随建，用完即删。 参考","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"容器","slug":"容器","permalink":"https://wenkexia.github.io/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"各平台软件分享","slug":"各平台软件分享","date":"2022-01-04T10:10:17.000Z","updated":"2022-01-04T10:10:17.000Z","comments":true,"path":"2022/010422249.html","link":"","permalink":"https://wenkexia.github.io/2022/010422249.html","excerpt":"","text":"多平台软件window软件everything本地快速搜索https://www.voidtools.com/zh-cn/ uTools是一个极简、插件化的现代桌面软件，通过自由选配丰富的插件，打造得心应手的工具集合。通过快捷键（默认 alt + space ）就可以快速呼出这个搜索框。你可以往输入框内粘贴文本、图片、截图、文件、文件夹等等，唤出超级面板即可使用插件 插件推荐图床图床管理工具 程序员手册内置了十多个实用离线的中文文档。文档包括Linux、php、Python、Js等，还可以根据需要添加自己的文档，启用需要的文档。 Ctool开发者常用功能 本地搜索 搭配everything食用 批量重命名 在线流程图 Diagram 快速跳转至drawio，用于流程图绘制。 知悉思维导图 一个免费的思维导图插件，用于快速启动知犀思维导图网页，账号和uTools同步。主要是启动方便，而且还免费，市场上还有许多共享的资源。 快捷命令 插件介绍：快速打开软件，网站，运行shell命令等。我个人认为最牛x的还是直接运行代码，几乎支持所有的开发语言，程序员必备，有时候想调试一下代码片段，这个功能最方便了。可以去分享中心安装别人分享的快捷命名，有种逛油猴市场的感觉。 自动化助手 和上文快捷命令相似，只不过这个插件提供了其它实用的功能：图片去背景（removebg），图片一键上传到图床（目前支持路过图床和ＳＭ图床） Excalidraw 在线绘图白板 在线绘图工具，漫画风格非常nice。非常适合用于绘制手稿和灵感！ tinypng压缩图片使用tinypng压缩图片，支持批量操作，鼠标选中，右键快捷操作。 图片聊天 将文字转换为图片 Caesium参考Caesium是一款开源免费的无损压缩工具，它能够在保证图像质量的前提下，最大化压缩图像大小，节省存储空间。 Caesium目前支持Windows和macOS系统，因此，无论你是Windows用户还是macOS用户，都可以体验到它的强大。 Caesium的使用非常简单，直接打开要压缩的图片，选择输出文件夹即可，它支持单幅图压缩，也支持批量压缩。 scrcpy投屏Github地址 使用手机数据线连接电脑后，开启usb调试，自动连接 鼠标右键是返回 要想卸载scrcpy,先在目录下进入cmd,输入adb kill-server,再删除整个scrcpy文件即可 adb功能异常，重启adb（1）把adb服务杀死：adb kill-server（2）重启adb服务：adb reconnect OOAPB通过这个应用程序可以卸载在Windows10/11上预装的应用程序，应用无需安装，个人使用完全免费https://www.oo-software.com/en/ooappbuster 大学出题2022优势：1.编辑题库，2.加入题库，3.生成试卷，4.自动生成答案，5.生成word，6.一键打印。解锁新增试题，修改试题功能，比如你可以新增1000个题目，然后出5个题，系统会自动抽选题目，带答案方便老师改卷。这是目前能找到的比较方便很好的题库软件了，而且是2022新版的。适合：企业内训、小学、初中、高中、大学、培训机构、职业院校等老师的出题工作，由于是独立提取的，无在线题库功能，你们单位找一个专门电脑，所有老师都在里面增加题库内容，然后可以共享题库。非常方便，这是目前能找到的最好的出题软件了！ 可以无上限增加新题 链接：https://pan.baidu.com/s/1MhMUVJCm_T9apOQj8YKDPw提取码：52pj WxDatViewer是一款非常好用的微信dat图片批量解密、查看、整理工具 https://pan.lanzoui.com/b0405repg 系统工具分区微pe工具箱 window激活KWI, KEU 数据恢复WinFR界面版支持在Win/1110、NTFS、FAT、exFAT、ReFS 下从 SSD/HDD/USB/存储卡中恢复丢失的文件。文件手滑意外删除、磁盘格式化、磁盘损坏、中病毒等导致的文件丢失都可以使用这款工具尝试恢复。https://maxiaobang.lanzoup.com/iTnW5yztejg ApowerRecoverhttps://mp.weixin.qq.com/s/W_DHyZFt9j13VuLns8X4ew 安装后，将Crack文件夹中的文件复制到软件安装目录中，即可免费使用了蓝奏云下载：https://idege.lanzouw.com/i6M2Nylj5qf appAidLux【应用版本】：1.0 【应用大小】：415MB 【适用平台】：IQ5 【软件简介】:AidLux App是一款专为AIoT打造的移动开发工具，支持多种语言，能够帮助用户随时快速进行办公，拓展性强，采用AI智能加速，让你事半功倍 基本简介 AidLux App是基于ARM架构的跨生态(Android+Linux)一站式AIoT应用开发及运行平台。 AidLux运行环境 Cpu架构：Arm64位 设备：手机、平板和开发板卡 环境：Android 6.0.3至Android 11 ……………………………………………… 软件说明: AidLux平台全面覆盖手机、边缘端、终端云等，并且打通手机、电脑、平板、电视、工业自动化控制、机器人成一个统一的平台，实现跨终端无缝协同体验，并且该平台能使用全部安卓应用、Arm环境下的Linux应用，对于智能硬件开发者，不用再面对硬件的复杂性，AI环境的多样性，通过AidLux的智能AI加速模块，实现CPU、GPU、NPU和DSP多种方式的AI加速。 软件特色 各种机器人套件：ROS，PCL点云，Eigen，Protobuf和G2o等多种工具 支持多种开发语言：C/C++，Python,Java,JavaScript，Ruby，PHP，Go，Shell等 丰富Linux软件，AidCode，Git，Mysql，Hadoop，Nigix，Apache，Vim，Ssh，Vscode，Jupyter，积木编程等 扩展性好：内置了极简的外设极速互连模块，通过USB和网络等方式控制Arduino、机械臂、机器人、高清摄像机等 集成主流AI框架(Caffe、Mxnet、Keras、Pytorch、Tensorflow、Ncnn、MindSpore、PaddlePaddle、TNN、Opencv)，无需配置，直接使用 内置丰富的AI案例：人脸识别、人脸关键点识别、肢体识别、手势识别、头发识别、物体分类、物体跟踪、3D检测-、身体交换、人体抠图等 主研发AI智能加速模块，支持CPU+GPU+NPU+DSP加速智能加速，自动适配主流深度学习模型格式，无需格式转换即可自动加速和Forward ……………………………………………… 使用方法:下载安装，点击用手机登陆即可自动安装界面Linux 下载方式: 1.手机各大应用商店搜索AidLux下载 2.百度网盘: https://pan.baidu.com/s/1QYDvCKSl_H-B6YVCqdf8Qg?pwd=1v5y 提取码:1v5y 海阔视界下载最新版软件地址如下https://haikuo.lanzoux.com/u/GoldRiver 备用地址： https://haikuo.lanzoui.com/u/GoldRiver 如果上面的地址都不可用，可以在公众号(新方圆小棉袄)对话框回复“最新版”这几个字获取新版下载地址。 Vmos pro手机虚拟机使用用mt管理器查看虚拟机里的文件 两仪原文 一个免 ROOT 的 Android 系统级容器 【下载地址】 百度网盘: https://pan.baidu.com/s/1tRFnXwc2An4pLNn0gmNvew?pwd=anlu提取码:anlu 微云:https://share.weiyun.com/3vUDEtdN 天翼:https://cloud.189.cn/t/N77Vn2Eb2YZv 迅雷:https://pan.xunlei.com/s/VMtzo7gpJ2nEJFrH-MTa9HtNA1 提取码：z2za SD Maid支持卸载残留扫描、系统/应用缓存清理、文件管理、应用管理、提取安装包、重复文件扫描、查看存储信息等。 ZArchiver安卓上最强的压缩/解压缩应用，有这一个就够了。基本上我们能用到的所有格式压缩包都可以处理。支持带密码的压缩包、分卷解压、免解压预览、自定义界面、文件管理等。 图叨叨宫格切图、模板拼图、以图搜图、电影台词、图片水印、图片打码、压缩裁剪、网页截图、动图制作、图片边框、图文卡片、手持弹幕等。 而且无广告、无后台，相当好用。 便捷下载一款万能手机下载器，简单方便。只要把链接粘贴进去，就可以自动解析下载图片、视频、音频、文档。 还支持音频提取、视频压缩、一键转换网页为 PDF 等。 kiwi brower李跳跳v1.75原文 【软件链接】 https://wwn.lanzoul.com/iKcrtywtuhc 密码:3m3m 【Xp框架免root】太极 v9.0.0原文太极是一个无需Root，无需解释Bootloader，也不需要刷机就能使用 Xposed 模块的一个APP。太极拥有无需刷机、无需解锁、使用简单的优点，支持目前大部分xposed模块，该应用搭配各种xpose模块使用时，可以让你的应用程序拥有强大的功能。 【下载链接】https://wwn.lanzoul.com/i5INgz5ugxe 【备用链接】https://wwn.lanzoux.com/i5INgz5ugxe 【免root】AppMgr Pro III5.35原文 需要开启无障碍隐藏应用: 允许您隐藏系统（内置）应用，让隐藏的应用从你的桌面程序列表中消失不见。 冻结应用: 允许您冻结应用，被冻结的应用将不会被启动、执行或使用任何 CPU 或存储，自然也不会消耗任何电力。 应用管理: 可以帮助您管理所安装的应用，例如批次卸载应用，批次移动应用或分享你安装的应用给朋友等等。【下载地址】https://rtkcxzh.lanzouw.com/i8YZSzu9psh Android开发工具箱安卓开发助手它能够用来反编译其他应用、查看其他应用布局和控件信息、快速查看 Activity 历史记录、查看其他应用 Manifest、查看最近使用和最近安装的应用详细信息、提取任何应用 Apk 和 So 文件、调试 【下载链接】：https://wwn.lanzoul.com/igSpq008kxwj【备用链接】：https://wwn.lanzoux.com/igSpq008kxwj 科学https://www.alpacadisk.com/shared/AKYTwnwK5k1fir3V iosTuneProiOS 平台免费听歌 app，曲库很大，一般歌都能听，不支持下载音乐。https://apps.apple.com/cn/app/tunepro-music/id12482625083 苹果快捷指令分享网站https://routinehub.co/相关链接：https://www.rcuts.com/https://applefans.today/category/applefans-classroom/apple-shortcuts/","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://wenkexia.github.io/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"github","slug":"github","date":"2022-01-01T04:01:32.000Z","updated":"2022-01-01T04:01:32.000Z","comments":true,"path":"2022/010114187.html","link":"","permalink":"https://wenkexia.github.io/2022/010114187.html","excerpt":"","text":"加速访问GitHub参考文章参考 基础知识 DNS能帮你在访问域名的时候查到实际的IP地址Github 在全球各地都有服务器，而在国内，DNS解析服务基本上都是把域名解析到了美国的服务器，所以访问起来会比较慢但我们可以通过修改本地 hosts 文件来绕过公共DNS解析，直接访问 Github 在韩国、日本等的服务器，从而达到加速访问的目的 hosts 文件就相当于本地通讯录，你的通讯录里面记了公司的电话。 steamcommunity 302（WIN）羽翼城大佬后来又开发的 steamcommunity 302 就是通过反代来加速访问 Github 等网站 软件可以到这里下载：https://www.dogfight360.com/blog/686/比较棘手的是可能会出现80／443端口被占用的情况，这个需要关闭对应监听端口的进程／服务来解决，具体教程可见羽翼城大佬在下载页面做出的说明 FastGithub（WIN／Mac／Linux）FastGithub 则是另一款同样基于反代来加速 Gtihub 访问的工具，支持WIN／Mac／Linux三端，还能在docker上一键部署：https://github.com/dotnetcore/FastGithub Windows端的话，下载后双击即可运行，软件没有程序界面，直接就是跑的命令行，所以开启之后不要关闭命令行窗口！ 而 FastGithub 除了可以加速访问 Gtihub ，最大的优势是它顺便还能助你直连V2EX 网易UU加速器网易在一款游戏加速器里面竟然还提供了Github网站访问加速 修改本地hosts1.打开本地host文件C:\\Windows\\System32\\drivers\\etc在这个项目https://github.com/521xueweihan/GitHub520复制添加内容到本地host2.更新DNS缓存 FasterHosts谷歌插件1.在Chromium内核的浏览器上，你可以安装FasterHosts这款浏览器扩展来解决：https://github.com/gauseen/faster-hosts 2.FasterHosts的 hosts 资源就是来自 GitHub520，每 1 小时更新一次，所以你无需配置，一装好之后就可以用 SwitchHosts软件1.这个工具来实现自动更新 hosts 中的IP地址2.我们先到 SwitchHosts 官网下载这款管理工具：https://swh.app/zh/3.下载安装好SwitchHosts之后标题随意取，URL地址填这个：https://raw.hellogithub.com/hosts4.自动刷新最好建议选1小时5.点击确认后，还要手动启用一下，接着稍等片刻本地 hosts 即会更新 UsbEAm Hosts Editor软件下载 上传本地文件到githubgithub在线上传文件夹在线上传也可以上传完整的文件夹结构，直接拖拽到上传文件页面的框 通过git工具上传本地文件夹（本地项目）跳转git使用文章 项目推荐Awesome GitHub RepoAwesome GitHub Repo 是逛逛 GitHub 创建的开源项目，会收集整理 GitHub 上高质量、有趣的开源项目，并将他们进行归类。地址：https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo 新一代爬虫平台平台以流程图的方式定义爬虫，是一个高度灵活可配置的爬虫平台。新一代爬虫平台，以图形化方式定义爬虫流程，不写代码即可完成爬虫。开源地址：https://github.com/ssssssss-team/spider-flow 开发者技术路线技术发展日新月异的，行业也是瞬息万变。技术迭代更新，有没有一个不断更新的指南，为技术进阶之路指一条明路？这个 GitHub 项目就是，它为前端、后端、DevOps等开发着准备可详细的技术路线图。 开源地址：https://github.com/kamranahmedse/developer-roadmap 自学编程之路Python 开源项目之「自学编程之路」，保姆级教程：AI实验室、宝藏视频、数据结构、学习指南、机器学习实战、深度学习实战、网络爬虫、大厂面经、程序人生、资源分享。 开源地址：https://github.com/Jack-Cherish/PythonPark","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://wenkexia.github.io/tags/GitHub/"}]},{"title":"mysql学习笔记","slug":"mysql学习笔记","date":"2021-12-31T17:12:58.000Z","updated":"2021-12-31T17:12:58.000Z","comments":true,"path":"2022/010151482.html","link":"","permalink":"https://wenkexia.github.io/2022/010151482.html","excerpt":"","text":"安装下载https://dev.mysql.com/downloads/mysql/ 下载完后，我们将 zip 包解压到相应的目录，这里我将解压后的文件夹放在D:\\ruanjian\\mysql-8.0.28-winx64 配置MySQL 的配置文件在安装目录下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息： 1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\\\web\\\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 环境变量新建系统变量MYSQL_HOME，变量值为你的安装目录D:\\ruanjian\\mysql-8.0.28-winx64在系统变量里，找到Path变量，点击“编辑”按钮，我们将;%MYSQL_HOME%\\bin添加到path变量（一般放在最后面） 启动MySQL 数据库1.初始化数据库：mysqld --initialize --console 执行完成后，会输出 root 用户的初始默认密码 12018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: qwsctyr(2+Da qwsctyr(2+Da 就是初始密码，后续登录需要用到，你也可以在登陆后修改密码。2.安装mysqld install3.启动net start mysql MySQL安装启动操作linux下安装启动操作1.安装mysql命令 ：$ sudo apt-get install -y mysql-server2.查看mysql的版本命令（注意-V是大写，不然会出现如下错误）：$ mysql -V3.启动mysql命令(关闭，重启等只需将start换成stop,restart等即可)：$sudo service mysql start4.登录mysql命令为：$ mysql -u用户名 -p密码5.连接远程数据库：$ mysql -h -P -u -p window下用户相关操作注：以下命令均需先以root身份登录mysql：mysql -uroot -p1.添加新用户（1）创建新用户：&gt; insert into mysql.user(Host,User,Password) values(“localhost”,”user1”,password(“password1”));（2）为用户分配权限： 设置用户可以在本地访问mysql：grant all privileges on . to username@localhost identified by “password” ; 设置用户只能访问指定数据库：grant all privileges on 数据库名.* to username@localhost identified by “password” ;（3）刷新系统权限表：&gt;flush privileges;2.查看MySql当前所有的用户：&gt;SELECT DISTINCT User FROM mysql.user;3.删除用户及其数据字典中包含的数据：&gt;drop user ‘xbb‘@’localhost’; 常用命令命令行执行sql文件source xxx.sql ; vscode链接MySQL安装插件MySQL ，MySQL syntax配置MySQL插件，点击+号，输入密码即可 通过命令行使用MySQL数据库的基础知识及概念 数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中的数据。 数据库（DATA BASE）指长期保存在计算机的存储设备上，按照一定规则组织起来，可以被各种用户或应用共享的数据集合。 表中用来存放数据信息，以二维行列存储数据。行（row）在sql中称作一条记录也叫实体，列（column）在sql中称作字段。 SQL：Structure Query Language。（结构化查询语言） 数据模型的分类：层次模型、网状模型和关系模型 数据库分类关系型数据库： 采用关系模型（二维表）来组织数据结构的数据库 oracle DB2 SQLServer Mysql SQLite 优点：*容易理解，逻辑类似常见的表格 *使用方便，都使用sql语句，sql语句非常成熟 *数据一致性高，冗余低，数据完整性好，便于操作 *技术成熟，功能强大，支持很多复杂操作 缺点：*每次操作都要进行sql语句的解析，消耗较大 *不能很好的满足并发需求，特别是海量数据爆发，关系型数据库读写能力会显得不足 *关系型数据库往往每一步都要进行加锁的操作，也造成了数据库的负担 *数据一致性高，有时也会使数据的存储不灵活 非关系型数据库（NoSql） 优点：*高并发，读写能力强 *弱化数据结构一致性，使用更加灵活 *有良好的可扩展性 缺点：*通用性差，没有sql语句那样通用的语句 *操作灵活导致容易出错和混乱 *没有外键关联等复杂的操作 Nosql的使用情况： 1、对数据存储灵活性要求高，一致性要求低 2、数据处理海量并发，要求瞬间效率速度比较高 3、数据比较容易建立Nosql模型 4、网站灵活时缓冲存储，爬虫应用 Nosql 的分类： 1、键值型数据库 Redis 2、文档型数据库 MongoDB 3、列存储数据库 HBase 4、图形数据库 mysql语句的四大组成成分（DDL、DML、DQL、DCL) SQL语句分类DML语言(Data Manipulation Language):数据操作语言用于操作数据库对象中所包含的数据： 关键字有：insert（插入），update（更改），delete（删除） DQL（Data Query Language）数据查询语言关键字SELECT语句1.基础查询2.条件查询3模查词(LIKE)4.字段控制查询( DISTINCT)5.排序( DRDER BY)6.分组查词 DDL(Data Definition Language):数据定义语言 关键字有：create(创建)，drop（删除） ，truncate（删除表结构，再创一张表），alter（修改） 6.INODB、MYISAM存储引擎的区别（PPT初识MySQL第67页） 二.数据的基本操作及高级查询库操作CREATE DATABASE xxx; – 创建数据库 SHOW DATABASES; – 查看当前数据库服务器中的所有数据库 DROP DATABASE xxx; – 删除指定数据库 USE xxx; – 使用数据库 表操作#创建数据表 #查看当前库所有表show tables; show 表名 #查看表信息 #查看表结构desc 表名; 改表记录 UPDATE 表名 SET 修改字段=’’ WHERE 条件 删除数据表 drop table if exists stu,student; 复制表-修改字段的数据类型 alter table &lt;表名&gt; modify &lt;字段名&gt; &lt;新数据类型&gt;添加字段 alter table &lt;表名&gt; add&lt;字段名&gt; &lt;新数据类型&gt;[约束条件] [first|after 已存在字段名];删除字段 alter table &lt;表名&gt; drop&lt;字段名&gt;; 1.基本操作语句：查看数据库列表，查看数据库中的表名 2.数据类型：字符串类型 char、varchar；一般超过200个汉字：用text；decimal()一般用于价钱、金额，考试会考其两个参数M、D表示什么意思教材27页） 3.表的创建、查询语句、数据的插入 4.创建表时涉及到的知识点，如 default 默认值 5.查询的时候，去掉重复的行：distinct 6.修改表的结构：alter的用法 7.where条件语句的用法 8.in 和 not in的用法 9.group by 分组语句，having子句的使用 10.limit 子句 11.exeits 关键字的用法 12.模糊查询 ：like (‘%’,’_’)（配合百分号、下划线使用） (课本没有) 13.between…and…的用法 ：如between 1 and 10 。包含1和10 14.uoion、 unoin all 的用法 15.truncate table 删除特点：可以删除表中所有的行（书本P56） 16.函数:聚合函数（sum()、max()、min()、count()、avg()）（使用原则书本58页） 17.日期函数：now()获取当前日期和时间 2021-12-16 16：59：30 18.内连接 外连接 基本语法及含义（书本P88）如返回左表中所有的记录和右表中符合连接条件的记录（左外连接） 19.条件筛选 where 和having的区别where语句从数据表中选取满足条件的数据行、列having子句选取满足条件的分组 20.批量子查询ALL、ANY 子查询子查询就是嵌套查询，一个select语句中包含另一个完整的select语句。 1.子查询出现的位置： where后，作为条为被查询的一条件的一部分；from后，作表；2.当子查询出现在where后作为条件时，还可以使用如下关键字： anyall3.子查询结果集的形式： 单行单列（用于条件）单行多列（用于条件）多行单列（用于条件）多行多列（用于表） 1.带比较运算符的子查询2.带 EXISTS关键字的子查询3.带ANY关键字的子查询4.带AL关键字的子查询 多表连接查询内连接查询 select 表1查询的字段，表2查询的字段 from 表1 inner join 表2 on 两表都有的字段； 3外连接查询(只适用于两表) 左（外）连接查询 select 表1查询的字段，表2查询的字段 from 表1 left join 表2 on 条件； 左表的记录将会全部表示出来，而右表只会显示符合搜索条件的记录 右（外）连接查询 22.SQL语句的执行顺序。（PPT数据查询第79页） 第三部分:事务、存储过程、存储函数、视图、索引、备份、恢复1.存储过程（重点）基本格式及使用，怎么调用存储过程 (PPT存储过程与事务第17页）定义 ： 存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。存储过程的特点 1、能完成较复杂的判断和运算 2、可编程行强，灵活 3、SQL编程的代码可重复使用 4、执行的速度相对快一些 5、减少网络之间的数据传输，节省开销创建存储过程的简单语法 1234create procedure 名称()begin.........end 调用存储过程 call 名称();存储函数里的变量 1234567891011create procedure test2()begin -- 使用 declare语句声明一个变量 declare username varchar(32) default ''; -- 使用set语句给变量赋值 set username='xiaoxiao'; -- 将users表中id=1的名称赋值给username select name into username from users where id=1; -- 返回变量 select username;end; 事务mysql事务处理的四种基本特性（原子性、一致性、隔离性、持久性）（书本P102页） 4.事务的基本语法，比如开启事务（start transcation、begin) ,提交事务commit，回滚 rollback（书本P103页） 5.mysql设置了事务的4种隔离级别（读未提交、读提交、可重复读、可串行化）（书本没有） 视图视图是由数据库中的一个表或多个表导出的虚拟表，是一种虚拟存在的表，方便用户对数据的操作。创建视图 create view 视图名 as select 7.数据库的备份与恢复。mysqldump的基本使用格式 索引索引并非越多越好避免对经常更新的表建立过多的索引数据量小的表最好不要使用索引在不同值少的列上不要建立索引为经常需要排序、分组和联接操作的字段建立索引 （2）索引的关键字（PPT 索引视图触发器第21页） 触发器 触发器与函数、存储过程一样，触发器是一种对象，它能根据对表的操作时间，触发一些动作，这些动作可以是insert,update,delete等修改操作。 123456create trigger tr_users_insert after insert on users for each row begin insert into oplog(userid,username,action,optime) values(NEW.id,NEW.name,'insert',now()); end;，三个激活触发器的操作（插入insert、修改update和删除delete）（书本没有）（PPT 索引视图触发器第43页） 第四部分：数据库规范化设计1.实体之间的映射关系：一对一1:1 、一对多1:n、多对一n:1 、多对多m:n 2.E-R图的绘制 3.E-R图转换成关系模型 4.数据库模型图的概念 命令速查https://blog.csdn.net/horses/article/details/104849500","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wenkexia.github.io/tags/MySQL/"}]},{"title":"计网学习","slug":"计网学习","date":"2021-12-24T00:55:20.000Z","updated":"2021-12-24T00:55:20.000Z","comments":true,"path":"2021/122451189.html","link":"","permalink":"https://wenkexia.github.io/2021/122451189.html","excerpt":"","text":"参考计算机网络谢希仁第八版 第一章 概述体系结构OSI的七层协议体系结构物理层，数据链路层，网络层，TCP/IP的四层体系结构链路层（网络接口层），网际层，运输层，应用层 重要内容 计算机网络的一些相关知识 互联网概述 因特网的标准化工作 互联网的组成 计算机网络的类别 计算机网络的性能指标 综合OSI和TCP/IP的优点采用五层协议的体系结构阐述计算机网络的原理 一. 物理层集线器，中继器 相关协议点对点协议PPP用在SONET/SDH链路时，采用零比特填充方法来实现透明传输。 通过传输介质发送和接收二进制比特流。 数据通信的基本知识 编码把数据转换成数字信号（01） 不归零制， 归零制（正脉冲代表1，负脉冲代表0）， 曼彻斯特编码（位周期中心的向上跳变代表0，向下代表1，反之亦可） 差分曼彻斯特编码（每一位的中心处始终有跳变。位开始边界有跳变为0，位开始边界无跳变为1）。 调制方法 转换为模拟信号 调幅：对基带信号的波幅进行调整，例如将上图的1信号波幅进行改变，在接收方读取时有载波输出为1 调相：对基带信号相位进行调制，例如将0信号的初相位调整为0度，1信号的初相位调整为180度。 调频：对基带信号频率进行调整，例如将0信号调制为频率f1，1信号调制为频率f2。 2.数据交换方式 ①分组交换 ②电路交换 信道复用技术 ①频分复用FDM 是有N路信号要在一个信道中传送。可以使用调制的方法，把各路信号分别搬迁到适当的频率位置，使彼此不产生干扰。各路信号在同样的时间占用不同的带宽资源。 ②时分复用TDM 是将时间划分为一段段等长的帧，每一路信号在每一个帧中占用固定信号的时隙。 ③波分复用 ④码分复用CDM 数字传输系统 宽带接入技术 重要内容 使用点对点信道的数据链路层 封装成帧 透明传输 差错检测 字节填充 使用广播通信的数据链路层 二. 数据链路层交换机，网桥 链路层服务组帧：封装高层数据报构成数据帧，加首部和尾部 控制字符SOH放在一帧的最前面，表示帧的首部开始 控制字符EOT放在一帧的最后，表示帧的结束 流量控制：协调相邻的发送结点，接收 差错检测：信号衰减和噪音会引起差错，接收端检测到差错，通知发送端重传或直接丢弃帧 差错纠正：接收端直接纠正比特差错 全双工和半双工通信控制 全双工：同时双向传输。半双工：交替双向传输 数据链路层协议的代表包括：PPP、帧中继等 适配器的作用CSMA/CD协议使用集线器的星形拓扑结构MAC层的硬件地址MAC帧的格式以太网的扩展 三. 网络层提供主机间的逻辑通信机制，在邻接节点间进行数据包可靠传输 负责对子网间的数据包进行路由选择，为分组交换网上的不同主机提供通信服务。 网络层协议的代表包括：IP、ICMP、IGMP等。网络层提供的两种服务 IP目前已经不采用分类表示法，所以大家重点关注CIDR表示法（无分类编址）。例 128.14.35.7/20 = 10000000 00001110 0010|0011 00000111 即前20位是网络前缀，后12位是主机号，那么我们通过令主机号分别为全0和全1就可以得到一个CIDR地址块的最小地址和最大地址，即 最小地址是：128.14.32.0 = 10000000 00001110 0010|0000 00000000 最大地址是：128.14.47.255 = 10000000 00001110 0010|1111 11111111 子网掩码是：255.255.240.0 = 11111111 11111111 1111|0000 00000000 因此就可以看出来，这个CIDR地址块可以指派(47-32+1)*256=4096个地址，这里没有把全0和全1除外。 地址解析协议ARPIP数据报的格式划分子网构造超网网际控制报文协议ICMP互联网的路由选择协议内部网关协议RIP内部网关协议OSPF外部网关协议BGP 路由器IPv6从IPv4向IP v6的过渡IP多播虚拟专用网VPN网络地址转换NAT 四. 运输层（transport layer）概述提供应用进程间的逻辑通信机制应用进程利用该服务传送应用层报文 复用功能多个应用层进程可同时使用下面运输层的服务 分用功能运输层把收到的信息分别交付到上面应用层中的相应进程运输层协议（端到端协议）发送方将应用递交的信息下传给网络层接收方将接收的信息上交给应用层 1.传输控制协议TCP数据传输单位是报文段 提供可靠的，面向连接的运输服务 不提供广播或多播服务3.开销较多 面向字节流，全双工 有流量控制和拥塞控制 TCP可靠传输的实现 三次握手 第一次：主机A向主机B发送一个同步序列号的数据段给主机B，请求建立连接 第二次：主机B收到主机A的请求后，用一个确认应答（ACK）和同步序列（SYN）的数据段响应主机A 第三次:主机A 收到这个数据段后，再发送一个确认应答，确认已收到主机B的数据段，开始传输实际数据 TCP的流量控制 TCP的拥塞控制 TCP的运输连接管理 2.用户数据报协议UDP数据传输单位是用户数据报 1.传输数据前不需要先建立连接 2.收到UDP报后，不需要给出确定 3.不提供可靠交付，但是一种最有效的工作方式 五.应用层（application layer）概述任务是通过应用进程间的交互来完成特定网络应用进程指的是主机正在运行的程序应用层交互的数据单元称为报文 应用层协议定义的是应用进程间通信和交互的规则 域名系统DNS将域名转换为Ip地址 文件传送协议FTPHTTPHTTP协议的服务端口为80 SMTPSMP协议的服务端口为25SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于传输系统之间的邮件信息并提供与来信有关的通知。 远程终端协议TELNET动态主机配置协议应用进程跨网络的通信P2P对等方式1.没有固定的服务请求者和服务提供2.对等方相互之间直接通信3.每个对等方既是服务请求者又是服务提供者 复习题选择题 物理层中指明在接口电缆的各条线上出现的电压的范围（ B ）。A. 机械特性 B. 电气特性C. 功能特性 D. 过程特性 下列属于半双工通信方式的是（ C ）。A. 无线电广播 B. 有线闭路电视C. 无线对讲机 D. 手机通话 光纤通信使用（ C ）。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM 典型应用于传输速率1Gbit/s(距离100米)的绞合线类别是（ C ）。A. 3类线 B. 超5类线C. 6类线 D. 8类线 传输带宽最大的介质是（ C ）。A. 双绞线 B. 同轴电缆C. 光纤 D. 微波 （ A ）是有N路信号要在一个信道中传送。可以使用调制的方法，把各路信号分别搬迁到适当的频率位置，使彼此不产生干扰。各路信号在同样的时间占用不同的带宽资源。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM （ A ）技术是用数字技术对现有模拟电话的用户线进行改造，使它能承载宽带数字业务。A．ADSL B. 光纤同轴混合网（HFC网）C. 光纤接入 D. FTTx技术 控制字符（ A ）放在一帧的最前面，表示帧的首部开始。A. SOH B. EOTC. ESC D. MTU 局域网通常采用的网络拓扑结构不包括（ D ）。A. 星形网 B. 环形网C. 总线网 D. 三角形 10GBASE-ER采用的媒体介质是（ B ）。A. 多模光纤 B. 单模光纤C. 同轴电缆 D. 双绞线 无分类编址CIDR地址块中网络前缀长度为/18相当于包含（ D ）个C类网络数。A. 21 B. 23C. 80 D. 64 CIDR地址块206.0.64.0/18的子网掩码采用点分十进制法是记法是（ C ）。A. 255.255.255.0 B. 255.255.240.0C. 255.255.192.0 D. 255.255.254.0 以下可分配给主机或者路由器的IP地址是（ C ）。A. 131.107.255.80/28 B. 231.211.128.0/17C. 126.1.4.255/23 D. 198.121.204.128/25 Internet的前身是美国的（ A ）。A. ARPANET B. 信息高速公路C. RFC D. 分组交换网络15．下列不属于ISP的是（ D ）。A. 中国联通 B. 中国电信C. 德国电信 D. 优酷16．计算机通信网络的数据传送方式属于（C ）。A. 电路交换 B. 报文交换C. 分组交换 D. 虚电路交换 广州工商学院的校园网属于（ C ）。A. 广域网 B. 城域网C. 局域网 D. 个域网 主机或路由器发送数据帧所需要的时间是（ A ）。A. 发送时延 B. 传播时延C. 处理时延 D. 排队时延 网络协议三要素中的（ A ）表示数据与控制信息的结构或格式。A. 语法 B. 语义C. 同步 D. 协议 以下属于UDP支持的应用程序是（ C ）。A. 浏览器打开网页 B. 收发电子邮件C. 网络视频点播 D. 远程登陆方式连接 物理层中指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等是（ A ）。A. 机械特性 B. 电气特性C. 功能特性 D. 过程特性 下列属于全双工通信方式的是（ D ）。A. 无线电广播 B. 有线闭路电视C. 无线对讲机 D. 手机通话 3G移动通信技术使用（ D ）。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM 通常双绞线的最大传输距离是（ D ）。A. 10米 B. 18米C. 50米 D. 100米 早期有线电视网使用的介质主要是（ B ）。A. 双绞线 B. 同轴电缆C. 光纤 D. 微波 （ B ）是将时间划分为一段段等长的帧，每一路信号在每一个帧中占用固定信号的时隙。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM （ B ）是目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传达电视节目外，还能提供电话、数据和其他宽带交互型业务。A．ADSL B. 光纤同轴混合网（HFC网）C. 光纤接入 D. FTTx技术 控制字符（ B ）放在一帧的最后，表示帧的结束。A. SOH B. EOTC. ESC D. MTU 总线型以太网通常采用（ A ）访问控制协议。A. CSMA/CD B.CSMA/CAC. 频分复用 D.时分复用 （ B ）的光源要使用昂贵的半导体激光器，而不能使用较便宜的发光二极管。A. 多模光纤 B. 单模光纤C. 同轴电缆 D. 双绞线 无分类编址CIDR地址块中网络前缀长度为/16相当于包含（ A ）个B类网络数。A. 1 B. 2C. 64 D. 256 CIDR地址块206.0.64.0/17的子网掩码采用点分十进制法是记法是（ B ）。A. 255.255.0.0 B. 255.255.128.0C. 255.255.192.0 D. 255.255.254.0 判断题（√）1.*一般的适配器都包括了数据链路层和物理层这两层的功能。（√）2.封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。（√）3.所有的PPP帧的长度都是整数字节。（√）4.PPP协议用在SONET/SDH链路时，采用零比特填充方法来实现透明传输。（√）5.最初的以太网是将许多计算机都连接到一根总线上，也称为共享以太网。（√）1.*一般的适配器都包括了数据链路层和物理层这两层的功能。（√ ）2.封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。（√）3.所有的 PPP 帧的长度都是整数字节。（√）4.PPP 协议用在 SONET/SDH 链路时，采用零比特填充方法来实现透明传输。（√）5.最初的以太网是将许多计算机都连接到一根总线上，也称为共享以太网。（×）6.以太网使用面向连接的工作方式。（√）7.*以太网发送的数据都使用曼彻斯特编码，其特点是可以实现时钟自同步。（√）8.以太网的站点在发送帧时，如果经过2τ后还没有检测到冲突，则本次发送不会再出现冲突了。（ √ ）9.速率达到或超过 100 Mb/s 的以太网称为高速以太网。（ √ ）10.100BASE-T 以太网工作在全双工方式时，不使用CSMA/CD协议( √ )11. CSMA/CD协议采用半双工通信。( × )6. 集线器工作于数据链路层。 //工作于物理层(√ )7. 以太网交换机是一种即插即用设备，其内部的地址表是通过自学习算法自动逐渐建立起来的。 填空题1．OSI/RM的七层协议分别是物理层、数据链路层、____网络层__、运输层、会话层、表示层、应用层。2．双绞线分为无屏蔽双绞线（UTP）和____屏蔽双绞线(STP)__。3．为了解决透明传输问题，在发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个_____转义字符“ESC”_____。 ____物理地址_____是使用数据链路层的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。 在IP层下面每一种数据链路层协议都规定了一个数据帧中的数据字段的最大长度，这称为___最大传送单元MTU ______。 HTTPS应用程序采用熟知的端口号____TCP_____。 万维网使用____超文本标记语言HTML ________来显示各种万维网页面。11．TCP/IP的四层协议包括链路层、网际层IP、运输层、____应用层______。12．数字信号可以通过_____调制器_____转化为模拟信号。13．在带宽W（Hz）的低通信道中，若不考虑噪声影响，则码元传输的最高速率是2W（码元/秒）。传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的识别称为不可能，这就是著名的____奈氏准则___。 ___香农公式_____表明信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。 ___封装成帧____就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。 计算机与外界局域网的连接是通过___网络适配器完成的_________。 网络层提供的服务分为虚电路和____数据报______。 C类地址可容纳的主机数是____254________。 HTTP应用程序采用熟知的端口号______TCP______。 FTP的中文翻译是___文件传输协议_________。 __生存时间或者TTL ___占8位，表明数据报在网络中的寿命。 内部网关协议IGP使用最多的是RIP和_____最短路径优先或者OSPF _______。 外部网关协议EGP使用最多的是_____ BGP的版本4或者BGP-4__。 1．数字信号可以通过___抽样，量化，编码____转化为模拟信号。 简答题1．什么是DNS？什么是DHCP服务器？答：域名系统DNS是互联网使用的命名系统，用来便于人们使用的机器名字转换为IP地址。动态主机配置协议DHCP提供了一种机制，称为即插即用连网。这种机制允许一台计算机自动加入新的网络和获取IP地址而不用手工参与。 什么是虚拟专用网络VPN？（P186）什么是网络地址转换NAT？(P188)答：虚拟专用网络VPN是指这种网络是为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信。如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么多有通过互联网传送的数据都必须加密。网络地址转换NAT是指在专用网连接到互联网的路由器上安装NAT软件。装有NAT软件的路由器叫作NAT路由器，它至少一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和互联网连接。 1.三报文握手建立TCP连接过程 P247第一次握手:客户端将报文标志位SYN置为1,产生一个序号值seq=x,将该数据包发送给服务器端后客户端进入SYN_SENT状态第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=x+1，随机产生一个序号值seq=y，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。第三次握手：客户端收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给服务器端，服务器端检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了 2.TCP和UDP的主要区别TCP提供面向连接、按序可靠的字节流服务（面向字节流）、有流量控制和拥塞控制。UDP提供无连接、不可靠的数据报服务（面向报文）。3.什么是VPN P1864.什么叫网络地址转换为NAT P188 5.什么是DNS P261将域名转换为IP地址 6.什么是DHCP P304动态 主机 配置 协议不需要手动的去配置ip地址以及其他的网络参数 7.什么是超文本传输协议HTTP答：超文本传输协议HTTP是面向事务的应用层协议，它是万维网上能够可靠的交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。协议HTTP不仅传送完成超文本跳转所必需的信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像等。 8.顶级域名分为哪几类 p263（1）国家顶级域名（2）通用顶级域名（3）基础结构域名9.域名服务器有哪几类 P265（1）根域名服务器（2）顶级域名服务器（3）权限域名服务器（4）本地域名服务器 10.什么是超文本标记语言HTML P283超文本标记语言HTML是一种制作万维网页面的标准语言，它消除了不同计算机之间信息交流的障碍11.什么是远程终端协议TELNET P271用户通过TCP登陆远地主机，远程操控远地主机，又称终端仿真协议12.什么是万维网www P272万维网是大规模的，联机式的信息储藏所，简称web13什么是统一资源定位符URL P274从互联网上获取资源位置和访问这些资源的方法6.什么叫做公用网和专用网？公用网：公用网用来提供服务。Client通过此网络与服务器通信。专用网：是某个部门为本单位的特殊工作的需要而建立的网络.这种网络不向本单位以外的人提供服务.例如,军队,铁路,电力等系统均有本系统的专用网。7.时延是由那几部分组成的？发送时延与传输时延的有什么区别？P22 8.IGP和EGP这两类协议的主要区别是什么? 答：内部网关协议IGP，是在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。外部网关协议EGP，是在不同的自治系统边界传递路由信息的协议，不关心自治系统内部使用何种协议。1、什么叫做“三网融合”？“三网融合”又叫“三网合一”，意指电信网络、有线电视网络和计算机网络的相互渗透、互相兼容、并逐步整合成为全世界统一的信息通信网络，其中互联网是其核心部分。2、什么叫做客户-服务器方式(C/S方式)？客户（Client）和服务器（Server）都是指通信种所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服务和被服务的关系。3、 什么叫做P2P方式？是指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机都运行了对等连接软件（P2P软件），它们就可以进行平等的、对等连接通信。这时，双方都可以下载对方已经存储在硬盘中的共享文档。因此这种的方式称为P2P方式。4、什么叫做电路交换？是指在同一电信网用户群中任意两个或多个用户终端之间建立电路暂时连接的交换方式。暂时连接独占一条通信路径并保持到连接释放为止例如，用固定电话拨打电话的数据传送方式属于（电路交换）。5、什么叫做报文交换？报文交换不要求在两个通信节点之间建立专用通路。节点把要发送的信息组织成一个数据包一报文，该报文中含有目标节点的地址，完整的报文在网络中一站一站地向前传送。每一个节点接收整个报文，检查目标节点地址，然后根据网络中的交通情况在适当的时候转发到下一个节点。经过多次的存储一转发，最后到达目标，因而这样的网络叫存储一转发网络。6、什么叫分组交换？分组交换也称为包交换，它将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组。首部指明了该分组发送的地址，当交换机收到分组之后，将根据首部中的地址信息将分组转发到目的地，这个过程就是分组交换。7、什么虚电路交换？所谓交换虚电路(SVC)就是两个数据终端要通信时先用呼叫程序建立电路（即虚电路），然后发送数据，通信结束后用拆线程序拆除虚电路。通过蓝牙无线技术连接起来的网络属于（ ）。8、什么叫做广域网？广域网(Wide Area Network ,简称WAN)是一种跨地区的数据通讯网络,通常包含一个国家或地区。广域网通常由两个或多个局域网组成。9、什么叫做城域网？城域网(Metropolitan Area Network)是在一个城市范围内所建立的计算机通信网，简称MAN。属宽带局域网。10、什么叫做局域网？局域网的覆盖范围一般是方圆几千米之内，其具备的安装便捷、成本节约、扩展方便等特点使其在各类办公室内运用广泛。11、什么叫做个域网？个人域网（PAN），是指能在便携式消费电器与通信设备之间进行短距离通信的网络，其覆盖范围一般在10米半径以内。 作图： P451、能根据比特流画出曼彻斯特编码、差分曼彻斯特编码、归零制和不归零制编码的图。2、能根据基带信号画出最基本调制方法中的调幅和调频图。调幅：对基带信号的波幅进行调整，例如将上图的1信号波幅进行改变，在接收方读取时有载波输出为1.调频：对基带信号频率进行调整，例如将0信号调制为频率f1，1信号调制为频率f2。调相：对基带信号相位进行调制，例如将0信号的初相位调整为0度，1信号的初相位调整为180度。 计算CIDR地址快的使用（即路由聚合方法），如课本129页的图4-13。 有如下的5个/24地址块，试进行最大可能的聚合。 156.152.0/24 156.153.0/24 156.154.0/24 156.155.0/24 156.156.0/24解：这几块地址前面两个字节一样，只需比较第三个字节： 156.152.0/24 第三个字节 1001 1000 156.153.0/24第三个字节 1001 1001 156.154.0/24第三个字节 1001 1010 156.155.0/24第三个字节 1001 1011 156.156.0/24第三个字节 1001 1100那么这五个地址块的共同前缀有21位：212.156. 1001 1最大可能聚合地址块是：212.156.1001 1000.00000000/21=212.156.152.0/21 2、 某单位分配到一个地址块136.23.12.32 /27。现在需要进一步划分为4 个一样大的子网。试问：（1）每个子网的网络前缀有多长？（2）每一个子网中有多少个地址？（3）每一个子网的地址块是什么？（4）每一个子网可分配给主机使用的最小地址和最大地址是什么？答：将136.23.12.32 /27转换为二进制：10001000 00010111 00001100 00100000/27（1）根据题意，建立4个子网，要借2位为子网号，22=4，所以网络前缀为27+2=29位，剩下32-29=3位作主机位。 所以每个子网前缀有29位。 （2）每个子网的地址中有3位留给主机用，因此共有23=8个地址。 （3）（4）四 个子网的地址块以及每个子网分配给主机的最小地址和最大地址是：第一个地址块136.23.12.32 /29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00100 000/29最小地址：136.23.12.33（00100 001）最大地址: 136.23.12.38（00100 110）第二个地址块136.23.12.40/29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00101 000/29最小地址：136.23.12.41（00101 001）最大地址：136.23.12.46（00101 110）第三个地址块136.23.12.48 /29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00110 000/29最小地址：136.23.12.49（00110 001）最大地址：136.23.12.54（00110 110）第四个地址块：136.23.12.56/29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00111 000/29最小地址：136.23.12.57（00111 001）最大地址：136.23.12.62（00111 110） 3、 某单位分配到地址块136.230/16。该单位有2000 台机器，平均分布在 8个不同的地点。试给每一个地点分配一个地址块，并计算出每个地址块中IP地址的最小值和最大值（说明：必须有完整的解题步骤，否则不得分。）答：2000/8=250，每个点平均250台电脑。如选255.255.255.0为掩码，每个子网有28-2=254&gt;250，共有子网数=28-2=254&gt;8，能满足实际需求。每个地点的网络前缀和主机IP地址的最小值和最大值为：地点 子网号 子网络地址 主机的最小值和值1 00000001 136.230.1.0/24 : 136.230.1.1–136.230.1.2542 00000002 136.230.2.0/24 : 136.230.2.1–136.230.2.2543 00000003 136.230.3.0/24 : 136.230.3.1–136.230.3.254………………………………..7 00000007 136.230.7.0/24 : 136.230.7.1–136.230.7.2548 00000001 136.230.8.0/24 : 136.230.8.1–136.230.8.254 4、某组织分配到一个地址块，其中第一个地址是14.24.74.0/24。这个组织需要划分为11个子网。具体要求是：具有64个地址的子网两个；具有32个地址的子网两个；具有16个地址的子网三个；具有4个地址的子网四个（这里的地址包括网络地址和广播地址）。试设计这些子网。分配结束后还剩下多少地址？（说明：必须有完整的解题步骤，否则不得分。）解答：将14.24.74.0/24转换为二进制：00001110 00011000 01001010 00000000/24 具有64个地址的子网2个：根据要求可知，要借2位为子网号，因为每个子网为64个地址，所以主机号最少要保留6位才能满足每个子网64个地址，主机号共有8位，剩下8-2=6位可借给网络号。00001110 00011000 01001010 00 000000 转为十进制：14.24.74.0/2600001110 00011000 01001010 01 000000 转为十进制：14.24.74.64/262）具有32个地址的子网2个因为每个子网为32个地址，所以主机号最少要保留5位才能满足每个子网32个地址，主机号共有8位，剩下8-5=3位可借给网络号。00001110 00011000 01001010 100 00000 转为十进制：14.24.74.128/2700001110 00011000 01001010 101 00000 转为十进制：14.24.74.160/273）具有16个地址的子网3个因为每个子网为16个地址，所以主机号最少要保留4位才能满足每个子网16个地址，主机号共有8位，剩下8-4=4位可借给网络号。00001110 00011000 01001010 1100 0000 转为十进制：14.24.74.192/2800001110 00011000 01001010 1101 0000 转为十进制：14.24.74.208/2800001110 00011000 01001010 1110 0000 转为十进制：14.24.74.224/284）具有4个地址的子网4个因为每个子网为4个地址，所以主机号最少要保留2位才能满足每个子网4个地址，主机号共有8位，剩下8-2=6位可借给网络号。00001110 00011000 01001010 111100 00 转为十进制：14.24.74.240/3000001110 00011000 01001010 111101 00 转为十进制：14.24.74.244/3000001110 00011000 01001010 111110 00 转为十进制：14.24.74.248/3000001110 00011000 01001010 111111 00 转为十进制：14.24.74.252/30全部256个地址已经分配完毕，没有剩下的地址。 超文本传输协议（HTTP）在开始讲解爬虫之前，我们稍微对超文本传输协议（HTTP）做一些回顾，因为我们在网页上看到的内容通常是浏览器执行 HTML （超文本标记语言）得到的结果，而 HTTP 就是传输 HTML 数据的协议。HTTP 和其他很多应用级协议一样是构建在 TCP（传输控制协议）之上的，它利用了 TCP 提供的可靠的传输服务实现了 Web 应用中的数据交换。按照维基百科上的介绍，设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法，也就是说，这个协议是浏览器和 Web 服务器之间传输的数据的载体。关于 HTTP 的详细信息以及目前的发展状况，大家可以阅读《HTTP 协议入门》、《互联网协议入门》、《图解 HTTPS 协议》等文章进行了解。 图2. HTTP请求 HTTP 请求通常是由请求行、请求头、空行、消息体四个部分构成，如果没有数据发给服务器，消息体就不是必须的部分。请求行中包含了请求方法（GET、POST 等，如下表所示）、资源路径和协议版本；请求头由若干键值对构成，包含了浏览器、编码方式、首选语言、缓存策略等信息；请求头的后面是空行和消息体。 图3. HTTP响应 HTTP 响应通常是由响应行、响应头、空行、消息体四个部分构成，其中消息体是服务响应的数据，可能是 HTML 页面，也有可能是JSON或二进制数据等。响应行中包含了协议版本和响应状态码，响应状态码有很多种，常见的如下表所示。","categories":[{"name":"前端","slug":"前端","permalink":"https://wenkexia.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://wenkexia.github.io/tags/web/"},{"name":"计网","slug":"计网","permalink":"https://wenkexia.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"java基础","slug":"java基础","date":"2021-12-24T00:53:47.000Z","updated":"2021-12-24T00:53:47.000Z","comments":true,"path":"2021/122465132.html","link":"","permalink":"https://wenkexia.github.io/2021/122465132.html","excerpt":"","text":"字符标识符命名规则可以包含数字，但不能以数字开头除了下划线_,和$符之外，不能有其它特殊字符，如空格区分字母大小写不能使用Java关键字换行符\\n要加双引号System.out.println(“名字”+“\\n”); 注释单行注释：//多行注释：从“/”开始到“/”结束，文档注释：从“/*”开始到“/”结束文档注释可以用javadoc命令提取出来，生成类似于jdk文档的网页文件，以便于他人了解一个类的功能。 变量变量基本结构：类型 变量名 =值 前面不可以有访问符 数据类型8种基本数据类型数值型 整数short型（短整型）数据在内存中占用2个字节long型（长整型）数据在内存中占用8个字节。int型（整型）数据在内存中占用4个字节。byte型（字节型）数据在内存中占用1个字节，表示的存储数据范围为：-128~127。 浮点数 float型（单精度浮点型）数据在内存中占用4个字节。 float t = 3.1f f转为double型 double型（双精度浮点型）数据在内存中占用8个字节。 一般小数默认是double型 字符型char每个字符占2个字节，定义时用单引号’ ‘布尔型boolean：数据值只有true或false，适用于逻辑计算。引用数据类型类 字符串类型String最常用的一种存储文本的数据类型，用双引号“”任何数据+字符串操作结果都是字符串使用关键字和构造方法来创建 String 对象。String str2=new String(“Runoob”);有内置方法hashCode() 方法用于返回字符串的哈希码。length() 方法，它返回字符串对象包含的字符数。 流程控制判断语句if条件语句switch多重选择循环语句while循环do while循环for循环12345for (初始条件; 循环检测条件; 循环后更新计数器) { // 执行语句}break语句通常都是配合if语句使用。要特别注意，break语句总是跳出自己所在的那一层循环continue则是提前结束本次循环，直接继续执行下次循环 for each循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的List、Map等。 数组遍历数组for循环通过索引来访问 12345int[] ns = { 1, 4, 9, 16, 25 };for (int i=0; i&lt;ns.length; i++) { int n = ns[i]; System.out.println(n);} for each循环直接迭代数组的每个元素 第七章异常 Error严重的错误 OutOfMemoryError：内存耗尽 NoClassDefFoundError：无法加载某个Class StackOverflowError：栈溢出 Exceptio是运行时的错误，它可以被捕获并处理。 RuntimeException以及它的子类； 非RuntimeException （包括IOException、ReflectiveOperationException等等） 异常类分为两种 1.错误。一般指与虚拟机相关的问题，这些错误无法恢复和捕获 2.异常（Exception），因编码错误或外在因素导致的问题 两种异常处理机制 1.使用try catch捕获异常 存在多个catch的时候，catch的顺序非常重要：子类必须写在前面 2.trrows抛出异常 面对对象一.类和对象1.属性直接把field用public暴露给外部可能会破坏封装性，所以用private外部代码可以调用get()方法和set()方法来间接获取和修改指定的私有成员变量的值 2.方法 定义语法 1234修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值;} 若方法中没有returun返回值，则该方法的返回类型为void类型 参数方法的参数传递机制形参：声明方法时定义的参数，形参前必须有数据类型 格式：方法名（数据类型 形参）实参：调用方法时给方法传递的实际数据，使用格式：对象名.方法名（实参） 可变参数：定义格式方法名（参数列表，数据类型 … 变量）注意：可变参数只能处于参数列表的最后一个方法最多只能包含一个可变参数可变参数本质是一个数组，因此在调用时，既可以传入多个参数，也可传入一个数组 构造方法作用：在创建对象时初始化对象中的属性值构造方法的名称必须是类名。构造方法没有返回类型（也没有void），调用构造方法，必须用new操作符。不能被static、final、synchronized、abstract和native修饰。构造方法不能被子类继承，所以用final和abstract修饰没有意义。 构造方法用于初始化一个新建的对象，所以用static修饰没有意义语法：访问符 类名 （参数）{} this关键字：this代表当前对象的内存地址，在实例方法或者构造方法中，为了区分局部变量和实例变量，this不能省略代表当前类将来产生的对象，即将来用该类new出来的对象，用于获取当前类的对象的引用 方法的调用1.调用非静态方法 对象名.方法名（）2.调用静态方法 类名.方法名() 12Person p1 = new Person(\"Xiao Ming\", 15); // 既可以调用带参数的构造方法Person p2 = new Person(); // 也可以调用无参数构造方法 方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。目的：功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。 方法重写子类重写了父类的方法注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法 对象创建对象语法：类名 变量名=new 类名();创建类的对象分为两步1.定义该类的一个变量，此时在栈上会分配空间储存对象在堆中的地址（即对象的引用）2.创建该对象的实际物理空间，即在堆中为该对象分配空间，并把此空间的地址（即引用）赋给对象名，此步骤通过new关键字来实例化该类的一个对象 使用对象创建对象后就可以使用对象访问对象的属性 语法：对象名.属性名调用对象的方法 语法：对象名.方法名（） 二.面向对象三大特征封装实际上就是信息隐藏，将类中的成员属性和成员方法修饰为私有化，数据被保护在对象的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系，即get/set方法。 其他对象只能通过该对象提供的get/set方法，与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外提供的接口来访问该对象。 访问符：用于指明类、属性或方法的访问权限public公共访问权限，可被同一包或不同包的所有类访问protected子类访问权限，可以被同一包的其它类访问，也可以被其他包的子类访问friendly包访问权限，如果没设置访问符则默认friendly包访问权限，可被同一包中所有类访问private 当前类访问权限，只能被当前类的其它成员访问 修饰符：用于指明类的特性 abstarct（抽象） static（静态） final（最终） 如果有很多代码都使用了Dog这个类；当某一天这个类的age属性需要换成String类型，那么，外部使用它的任何地方都需要需改xxx.age=”xxx”，这将是非常繁琐的一个过程，那该怎么办呢？很简单，使用private修饰符将属性封装，开放访问接口的方法，我们只需要修改一下set方法就能完美解决。 1234567891011121314151617public static void main(String[] args) { Dog d1 = new Dog(); //调用时发生变化 d1.setName(\"旺财\"); d1.setAge(3); }}class Dog{ private String age;//修改为String类型 private String name; //将属性私有化，提供set方法，将int类型的值转成String public void setAge(int age) { this.age = String.valueOf(age); } public void setName(String name) { this.name = name; } 这样外部使用它的地方都不用修改，我们只用简单的修改对象内部就可以了，更加方便快捷。到了这里我们应该可以看出，封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。 这里还可以体现出一些封装属性的优势，案例如下： 12345678910111213141516171819202122public static void main(String[] args) { Dog d1 = new Dog(); d1.setName(\"旺财\"); d1.setAge(300);//狗的年龄赋值很明显不合理，这里就需要在set方法中给出提示 }}class Dog{ private String age; private String name; public void setAge(int age) { if(age&gt;100||age&lt;0) { System.out.println(\"你见过超过100岁的狗狗吗？\"); }else { this.age = String.valueOf(age); } } public void setName(String name) { this.name = name; } } 继承作用：通过继承，子类可以使用父类中的非私有属性和非私有方法，从而提高代码的重用性，提高开发效率。子类自动获得了父类的所有字段，严禁定义与父类重名的字段！为了让子类可以访问父类的字段，把private改为protected。用protected修饰的字段可以被子类访问除了父类中私有的属性和方法，子类必须全部继承。3、子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。4、子类可以用自己的方式实现父类的方法（即方法的重写/覆盖）。5、构造器而言，它只能够被调用，而不能被继承，子类可以使用super()调用父类构造器。6、对于继承而已，子类会默认调用父类的无参构造，但是如果父类没有无参构造，子类必须要在其构造方法中的第一行代码调用指定父类的构造器，传递对应参数。7、Java 的继承是单继承，即每个子类只能拥有一个直接父类，但是该父类可以有多个子类通过extends关键字实现继承语法格式访问符 修饰符 class 子类 extends 父类{ } 12345678910111213141516171819202122232425class Father{ //父类中的非私有属性都会被继承 public int age; private double money; String home; //父类中的非私有方法都会被继承 void eat() {} //吃东西 public void sleep() {}//睡觉 private void soner() {}//打呼噜 //父类构造方法如果有参数，子类必须在构造方法第一行中调用 public Father(int x) { //父类如果写了有参构造，那么默认的无参构造将不再生效 }}class Son extends Father{ public Son(int x) { super(x);//调用父类构造 super() age=12;//继承后拥有父类的属性 home=\"王者峡谷河道下边的草丛\"; //money=3.0; 父类私有属性无法访问 sleep();//可以执行父类中的非私有方法 } } 子类继承父类，默认在子类构造方法中调用父类构造，在创建子类实例对象时，实际上的执行顺序是（父类构造——子类构造）。在类的构造器中还有一段特别的代码，优先与构造器，在创建对象时优先执行，话不多说直接看代码： 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) { Z z1 = new Z();//创建子类实例对象时，实际上的执行顺序 } }class F { static { //静态代码块，只有方法的大括号，没有方法名返回值等任何内容 System.out.println(\"父类静态代码块\"); } { //构造代码块，只有方法的大括号，没有方法名返回值等任何内容 System.out.println(\"父类构造代码块\"); } public F() { // 父类构造器 System.out.println(\"父类构造器\"); }}class Z extends F{ static { //静态代码块，只有方法的大括号，没有方法名返回值等任何内容 System.out.println(\"子类静态代码块\"); } { //构造代码块，只有方法的大括号，没有方法名返回值等任何内容 System.out.println(\"子类构造代码块\"); } public Z() { // 父类构造器 System.out.println(\"子类构造器\"); }} 运行结果 123456父类静态代码块子类静态代码块父类构造代码块父类构造器子类构造代码块子类构造器 多态面向对象三大特征，封装、继承、多态。从某种意义上来讲，封装和继承几乎就是为了多态而准备的，也是三大特征中最重要的知识点。 多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。简单来说就是不同类型的对象（父类或子类）调用同一个方法，根据发出调用的对象不同，执行的方法也就不同。 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 多态的作用：消除类型之间的耦合关系。 这里举一个简单的小例子：父类是个农民，技能是使用锄头耕地。子类继承了父类，重写了父类的锄头耕地技能，更新换代为使用拖拉机耕地。如果是父类对象调用这个技能，就是使用锄头手动耕地，如果是子类对象调用这个技能，就是使用拖拉机耕地。 java实现多态有三个必要条件：继承、重写、父类引用指向子类对象。继承：在多态中必须存在有继承关系的子类和父类。重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。父类引用指向子类对象（向上转型）：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 123456789101112131415161718192021222324252627282930public class People {//人类 作为所有职业的父类 public int age; public String name; void work() {//父类的方法 System.out.println(\"劳动\"); } public static void main(String[] args) { //父类引用指向子类对象就是多态性的体现 People p1 = new Doctor();// p1的类型是人类类型，但是指向的实例对象是医生 p1.work();//父类引用发出的调用，调用到的是医生类中重写父类的方法 People p2 = new Teacher(); p2.work();//父类引用发出的调用，调用到的是教师类中重写父类的方法 } } class Doctor extends People{ @Override void work() {//医生类继承人类，重写工作方法 System.out.println(\"救死扶伤\"); } }class Teacher extends People{ @Override void work() {//教师类继承人类，重写工作方法 System.out.println(\"教书育人\"); }} 运行结果 12救死扶伤教书育人 注意：指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的。比如说方法的重载，尽管方法名称相同，但是父类只能调用到子类重写的方法，调用不到重载方法。 12345678910 class Teacher extends People{ @Override void work() {//教师类继承人类，重写work方法 System.out.println(\"教书育人\"); } void work(String name) {//重载了work方法，但是此方法父类引用无法调用 System.out.println(\"负责教导的课程是\"+name); }}多态的好处： 1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如：医生、律师、程序员都是人类的子类，根据使用场景不同随时可以替换为符合的职业。2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在拥有了医生、律师的继承上，还可以继续添加新的职业，比如主播，运动员等，都是添加为人类的多态性。3.接口性（interface-ability）。多态是超类通过抽象方法，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。每个子类都可以根据自身的特性去重写父类的抽象方法。4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 https://blog.csdn.net/weixin_37942054/article/details/119081228?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164069407816780265482575%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164069407816780265482575&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-119081228.pc_search_insert_es_download&amp;utm_term=java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&amp;spm=1018.2226.3001.4187 三.类之间的关系继承依赖关系在一个类的方法中操作另一个类的对象，则称其依赖于第二个类例如方法的参数时某个类的对象 关联关系体现为一个类中使用另一个类的对象作为该类的成员变量 聚合关系聚合关系是关联关系的一种特例，体现是整体与部分的关系，表现为一个类（整体）由多个其他类的对象（部分）作为该类的成员变量 组成关系抽象类定义抽象类语法格式： 123访问符 abstract class 类名{ 访问符 abstract 返回类型 方法名（参数列表）} 有抽象方法的类只能被定义为抽象类，但抽象类中可以没有抽象方法抽象类不能被实例化，即无法用new创建一个抽象类的对象抽象类作为子类的模版，避免子类设计的随意性对象不能由抽象类直接创建，只可以通过抽象类派生出新的子类，再由其子类来创建对象abstract 关键字不能用来修饰属性和构造方法抽象方法必须被子类重写才有意义，因此不能用private修饰抽象方法抽象方法,没有方法体 12public abstract void call（）； //抽象方法，没有{}括起来的方法体public void call（）{}. //空方法 使用抽象类写一个子类继承抽象类，重写抽象方法虽然不能直接new一个抽象类，但可以先声明一个抽象类变量，再用这个变量指向其子类对象 12抽象类名 a;a = new 子类名(); 接口接口规定一批类必须提供某些方法，但不提供实现方法不能用final关键字修饰接口 定义接口接口是隐性抽象的，不必使用abstract用关键字interface定义 1234567891011访问符 interface 接口名 {//接口定义的只能是静态常量int a = 5;//接口定义的普通方法只能是public的抽象方法void display();//接口中定义默认方法，用default修饰default void print(int b){}//接口中定义类方法，用static修饰static void del(){}} 注意：访问符可以是public或默认，默认是采用包权限访问控制，即在相同包内才可以访问该接口成员变量被隐含地声明为public static final，属性只能是静态常量接口中的方法被隐形指定为public absrtact接口定义的方法只能是定抽象方法，默认方法，类方法接口内定义的常量和方法默认为public,可以不写 实现接口用implements实现接口一个类可实现多个接口，且必须实现接口中定义的所有抽象方法，否则该类必须定义为抽象类语法格式： 12345678910111213访问符 class implements 接口1，接口2{}public static void main (String[]args){//先声明一个接口类型的变量，new一个该接口实现类的实例对象，并将其引用赋值给变量接口名 变量名 = new 接口实现类（）;//调用接口的默认方法，必须通过实例对象来调用变量名.默认方法（）;//调用接口的类方法接口名.类方法（）;//声明接口实现类的变量，并实例化该类型对象接口实现类名 变量名 = new 接口实现类名（）;} 接口的继承接口可以继承多个接口，不能继承类使用interface可以声明一个接口： 1234interface Person { void run(); String getName();} 属性只能是常量 一个类可以实现多个interface，例如： 123class Student implements Person, Hello { // 实现了两个interface ...} 核心类字符串类每个用双引号括起来的字符串都是String类的一个实例 内部类java允许在一个类的类体里再定义一个类，该情况下外面的类叫外部类，里面的叫内部类内部类可以访问其所在内部类的所有属性 成员内部类在外部类的内部定义一个类 静态内部类非静态内部类局部内部类匿名内部类final class就不能被别的类继承 习题简答题1、java源程序在控制台环境下编译和运行的命令是什么？编译之后生成了什么文件？编译Javac name.java 生成.class文件运行Java name 2．Java的数据类型分为哪几种？请列举出8个Java的基本数据类型。 byte short int long double float char boolean 继承的主要作用是什么？如何使用一个子类继承一个父类？通过继承，子类可以使用父类的非私有属性和非私有方法，从而提高代码重用性，提高开发效率 4、continue的功能是什么？break的功能是什么？两者的区别？continue跳出本次循环，直接执行下一次循环break直接跳出本层循环 toString 方法的功能是什么？如何使用toString 来实现方法重写？toString()将对象的内容转换为字符串当需要将一个对象输出到显示器时,通常要调用他的toString()方法,将对象的内容转换为字符串.java中的所有类默认都有一个toString()方法 默认情况下 System.out.println(对象名)或者System.out.println(对象名.toString())输出的是此对象的类名和此对象对应内存的首地址 如果想自定义输出信息必须重写toString()方法 12345678/*注意事项1.必须被声明为public2.返回类型为String3.方法的名称必须为toString,且无参数4.方法体中不要使用输出方法System.out.println()语法格式为*/public String toString(){ } 6、构造方法的作用是什么？在创建对象时，初始化对象的属性 什么是抽象方法？什么是抽象类？抽象类就是不能使用new方法进行实例化的类，即没有具体实例对象的类抽象方法：抽象方法就是以abstract修饰的方法，这种方法只声明返回的数据类型，方法名称和所需要的参数，没有方法体，这个方法必须被子类的方法所重写 8 什么是类间的依赖关系？什么是类的关联关系？什么是类的聚合关系？什么是类的组成关系？ 依赖关系在一个类的方法中操作另一个类的对象，则称其依赖于第二个类例如方法的参数时某个类的对象 关联关系体现为一个类中使用另一个类的对象作为该类的成员变量 聚合关系是关联关系的一种特例，表现为一个类（整体）由多个其他类的对象（部分）作为该类的成员变量 super关键字的主要作用是什么？对于有继承关系的类，子类可以通过这个关键字调用父类中的方法写法，即 super（构造方法名），而且必须是这个构造方法的第一句。在子类的构造方法中调用父类的构造方法在子类方法访问父类的属性和方法 this代表什么？this大部分情况下是可以省略的，请说明什么时候不能省略this。this是一个变量，保存了当前对象的内存地址，指向这个对象自身。this代表的就是 “当前对象”在实例方法或者构造方法当中，为了区分同名的局部变量和实例变量，this不能省略 Java中包含哪几种内部类？什么是成员内部类？什么是局部内部类？什么是最终类？包含：成员内部类、局部内部类、静态内部类、匿名内部类成员内部类：在“外部类”的内部定义一个类，作为一个成员存在，与外部类的属性、方法并列局部内部类：在方法中定义的内部类称为局部内部类，不仅可以访问包含它的外部类成员，还可以访问局部变量最终类：最终类有final关键字修饰，最终类不可被继承 什么是类？类里面包含什么？什么是对象？两者之间的区别是什么？类：类是具有相同属性和方法的一组对象的集合类包含字段和方法对象：对象是一具体事物区别：对象是类的一个实例，拥有类定义的属性和方法 java中有哪几种注释？分别用什么符号表示？单行注释：//多行注释：从“/”开始到“/”结束，文档注释：从“/*”开始到“/”结束文档注释可以用javadoc命令提取出来，生成类似于jdk文档的网页文件，以便于他人了解一个类的功能。 什么是缺省构造器？它的作用是什么？缺省构造器什么时候无法产生作用？如果一个类没有定义构造方法，编译器会自动创建一个缺省构造器作用在创建对象时初始化对象的属性如果你已经定义了一个无参构造方法， public、private、protected三个访问控制符代表了不同的访问级别，请分别进行说明。public公共访问权限，可被同一包或不同包的所有类访问protected子类访问权限，可以被同一包的其它类访问，也可以被其他包的子类访问friendly包访问权限，如果没设置访问符则默认friendly包访问权限，可被同一包中所有类访问private 当前类访问权限，只能被当前类的其它成员访问 什么是多态？多态在代码中的表现形式是什么？多态的作用？同一个对象在不同阶段，多种状态表现形式：继承、重写、父类引用指向子类对象作用：可以将子类对象直接赋值给一个父类引用变量，无须任何类型转换 一个”.java”源文件中是否可以包括多个类(不是内部类)?有什么限制?可以，但只能有一个public类，并且public的类名必须和文件名一致 final关键字的主要作用是什么？被final关键字修饰的类不能被继承，被final关键字修饰的类属性和类方法不能被覆盖（重写）； 什么是接口？接口如何定义？接口中能够包含哪些方法？接口和类在继承方面的区别。接口可以定义抽象方法，默认方法，类方法接口可以多继承，即一个接口可以继承多个接口类只能单继承，一个子类只能有一个直接父类 什么是方法重载？什么是方法重写？两者的区别？方法重载是指在同一个类中定义多个同名的方法，但要求每个方法具有不同的参数类型或者参数个数方法重写是指在子类创建一个与父类中除了方法体的实现不同外，其它都相同的方法，以便实现不同于父类的功能 判断一个变量的数据是奇数还是偶数12345678910111213141516171819public class Test { public static void main(String[] args) { judgeNum(2); judgeNum(3);}/*** 判断是奇数还是偶数的方法* @param num*/public static void judgeNum(int num) { if(num % 2 == 0) { System.out.println(num + \"是偶数\");} else { System.out.println(num + \"是奇数\");}}} 计算 1000 以内不能被 7 整除的整数之和。1234567891011public class Test02 { public static void main(String[] args) { int s=0; for(int i=1;i&lt;=1000;i++){ if((i%7)!=0){ s=s+i; } } System.out.println(s); }} 计算 1+2-3+4-5+…+100 的结果。12345678910111213141516171819public class Method03 { public static void main(String[] args) { int res = getSum(); System.out.println(res); } /* 返回值类型: int 方法名称： getSum 参数列表： */ public static int getSum(){ int sum = 0; for (int i = 1; i &lt;= 100; i++) { sum += i; } return sum; } 定义一个方法，计算某个整数的阶乘。1234567891011121314public class Method04 { public static void main(String[] args) { int res = jieCheng(5); System.out.println(res); } public static int jieCheng(int num) { int result = 1; for (int i = num; i &gt; 1; i--) { result *= i; } return result; }} 定义一个方法，判断某个整数是否为质数。（质数是指大于 1 的自然数中，除了 1 和它本身之外不再有其它因数的自然数。） 12345678910111213141516171819202122232425public class Test02 { public static void main(String[] args) { System.out.println(prime(3)); } //定义方法 public static boolean prime(int n) { //先判断小于0的 if (n &lt; 0) { return false; } if (n == 1 || n == 2) { return true; } else { int a = (int) Math.sqrt(n); //如9%3=0 他除了1合本身还有别的数 for (int i = 2; i &lt;= a; i++) { if (n % i == 0) { return false; } } return true; } }} 小红的妈妈每天都会给她 2.5 元钱，她都会存起来。但是，如果这一天是存钱的第 5 天或者是 5 的倍数的话，她都会花去 6 元。请问：经过多少天，小红才可以存到 100 元钱。 123456789101112131415public class XiTi5 { public static void main(String[] args){ double sum = 0; for(int i=1;;i++){ sum = 2.5 + sum; if(i%5==0){ sum = sum-6; } if(sum&gt;=100){ System.out.println(\"经过\"+i+\"天可以存到100元钱\"+\",\"+\"钱的总数是\"+sum+\"元\"); break; } } }} 水仙花数一个数如果是一个三位数，并且它的十位、个位、百位的数字立方和等于它本身，这个数就叫做水仙花数。例如：371 = 3 的立方+7 的立方+1 的立方。 请求出所有水仙花数。 123456789101112131415public class XiTi6 { public static void main(String[] args) { int a,b,c,s; for(int i=100;i&lt;1000;i++) { c=i%10; b=(i/10)%10; a=i/100; if(Math.pow(a,3)+Math.pow(b,3)+Math.pow(c,3)==i) { System.out.print(\" \"+i); } } }} 求出数组中的最大值[5, 15, 30, 20, 1000] 12345678910111213141516public class Array03 { public static void main(String[] args) { int[] array = {5, 15, 30, 20, 1000}; int max; max = array[0]; for (int i = 1; i &lt; array.length; i++) { if(array[i] &gt; max) { max = array[i]; } } System.out.println(\"max:\" + max); }} 数组元素反转本来：[10, 30, 20, 40, 50]结果：[50，40, 20, 30, 10]要求不能使用新数组，就用原来的唯一一个数组。 12345678910111213141516171819202122232425262728293031323334public class Array04 { public static void main(String[] args) { int[] array = {10, 20, 30, 40, 50}; //遍历打印数组本来的样子 for (int i = 0; i &lt; array.length; i++) { System.out.println(array[i]); } System.out.println(\"==================\"); /* 初始化语句： int min = 0, max = array.length - 1; 条件判断： min &lt; max 步进表达式： min++, max-- 循环体：交换 */ for(int min = 0, max = array.length - 1; min &lt; max; min++, max--) { //交换 int temp = array[min]; array[min] = array[max]; array[max] = temp; } for (int i = 0; i &lt; array.length; i++) { System.out.println(array[i]); } }} 对象数组定义一个数组，用来存储 3 个 Person 类的对象break &amp; continue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class Person { //属性 == 实例变量 private String name; private int age; //构造方法 public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } //setter getter public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}public class PersonTe { public static void main(String[] args) { //首先创建一个长度为3的数组，用来存放Person类型的对象 Person[] array = new Person[3]; System.out.println(array[0]); //创建3个对象 Person p1 = new Person(\"ZhangSan\", 18); Person p2 = new Person(\"ZhangSa\", 19); Person p3 = new Person(\"Zhang\", 20); //赋值 array[0] = p1; array[1] = p2; array[2] = p3; System.out.println(array[1].getName()); }}public class PersonTest { public static void main(String[] args) { Person01 p1 = new Person01(); p1.name = \"ZhangSan\"; p1.sayHello(\"Lisi\"); System.out.println(p1); }}class Person01{ //实例变量 String name; //实例方法 public void sayHello(String name) { System.out.println(name + \" , hello, I am \" + this.name); System.out.println(this); }} 实现一个 student 类包含属性：name age address zipCode要求：全部属性都私有化，并提供相应的 get/set 方法以及无参构造方法和有参构造方法。并为该类添加一个方法，返回 student 对象的地址和邮编。最后编写测试类，返回自己的地址邮编。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Student { //实例变量 private String name; private int age; private String address; private String zipcode; //静态变量：类级别 static String job = \"study\"; //无参构造 public Student(){ } //有参构造 public Student(String name, int age, String address, String zipcode) { this.name = name; this.address = address; this.age = age; this.zipcode = zipcode; } //返回地址和邮编 public String getPostAddress() { return \"地址：\" + this.address + \" , 邮编：\" + this.zipcode; //return \"地址：\" + this.g + \" , 邮编：\" + this.zipcode; } public void study() { System.out.println(this.getName() + \"is studying.\"); } //静态方法 public static void testStatic() { System.out.println(\"static\"); } //getter and setter public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}public class StudentTest { public static void main(String[] args) { Student s1 = new Student(); s1.setName(\"XiaoMei\"); s1.setAge(20); System.out.println(s1.getName() + \",\" + s1.getAge()); Student s2 = new Student(\"XiaoMing\", 18, \"佛山\", \"374893748\"); System.out.println(s2.getPostAddress()); }} 实现一个日期类，表示年月日信息。要求：全部属性都私有化，并提供相应的 get/set 方法以及无参构造方法和有参构造方法。如果调用无参构造方法，默认创建的日期为 1970 年 1 月 1 号。并为该类添加一个可以打印日期的方法。最后编写测试类输出 2022 年 1 月 1 日。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Date { //实例变量 private int year; private int month; private int day; //无参构造 public Date() { this.year = 1999; this.month = 1; this.day = 1; } //有参构造 public Date(int year, int month, int day){ this.year = year; this.month = month; this.day = day; } //setter and getter public void setYear(int year) { //设立关卡 this.year = year; } public int getYear() { return year; } //打印的日期方法 public void printDate() { //System.out.println(this.year + \"年\" + this.month + \"月\" + this.day + \"日\"); //System.out.println(year + \"年\" + month + \"月\" + day + \"日\"); System.out.println(this.getYear() + \"年\" + this.month + \"月\" + this.day + \"日\"); }}public class DateTest { public static void main(String[] args) { Date d1 = new Date(); d1.printDate(); Date d2 = new Date(2021, 11, 16); //System.out.println(d2.printDate()); }} 继承和方法覆盖： 实现说话中国人说中文，输出 小美说中文美国人说英文， 输出 jack 说英文（要求用多态实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class PersonTest { public static void main(String[] args) { Chinese chinese = new Chinese(); chinese.setName(\"XiaoMei\"); chinese.speak(); American american = new American(); american.setName(\"Jack\"); american.speak(); }}//父类class Person{ //属性 private String name; //构造方法 public Person(){} public Person(String name){ this.name = name; } //setter and getter public void setName(String name) { this.name = name; } public String getName() { return name; } //speak public void speak(){ System.out.println(name + \" is speaking...\"); }}//子类class Chinese extends Person{ @Override public void speak(){ System.out.println(this.getName() + \" is speaking Chinese.\"); }}class American extends Person{ @Override public void speak(){ System.out.println(this.getName() + \" is speaking English.\"); }}## 1、编写程序模拟 主人 喂养 宠物 的场景。 主人养了一只狗作为宠物， 主人会喂狗，只要主人喂狗，狗就吃 最后输出：主人喂了食物，狗吃的很香 过了一段时间，主人又养了一个新的宠物：猫咪 最后输出：主人喂了食物，猫吃的很香 ```javaclass Testfeed{ public static void main(String[] args) { //创建一个宠物对象 Pet pet = new Pet(); //创建一个狗对象 Dog dog = new Dog(); //创建一个主人对象 Master master = new Master(); //调用主人投喂方法 master.feed(dog); }}class Pet{//创建宠物类让其它类都继承他 public void eat(){//创建宠物吃方法 System.out.println(\"动物在吃\"); }}class Dog extends Pet//创建狗类{ public void eat(){//覆盖父类吃方法对吃方法重写 System.out.println(\"狗在吃\"); }}class Cat extends Pet{ public void eat(){ System.out.println(\"猫在吃\"); }}class YingWu extends Pet{ public void eat(){ System.out.println(\"鹦鹉在吃\"); }}class Master{ public void feed(Pet p){//此处实际上是 Pet p = new Dog();此处涉及到父类引用指向子类对象，即多态 p.eat();//调用父类吃方法，此处为编译器识别通过，具体调用哪个子类的吃方法还要看动态绑定的那个子类是啥 }} 2、编写程序实现乐手弹奏乐器，可以弹奏不同的乐器从而发出不同的声音。乐器包括：二胡、钢琴和琵琶实现乐器类 Instrument, 包括方法 makeSound()通过测试类，让乐手弹奏不同的乐器参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void play(Instrument instrument){ instrument.makeSound() }//测试类public class TestMusic { public static void main(String[] args) { Musician m = new Musician(); Violin v = new Violin(); m.play(v); }}//乐器类class Instrument{ public void makeSound(){ System.out.println(\"乐器发声\"); }}//二胡class Erhu extends Instrument{ public void makeSound(){ System.out.println(\"二胡在拉\"); }}//钢琴class Piano extends Instrument{ public void makeSound(){ System.out.println(\"弹钢琴\"); } }//小提琴class Violin extends Instrument{ public void makeSound(){ System.out.println(\"拉小题琴\"); } }class Musician{ public void play(Instrument i){ i.makeSound(); }} 接口：（要求用多态实现） 1、创建一个用于描述汽车的接口行驶、刹车、鸣笛都继承该接口并且实现具体功能，测试类进行测试。汽车行驶中汽车鸣笛嘀嘀嘀汽车刹车声！ 123456789101112131415161718 public class Test02 { public static void main(String[] args) { Car car = new MingDi(); car.action(); }}interface Car{ public abstract void action();}class MingDi implements Car{ @Override public void action(){ System.out.println(\"汽车鸣笛嘀嘀嘀！\"); }} 2、实现：中午去饭馆吃饭顾客 点菜菜（菜单）是接口厨师 做菜厨师负责实现这个接口顾客负责调用这个接口 12345678910111213141516171819interface Menu{ public abstract void yuXiang();}class Cook implements Menu{ public void yuXiang(){ System.out.println(\"yuXiang\"); }}class Customer{ Menu menu; public void order(){ menu.yuXiang(); }}","categories":[{"name":"java","slug":"java","permalink":"https://wenkexia.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wenkexia.github.io/tags/java/"}]},{"title":"什么是RSS订阅","slug":"什么是RSS订阅","date":"2021-12-19T11:00:06.000Z","updated":"2022-03-17T00:15:14.209Z","comments":true,"path":"2021/121949063.html","link":"","permalink":"https://wenkexia.github.io/2021/121949063.html","excerpt":"","text":"原文 什么是RSS服务RSS&nbsp;的全称是&nbsp;Really&nbsp;Simple&nbsp;Syndication（简易信息聚合），用户可以通过订阅不同网站 RSS 链接的方式将不同的信息源进行聚合，在一个工具里阅读这些内容。简单来说，RSS&nbsp;就是一种订阅某个网站内容更新的协议。社交媒体混乱的时间线、聚合阅读工具烦人的算法推荐，都让我们无法高效地获取需要的信息。RSS 只抓取订阅信息源、按照时间顺序展示内容 虽然&nbsp;RSS&nbsp;能做到只呈现你订阅的内容，但并非所有网站都像少数派这样，每天只推送几篇文章。以科技媒体&nbsp;Engadget&nbsp;为例，它每周推送的新闻就有上百条。相信你不想、也没时间去逐条阅读这些内容。这时候，如何通过 RSS 只看想看的内容、防止信息过载就成了我们需要解决的问题。 RSS&nbsp;服务是基于&nbsp;RSS&nbsp;协议开发的聚合服务，目前比较知名的&nbsp;RSS&nbsp;服务有&nbsp;Feedly、NewsBlur、Inoreader 等，这些服务大多提供了过滤筛选文章的功能。它们在能够自动抓取 RSS 订阅源中的更新内容的同时，还能按照你设置好的过滤条件，将符合条件的文章以文件夹或者标签的形式进行聚合并呈现给你，让你只看想看的内容，告别信息过载。除此之外，各家&nbsp;RSS&nbsp;服务也有自己的特色功能：比如，Feedly 支持对文章内容进行高亮和记笔记，Inoreader 支持丰富的过滤规则、能和自动化服务联动等。你可以根据自己的需求选择适合的 RSS 服务，让通过 RSS 获取信息这件事变得更加简单和轻松。2018 年主流 RSS 服务选哪家？Feedly、Inoreader 和 NewsBlur 全面横评 https://sspai.com/post/44420 如何寻找 RSS 订阅源要知道一个网站是否支持&nbsp;RSS&nbsp;订阅，最直接的方法就是看网站的底部或侧边栏是否有&nbsp;RSS&nbsp;图标。一般来说，图标所指向的地址就是该网站的订阅链接。你可以直接点击 RSS 订阅链接跳转到 RSS 客户端内进行订阅，也可以复制粘贴按钮中的地址到自己在用的 RSS 服务中订阅这些网站中的内容。大多数情况下，支持&nbsp;RSS&nbsp;订阅的网站都会将&nbsp;RSS&nbsp;图标展示出来。不过总有例外，这时候你也可以尝试在网站域名后面加上&nbsp;/feed&nbsp;或&nbsp;/rss&nbsp;或许可以碰巧猜中，比如少数派的&nbsp;RSS&nbsp;订阅链接就是&nbsp;https://sspai.com/feed。当然，你也可以直接通过搜索引擎通过&nbsp;网站名&nbsp;+&nbsp;RSS&nbsp;的关键字进行搜索，往往都能找到支持网站的 RSS 链接。除了手动搜索订阅链接，RSSHub Radar 是一个可以帮你一键发现并订阅当前网站 RSS 链接的 Chrome 浏览器扩展。如果你当前浏览的网页支持 RSS，你可以通过这一插件直接复制 RSS 订阅链接、或者一键订阅 RSS 链接到 Feedly、Inoreader 等 RSS 服务中。 如何自己制作 RSS 订阅源我们常用的公众号、B&nbsp;站等网站都不支持&nbsp;RSS，又或许你想精确订阅某个具体的页面，这些情况下，学会制作订阅源就显得尤为重要。 借助&nbsp;RSSHub&nbsp;等工具，你可以轻松地制作一个订阅源。举个例子，我在&nbsp;Bilibili&nbsp;发现了一个名为「少数派&nbsp;sspai」的高产&nbsp;UP&nbsp;主，想要订阅他的视频更新。我们可以在他的个人空间找到这位&nbsp;UP&nbsp;主的&nbsp;UID：176321970。随后根据&nbsp;官方文档&nbsp;的介绍，在&nbsp;https://rsshub.app/bilibili/user/video/&nbsp;后填入&nbsp;UID&nbsp;即可完成制作。","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"RSS","slug":"RSS","permalink":"https://wenkexia.github.io/tags/RSS/"}],"author":"wenke"},{"title":"浏览器插件分享","slug":"浏览器插件分享","date":"2021-12-19T10:55:43.000Z","updated":"2022-01-26T02:39:11.458Z","comments":true,"path":"2021/121924995.html","link":"","permalink":"https://wenkexia.github.io/2021/121924995.html","excerpt":"","text":"谷歌插件国内可下载安装Chrome扩展的方法https://www.gugeapps.net/https://www.extfans.com/https://huajiakeji.com/https://www.cnplugins.com/https://www.crx4chrome.com/https://fnd.io/#/https://chrome.zzzmh.cn/#/indexhttps://www.chromefk.com/https://www.yuque.com/eureka007https://crxdl.com/http://blandlifedev.blogspot.com/https://marketplace.visualstudio.com/https://www.chajian5.com/https://173app.com/chrome-exthttps://crxdl.com/https://chrome.zzzmh.cn/#/indexhttps://www.extfans.com/https://www.chromefor.com/http://yurl.sinaapp.com/crx2.php Chrome扩展安装方法1.直接把crx文件拖进扩展管理中心如果顺利，你直接把这个直接拖进 Chrome 扩展程序页面就能安装了2.不过有些时候，你可能会遇到安装 crx 文件报错 这样的话，就用另外一个办法： 在你的文件夹找到这个 crx 文件，确保你打开了文件管理器中的查看「文件扩展名」功能是勾上的 然后对你刚刚下载到的 crx 文件进行重命名，把扩展名改为 zip 然后把这个压缩包解压到一个你不会删除的位置！ 打开 Chrome 扩展程序页面的「开发者模式」 然后「加载已解压的扩展程序」 二管家Chrome 扩展管理工具功能1.根据规则自动开关扩展2.管理扩展3.根据网站推荐扩展4.快速提取CRX BookmarkHub跨浏览器同步书签它使用 GitHub 的 Gist 记录来存储浏览器的书签，可以放心安全的使用。 获取Github Token登录Github选择“设置-开发者设置-生成新token”，这里记得勾选Gist，然后点击“生成token”即可。 获取Gist ID这里new gist 进入对应的网页之后，输入描述、文件名、内容，这里可以随便输入即可，然后点击创建私有Gist。这时，在地址栏可以看到，URL的尾部就是Gist ID。从4a开始 配置插件点击插件的设置添加信息 Unpaywal当你浏览一篇学术文章时，Unpaywall会从2000万个免费合法的文献库里索引一个PDF副本，如果找到对应的文章，会在侧边出现一个绿色按钮，点击按钮就可以阅读或者下载全文。 WeChatSync（微信公众号同步助手）原文：https://mp.weixin.qq.com/s/oTMc_t_f65ITyTgy4Wdg9g是一款将微信文章同步到知乎， B站，微博，豆瓣，百家号， 简书， 头条号，搜狐号， 大鱼号， 一点资讯， Cnblog， CSDN， 51CTO， 掘金， 慕课网-手记， 开源中国，Typecho，WordPress等许多平台。 automa 自动化处理重复工作原文：https://mp.weixin.qq.com/s/ARID9OYRGcLLWGKT4BSd8QAutoma v0.5.1https://www.123pan.com/s/HQeA-EN1Sh Global Speed: 视频速度控制 支持0.25~16倍速的视频加速播放。而且它能用到的场景很多，比如某奇艺等平台的开头广告，直接点击16倍数，几秒就跳过去了。 ViolentMonkey 让你的Chrome可以使用油猴脚本（相比 Tampermonkey、GreaseMonkey 更为简洁方便） Nimbus一个网页版的多功能截图工具，提供了类似区域截屏、可滚动截屏、延迟截屏等等，花式截屏的小功能，甚至还可以帮你录制视频。 油猴脚本网页文章转PDF脚本名称：网页限制解除(改)作用：解除网页复制的限制 脚本名称：知乎增强作用：让电脑浏览知乎的时候界面更实用 1、Userscript+一款脚本推荐利器，能够自动帮我们寻找适用于当前网站的所有脚本。AC-baidu-重定向优化去广告、绕过搜索引擎的重定向、自定义网址拦截、添加站点图标、优化搜索结果排版、自动翻页……searchEngineJump 搜索引擎快捷跳转在搜索引擎的输入框下面添加一行快捷菜单。能够快捷地在多个搜索引擎和网站之间进行跳转。支持自定义编辑跳转网站。5、Search By Image以图搜图脚本，内置了 12 个图片搜索引擎， kiwi浏览器一款基于Chromium核心的手机浏览器，强大的可扩展性让你轻松安装chrome应用商店里的扩展，真正支持Chrome电脑版插件 Via浏览器：https://viayoo.com/zh-cn/参考：https://mp.weixin.qq.com/s/aUBBfdWrzXReW8DRmQ24sA启动秒开，没有杂七杂八的附加功能会自主学习的搜索引擎：Magi：https://magi.com/search?q=via相关插件：http://via-app.cn广告过滤1：https://cats-team.coding.net/p/adguard/d/AdRules/git/raw/main/adguard.txt广告过滤2：https://cats-team.coding.net/p/adguard/d/AdRules/git/raw/main/AdKillRules.txt&nbsp;广告过滤3：https://cdn.jsdelivr.net/gh/DoingDog/xXKiller@main/w.txt&nbsp; iosUserscripts for Safarihttps://www.appinn.com/userscripts-for-safari/Userscripts 就是可以让海量的油猴脚本在 Safari 上运行的脚本管理器，和 Tampermonkey 是一个功能，只不过，它可以在 iPhone 上使用，就很香了。 由于 Userscripts 属于标准的 Safari 扩展，所以在 App Store 安装（Mac/iPhone/iPad）之后，需要前往 Safari 设置中开启扩展，具体路径是： iPhone 系统设置 &gt; Safari 浏览器 &gt; 扩展 &gt; Userscripts： 注意除了打开 Userscripts 之外，在里面的设置中，还需要允许所有网站。注意这里青小蛙尝试过“询问”，但并不成功，所以设置为了允许，如果你有安全顾虑，请谨慎操作。 持续更新中","categories":[{"name":"资源分享","slug":"资源分享","permalink":"https://wenkexia.github.io/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"插件","slug":"插件","permalink":"https://wenkexia.github.io/tags/%E6%8F%92%E4%BB%B6/"}],"author":"wenke"},{"title":"网站分享","slug":"网站分享","date":"2021-12-19T10:50:21.000Z","updated":"2022-03-21T11:11:35.577Z","comments":true,"path":"2021/121924397.html","link":"","permalink":"https://wenkexia.github.io/2021/121924397.html","excerpt":"","text":"好用的网站https://hyperbeam.com/注册好账号登录后，需要你创建一个房间，然后把房间链接分享出去就能和远在异地的女朋友交流了，支持文字、GIF、视频、语音通话。 搜索引擎fsou.cc搜索结果排除了百度和搜狗的结果，30%来自Google，30%来自必应，其余的40%来自其他的搜索渠道。 系统密钥分享：https://pkeytools.azurewebsites.net/ShareKeys 设计改图鸭网站提供图片压缩、图片编辑、图片转文字等功能https://www.gaituya.com/用卷积神经网络把小而糊的图片进行放大，支持降噪处理，http://waifu2x.udp.jp/可快速将 JPG、PNG 等格式的图片快速转换为 SVG 矢量图https://www.visioncortex.org/vtracer/ 世界各地的朋友在这里分享他们的桌面布置灵感https://www.makerstations.io/为大家介绍创意相关工作者的工作桌面摆设情况https://www.workspaces.xyz/ 东京大学发布的一款工具 ：paper-digest可利用 AI 为每篇论文生成摘要，将阅读时间缩短为 3 分钟目前该工具仍处于初级阶段，生成的论文摘要仅供参考，深入研究最好还是阅读论文原稿。https://www.paper-digest.com/ 清华大学计算机系课程攻略https://rekcarc-tsc-uht.readthedocs.io/en/latest/https://github.com/PKUanonym/REKCARC-TSC-UHT spider-flow一个无需写代码的爬虫平台https://www.spiderflow.org/https://github.com/ssssssss-team/spider-flow Kmonad，一个自由改变键盘布局的软件可以让你无限地定制和扩展几乎所有键盘功能，包括改建、配置组合键等功能https://www.appinn.com/kmonad/ 用 Fruition + Notion 搭建个人网站DEMO: https://fruitionsite.com/GitHub: https://github.com/stephenou/fruitionsite作者主页： https://stephenou.com/教程：https://the-block.club/Fruition-Notion-e05ddf4392744a8a819a30ac7952520b 2021年【思维导图】盒子，C/C++，Golang，Linux，云原生，数据库，DPDK，音视频开发，TCP/IP，数据结构，计算机原理等https://github.com/0voice/learning_mind_map extract.pics？ Extract.pics 是一个易于使用的工具，允许您从任何公共网站提取、查看和下载图像。只需将网站的 URL 粘贴到输入字段中，然后单击“提取”即可开始该过程。 fffuel：设设设计用的小工具集合 官网 https://fffuel.co/ fffuel 是一个「即将推出」Html 模板的集合网站。除了网页模板，还提供了一些在网页设计中会使用到的工具 ssshape https://fffuel.co/ssshape/ ：矢量形状生成器在画布上添加几个点，点击 ssshape，会自动闭合所有点并对其形状进行平滑处理，最终得到一个边缘平滑的 SVG 形状 llline https://fffuel.co/llline/ ：矢量线段生成器在画布上添加几个点，点击生成后便能得到一条光滑的曲线，然后你可以旋转角度、改变它的颜色以及线段的形态 bbburst https://fffuel.co/bbburst/ ：图形散落分布以往想要制作一个「图形散落」风格的背景图，大多是通过喷枪或逐个逐个放置而成，过程比较繁琐。bbburst 可以帮你在预设的几个图形中，自动生成一张「图形散落」风格的图片 nnnoise https://fffuel.co/nnnoise/ ：「杂色」纹理生成器利用 nnnoise，可以生成一些「杂色」纹理，搭配上你想要的风格，或许别有一番滋味 dddoodle https://fffuel.co/dddoodle/ ：「极其」手绘风格的插图dddoodle 是一套手绘的 doodle 插图，其中有线段、箭头、圆形、星星以及一些有趣的形状，均为 CC 协议 ✅ rrready https://fffuel.co/rrready/ ：CSS 特性兼容列表不同浏览器支持不同 CSS 特性，这个问题长期困扰着开发者，利用 rrready 可以查看要使用到的 CSS 特性在不同浏览器中是否能够达成一致的效果 cccolor https://fffuel.co/cccolor ：选色器除了能够利用色盘、哈希值选取到想要的颜色，cccolor 还会为你生成匹配该颜色的相似色调、适合作为其阴影的颜色，及与其匹配的冷暖色调 ffflux https://fffuel.co/ffflux/ ：流体渐变生成器流体渐变带来的冲击力会比普通渐变色更强，色彩也更加丰富，或许能让你的设计更加活跃 lllook https://fffuel.co/lllook/ ：你想要什么表情lllook 是一套面部的简笔画表情包，比 emoji 丰富得多，也更加有趣 除了这些小工具，fffuel 的作者 Seb https://sebseb.co/ 还有其它有趣的项目，不妨去看看，其中我比较喜欢的是 muted https://muted.io/ 和 rrrelax https://rrrelax.app/ ，这里还有他整理的一些 设计小工具 https://cccreate.co/ 程序员学习网站原文 中国大学MOOC中国大学MOOC原名ICOURSE（爱课程），是教育R部和网易共同合作发布的一个互联网教育平台，旨在推动高等教学资源共享，让大家能免费享受许多985及TOP名校课程。绝大部分领域均有免费国家精品课程，资深教授授课！蹭网课必备！ 网址：https://www.icourse163.org/ 中国国家图书馆中国国家图书馆，收录绝对够全！只有你想不到，没有你搜不到，想要的资料应有尽有，还可以在线阅读~ 无论专业书籍还是人文书籍，均可搜索得到，还配有其ISBN账号，配合某盘资源可以进行pdf搜索下载！ 网址：http://www.nlc.cn/ B站B站不再是一个看番刷鬼畜的地方，学习课程越来越多，你想学的东西基本都可以在这里找到~ 网址：https://www.bilibili.com/ W3CW3School，一个全球最大的中文 Web 技术教程。在 W3School，你可以找到你所需要的所有的网站建设教程。从基础的 HTML 到 CSS，乃至进阶的 XML、SQL、JS、PHP 和 ASP.NET。 网址：https://www.w3school.com.cn/ 菜鸟教程和W3C性质差不多，都是提供各种基础编程教程，可以让你在短时间内实现从0到1的质的飞跃！ 网址：https://www.runoob.com/ MDNMDN Web Docs 站点提供有关开放 Web 技术的信息，包括用于 Web 站点和渐进式 Web 应用程序的 HTML、CSS 和 API。面向Web开发者的文档，权威教程。 网址：https://developer.mozilla.org/zh-CN/docs/Web 掘金掘金是一个帮助开发者成长的社区,是给开发者用的 Hacker News,给设计师用的 Designer News,和给产品经理用的 Medium。有不少技术大牛和极客们在输出优质干货。 网址：https://juejin.cn/ GithubGitHub 是世界上最大的代码托管平台。如果说 P***Hub 对于宅男来说是神一般的存在，那么 GitHub 对于程序员来说是永远滴神！ 网址：https://github.com/ 慕课网慕课网（IMOOC）是IT技能学习平台。慕课网(IMOOC)课程涉及JAVA、前端、Python、大数据等60类主流技术语言，覆盖了面试就业、职业成长、自我提升等需求场景，帮助用户实现从技能提升到岗位提升的能力闭环。 网址：https://www.imooc.com/ 张鑫旭的博客博客语言以简单明了著称，擅长深入挖掘css技巧及内部实现机制。 https://www.zhangxinxu.com/wordpress/ The Odin ProjectOdin 项目使有抱负的 Web 开发人员能够免费一起学习 网址：https://www.theodinproject.com/paths/foundations/courses/foundations angularJS学习资源合集一个 angularJS 资源大全 网址：https://angularjs.zeef.com/gianluca.arbezzano 30 seconds of code当你打开这个网站时，你会发下自己捡到宝了，这个网站分享了1084个有用的简短代码片段,你可以在30秒或更少时间中理解,满足开发者绝大多数开发需求 网址：https://www.30secondsofcode.org/ JS Tips这是一个分享 JavaScript 小技巧的网站,让读者提升撰写代码的能力.每天花不到 2 分鐘，你可以阅读到关于效能、习惯、技术、面试问题以及所有 JavaScript 相关知识 网址：https://www.jstips.co/zh_CN/javascript/ 如何跟上前端开发的最新前沿这是一个帮助前端学子们了解最新推出的工具, 最新的潮流以及开发流程的网站 网址：https://uptodate.frontendrescue.org/zh/ JS RunJSRUN.NET 一个极具活力的代码在线运行平台。有专业的HTML/CSS/JS在线调试工具，适用前端工程师的开发和学习。同时还有C语言、Java、PHP、Python等代码在线编译运行工具 网址：https://jsrun.net/ CodepenCodepen是一个完全免费的前端 Web 开发的在线代码编辑器、学习环境和社区，汇集了大量的优秀前端作品，很多大佬的作品都会上传到这里。 网址：https://codepen.io/ ES6 入门教程《ECMAScript 6 入门教程》一本由阮一峰老师撰写开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。这本书主要引导你进入 React 和 Webpack 世界。 网址：https://es6.ruanyifeng.com/ Stack OverflowStack Overflow 作为全球最大的技术问答网站，几乎没有你找不到的问题 网址：https://stackoverflow.com/ SegmentFaultSegmentFault 思否是中国领先的开发者技术社区。国内风靡的程序员社区，以技术问答、技术专栏、技术课程、技术资讯为核心的产品形态,为开发者提供纯粹、高质的技术交流平台。 网址：https://segmentfault.com/ LeetCodeLeetCode 是一个非常棒的OJ（Online Judge）平台，收录了许多互联网公司的算法题目，被称为刷题神器 网址：https://leetcode-cn.com/ LintCode这个网站可算是个面试的“作弊神器”吧，因为上面有很多国内外大厂面试真题，里面大厂面试真题还挺多的，而且会定期更新，跳槽前可以看一看~ 网址：https://www.lintcode.com/ 程序员一站式导航这个导航站提供了最精华有趣的内容，根据分类可以找到你所需要的站点、工具，能够节省不少时间~ 网址：https://cxy521.com/ 提高web前端开发效率的网站Animista地址：https://animista.net/Animista 是一个简单的 CSS 动画库网站。您可以测试和使用现成的 CSS 动画，也可以下载它们的代码。Web 开发人员一定要上的网站，这个对您提升开发效率非常有帮助。 Ray.so地址：https://ray.so/此网站可以将让您制作的精美图像进行源代码的分享。它支持几乎所有的编程语言格式。您可以设置背景、颜色、字体等。一定要试试这个网站。 FontAwesome地址：https://fontawesome.com/ 如果您在为您的项目寻找一些很棒的图标，您可以访问 FontAwesome 下载任何项目的免费图标。 Jsfiddle地址：http://jsfiddle/ Jsfiddle 是代码编辑器，您可以在其中通过实时预览测试 JavaScript、CSS、Html 代码。该网站是 Web 开发人员的便捷工具。 Unscreen地址：https://www.unscreen.com/ Unscreen 是一个帮助您去除视频背景的网站。它用于制作无背景视频。必须尝试该网站。 Dev Samples地址：https://www.devsamples.com/此网站是您可以自由复制粘贴到项目中的代码集合网站。该网站的重点是 Web 开发人员的源代码。Dev Samples 对新手开发人员来说很方便。 Readme.so 地址：https://readme.so/ Readme.so 是一个在线自述文件制作，可帮助开发人员为其项目创建自述文件。大多数开发人员使用readme.so为其 Github 项目创建自述文件。 ScreenShot.rock地址：https://screenshot.rocks/ Screenshot Rock 是一个可以创建漂亮的移动和浏览器屏幕截图的地方。您只需要上传任何屏幕截图，它就会为浏览器提供移动框架触摸功能。 Undesign地址：https://undesign.learn.uno/ Undesign 是设计工具、插图、开发人员和设计师的源代码、制造商资源等的免费集合。一定要试试这个网站。 Coolors地址：http://coolors/ Coolors 是我推荐的颜色组合网站。每次按“空格键”时，它都会生成新的颜色组合。 参考 服务器和网站在线测速工具http://ping.pehttps://www.ping.cn/站长工具https://ping.aizhan.com阿里云网站运维检测平台 写论文可以用到的网站： 国家哲学社会科学文献中心： www.ncpssd.org现有中文期刊、外文期刊、古籍等资源，收录哲学社会科学相关领域文献共计10,000,000余条，提供有线阅读、全文下载等服务。 文津搜索： find.nlc.cn国家图书馆资源检索，汇聚了60多个资源库、近2亿条文献信息，可以查询包括图书、古文献、论文、期刊报纸、多媒体等在内的多种资料。 术语在线： www.termonline.cn一个可以查询专业术语的在线网站，非常权威，内容更新也很及时。 科塔学术： site.sciping.com学术导航网站，整理了许多论文搜索网站、学术工具、科研软件、期刊出版等，每一个都有细致的分类，并归纳了对应的网站。 Academic Phrasebank： www.phrasebank.manchester.ac.uk论文写作助手，这个网站主要提供论文各部分的模版，如介绍怎么写，总结怎么写，如何描述方法，报告细节等，对非英语母语作者非常有帮助。 iData： www.cn-ki.net一个知网镜像站，可以免费下载论文，知网比较新的没有，每天有免费下载限额。 SCI-Hub： sci-hub.com这个网站就不多介绍了，一个超棒的免费下载论文的网站，输入文献doi号即可搜索下载。 OALib： www.oalib.com目前收录了570万篇学术论文，涵盖多个领域，所有文章均可免费下载，是一个较为高效的论文查找网站。 研享网： www.academicshare.cn检索下载英文文献的利器，页面超级干净，支持关键词、题目、论文doi搜索。 Medsci： www.medsci.cn/sci期刊智能查询系统，支持模糊查询，每一个期刊还有对应的论坛。 Connected Papers： www.connectedpapers.com文献调研必备神器，它可以在线进行分析文献的引文信息，轻松了解某篇文献的引用和被引用关联，分析出文献的前世今生，方便我们对一篇文献或者某个领域进行调研。 近邻词汇检索： tool.mingdawoo.com可免费查找近似短语和相关术语，词穷的时候可以看看。 秘塔写作猫： xiezuocat.com可以校对中文字词错误、标点错误、语序错误、语法问题、同意混淆等，并给出修改建议，支持全文分析和智能排版，免费版基本上能满足日常需求。 Grammarly： www.grammarly.com英文语法错误查询好助手，可以安装为word插件，在你写作的时候就可以纠正你的语法错误了。 知犀思维导图： www.zhixi.com免费好用的论文大纲整理工具，可以借助这个工具做论文大纲。这个网站还提供许多思维导图模板，包括工作方法、考研考证的资料、管理方法、科普知识等方面的模板。 词云统计： cloud.niucodata.com在线中文词汇统计和分析工具，可以帮助用户分析一段话中的词性分类、词频统计并生成词云图。 Linggle： www.linggle.com提供英文常用语、搭配、近义词等检索，可以根据词性来推测完整搭配，还能帮助学习者分析出更准确的英文写作建议。 Netspeak： netspeak.org这个网站也是词汇，不过是用来查找你记不太清楚的词汇，比如congratulations，你不记得全部拼写了，你就可以在这个网站上来查一下。 Linguee： cn.linguee.com一个全能的在线多语言互译平台，提供24种语言的对应查询服务，而且还收集了数亿条译文例句，无论是日常领域的术语，还是专业难度偏大的词汇，在这里都能找到专业的翻译方式。 DocTranslator： www.onlinedoctranslator.com可免费在线翻译文档，支持109种不同语言文档任意转换，并保持排版不变。操作简单，直接上传文档就可以。 学习用CSDN：https://www.csdn.net/ TED（最优质的演讲）： https://www.ted.com/ 谷粉学术： https://gfsoso.99lb.net/scholar.html 大学资源网：http://www.dxzy163.com/ 简答题：http://www.jiandati.com/ 网易公开课：https://open.163.com/ted/ 网易云课堂：https://study.163.com/ 中国大学MOOC：www.icourse163.org 哔哩哔哩弹幕网：www.bilibili.com 我要自学网：www.51zxw.net 知乎：www.zhihu.com 学堂在线：www.xuetangx.com 爱课程：www.icourses.cn 猫咪论文：https://lunwen.im/ iData（论文搜索）：www.cn-ki.net 文泉考试：https://www.wqkaoshi.com 编程题库网(大厂最热题库列表) https://94tiku.com 找书籍用书栈网（极力推荐）：https://www.bookstack.cn/ 码农之家（计算机电子书下载）： www.xz577.com 鸠摩搜书：www.jiumodiary.com 云海电子图书馆：www.pdfbook.cn 周读（书籍搜索）：ireadweek.com 知轩藏书：http://www.zxcs.me/ 脚本之家电子书下载： https://www.jb51.net/books/ 搜书VIP-电子书搜索： http://www.soshuvip.com/all.html 书格（在线古籍图书馆）： https://new.shuge.org/ caj云阅读： http://cajviewer.cnki.net/cajcloud/ 必看网（人生必看的书籍）： https://www.biikan.com/ 冷知识 / 黑科技上班摸鱼必备（假装电脑系统升级）：http://fakeupdate.net/ PIECES 拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）： http://www.species-in-pieces.com/ 图片立体像素画： https://pissang.github.io/voxelize-image/ 福利单词（一个不太正经的背单词网站）： http://dict.ftqq.com 查无此人（刷新网站，展现一张AI 生成的人脸照片）： https://thispersondoesnotexist.com/ 在线制作地图图例：https://mapchart.net/ 创意光线绘画：http://weavesilk.com/ 星系观察：https://stellarium-web.org/ 煎蛋：http://jandan.net/ 渣男-说话的艺术：https://lovelive.tools/ 全历史：https://www.allhistory.com/ iData：https://www.cn-ki.net/ 术语在线：http://www.termonline.cn/ 写代码用GitHub：https://github.com/ 码云：https://gitee.com/ 源码之家：https://www.mycodes.net/ JSON to Dart： https://javiercbk.github.io/json_to_dart/ Json在线解析验证： https://www.json.cn/ 在线接口测试（Getman）： https://getman.cn/ 资源搜索用DogeDoge搜索引擎：www.dogedoge.com 秘迹搜索：https://mijisou.com/ 小白盘：https://www.xiaobaipan.com/ 云盘精灵（资源搜索）： www.yunpanjingling.com 虫部落（资源搜索）： www.chongbuluo.com 如风搜（资源搜索）： http://www.rufengso.net/ 爱扒：https://www.zyboe.com/ 各种小工具奶牛快传（在线传输文件利器）：cowtransfer.com 文叔叔（大文件传输，不限速）： https://www.wenshushu.cn/ 云端超级应用空间（PS，PPT，Excel，Ai）：https://uzer.me/ 香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）： https://www.xiangdang.net/ 二维码生成：https://cli.im/ 搜狗翻译：fanyi.sogou.com 熵数（图表制作，数据可视化）： https://dydata.io/appv2/#/pages/index/home 拷贝兔：https://cp.anyknew.com/ 图片无限变放大：http://bigjpg.com/zh 幕布（在线大纲笔记工具）：mubu.com 在线转换器（在线转换器转换任何测量单位）：https://zh.justcnw.com/ 调查问卷制作： https://www.wenjuan.com/ 果核剥壳（软件下载）： https://www.ghpym.com/ 软件下载：https://www.unyoo.com/ MSDN我告诉你（windows10系统镜像下载）：https://msdn.itellyou.cn/ 网站工具箱https://www.67tool.com/ https://tools.miku.ac/功能：收款码合并 导航页（工具集）世界各国网址大全： http://www.world68.com/ 小森林导航：http://www.xsldh6.com/ 简捷工具：http://www.shulijp.com/ NiceTool.net 好工具网： http://www.nicetool.net/ 现实君工具箱（综合型在线工具集成网站）：http://tool.uixsj.cn/ 蓝调网站：http://lcoc.top/ 偷渡鱼：https://touduyu.com/ 牛导航：http://www.ziliao6.com/ 小呆导航： https://www.webjike.com/index.html 简法主页：http://www.jianfast.com/ KIM主页：https://kim.plopco.com/ 聚BT：https://jubt.net/cn/index.html 精准云工具合集： https://jingzhunyun.com/ 兔2工具合集：https://www.tool2.cn/ 爱资料工具（在线实用工具集合）： www.toolnb.com 工具导航：https://hao.logosc.cn/ 音乐将加密的音乐文件转为可播放的 mp3 文件。目前支持网易云音乐 (.ncm) 、QQ 音乐 (.qmc, .mflac, .mgg) 、酷狗音乐 (.kgm) 、虾米音乐 (.xm) 、酷我音乐 (.kwm) 等格式。项目提供了网页版 浏览器扩展 Docker 和命令行版 等多种使用方式，所有转换都在本地进行，无需担心隐私问题。网页版：https://demo.unlock-music.dev/项目地址：https://github.com/unlock-music/unlock-music代码仓库：https://git.unlock-music.dev/um/web 看视频用阿木影视：https://www.aosk.online/ 电影推荐（分类别致）： http://www.mvcat.com APP影院：https://app.movie 去看TV：https://www.qukantv.net/ 动漫视频网：http://www.zzzfun.com/ 94神马电影网：http://www.9rmb.com/ NO视频官网：http://www.novipnoad.com/ 蓝光画质电影：http://www.languang.co/ 在线看剧：http://dy.27234.cn/ 大数据导航：http://hao.199it.com/ https://qzy998-1.ysgq.xyz/ 片库：https://www.mypianku.net 奈飞中文电影站：https://yanetflix.com 剧嗨：https://www.juhi.cc 555电影网：https://www.o8tv.com Tubitv：https://tubitv.com 片源：http://pianyuan.org/影视导航网站：http://www.549.tv/片吧 https://www.pianba.net/低端影视 https://ddrk.me/片库 https://www.pianku.li/七七看片 https://www.77kpp.com/旋风视频 https://miao101.com/体育直播：https://feisuzhibo.comBD影视分享 https://www.bd2020.com/一刻电影 http://www.yikedy.co/影视教程 https://www.yuque.com/eureka007/ziyuan/rnezaq VIP视频解析网站365t在線免費解析觀看系統http://vip.365tol.top/BL智能解析https://vip.bljiex.com/BL解析-Vip视频在线解析https://vip.bljiex.cc/TVB云播全网VIP视频解析：http://vip.tvyb10.com/Playm3u8解析-PC和手机全无广告!https://www.playm3u8.cn/jiexi.php?url=诺讯全网视频在线解析无广告https://www.nxflv.com/?url=天翼解析https://jsap.attakids.com/?url=kingtail智能解析 https://jx.kingtail.xyz/?url= 在线动漫网站汇总ZzzFun动漫 http://www.zzzfun.com/樱花动漫 http://www.yinghuacd.com/AGE动漫 https://www.agefans.vip/動畫線上看 https://anime1.me/嘀哩嘀哩 https://www.dilidili55.com/哈哩哈哩 http://halihali4.com/ 学设计用码力全开（产品/设计师/独立开发者的资源库）：https://www.maliquankai.com/designnav/ 免费音频素材：https://icons8.cn/music 新CG儿（视频素材模板，无水印+免费下载）： https://www.newcger.com/ Iconfont（阿里巴巴矢量图标库）： https://www.iconfont.cn/ 小图标下载：https://www.easyicon.net/ Flight Icon：https://www.flighticon.co/ 第一字体转换器：http://www.diyiziti.com/ doyoudosh（平面设计）： www.doyoudo.com 企业宣传视频在线制作：https://duomu.tv/ MAKE海报设计官网：http://maka.im/ 一键海报神器： https://www.logosc.cn/photo/utm_source=hao.logosc.cn&amp;utm_medium=referral 字由（字体设计）： http://www.hellofont.cn/ 查字体网站：https://fonts.safe.360.cn/ 爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）：http://www.aigei.com/ 在线视频剪辑： https://bilibili.clipchamp.com/editor 搞文档用即书（在线制作PPT）： https://www.keysuper.com/ PDF处理：https://smallpdf.com/cn PDF处理：https://www.ilovepdf.com/zh-cn PDF处理：https://www.pdfpai.com/ PDF处理：https://www.hipdf.cn/ 图片压缩，PDF处理： https://docsmall.com/ 腾讯文档（在线协作编辑和管理文档）： docs.qq.com ProcessOn（在线协作制作结构图）： www.processon.com iLovePDF（在线转换PDF利器）： www.ilovepdf.com PPT在线制作：https://www.woodo.cn/ PDF24工具（pdf处理工具）： https://tools.pdf24.org/en IMGBOT（在线图片处理）： www.imgbot.ai 福昕云编辑（在线编辑PDF）： edit.foxitcloud.cn TinyPNG（在线压缩图片）：tinypng.com UZER.ME（在线使用各种大应用，在线使用CAD，MATLAB，Office三件套 ）：uzer.me 优品PPT（模板下载）： http://www.ypppt.com/ 第一PPT（模板下载）： http://www.1ppt.com/xiazai/ 三顿PPT导航：sandunppt.com Excel函数表： https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188 图片图像处理Magic Eraser，中文名为魔术橡皮擦，是一款免费的 AI 工具，可在几秒钟内删除图像中不需要的东西。你只需要上传图片，标记需要删除的位置，平台将快速智能处理，然后将处理后的图片下载到本地即可，一切都在几秒钟内完成！https://www.magiceraser.io/ 在线图片高清化https://bigjpg.com/ 壁纸wallhavenhttps://wallhaven.cc/ 极简壁纸https://bz.zzzmh.cn/index 电脑壁纸：http://lcoc.top/bizhi/ https://unsplash.com/ https://pixabay.com/ https://www.pexels.com/ https://visualhunt.com/ https://www.ssyer.com/ 彼岸图网：http://pic.netbian.com/ 极像素（超高清大图）： https://www.sigoo.com/ 免费版权图片搜索： https://www.logosc.cn/so/ 多功能图片网站：https://www.logosc.cn/so/ 牛牛TV：http://www.ziliao6.com/tv/ VideoFk解析视频： http://www.videofk.com/ 蓝调网站：http://lcoc.top/vip2.3/ 永久资源采集网： http://www.yongjiuzy1.com/","categories":[{"name":"资源分享","slug":"资源分享","permalink":"https://wenkexia.github.io/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://wenkexia.github.io/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"搜索技巧","slug":"搜索技巧","date":"2021-12-19T10:42:40.000Z","updated":"2021-12-20T03:15:10.996Z","comments":true,"path":"2021/121943862.html","link":"","permalink":"https://wenkexia.github.io/2021/121943862.html","excerpt":"","text":"常用搜索电子书搜索技巧 Google的相关索引量巨大，但需要配一些关键词食用。本站不提供代理服务，请自行料理 只是输入入特别一点：书名关键词后加上格式(pdf/epub/mobi/azw3/txt) 书名+格式：例如：巴圣母院 pdf 书名+ filetype/inu格式；例如：格林童话 filetype: mobi ; 三个火枪手 inurl: pdf. 书名+提取码：例如：三体 提取码 中文 图书馆联盟[需先注册]:http://www.ucdrs.superlib.net/ 脚本之家：htps://ww.jb51.net/ books/ 电子书共享社区https://ebook2.lorefree.com/ 外文学术搜索综合 字术搜素合集https://scholar.chongbuluo.com/ 电子书搜索综合 电子书搜素合集：htps://www. giffox.com/ 网盘 阿里网盘https://www.alipansou.com/https://www.niceso.fun/ 百度网盘飞猪盘：https://www.feizhupan.com/ 浏览器搜索语法+加号 –强制包含关键词减号一排除关键词或网站“双引号和书名号一精确匹配(|)一一并行搜索site_一在特定网站或域中搜索 intitle–在特定的网页标题中搜索inurl一在特定ur链接中搜索filetype–在特定文档格式中搜索『』一一查找论坛版块intitle: bookmarks一查询别人的收藏夹 资源网站语雀:https://www.yuque.com/eureka007/ziyuan电报tg:https://t.me/fku0007吾爱论坛：https://www.52pojie.cn/虫部落：https://www.chongbuluo.com/知乎：https://ww.zhihu.com/Github:https://github.com/B站:https://ww.bilibili.com/油管：https://www.youtubecom/瑞客论坛[大多为计算机内容J:https://www.ruikel.com/","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wenkexia.github.io/tags/%E5%AD%A6%E4%B9%A0/"}],"author":"wenke"},{"title":"node.js","slug":"node.js","date":"2021-12-18T12:24:22.000Z","updated":"2022-03-03T00:04:04.207Z","comments":true,"path":"2021/12184010.html","link":"","permalink":"https://wenkexia.github.io/2021/12184010.html","excerpt":"","text":"Nodejs是什么JavaScript 是一种编程语言，在 Node.js 诞生前，JavaScript 都运行于浏览器端， Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。电脑安装了Node.js后， Node.js 相当于浏览器，也可以在里面运行 JavaScript 了！ 简单的说node.js就是把浏览器的解释器封装起来作为服务器运行平台，用类似javascript的结构语法进行编程，在node.js上运行。 在Node端写JS，就是用Node封装好的一系列功能模块来写代码。NodeJS封装了网络，文件，安全加密，压缩等等很多功能模块，我们只需要学会常用的一些，然后在需要的时候去查询文档即可。 Nodejs的组成：ECMAScript(语言基础，如：语法、数据类型结构以及一些内置对象) os(操作系统) file(文件系统) net(网络系统) database(数据库) 安装Node.js下载地址 打开cmd输入命令检查是否安装成功： 12node -v 查看node版本npm -v 查看npm版本 Node.js 安装成功时也默认安装了 npm， npm 是随 Node.js 一起被安装的包管理工具，你可以理解成 Node.js 自带的应用商店。是用来安装/卸载Node.js需要装的东西 环境配置1.修改全局模块路径和缓存路径当我们在执行npm install express -g命令时，会默认下载到c盘，更改下载盘在nodejs安装目录下创建创建两个文件夹，名称分别为：node_global(全局模块)和node_cache(缓存)，在node_global文件夹下再建一个node_modules文件夹，配置环境变量用 2.win+R打开运行窗口，输入cmd，再输入以下两条指令npm config set prefix “创建的node_global文件夹所在路径”npm config set cache “创建的node_cache文件夹所在路径” 3.修改完毕后，再配置环境变量右键此电脑——&gt;高级系统设置——&gt;环境变量在系统变量中，新建，变量名：NODE_PATH变量值：node_global文件夹下的node_modules文件夹。如：E:\\develop\\nodejs\\node_global\\node_modules 修改用户变量中的Path变量，将默认的npm路径修改为新建的node_global路径如：D:\\ruanjian\\nodejs\\node_global npmnpm 是什么？参考npm 为你和你的团队打开了连接整个 JavaScript 天才世界的一扇大门。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package）（即代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。 npm (node package manager) 是 JavaScript 世界的包管理工具，是 Node.js 平台的默认包管理工具，简单地说，就是通过 npm 下载模块，复用已有的代码，提高工作效率。 组成npm 由三个独立的部分组成： 网站 注册表（registry） 命令行工具 (CLI) 网站 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。 注册表 是一个巨大的数据库，保存了每个包（package）的信息。 CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。 npm中文文档 切换为 taobao 镜像源国内使用 npm 可能很慢。你可以考虑切换为 taobao 镜像源。 1npm config set registry https://registry.npm.taobao.org 使用123456# 安装npm install# 卸载npm uninstall# 清理缓存npm cache clean -f cnpm 是什么？简单的讲就是中国版的 NPM，因为 npm 安装插件是从国外服务器下载，受网络影响大，可能出现异常，需要安装 cnpm 模块，命令如下： 1npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm 支持可以使用支持 npm 除 publish 之外的所有命令。 因为 cnpm 的仓库只是 npm 仓库的一个拷贝，它不承担 publish 工作，所以执行 cnpm publish 命令会失败的。 yarn 是什么？yarn 是个包管理器。你可以通过它使用全世界开发者的代码， 或者分享自己的代码。 从 npm 安装软件包并保持相同的包管理流程。 特点：1.速度超快。Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。 2.超级安全在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。 3.超级可靠使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。通过命令安装 1npm install -g yarn 常用命令：yarn init：初始化项目，会在根目录下生成一个 package.json，与 npm 类似具体不做解释 yarn add ：安装依赖包，会自动安装最新版本，会覆盖指定版本号 yarn add ：一次性添加多个包 yarn add @version：添加指定版本的包 yarn upgrade @version：将包更新到指定版本 yarn upgrade –latest ：将包更新到最新版本 yarn remove ：删除包 yarn remove ：一次性删除多个包 yarn info ：可以用来查看某个模块的最新版本信息 yarn install：安装 package.json 里所有包，并将包及它的所有依赖项保存进 yarn.lock yarn install –force ：强制重新下载所有包 yarn install –flat：安装一个包的单一版本 yarn install –production：只安装 dependencies 里的包 yarn install –no-lockfile：不读取或生成 yarn.lock yarn install –pure-lockfile：不生成 yarn.lock npm是Nodejs自带的包管理器，当你安装Node的时候就自动安装了npm。通俗的讲，当我们想使用一个功能的时候，而Node本身没有提供，那么我们就可以从npm上去搜索并下载这个模块。每个开发语言都有自己的包管理器，比如，java有maven，python有pip。而npm是目前世界上生态最丰富，可用模块最多的一个社区，没有之一。基本上，你所能想到的功能都不用自己手写了，它已经在npm上等着你下载使用了。 npm的海量模块，使得我们开发复杂的NodeJs的程序变得更为简单。 遇到的问题安装npm模块时，没有权限解决方法：打开nodejs安装目录的属性把权限全部勾上 npm的包安装分为本地安装（local）、全局安装（global）两种 本地安装: npm install xxx 安装到命令行所在目录的node_module目录。 全局安装: npm install xxx -g 安装到 \\AppData\\Roaming\\npm\\node_modules目录。","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://wenkexia.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"git使用","slug":"git使用","date":"2021-11-20T13:42:04.000Z","updated":"2022-03-17T23:35:02.233Z","comments":true,"path":"2021/11205629.html","link":"","permalink":"https://wenkexia.github.io/2021/11205629.html","excerpt":"","text":"git安装及配置Git是一个分布式代码管理工具，可以在本地提交，不需要依赖网络，并且会将每次提交自动备份到本地。每个开发者都可以把远程仓库clone一份到本地，并会把提交历史一并拿过来。 官网下载 按照安装向导来安装Git，相关参数勾选为默认即可 安装完成后，右键菜单栏会出现Git GUI和Git Bash git基本操作命令查看系统配置git config -l 配置Github用户名和账号打开Git bash 1234567# 配置git用户和邮箱git config --global user.name \"xxxx\" git config --global user.email \"xxxxx@qq.com\" #查看配置的结果 git config --global --list## 本机生成SSH公钥，实现免密登录 ssh-keygen -t rsa 将公钥添加到Github管理平台我的目录是：C:\\Users\\wenke.ssh将ssh文件夹中的公钥（ id_rsa.pub）添加到GitHub管理平台中，在GitHub的个人账户的设置中找到如下界面 12#测试配置是否成功 ssh -T git@github.com 关联本地与远程仓库第一种方法在github创建一个仓库，然后在本地选择一个文件夹克隆仓库git clone [url] 然后添加文件即可 第二种方法本地创建一个git库进入到指定的文件夹之后，右键打开git bash输入git init本地文件夹中也会出现.git隐藏文件夹（是git的控制文件） 新建仓库，选择ssh方式进行连接Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 复制代码到Git Bash，即可实现新仓库和本地git的相关联 123git remote add origin git@github.com:PanXF-HUST/test.git #命令查看关联状况git remote -v vscode使用git安装git插件git-commit-plugin：自动生成规范 git 提交信息的插件。 安装后在左边功能区有个源代码管理，根据提示操作 1.提交之前先拉取代码 2.点击加号暂存需要提交的文件 3.提交暂存的文件，写注释 4.推送 git工作原理详解工作区域Git有四个工作区域 工作区（Working Directory)：就是你平时存放项目代码的地方 暂存区(Stage/Index)：用于临时存放你的改动，事实上是一个保存即将提交到文件列表信息的文件 仓库区或本地仓库(Repository或Git Directory)：就是安全存放数据的位置，这里面有你提交到所有版本的数据，其中HEAD指向最新放入仓库的版本 远程仓库(Remote Directory)：托管代码的服务器 git的工作流程1.在工作区添加，修改文件2.将需要进行版本管理的文件存入暂存区 git add.3.将暂存区的文件提交到git仓库 git commit 因此，git管理的文件有三种状态：已修改（modified）、已暂存（staged）、已提交（committed） 1234567891011#查看指定文件状态git status [filename]#查看所有文件状态git status#添加所有文件到暂存区git add.#提交暂存区中的内容到本地仓库git commit -m \"描述\" 忽略文件有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立”.gitignore”文件，此文件有如下规则： 1.忽略文件中的空行或以井号(#)开始的行将会被忽略。2.可以使用Liux通配符。例如：星号(*)代表任意多个字符，问号(？)代表一个字符，方括号([abc])代表可选字符范围，大括号({string1,string2})代表可选的字符串等。3.如果名称的最前面有一个感叹号(！)，表示例外规则，将不被忽略。4.如果名称的最前面是一个路径分隔符(/)，表示要忽略的文件在此目录下，而子目录中的文件不忽略。5.如果名称的最后面是一个路径分隔符(/)，表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 提交文件修改到远程仓库的最简步骤git add .git commit -m “注释” 注释必填git pullgit push origin 分支 git bash快捷键 复制 ctrl + insert 粘贴 shift + insert 参考参考文章 参考文章 参考 参考b站视频","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/tags/%E7%9F%A5%E8%AF%86/"}],"author":"wenke"},{"title":"hexo博客搭建","slug":"hexo博客搭建","date":"2021-11-19T02:32:49.000Z","updated":"2022-03-17T04:18:20.966Z","comments":true,"path":"2021/111958091.html","link":"","permalink":"https://wenkexia.github.io/2021/111958091.html","excerpt":"","text":"Hexo 简介Hexo 是一个快速，简单且功能强大的博客框架。如果你用 Markdown 写博客，Hexo 可以在几秒内生成带有精美主题的静态文件。 准备环境Node.js 安装。Git 并安装配置环境变量，两个都要配置 安装Hexo，创建一个文件夹例如blog，右键打开Git Bash运行： npm install -g hexo-cli查看版本 hexo -v 初始化Hexohexo init blogcd blog #进入blog目录npm install 新建完成后，指定文件夹目录下有：node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件 Hexo版本升级12345678910111213141516171819# 使用淘宝源的 cnpm 替换 npmnpm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g cnpm # 升级 npmcnpm cache clean -f # 清除 npm 缓存===更新 hexo: 进入 blog 目录，执行如下命令=== # 更新 package.json 中的 hexo 及个插件版本cnpm install -g npm-check npm-check # 检查之前安装的插件，都有哪些是可以升级的 cnpm install -g npm-upgrade npm-upgrade # 升级系统中的插件# 更新 hexo 及所有插件cnpm update# 确认 hexo 已经更新hexo -v 创建GitHub仓库或者码云仓库1.创建仓库，仓库名必须和用户名一致，其他按照默认，直接创建2.打开cmd，添加Git本地用户git config –global user.name “ 用户名 “git config –global user.email “绑定的邮箱” 3.申请Sky秘钥ssh-keygen -t rsa -C “Git绑定的邮箱”sky在这 C:\\Users\\啊科.ssh 4.复制Sky秘钥添加到GitHub或者码云查看是否成功 ssh -T git@github.com 将本地仓库与远程仓库连接1.安装git部署插件：才能用hexo d 上传npm install hexo-deployer-git –save 2.复制生成的仓库连接修改博客目录下的_config.yml文件 1234deploy: type: git repository: https://gitee.com/wenkex/wenkex.git branch: master 本地创建文章，上传到远程仓库hexo clean清理缓存 hexo g 刷新博客文章 hexo s 开启本地映射 #为了在本地检查文章，该步骤可以跳过，该命令按Ctrl+C结束 hexo d 将本地博客上传到远程仓库，第一次上传会让你输入GitHub或码云的账号密码等待上传完成，打开Gitee pages，更新Https内容（每次上传文件后都要执行这一步） 在你创建的博客文件夹下打开git bash，输入命令 hexo new 文章标题 用yarn cgd或npm run cgd运行如下命令hexo cl &amp;&amp; hexo g &amp;&amp; hexo d一键上传到远程仓库hexo cl &amp;&amp; hexo g &amp;&amp; hexo s一键开启本地映射 1.目录结构说明参考参考 在执行过Hexo deploy命令之后，目录结构新增了.deploy_git，public，.gitignore，如下 123456789101112131415161718 $ tree -L 2.├── .deploy_git├── node_modules├── public├── scaffolds│&nbsp;&nbsp; ├── draft.md│&nbsp;&nbsp; ├── page.md│&nbsp;&nbsp; └── post.md├── source│&nbsp;&nbsp; ├── _posts│&nbsp;&nbsp; ├── _drafts├── themes├── _config.yml├── db.json├── package.json└── package-lock.json _config.yml用来配置博客相关的参数，初始化时自动创建 node_modules用来存储已安装的各类依赖包 package.json用来查看 Hexo 的版本以及相关依赖包的版本。 scaffold模板文件夹，初始化时自动创建。包含page，post，draft三种模板，分别对应 页面、要发布的文章、草稿。在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：$ hexo new photo \"My Gallery\"在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章， themes主题文件夹，初始化时自动创建。每一个主题，都有一个单独的文件夹。 source：资源文件夹。用来存放图片、Markdown 文档（文章、草稿）、各种页面（分类、关于页面等）。 public：将 source 文件夹里的 Markdown 文档，转换成 index.html。再结合主题进行渲染，就是我们最终看到的博客。 .deploy_git：将 public 文件夹的内容提交到 Github 后生成，内容与 public 文件夹基本一致。 这三者的关系大致是：source -&gt; public -&gt; .deploy_git执行hexo generate，根据 source，更新 public。执行hexo deploy，根据 public，更新 .deploy_git。 2.常用命令1.hexo server #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。简写：hexo s 2.hexo clean#清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹 3.hexo g#生成静态网页 (执行后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下) 等价于hexo generate 4.hexo d#自动生成网站静态文件，并将本地数据部署到设定的仓库(如github)等价于hexo deploy 3.更换主题Hexo主题升级方法1.使用Git Bash工具跳转到主题文件对应的目录中2.首先，更新工作的状态树：git add .3.之后，输入如下命令，将文件放在堆栈中，获取更新后，再弹栈： 1234git stashgit pullgit stash pop 4.新建文章自动打开编辑器执行 hexo new “名字”，这样就会在_posts 下生成一篇新文章，但需要手动打开，1.只需要在站点根目录下新建 scripts 目录，2.然后在scripts目录下新建 auto_open.js，在文件填入一下内容： 12345var spawn = require('child_process').exec;// Hexo 3 用户复制这段hexo.on('new', function(data){ spawn('start \"D:\\Program Files\\Typora\\Typora.exe\" ' + data.path);}); 其中 “D:\\Program Files\\Typora\\Typora.exe” 是我本地编辑器的路径，只需要改为你本地编辑器的路径即可，然后在执行 hexo cl &amp;&amp; hexo g -d，部署到 GitHub 即可，以后在发布文章就会自动打开编辑器。 5.一键部署通过 hexo-deployer-git 插件可以实现一键将博客同时部署到多个git仓库中。如同时发布到github及gitee提供的pages服务。安装：npm install hexo-deployer-git --save修改 Hexo 根目录下的_config.yml 文件中的如下内容: 12345678910#一键部署，修改成自己的repo和branchdeploy: - type: git repo: https://github.com/lxl80/blog.git branch: gh-pages ignore_hidden:false -type:git repo:https://gitee.com/lxl80/lxl80.git branch:master ignore_hidden:false 简化部署在package.json中添加\"cgd\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo d\"以后就可以用npm run cgd直接部署上线 12345678\"scripts\": { \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"deploy\": \"hexo deploy\", \"server\": \"hexo server\", \"cgs\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\", \"cgd\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo d\"}, 6.使用文章资源文件夹(弃用，现在用图床)在config.yaml文件中更改一下配置：post_asset_folder: true当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。此时应该使用这样的方式来引入图片：{% asset_img image.jpg 这是一张图片 %} 图片插件 插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 7.github添加自己的域名参考 1.注册一个域名2.添加域名解析（注：使用自定义域名，需要将记录类型修改为 CNAME 将域名指向另一个域名，记录值修改为 GitHub对应仓库名，如：zhang123-123.github.io）3.在GitHub 中设置新的注册的域名（具体位置：Settings –&gt; Pages –&gt; Custom domain），之后保存验证就可以了4.进入 hexo 根目录的 source 文件夹；创建 CNAME 文件，文件添加域名 –&gt; zhangyh.fun。注意：文件名全部大写，没有后缀；文件内容只有域名；5.重新生成静态文件，并提交。hexo d 8.搜索1.使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下：npm install hexo-generator-search --save2.在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123search: path: search.xml field: post 3.在主题配置文件中开启本地搜索 9.文章字数统计插件如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。安装命令如下：npm i --save hexo-wordcount然后只需在主题下的 _config.yml 文件中，激活以下配置项即可： 12345wordCount: enable: false # 将这个值设置为 true 即可. postWordCount: true min2read: true totalCount: true 10.图片懒加载 图片预加载：顾名思义，图片预加载就是在网页全部加载之前，提前加载图片。当用户需要查看时可直接从本地缓存中渲染，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，这样浏览者可能以为图片预览慢而没兴趣浏览，把网页关掉，这时，就需要图片预加载。当然这种做法实际上牺牲了服务器的性能换取了更好的用户体验。 图片懒加载（缓载）：延迟加载图片或符合某些条件时才加载某些图片。这样做的好处是减少不必要的访问数据库或延迟访问数据库的次数，因为每次访问数据库都是比较耗时的即只有真正使用该对象的数据时才会创建。懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 懒加载对服务器前端有一定的缓解压力作用，预载则会增加服务器前端压力。使用图片懒加载需要安装插件：hexo-lazyload-image在站点根目录执行下面的命令： 1npm install hexo-lazyload-image --save 之后在站点配置文件下添加下面的代码： 1234lazyload: enable: true # 是否开启图片懒加载 onlypost: false # 是否只对文章的图片做懒加载 loadingImg: # eg ./images/loading.gif 11.代码压缩因为 hexo 生成的 html、css、js 等都有很多的空格或者换行，而空格和换行也是占用字节的，所以需要将空格换行去掉也就是我要进行的 “压缩”。我们采用 gulp 代码压缩方式。使用方法： 进入站点根目录下依次执行下面的命令： 123456# 全局安装gulp模块npm install gulp -g# 安装各种小功能模块 执行这步的时候，可能会提示权限的问题，最好以管理员模式执行npm install gulp gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save# 额外的功能模块npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save 在 Hexo 根目录新建文件 gulpfile.js，并复制以下内容到文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168var gulp = require(\"gulp\");var debug = require(\"gulp-debug\");var cleancss = require(\"gulp-clean-css\"); //css压缩组件var uglify = require(\"gulp-uglify\"); //js压缩组件var htmlmin = require(\"gulp-htmlmin\"); //html压缩组件var htmlclean = require(\"gulp-htmlclean\"); //html清理组件var imagemin = require(\"gulp-imagemin\"); //图片压缩组件var changed = require(\"gulp-changed\"); //文件更改校验组件var gulpif = require(\"gulp-if\"); //任务 帮助调用组件var plumber = require(\"gulp-plumber\"); //容错组件（发生错误不跳出任务，并报出错误内容）var isScriptAll = true; //是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件)var isDebug = true; //是否调试显示 编译通过的文件var gulpBabel = require(\"gulp-babel\");var es2015Preset = require(\"babel-preset-es2015\");var del = require(\"del\");var Hexo = require(\"hexo\");var hexo = new Hexo(process.cwd(), {}); // 初始化一个hexo对象// 清除public文件夹gulp.task(\"clean\", function () { return del([\"public/**/*\"]);});// 下面几个跟hexo有关的操作，主要通过hexo.call()去执行，注意return// 创建静态页面 （等同 hexo generate）gulp.task(\"generate\", function () { return hexo.init().then(function () { return hexo .call(\"generate\", { watch: false }) .then(function () { return hexo.exit(); }) .catch(function (err) { return hexo.exit(err); }); });});// 启动Hexo服务器gulp.task(\"server\", function () { return hexo .init() .then(function () { return hexo.call(\"server\", {}); }) .catch(function (err) { console.log(err); });});// 部署到服务器gulp.task(\"deploy\", function () { return hexo.init().then(function () { return hexo .call(\"deploy\", { watch: false }) .then(function () { return hexo.exit(); }) .catch(function (err) { return hexo.exit(err); }); });});// 压缩public目录下的js文件gulp.task(\"compressJs\", function () { return gulp .src([\"./public/**/*.js\", \"!./public/libs/**\"]) //排除的js .pipe(gulpif(!isScriptAll, changed(\"./public\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress JS:\" }))) .pipe(plumber()) .pipe( gulpBabel({ presets: [es2015Preset] // es5检查机制 }) ) .pipe(uglify()) //调用压缩组件方法uglify(),对合并的文件进行压缩 .pipe(gulp.dest(\"./public\")); //输出到目标目录});// 压缩public目录下的css文件gulp.task(\"compressCss\", function () { var option = { rebase: false, //advanced: true, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: \"ie7\" //保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式] //keepBreaks: true, //类型：Boolean 默认：false [是否保留换行] //keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 }; return gulp .src([\"./public/**/*.css\", \"!./public/**/*.min.css\"]) //排除的css .pipe(gulpif(!isScriptAll, changed(\"./public\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress CSS:\" }))) .pipe(plumber()) .pipe(cleancss(option)) .pipe(gulp.dest(\"./public\"));});// 压缩public目录下的html文件gulp.task(\"compressHtml\", function () { var cleanOptions = { protect: /&lt;\\!--%fooTemplate\\b.*?%--&gt;/g, //忽略处理 unprotect: /&lt;script [^&gt;]*\\btype=\"text\\/x-handlebars-template\"[\\s\\S]+?&lt;\\/script&gt;/gi //特殊处理 }; var minOption = { collapseWhitespace: true, //压缩HTML collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=\"true\"/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=\"\" /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=\"text/javascript\" removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=\"text/css\" removeComments: true, //清除HTML注释 minifyJS: true, //压缩页面JS minifyCSS: true, //压缩页面CSS minifyURLs: true //替换页面URL }; return gulp .src(\"./public/**/*.html\") .pipe(gulpif(isDebug, debug({ title: \"Compress HTML:\" }))) .pipe(plumber()) .pipe(htmlclean(cleanOptions)) .pipe(htmlmin(minOption)) .pipe(gulp.dest(\"./public\"));});// 压缩 public/medias 目录内图片gulp.task(\"compressImage\", function () { var option = { optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false //类型：Boolean 默认：false 多次优化svg直到完全优化 }; return gulp .src(\"./public/medias/**/*.*\") .pipe(gulpif(!isScriptAll, changed(\"./public/medias\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress Images:\" }))) .pipe(plumber()) .pipe(imagemin(option)) .pipe(gulp.dest(\"./public\"));});// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆 -&gt; 部署到服务器gulp.task( \"build\", gulp.series( \"clean\", \"generate\", \"compressHtml\", \"compressCss\", \"compressJs\", \"compressImage\", gulp.parallel(\"deploy\") ));// 默认任务gulp.task( \"default\", gulp.series( \"clean\", \"generate\", gulp.parallel(\"compressHtml\", \"compressCss\", \"compressJs\",\"compressImage\") ));//Gulp4最大的一个改变就是gulp.task函数现在只支持两个参数，分别是任务名和运行任务的函数 以后的执行方式有两种： 直接在 Hexo 根目录执行 gulp 或者 gulp default ，这个命令相当于 hexo cl&amp;&amp;hexo g 并且再把代码和图片压缩。 在 Hexo 根目录执行 gulp build ，等于说生成、压缩文件后又帮你自动部署了。 12.文章链接转静态短地址如果文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于SEO，且gitment评论对中文链接也不支持。我们可以用hexo-permalink-pinyin Hexo 插件生成文章时生成中文拼音的永久链接，或者用hexo-abbrlink 生成静态文章链接。以下结合hexo-abbrlink生成类似 /yyyy/mmdd+随机数.html 的文章链接地址。安装命令如下：npm install hexo-abbrlink --save在 Hexo 根目录下的 _config.yml 文件中，修改 permalink: ，并在文件末尾新增 abbrlink:配置项： 12345permalink: :year/:month:day:abbrlink.htmlabbrlink: alg: crc16 #算法选项：crc16丨crc32 rep: dec #输出进制：dec为十进制，hex为十六进制 博客备份hexo-git-backup(暂未采用)项目地址 安装npm install hexo-git-backup --save 配置新建仓库，例如 Hexo_backup ，权限设为 private ，分支默认main先获取项目 ssh 链接：在 hexo配置文件 中添加以下内容： 1234backup: type: git repository: backup: git@github.com:xingjiahui/Hexo-Backup.git,main 使用hexo b 3.CDN 加速5.SEO优化参考 搜索引擎优化，又称为SEO，即Search Engine Optimization，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。Google自动收录效果还不错，百度就差得远了（GitHub不允许百度的Spider爬取GitHub上的内容）。所以在第三步验证网站的时候，建议选择CNAME验证的方式。 生成 sitemap 文件1.安装插件查看是否有安装插件npm [name] -v 百度 npm install hexo-generator-baidu-sitemap --save谷歌 npm install hexo-generator-sitemap --save 2.添加站点配置_config.yml 12345sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 再重启 hexo，在本地访问 localhost:4000/sitemap.xml和 localhost:4000/baidusitemap.xml 就能正确的展示出两个sitemap 文件了。 推送到 谷歌 和 百度百度百度站点管理添加文件方式不可行，hexo会处理html文件 所以选择，在 head.ejs 里添加 html 标签 1.1 手动提交baidusitemap.xml(里面也有自动提交的代码) 1.2 可以用”抓取诊断”，手动-百度抓取 1.3 Robots → 检测并更新 谷歌谷歌站点管理 在根目录下 新建 robots.txtrobots配置 1234567891011121314User-agent: *Allow: /Allow: /home/Allow: /archives/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://yoursite/sitemap.xmlSitemap: http://yoursite/baidusitemap.xml Hexo自定义原理Hexo 系列的博客中的文章都是经Hexo的主题渲染的静态网页。所以Hexo博客大部分都呈现出一种高度的统一化与规范化。不过 Hexo 提供了跳过渲染功能，使得我们可以直接在博客中放入自定义网页。 比如在博客中放入图片、自定义404.html、自定义About页面、简历等创建自定义网页网页可以是自己编写的，也可以是别人现成的源码（下载喜欢的页面）。 添加文件网页编写完成后，在Hexo\\source目录下创建一个文件夹（文件夹名称任意，比如我创建的是about这个文件夹，部署完成后，访问http://mrlsm.github.io/about即可看到效果，依此类推） 将 html 文件放置于此文件夹，并重命名为 index.html 。 跳过渲染有下述两种方法： 1.指定文件跳过渲染实现原理 给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。 实现方法在不需要渲染的文章或HTML文件头部添加以下标记 123---layout: false--- 添加该指令后，执行 hexo g命令时便会跳过该 index.html文件，使得index.html不受当前 hexo 主题影响，完全是一个独立的网页，如果网页引用了 css 或 js，css 和 js 需使用外链或者将css js 文件放入index.html同目录下引用。 引用图片亦是如此 2.对相关文件跳过渲染实现原理只有source目录下的文件才会发布到public（能够在网络上访问到），因此Hexo只渲染source目录下的文件。skip_render参数设置的路径是相对于source目录的路径。Hexo的配置文件中提供了配置项skip_render ，是用来对不需要的目录或者文件进行渲染排除。 实现方法在_config.yml文件中设置skip_render使用编辑器打开 Hexo 目录下的_config.yml文件，找到skip_render skip_render一般有以下四种常用参数： 跳过source目录下的 test.html:skip_render: test.html 跳过source目录下 test 文件夹内所有文件：skip_render: test/* 跳过source目录下 test 文件夹内所有文件包括子文件夹以及子文件夹内的文件：skip_render: test/** 跳过多个路径：1234skip_render: - test.html - test/* 不渲染 md 文件skip_render: test/*.md 单个文件夹下指定类型文件 安装一个本地后台管理(Hexo Admin)1.在博客根目录下运行下列指令npm install –save hexo-admin2.运行hexo s3.接下来在浏览器地址栏粘贴这个地址，http://localhost:4000/admin/4.增加密码进入Settings &gt; Setup authentification设置账户，密码得到一串配置填加到站点配置文件下 12345admin: username: myfavoritename password_hash: be121740bf988b2225a313fa1f107ca1 secret: a secret something 增加上传功能在博客根目录下运行下列指令 123456echo \"hexo clean &amp;&amp; hexo g -d\"&gt;hexo-deploy.bat #生成一个内容为\"hexo clean &amp;&amp; hexo g -d\"，名为\"hexo-deploy\"的bat文件。#配置_config.yml文件，echo admin:&gt;&gt;\"_config.yml\"echo \" deployCommand: 'hexo-deploy.bat'\"&gt;&gt;\"_config.yml\"#开启hexo服务hexo server -d 这个教程是对于github的部署的。如果想用来管理gitee的博客，建议修改成echo “hexo clean &amp;&amp; hexo g -d &amp;&amp; start https://gitee.com/用户名/用户名/pages\"&gt;hexo-deploy.bat，这样方便在网页端同步更新gitee page。在网页中编辑完，直接左上角Deploy，直接点deploy按钮，就可以完成博客的部署。 可能遇到的问题(每次都要输入密码)：查看一下你的_config.yml，将文档最后的deploy的repo从http改为git@github类型。 图床建议使用utool里的图床插件，picGo还要下载，而utool里还有其他有趣的插件 使用 PicGo+GitHub图床参考 新建GitHub仓库创建是记住分支名，默认是main 生成一个Token在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页 配置PicGo前往下载PicGo，安装好后开始配置图床设定仓库名：按照【用户名/图床仓库名】的格式填写 设定分支名：【main】 设定Token：粘贴之前生成的【Token】 设定自定义域名：它的作用是，在图片上传后，PicGo 会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接，并放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【https://cdn.jsdelivr.net/gh/用户名/图床仓库名 】 使用 PicGo+Gitee (码云) 搭建免费图床参考1.新建公开仓库2.在主页的设置里生成私人令牌，这个密钥一定要保存好，之后就显示不了了3.下载安装PigGo软件，进去软件界面，搜索插件gitee-uploader下载安装，然后重启配置图床","categories":[{"name":"hexo","slug":"hexo","permalink":"https://wenkexia.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wenkexia.github.io/tags/hexo/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"},{"name":"前端","slug":"前端","permalink":"https://wenkexia.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"学习","slug":"学习","permalink":"https://wenkexia.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"},{"name":"hexo","slug":"hexo","permalink":"https://wenkexia.github.io/categories/hexo/"},{"name":"自动化","slug":"自动化","permalink":"https://wenkexia.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkexia.github.io/categories/%E9%B8%BF%E8%92%99/"},{"name":"java","slug":"java","permalink":"https://wenkexia.github.io/categories/java/"},{"name":"资源分享","slug":"资源分享","permalink":"https://wenkexia.github.io/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"图像","slug":"图像","permalink":"https://wenkexia.github.io/tags/%E5%9B%BE%E5%83%8F/"},{"name":"pandas","slug":"pandas","permalink":"https://wenkexia.github.io/tags/pandas/"},{"name":"numpy","slug":"numpy","permalink":"https://wenkexia.github.io/tags/numpy/"},{"name":"web自动化","slug":"web自动化","permalink":"https://wenkexia.github.io/tags/web%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"爬虫","slug":"爬虫","permalink":"https://wenkexia.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"css","slug":"css","permalink":"https://wenkexia.github.io/tags/css/"},{"name":"待分","slug":"待分","permalink":"https://wenkexia.github.io/tags/%E5%BE%85%E5%88%86/"},{"name":"深度学习","slug":"深度学习","permalink":"https://wenkexia.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"web","slug":"web","permalink":"https://wenkexia.github.io/tags/web/"},{"name":"linux","slug":"linux","permalink":"https://wenkexia.github.io/tags/linux/"},{"name":"小程序","slug":"小程序","permalink":"https://wenkexia.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"window","slug":"window","permalink":"https://wenkexia.github.io/tags/window/"},{"name":"自动化","slug":"自动化","permalink":"https://wenkexia.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"hexo","slug":"hexo","permalink":"https://wenkexia.github.io/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"https://wenkexia.github.io/tags/markdown/"},{"name":"vscode","slug":"vscode","permalink":"https://wenkexia.github.io/tags/vscode/"},{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/tags/python/"},{"name":"autojs","slug":"autojs","permalink":"https://wenkexia.github.io/tags/autojs/"},{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkexia.github.io/tags/%E9%B8%BF%E8%92%99/"},{"name":"效率","slug":"效率","permalink":"https://wenkexia.github.io/tags/%E6%95%88%E7%8E%87/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://wenkexia.github.io/tags/JavaScript/"},{"name":"容器","slug":"容器","permalink":"https://wenkexia.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"软件","slug":"软件","permalink":"https://wenkexia.github.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"GitHub","slug":"GitHub","permalink":"https://wenkexia.github.io/tags/GitHub/"},{"name":"MySQL","slug":"MySQL","permalink":"https://wenkexia.github.io/tags/MySQL/"},{"name":"计网","slug":"计网","permalink":"https://wenkexia.github.io/tags/%E8%AE%A1%E7%BD%91/"},{"name":"java","slug":"java","permalink":"https://wenkexia.github.io/tags/java/"},{"name":"RSS","slug":"RSS","permalink":"https://wenkexia.github.io/tags/RSS/"},{"name":"插件","slug":"插件","permalink":"https://wenkexia.github.io/tags/%E6%8F%92%E4%BB%B6/"},{"name":"网站","slug":"网站","permalink":"https://wenkexia.github.io/tags/%E7%BD%91%E7%AB%99/"},{"name":"学习","slug":"学习","permalink":"https://wenkexia.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/tags/%E7%9F%A5%E8%AF%86/"}]}