{"meta":{"title":"wenke","subtitle":"个人博客","description":"专注于编程,分享生活,分享知识","author":"wenke","url":"https://wenkex.gitee.io","root":"/"},"pages":[{"title":"404","date":"2021-11-01T11:37:13.000Z","updated":"2021-11-01T11:38:12.585Z","comments":true,"path":"404/index.html","permalink":"https://wenkex.gitee.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2021-11-01T11:29:40.000Z","updated":"2022-01-08T12:59:04.203Z","comments":true,"path":"about/index.html","permalink":"https://wenkex.gitee.io/about/index.html","excerpt":"","text":"“&nbsp;免责声明” 大部分资源来源于网络，仅供学习和交流使用，严禁商用，如有侵权，请联系我删除。 所有资源都有时效性，如果遇到失效的，请私信我。"},{"title":"分类","date":"2021-11-01T11:27:35.000Z","updated":"2021-12-21T11:53:24.702Z","comments":true,"path":"categories/index.html","permalink":"https://wenkex.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"相册集","date":"2020-04-21T10:44:23.000Z","updated":"2022-01-06T10:15:44.567Z","comments":true,"path":"gallery/index.html","permalink":"https://wenkex.gitee.io/gallery/index.html","excerpt":"","text":"虾虾 关于虾虾"},{"title":"contact","date":"2021-11-01T11:31:07.000Z","updated":"2021-11-01T11:34:49.609Z","comments":true,"path":"contact/index.html","permalink":"https://wenkex.gitee.io/contact/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-12-21T11:51:03.000Z","updated":"2021-12-21T11:51:03.000Z","comments":true,"path":"link/index.html","permalink":"https://wenkex.gitee.io/link/index.html","excerpt":"","text":"申请友链在评论区留言即可，但需先添加本站友链（申请格式如下文所述） ‘name: wenke’ ‘link: https://wenkex.top/'‘avatar: https://gitee.com/wenkex/blogimage/raw/master/favicon.png' ‘descr: wenke’"},{"title":"","date":"2022-01-06T10:26:36.009Z","updated":"2022-01-06T10:26:36.009Z","comments":true,"path":"gallery/虾虾/index.html","permalink":"https://wenkex.gitee.io/gallery/%E8%99%BE%E8%99%BE/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-01T11:27:35.000Z","updated":"2021-12-21T11:53:03.522Z","comments":true,"path":"tags/index.html","permalink":"https://wenkex.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"nodejs学习","slug":"JavaScript","date":"2022-08-19T07:39:35.000Z","updated":"2022-08-19T07:39:35.000Z","comments":true,"path":"2022/081920764.html","link":"","permalink":"https://wenkex.gitee.io/2022/081920764.html","excerpt":"","text":"JavaScriptJavaScript是一种解释型的脚本语言。不同于C、C++、Java等语言先编译后执行, JavaScript不会产生编译出来的字节码文件，而是在程序的运行过程中对源文件逐行进行解释。 JavaScript 插入 HTML 页面后，由浏览器执行。JavaScript 控制了网页的行为 推荐w3school或者runoobhttps://www.yuque.com/yashujs/bfug6u/ntxhzu#cc4dd1da 浏览器端和服务器端JavaScript组成区别浏览器端： ECMAScript，描述了JavaScript语言的语法和基本对象 文档对象模型（DOM），描述处理网页内容的方法和接口 浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口 服务器端： ECMAScript node.js内置模块：文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等 浏览器端Chrome浏览器运行环境包括V8引擎，内置API V8引擎负责解析和执行js代码 内置API是由运行环境提供的特殊接口 js代码嵌入方式HTML文档内JavaScript代码要写在script标签内script标签可以写在文档内的任意位置为了能够方便查询或操作HTML标签（元素）script标签可以写在body标签后面 12345678&lt;script type=\"text/javascript\"&gt; // 下面是同样实现HelloWorld功能的简化版代码 document.getElementById(\"helloBtn\").onclick = function() { alert(\"Hello simple\"); }; &lt;/script&gt; 引入外部JavaScript文档在script标签内通过src属性指定外部xxx.js文件的路径即可。但是要注意以下两点： 引用外部JavaScript文件的script标签里面不能写JavaScript代码先引入，再使用script标签不能写成单标签 DOMDOM是Document Object Model的缩写，意思是『文档对象模型』——将HTML文档抽象成模型，再封装成对象方便用程序操作。 这是一种非常常用的编程思想：将现实世界的事物抽象成模型，这样就非常容易使用对象来量化的描述现实事物，从而把生活中的问题转化成一个程序问题，最终实现用应用软件协助解决现实问题。而在这其中『模型』就是那个连通现实世界和代码世界的桥梁。 DOM树浏览器把HTML文档从服务器上下载下来之后就开始按照『从上到下』的顺序『读取HTML标签』。每一个标签都会被封装成一个『对象』。 而第一个读取到的肯定是根标签html，然后是它的子标签head，再然后是head标签里的子标签……所以从html标签开始，整个文档中的所有标签都会根据它们之间的『父子关系』被放到一个『树形结构』的对象中。 各个组成部分的类型整个文档 文档节点 DocumentHTML标签 元素节点 ElementHTML标签内的文本 文本节点 TextHTML标签内的属性 属性节点 Attr注释 注释节点 Comment 基础单行注释//块注释/**/ 变量var 存在变量提升的情况，即 var 声明会被提升至该作用域的顶部，但是他们的赋值并不会。而 const 和 let 并不存在这种情况， 在作用域顶部声明变量，避免变量声明和赋值引起的相关问题。var的作用域被规定为一个函数作用域，而let则被规定为块作用域，块作用域要比函数作用域小一些但是如果两者既没在函数中，也没在块作用域中定义，那么两者都属于全局作用域。 局部变量在 JavaScript 函数内部声明的变量是局部变量，所以只能在函数内部访问它，局部变量生命期从被声明的时间开始。在函数运行以后被删除。 基本数据类型数值型：JavaScript不区分整数、小数 布尔型：true、false 在JavaScript中，其他类型和布尔类型的自动转换。 true：非零的数值，非空字符串，非空对象 false：零，空字符串，null，undefined 字符串字符串：JavaScript不区分字符、字符串；单引号、双引号意思一样。 String和Number相加时，会将数字转为字符串；String和Number相减时，会将字符串转为数字； 字符串太长的时候，请不要使用字符串连接符换行 \\，而是使用 + 123const str = '牙叔教程 牙叔教程 牙叔教程' + '牙叔教程 牙叔教程 牙叔教程' + '牙叔教程 牙叔教程' 编程时使用join而不是字符串连接来构建字符串 格式化字符串1234console.show();var i = { name: \"小明\", age: 18, height: 1.72 }; console.log(\"大家好, 我叫%s, 今年%d岁, 身高%d米\", i.name, i.age, i.height);console.log(\"实际上我是一个对象啦，长这样子: %j\", i); 随机字符1234567891011function Radom(n){ //如果不传参就是n=8 var n= n || 8 var str=\"\"; for(var i=0;i&lt;n;i++){ str+=String.fromCharCode(random(0,65535)); } return str;}log(Radom(8)) 引用类型所有new出来的对象用[]声明的数组用{}声明的对象 对象JavaScript 对象是变量的容器。但是，我们通常认为 “JavaScript 对象是键值对的容器”。对象也是一个变量，但对象可以包含多个值（多个变量），每个值以 name:value 对呈现。总结：JavaScript 对象是属性和方法的容器。 JavaScript中没有『类』的概念，对于系统内置的对象可以直接创建使用。 1234567891011121314151617// badconst item = { value: 1, addValue: function (val) { return item.value + val }}// 请使用对象方法的简写方式, 属性不可简写, 方法可以简写 // goodconst item = { value: 1, addValue (val) { return item.value + val }} 创建对象使用new关键字创建对象12345678910// 创建对象var obj01 = new Object();// 给对象设置属性和属性值obj01.stuName = \"tom\";obj01.stuAge = 20;obj01.stuSubject = \"java\";// 在控制台输出对象console.log(obj01); 使用{}创建对象123456789// 创建对象var obj02 = { \"soldierName\":\"john\", \"soldierAge\":35, \"soldierWeapon\":\"gun\"};// 在控制台输出对象console.log(obj02); 对象属性键值对在 JavaScript 对象通常称为 对象属性。访问对象属性你可以通过两种方式访问对象属性: 121.person.lastName;2.person[\"lastName\"]; 对象方法123456789//也可以通过person.firstName=\"...\"的方式初始化var person = {firstName: \"Bill\",lastName : \"Gates\",id : 678,fullName : function() { //成员函数 return this.firstName + \" \" + this.lastName;}}; this关键字this关键字只有两种情况： 在函数外面：this关键字指向window对象（代表当前浏览器窗口） 在函数里面：this关键字指向调用函数的对象12345678910111213141516171819202122// 直接打印thisconsole.log(this);// 函数中的this// 1.声明函数function getName() { console.log(this.name);}// 2.创建对象var obj01 = { \"name\":\"tom\", \"getName\":getName};var obj02 = { \"name\":\"jerry\", \"getName\":getName};// 3.调用函数obj01.getName();obj02.getName(); 数组创建数组使用new关键字创建数组12345678910111213141516171819202122232425262728293031323334// 1.创建数组对象var arr01 = new Array();// 2.压入数据arr01.push(\"apple\");arr01.push(\"orange\");arr01.push(\"banana\");arr01.push(\"grape\");// 3.遍历数组for (var i = 0; i &lt; arr01.length; i++) { console.log(arr01[i]);}// 4.数组元素反序arr01.reverse();for (var i = 0; i &lt; arr01.length; i++) { console.log(arr01[i]);}// 5.数组元素拼接成字符串var arrStr = arr01.join(\",\");console.log(arrStr);// 6.字符串拆分成数组var arr02 = arrStr.split(\",\");for (var i = 0; i &lt; arr02.length; i++) { console.log(arr02[i]);}// 7.弹出数组中最后一个元素var ele = arr01.pop();console.log(ele); 使用[]创建数组123// 8.使用[]创建数组var arr03 = [\"cat\",\"dog\",\"tiger\"];console.log(arr03); arr.push()arr.sort() 数组转字符串123456// join() 方法可以把数组转换为字符串，不过它可以指定分隔符。在调用 join() 方法时，可以传递一个参数作为分隔符来连接每个元素。如果省略参数，默认使用逗号作为分隔符var a = [1,2,3,4,5]; //定义数组var s = a.join(\"\"); //指定分隔符console.log(s); //返回字符串“12345” 使用数组的多个值时123456789// 当需要使用数组的多个值时，请使用解构赋值 const arr = [1, 2, 3, 4]// badconst first = arr[0]const second = arr[1]// goodconst [first, second] = arr 调用数组每个元素forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。 1[1, 2, 3, 5].forEach(function(i){console.log(i);}) 递归autojs之递归 123456789101112131415161718192021// 遍历文件夹, 获取文件列表let dirPath = \"/sdcard/脚本\";let filePathList = getFilePathList(dirPath);log(filePathList);function getFilePathList(dirPath, filePathList) { filePathList = filePathList || []; var fileNameList = files.listDir(dirPath); var len = fileNameList.length; for (var i = 0; i &lt; len; i++) { let filepath = files.join(dirPath, fileNameList[i]); if (files.isFile(filepath)) { filePathList.push(filepath); } else { // 文件夹, 继续向下递 getFilePathList(filepath, filePathList); } } // 文件遍历完成, 终止条件, 返回结果 return filePathList;} 函数参数12// 设置默认参数var n= n || 8 函数表达式1234567891011121314151617181920212223// 匿名函数表达式var anonymous = function() { return true;};// 有名函数表达式(在一个非函数块里声明一个函数)if (currentUser) { var test = function test() { console.log('Yup.'); };}// 自执行匿名函数 (function() { console.log('Welcome to the Internet. Please follow me.');})();// 箭头函数(使用函数表达式（传递匿名函数）时)[1, 2, 3].map((x) =&gt; { const y = x + 1 return x * y}) 构造函数相比于其他面向对象语言，JavaScript对象的构造函数比较特殊，它可以是任何一个普通的函数，而且无需在对象中定义。只有两个约定：构造函数的命名通常以大写开头；构造函数只能由new操作符执行； 当使用new调用一个函数时，这个函数就会变成构造函数使用new调用函数后，函数是有返回值的，即使在定义函数时没有return语句。 12345function People(name){ this.name = name;}let xiaoming = new People('xiaoming'); 匿名函数123456//单独运行一个匿名函数，由于不符合语法要求，报错啦！解决方法只需要给匿名函数包裹一个括号即可：//匿名函数在其它应用场景括号可以省略(function (){ //由于没有执行该匿名函数，所以不会执行匿名函数体内的语句。 console.log(\"张培跃\");}) 如果需要执行匿名函数，在匿名函数后面加上一个括号即可立即执行！ 123(function (){ console.log(\"张培跃\");})() 箭头函数12345678910111213141516//1.经典格式： 函数名 = ( 参数 ) =&gt; { 方法体 } const sum3 = (x,y)=&gt;{ return x+y; }console.log(sum3) //2.当方法体只有一行时，花括号可以省略： const sum4 = (x,y) =&gt; x+y; console.log(sum4) //当只有一个参数时，括号可以省略： const sum4 = x =&gt; x+1; console.log(sum4) 常用函数eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。stringObject.split(separator,howmany) 方法用于把一个字符串分割成字符串数组。 separator 必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。 逻辑运算符1.== 双等号 返回值只有true 和false 类型为布尔型，只比较左右的值，若相等则返回true，反之false2.=== 全等号 返回值为true或false 若左右两边的值和类型均相等，则返回true，反之false3.!= 不相等号 返回值为true或false 不比较类型，只比较值，若左边不等于右边则返回true，反正false ● 使用 === 和 !== 而非 == 和 !=，eslint: eqeqeq● 条件声明例如 if 会用 ToBoolean 这个抽象方法将表达式转成布尔值并遵循如下规则 Objects 等于 true Undefined 等于 false Null 等于 false Booleans 等于 布尔值 Numbers 在 +0, -0, 或者 NaN 的情况下等于 false, 其他情况是 true Strings 为 ‘’ 时等于 false, 否则是 true 12345678910111213141516171819202122//如果等于 ==if(1==1){toastLog(\"正确\")};//如果 不等于 !=if(1 != 2){toastLog(\"正确\")};//如果 大于小于 &gt; &lt; 不举例子var a=true;b=false;//如果真判断简写 正常写 if(a == true){ }if(a){toastLog(\"a=真\")}//如果假判断简写 正常写 if(b == false){ }if(!b){toastLog(\"b=假\")}// &amp;&amp; = 并且if( a==true &amp;&amp; b==false ){toastLog(\"a为真-b为假\")}// || = 或者if( a==false || b==false ){toastLog(\"a或者b其中为假\")} 条件语句if else if else123456789101112if (condition1){ 当条件 1 为 true 时执行的代码}else if (condition2){ 当条件 2 为 true 时执行的代码}else{ 当条件 1 和 条件 2 都不为 true 时执行的代码} Switch 语句计算一次 switch 表达式把表达式的值与每个 case 的值进行对比如果存在匹配，则执行关联代码 1234567891011switch(表达式) { case n: 代码块 break; case n: 代码块 break; default: 默认代码块} 循环语句for语句 1234for (语句 1; 语句 2; 语句 3){ 被执行的代码块} for/in - 循环遍历对象的属性 while 1234while (条件){ 需要执行的代码} do/while 12345do{ 需要执行的代码}while (条件); js正则autojspro不支持正则前向断言 模块管理CJS模块管理模块化主要是用于管理代码，解决解耦与复用问题命名冲突，全局污染模块内部逻辑的封装性隔离模块之间的通讯（依赖引用、循环引用、引用顺序） CJSCommonJS，主要用于服务器端如node.js，主要使用如下： CommonJS规范缺点CommonJS加载模块是同步的：同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行。这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快。 123456789101112// 在模块文件中导出const object = { HaoranOcrClick: HaoranOcrClick, BdOcrClick: BdOcrClick,};module.exports = object; // 在使用文件引入const ocr = require(\"/sdcard/脚本/模块/ocr模块.js\");// \"/storage/emulated/0/\"ocr.HaoranOcrClick('') ESMESM是ESModule，是ECMAScript自己的模块体系，于ES6引入，基本上可以完全取代CJS和AMD。 123456789101112131415// 导出：export命令export const obj = {name: 'E1e'}； // 默认导出 export default命令export default {name: 'E1e'}; // 引入接口：import命令 // 引入普通导出import { obj } from './test.js'; // 引入默认导出import obj from './test.js'; 命名约定方法命名initXX：初始化相关方法，使用 init 为前缀标识，如初始化布局 initViewisXX：方法返回值为 boolean 型的请使用 is 或 check 为前缀标识getXX：返回某个值的方法，使用 get 为前缀标识，例如 getNamesetXX：设置某个属性值，使用 set 为前缀标识，例如 setNamehandleXX/processXX：对数据进行处理的方法，例如 handleMessagedisplayXX/showXX：弹出提示框和提示信息，例如 showDialogupdateXX：更新某个东西，例如 updateDatasaveXX：保存某个东西，例如 saveDataresetXX：重置某个东西，例如 resetDataclearXX：清除某个东西，例如 clearDataremoveXX：移除数据或者视图等，例如 removeViewdrawXX：绘制数据或效果相关的，使用 draw 前缀标识，例如 drawText 避免单个字符名，让你的变量名有描述意义。123456789// badfunction q() { // ...stuff...}// goodfunction query() { // ..stuff..} 当命名对象、函数和实例时使用驼峰命名规则123456789101112131415// badvar OBJEcttsssss = {};var this_is_my_object = {};var this-is-my-object = {};function c() {};var u = new user({ name: 'Bob Parr'});// goodvar thisIsMyObject = {};function thisIsMyFunction() {};var user = new User({ name: 'Bob Parr'}); 异步Promisepromise是一个异步编程的抽象，它是一个返回值或抛出exception的代理对象，一般promise对象都有一个then方法，这个then方法是我们如何获得返回值(成功实现承诺的结果值，称为fulfillment)或抛出exception(拒绝承诺的理由，称为rejection)，then是用两个可选的回调作为参数，我们可以称为onFulfilled和OnRejected： 一个promise有下面三个不同状态： pending待承诺 - promise初始状态 fulfilled实现承诺 - 一个承诺成功实现状态 rejected拒绝承诺 - 一个承诺失败的状态 以读取文件为案例，下面是使用回调实现读取文件后应该做什么事情(输出打印)： 1234567readFile(function (err, data) { if (err) return console.error(err) console.log(data)}) 如果我们的readFile函数返回一个promise，那么我们可以如下实现同样的逻辑(输出打印)： 12var promise = readFile()promise.then(console.log, console.error) async与await123456789101112131415161718// await 关键字后的函数var Delay_Time = function(ms) { return new Promise(function(resolve) { setTimeout(resolve, 1000) } )}// async 函数(在函数体前通过关键字async可以将函数变为async函数)var Delay_Print = async function(ms) { // 在async函数中对需要异步执行的函数前需加await关键字 await Delay_Time(ms) return new Promise(function(resolve, reject) { resolve(\"End\"); })}// 执行async函数后Delay_Print(1000).then(function(resolve) { console.log(resolve);}) 上面的示例代码定义了三个方法块，分别是async 声明的函数体、await 执行的函数体、async 函数执行后的函数体。整段代码执行的结果是在1000毫秒后，控制台打印出“End”。 通过整段代码我们可以看出：c. await后的函数必须使用Promise对象封装d. async函数执行后返回的是一个Promise对象 NodejsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。电脑安装了Node.js后， Node.js 相当于浏览器，也可以在里面运行 JavaScript 了！ Nodejs的组成：ECMAScript(语言基础，如：语法、数据类型结构以及一些内置对象) os(操作系统) file(文件系统) net(网络系统) database(数据库) 安装Node.js下载地址 打开cmd输入命令检查是否安装成功： 12node -v #查看node版本npm -v #查看npm版本 Node.js 安装成功时也默认安装了 npm， npm 是随 Node.js 一起被安装的包管理工具，你可以理解成 Node.js 自带的应用商店。是用来安装/卸载Node.js需要装的东西 环境配置1.修改全局模块路径和缓存路径当我们在执行npm install express -g命令时，会默认下载到c盘，更改下载盘在nodejs安装目录下创建创建两个文件夹，名称分别为：node_global(全局模块)和node_cache(缓存)，在node_global文件夹下再建一个node_modules文件夹，配置环境变量用 2.win+R打开运行窗口，输入cmd，再输入以下两条指令npm config set prefix “创建的node_global文件夹所在路径”npm config set cache “创建的node_cache文件夹所在路径” 3.修改完毕后，再配置环境变量右键此电脑——&gt;高级系统设置——&gt;环境变量在系统变量中，新建，变量名：NODE_PATH变量值：node_global文件夹下的node_modules文件夹。如：E:\\develop\\nodejs\\node_global\\node_modules 修改用户变量中的Path变量，将默认的npm路径修改为新建的node_global路径如：D:\\ruanjian\\nodejs\\node_global nodejs执行js代码命令行运行nodejs文件打开命令行窗口，把当前目录切换到.js所在目录 1node 文件名.js vscode搭建node开发环境npm参考npm (node package manager) 是 JavaScript 的包管理工具，是 Node.js 平台的默认包管理工具，简单地说，就是通过 npm 下载模块，复用已有的代码，提高工作效率。 NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。npm -v #npm版本 组成npm 由三个独立的部分组成： 网站 注册表（registry） 命令行工具 (CLI) 网站 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。 注册表 是一个巨大的数据库，保存了每个包（package）的信息。 CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。 npm中文文档 切换为 taobao 镜像源国内使用 npm 可能很慢。你可以考虑切换为 taobao 镜像源。 1npm config set registry https://registry.npm.taobao.org 使用123456789101112131415# 安装npm install# 卸载npm uninstall# 清理缓存npm cache clean -fnpm list -g #查看所有全局安装的模块npm list &lt;Module Name&gt; #查看某个模块的版本#使用 npm 命令安装模块npm install &lt;Module Name&gt; # 本地安装npm install &lt;Module Name&gt; -g # 全局安装npm uninstall &lt;Module Name&gt; #卸载 npm update 本地安装： 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。全局安装： 将安装包放在 /usr/local 下或者你 node 的安装目录。 可以直接在命令行里使用。 创建npm模块npm init 版本号: 使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。 语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。 如果只是修复bug，需要更新Z位。 如果是新增了功能，但是向下兼容，需要更新Y位。 如果有大变动，向下不兼容，需要更新X位。 cnpm 是什么？简单的讲就是中国版的 NPM，因为 npm 安装插件是从国外服务器下载，受网络影响大，可能出现异常，需要安装 cnpm 模块，命令如下： 1npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm 支持可以使用支持 npm 除 publish 之外的所有命令。 因为 cnpm 的仓库只是 npm 仓库的一个拷贝，它不承担 publish 工作，所以执行 cnpm publish 命令会失败的。 yarn 是什么？Yarn 是一个软件包管理器，还可以作为项目管理工具，你可以通过它使用全世界开发者的代码， 或者分享自己的代码。 从 npm 安装软件包并保持相同的包管理流程。 特点：1.速度超快。Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。 2.超级安全在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。 3.超级可靠使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。通过命令安装 1npm install -g yarn 常用命令yarn init：初始化项目，会在根目录下生成一个 package.json，与 npm 类似具体不做解释 yarn add ：安装依赖包，会自动安装最新版本，会覆盖指定版本号 yarn add ：一次性添加多个包 yarn add @version：添加指定版本的包 yarn upgrade @version：将包更新到指定版本 yarn upgrade –latest ：将包更新到最新版本 yarn remove ：删除包 yarn remove ：一次性删除多个包 yarn info ：可以用来查看某个模块的最新版本信息 yarn install：安装 package.json 里所有包，并将包及它的所有依赖项保存进 yarn.lock yarn install –force ：强制重新下载所有包 yarn install –flat：安装一个包的单一版本 yarn install –production：只安装 dependencies 里的包 yarn install –no-lockfile：不读取或生成 yarn.lock yarn install –pure-lockfile：不生成 yarn.lock 遇到的问题安装npm模块时，没有权限解决方法：打开nodejs安装目录的属性把权限全部勾上 npm的包安装分为本地安装（local）、全局安装（global）两种 本地安装: npm install xxx 安装到命令行所在目录的node_module目录。 全局安装: npm install xxx -g 安装到 \\AppData\\Roaming\\npm\\node_modules目录。 AxiosAxios中文网Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。 安装123456789101112131415使用 npm:$ npm install axios使用 bower:$ bower install axios使用 yarn:$ yarn add axios使用 jsDelivr CDN:&lt;script src=\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\"&gt;&lt;/script&gt;使用 unpkg CDN:&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;","categories":[{"name":"待分","slug":"待分","permalink":"https://wenkex.gitee.io/categories/%E5%BE%85%E5%88%86/"}],"tags":[{"name":"待分","slug":"待分","permalink":"https://wenkex.gitee.io/tags/%E5%BE%85%E5%88%86/"}]},{"title":"题目集合","slug":"题目集合","date":"2022-06-24T00:00:27.000Z","updated":"2022-06-24T00:00:27.000Z","comments":true,"path":"2022/062453983.html","link":"","permalink":"https://wenkex.gitee.io/2022/062453983.html","excerpt":"","text":"python19.sys模块是python标准库中最常用的模块之一。通过它可以获取命令行参数，从而实现从程序外部向程序内部传递参数的功能，也可以获取程序路径和当前系统平台等信息。 25、打开一个已有文件，然后在文件末尾添加信息，正确的打开方式为( C )。A.‘r’B.‘w’C.‘a’D.‘w+’ 31.可以使用del释放变量资源 34、下列表达式的值为True的是 （C）A、5+4j &gt; 2-3j B、3&gt;2&gt;2C 、1==1and2!=1? D、not(1==1and 0!=1)复数不能比较大小，只能比较模 38.(B)函数用于将指定序列中的所有元素作为参数调用指定函数，并将结果构成一个新的序列返回A. lambdaB. mapC. filterD. zip 39.（D）函数以一系列列表作为参数，将列表中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。A. lambdaB. mapC. filterD. zip 51.若 a = ‘abcd’ ，若想将 a 变为 ‘ebcd’ ，则下列语句正确的是DA. a[0] = ‘e’B. replace(‘a’, ‘e’)C. a[1] = ‘e’D. a = ‘e’ + a[1:] 53.执行以下两条语句后，lst的结果是Blst = [3, 2, 1]lst.append(lst) A. [3, 2, 1, [3, 2, 1]]B. [3, 2, 1, […]]，其中“…”表示无穷递归C. 抛出异常D. [3, 2, 1, lst] 75、对于列表ls的操作，以下选项中描述错误的是（A）。A．ls.clear()：删除ls的最后一个元素B．ls.copy()：生成一个新列表，复制ls的所有元素C．ls.reverse()：列表ls的所有元素反转D．ls.append(x)：在ls最后增加一个元素 28%45=28 82、Button组件属性中哪一个是设置Button可变的文本内容对应的变量（A）。A、textvariableB、textC、anchorD、variable 84、下面使用geometry方法设置窗口对象win大小的写法正确的是（C）。A、win.geometry(“400*300”)B、win.geometry(400,300)C、win.geometry(“400x300”)D、win.geometry(400x300) 85、以下哪个不属于SQLite3中的存储类型（B）。A、NULLB、FLOATC、BLOBD、TEXT 87，创建游标对象Cur，以下执行SQL语句正确的是（A）。 A、Cur.execute(“select * from school”)B、Cur.curson(“select * from school”)C、Cur.curson(select * from school)D、Cur.execute(select * from school) 88，以下哪项不是获取游标的查询结果集（d）。 A、cur.fetchone()B、cur.fetchmany()C、cur.fetchall()D、cur.fetchrow() 90、以下关于数据组织的描述中，错误的是（A）。A、一维数据采用线性方式组织，可以用Python集合或列表类型表示B、列表类型仅用于表示一维和二维数据C、二维数据采用表格方式组织，可以用Python列表类型表示D、更高维数据组织由键值对类型的数据构成，可以用Python字典类型表示 22、使用Python列表的方法 insert( ) 为列表插入元素时会改变列表中插入位置之后元素的索引。 36、表达式 list(zip([1,2],[3,4]))的值为 [(1,3),(2,4)] 。37、表达式 sorted([111,2,33], key=lambda x: len(str(x))) 的值为 [2.33.111] 。38、表达式list(filter(lambda x:x&gt;2, [0,1,2,3,0,0]))的值为 [3] 。41、在用来打开或创建文件并返回文件对象函数中访问模式参数使用 b 表示二进制模式。42、打开随机文件后，可以使用实例方法 seek() 函数进行定位。seek()&nbsp;方法用于移动文件读取指针到指定位置。 47、创建对象时，默认调用构造方法；当删除一个对象时，同样会默认调用一个方法，这个方法就是 析构方法 。 50、Tkinter的子模块filedialog中打开文件对话框的函数是 askopenfilename() 。51、Tkinter模块中Label控件的作用是 显示文本和位图 。52、askfloat函数主要用来打开输入对话框,输入并返回 浮点数 。53、SQLite3中浮点数的存储类型是 real 。54、SQLite3中使用 connect 函数建立数据库连接。 简答题1 面向对象语言都有封装，继承，多态，分别描述 封装，继承，多态的含义和作用？答：封装：将类属性赋予给对象 作用：方便调用继承：子类继承父类的属性和方法 作用：减少代码量多态：一类事物的多种表现形式，需要利用继承，方法重写和重载 2.简述read. readline. readlines的区别read:一次性读取整个文件readline:每次读取文件的一行，每一行末尾会读到\\nreadlines:以行的形式读取文件的全部内容，返回一个列表 3.简述实例属性与类属性的区别实例属性：定义在构造方法内，描述类创建的实例对象，需要通过对象来访问。在每个实例对象的内存中都保留一份类属性:在构造方法外定义，描述类对象的属性，所有实例对象公用 4.简述list和tuple的区别？list 是可变数据类型，tuple是不可变数据类型定义方式：list[] tuple()list有insert(),extend(),remove()等方法，tuple没有 5.简述Python 中标识符的命名规则？只能以字母或下划线开头区分大小写关键词不能作为标识符 6.闭包的形成必要条件是什么闭包函数必须有内嵌函数，内嵌函数必须引用外层函数的变量，外层函数返回内嵌函数 在Python面向对象编程时，方法中的”self”代表什么？在定义实例方法时，self作为第一个参数，代表类创建的实例对象本身，用self来引用类的属性和函数","categories":[{"name":"待分","slug":"待分","permalink":"https://wenkex.gitee.io/categories/%E5%BE%85%E5%88%86/"}],"tags":[{"name":"待分","slug":"待分","permalink":"https://wenkex.gitee.io/tags/%E5%BE%85%E5%88%86/"}]},{"title":"计算机原理","slug":"计算机操作系统","date":"2022-05-17T03:07:09.000Z","updated":"2022-05-17T03:07:09.000Z","comments":true,"path":"2022/051717870.html","link":"","permalink":"https://wenkex.gitee.io/2022/051717870.html","excerpt":"","text":"计算机操作系统操作系统的功能和目标作为用户与计算机硬件之间的接口 用户接口操作系统作为用户和计算机硬件之间的接口，需要向上提供一些服务，主要包括命令接口和程序接口 命令接口允许用户直接使用交互式命令接口cmd联机命令接口=交互式命令接口：用户说一句，系统做一件 批处理命令接口脱机命令接口=批处理命令接口：用户说一堆，系统做一堆 系统调用(程序接口)允许用户通过程序间接使用用户进程想要使用硬件资源，只能通过系统调用向操作系统发出请求，操作系统会对各个请求进行协调管理 GUI图形用户界面并发：并发指两个或者多个事件同一时间间隔内发生。这些事件在宏观上是同时发生的，但在微观上是交替发生。 并行：指两个或者多个事件同一时刻同时发生。 共享：共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。 两种资源共享方式： 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段同时共享方式：系统中的某些资源，允许一个时间段内由多个进程”同时”对其进行访问 所谓的”同时”往往是指宏观上的，而为微观上，这些进程可能是交替地对该资源进行访问（即分时共享）。 并发和共享的关系： 并发性：指计算机系统中同时存在着多个运行着的程序。共享性：指系统中的资源可以提供给内存中多个并发执行的进程共同使用。如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义。如果失去共享性，则多个程序进程不能同时访问硬盘资源，就无法同时对硬盘中的数据进行操作，也就无法并发。 进程与进程管理引入进程的作用：为了方便操作系统管理，完成各个程序并发执行程序：就是一个指令序列！ 进程的构成程序段：程序的代码存放的内存空间数据段：程序运行过程中处理的数据存放的内存空间PCB：称为进程控制块（PCB），用来描述进程的各种信息（如程序代码存放位置）PCB是进程存在的唯一标志 程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程。例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。注意：PCB是进程存在的唯一标志！ 从不同的角度，进程可以有不同的定义，比较传统典型的定义有： 进程是程序的一次执行过程。执行前需要将该程序放到内存中，才能够被CPU处理 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 引用进程实体的概念后，可把进程定义为： 进程是进程实体的运行过程，是系统进程资源分配和调度的一个独立单位。 严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。 进程特性进程的异步性：并发执行的进程以各自独立的、不可预知的速度向前推进 进程控制进程控制相关的原语：创建、终止、阻塞、唤醒、切换。也就是说我们通过原语进行进程控制，原语的执行具有原子性，不允许被中断，原语的实现可以通过“关中断指令”和“开中断指令”实现。 进程状态：运行态，就绪态，阻塞态 进程状态转换的条件： 运行 -&gt; 阻塞 等待I/O或事件完成 运行 -&gt; 就绪 进程的CPU时间片用完 就绪 -&gt; 运行 获得了CPU的时间片 阻塞 -&gt; 就绪 I/O或事件完成 进程调度算法https://blog.csdn.net/weixin_46013401/article/details/110819774 1.先来先服务（FCFS）算法：按到达的先后顺序 2.短作业优先算法：选择当前已到达的，且运行时间最短的进程 3.优先级调度算法： 各种时间周转时间：作业被提交给系统开始，到作业完成为止的这段时间间隔。包括：（1）作业在外存后备队列上的等待作业调度的时间。（2）进程在就绪队列上等待进程调度的时间。（3）进程在CPU上执行的时间。（4）进程等待IO操作完成的时间（阻塞队列中等待时间）。公式等待时间=周转时间-运行时间周转时间=等待时间+运行时间=完成时间-到达时间 平均周转时间=各个作业周转时间之和/作业数 带权周转时间=作业周转时间/作业实际运行时间 平均带权周转时间=各个作业带权周转时间之和/作业数 线程当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。 死锁的概念与处理死锁的4个条件，缺一不可 互斥条件：对必须互斥使用的资源的争抢才会导致死锁 不剥夺条件：进程所获得的资源未使用完之前，不能被其他进程强行夺走，只能主动释放。 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己有的资源保持不放。就像很窄的桥，两个人都要去对面，但谁又都无法让出位置来 循环等待条件：存在一种进程资源的循环等待，链中的每一个进程已获得的资源同时被下一个进程所请求。想象有一个闭环，闭环上每个人都需要下一个人手上的某个资源，那么所有人都没办法满足 死锁预防 破坏互斥条件(创建一个队列，所有的请求都会被快速响应，然后队列逐渐将请求发送到处理器进行整理) 破坏不剥夺条件(进程的某个资源得不到满足时，就必须立刻释放所持有的资源) 破坏请求和保持条件(静态分配，进程在运行前就一次性申请全部的资源，不满足就不让允许，就像过桥时保证桥上没人才让通行，否则禁止通行) 破坏循环等待条件(资源编号，进程必须按照编号递增的顺序请求资源,这样就不会出现持有大资源请求小资源的情况，也就不会有循环的等待) (方式较多，这里简单列举一些案例) 死锁避免 银行家算法：进程提出资源申请时，先判断这次分配会不会导致系统进入不安全状态，如果会则不答应请求，让该进程阻塞。简而言之，请求不能大于手中的资源。这种算法也叫银行家算法。 信号量机制原语：是一种特殊的程序段。其执行只能一气呵成，不可被中断用户进程通过使用操作系统提供的一对原语来对信号量进行操作，从而实现对进程互斥，进程同步 信号量其实是一个变量，用一个信号量来表示系统中某种资源的数量对信号量的操作只有三种(初始化，P操作，V操作) 整型信号量:记录型信号量 进程同步和进程互斥进程通信1.管道（pipe）及有名管道（named pipe）： 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 2.信号（signal）： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 3.消息队列（message queue）： 消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。 其基本思想是:根据”生产者-消费者”原理,利用内存中公用消息缓冲区实现进程之间的信息交换. 内存中开辟了若干消息缓冲区,用以存放消息.每当一个进程向另一个进程发送消息时,便申请一个消息缓冲区,并把已准备好的消息送到缓冲区,然后把该消息缓冲区插入到接收进程的消息队列中,最后通知接收进程.接收进程收到发送里程发来的通知后,从本进程的消息队列中摘下一消息缓冲区,取出所需的信息,然后把消息缓冲区不定期给系统.系统负责管理公用消息缓冲区以及消息的传递.一个进程可以给若干个进程发送消息,反之,一个进程可以接收不同进程发来的消息.显然,进程中关于消息队列的操作是临界区.当发送进程正往接收进程的消息队列中添加一条消息时,接收进程不能同时从该消息队列中到出消息:反之也一样.4.共享内存（shared memory）： 可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。 这种通信模式需要解决两个问题：第一个问题是怎样提供共享内存；第二个是公共内存的互斥关系则是程序开发人员的责任。 5.信号量（semaphore）： 主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。 6.套接字（socket）； 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 中断与异常中断机制实现了多道程序并发执行，发生中断意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配i/o设备）需要特权指令，中断使cpu从用户态转换到核心态。并且是唯一途径 内中断(异常)内中断也称为异常，例外，陷入 外中断：信号来源于cpu外部，于当前指令无关 死锁死锁（Deadlock）：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。称此时系统处于死锁状态或系统产生了死锁。称这些永远在互相等待的进程为死锁进程。 存储管理固定分区存储管理可变分区存储管理分页存储管理磁盘移臂调度磁盘移臂调度的目的是尽可能地减少输入输出操作中的寻找时间。常用的移臂调度算法有：① 先来先服务算法② 最短寻找时间优先算法③ 电梯调度算法④ 单向扫描算法。 I/O 控制方式①程序I/O控制方式:适用于结构简单，只需少量硬件的电路；②中断驱动I/O控制方式：适用于高效场合；③直接存储访问DMA I/O控制方式：适用于无须CPU介入的控制器来控制内存与外设之间的数据交流的场合； ④I/O通道控制方式：适用于以字节为单位的干预，同时实现CPU，通道和I/O设备三者并行操作的场合。—- I/O通道控制方式是对DMA控制方式的发展，它进一步使CPU参与到数据传输的控制减少，即把对一个数据块的读/写为单位的干预，减少为对一组数据块的读/写及有关的控制和管理为单位的干预。同时，又可实现CPU、通道和I/O设备的并行操作，从而更有效地提高整个系统的资源利用率。在通道控制方式中，CPU只需发出启动指令，指出要求通道执行的操作和使用的I/O设备，该指令就可以启动通道并使该通道从内存中调出相应的通道程序执行。 进制在计算机中任意数据都是以二进制的形式来储存的 任意进制转十进制系数*基数的权次幂 相加基数：当前机制数权：从左到右依次是0，1，2，3 二进制转十进制8421快速转换法：每一位二进制值的1都代表一个固定数值，把每一位的1代表的十进制数加起来的结果就是所代表的十进制数记住 256 128 64 32 16 8 4 2 1 01111101先写上 ： 0 1 1 1 1 1 0 1然后填充 128 64 32 16 8 4 2 1十进制为 64+32+16+8+4+1=125 十进制转其他进制除基取余法：不断的除以基数,得到余数，知道商为0，再将余数倒着拼起来即为所求进制数 注意16进制AF表示1015 路径相关算法图像相关我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。 名称 RGBA值 名称 RGBA值 White (255, 255, 255, 255) Red (255, 0, 0, 255) Green (0, 255, 0, 255) Blue (0, 0, 255, 255) Gray (128, 128, 128, 255) Yellow (255, 255, 0, 255) Black (0, 0, 0, 255) Purple (128, 0, 128, 255) 像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。分辨率屏幕分辨率例如，屏幕分辨率是1024×768，也就是说设备屏幕的水平方向上有1024个像素点，垂直方向上有768个像素点。像素的大小是没有固定长度的，不同设备上一个单位像素色块的大小是不一样的。例如，尺寸面积大小相同的两块屏幕，分辨率大小可以是不一样的， 分辨率高的屏幕上面像素点（色块）就多，所以屏幕内可以展示的画面就更细致，单个色块面积更小。 分辨率低的屏幕上像素点（色块）更少，单个像素面积更大，可以显示的画面就没那么细致。 图像分辨率例如，一张图片分辨率是500x200,也就是说这张图片在屏幕上按1:1放大时，水平方向有500个像素点（色块），垂直方向有200个像素点（色块）。 在同一台设备上，图片分辨率越高，这张图片1:1放大时，图片面积越大；图片分辨率越低，这张图片1:1缩放时，图片面积越小。（可以理解为图片的像素点和屏幕的像素点是一个一个对应的）。 但是，在屏幕上把图片超过100%放大时，为什么图片上像素色块也变的越大，其实是设备通过算法对图像进行了像素补足，我们把图片放的很大后看到的一块一块的方格子，虽然理解为一个图像像素，但是其实是已经补充了很多个屏幕像素；同理，把图片小于100%缩小时，也是通过算法将图片像素进行减少。","categories":[{"name":"学习","slug":"学习","permalink":"https://wenkex.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"知识","slug":"知识","permalink":"https://wenkex.gitee.io/tags/%E7%9F%A5%E8%AF%86/"}]},{"title":"正则表达式学习","slug":"正则表达式学习","date":"2022-05-05T00:53:39.000Z","updated":"2022-05-05T00:53:39.000Z","comments":true,"path":"2022/050513105.html","link":"","permalink":"https://wenkex.gitee.io/2022/050513105.html","excerpt":"","text":"正则表达式《正则表达式30分钟入门教程》 正则表达式是一种工具验证字符串是否与指定模式匹配(例如，字符串具有电子邮件地址的格式)在字符串中执行替换(例如，将所有美国拼写更改为英国拼写)。 学习正则表达式的最好方法是从例子开始，理解例子之后再自己对例子进行修改， 元字符123456789101112131415. 匹配除换行符 (\\n)以外的任意字符\\w 匹配字母或数字或下划线或汉字\\b 匹配单词的开始或结束，只匹配一个位置。\"/\" 是表达式开始和结束的标记^ 脱字符 表示字符串的开始 $ 表示字符串的结束\\w 匹配字母/数字/下划线\\W 匹配非字母/非数字/非下划线[] 匹配来自括号内字符集的任意单一字符[^] 匹配不在字符集中的任意单一字符，^在[]表示取反\\d 匹配数字\\s 匹配空白字符（包括\\r、\\n、\\t等） 限定符123456* 重复零次或更多次+ 重复一次或更多次? 重复零次或一次{n} 重复n次{n,} 重复n次或更多次{n,m} 重复n到m次 当? 字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 说明： 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\\进行转义处理，例如想匹配小数点可以写成\\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\\(和\\)，否则圆括号被视为正则表达式中的分组。 运算符优先级从高到底\\ 转义符(), (?:), (?=), [] 圆括号和方括号*, +, ?, {n}, {n,}, {n,m} 限定符^, $, \\任何元字符、任何字符 定位点和序列（即：位置和顺序）| 替换，”或”操作字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。 例子从浏览器拷贝出来请求头后， 需要手动的一个个加引号和逗号。现在我们利用Pycharm来进行批量替换。 12345678910Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cache-Control: no-cacheConnection: keep-aliveCookie: read_mode=day; default_font=font2; locale=zh-CN; remember_user_token=W1231sxMzYwNzkwMF0sIiQyYSQxMSRnNVl5MWpmZ0JINXJVazFreXlzQ0V1IiwiMTU0MDI1NTAzNS4xMDE5NDAyIl0%3D--10326e210f857747d9a7c9ace127cab6cdf8d947e; Hm_lvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1540276756,1540284104,1540301802,1540371744; _m7e_session=dbf3985c991afa4c90bb79228626ed6e; Hm_lpvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1540453366; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%221663393b621590-01c145ebcced4d-8383268-2073600-1663393b62272c%22%2C%22%24device_id%22%3A%221663393b621590-01c145ebcced4d-8383268-2073600-1663393b62272c%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E8%87%AA%E7%84%B6%E6%90%9C%E7%B4%A2%E6%B5%81%E9%87%8F%22%2C%22%24latest_referrer%22%3A%22https%3A%2F%2Fwww.baidu.com%2Flink%22%2C%22%24latest_referrer_host%22%3A%22www.baidu.com%22%2C%22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC%22%2C%22%24latest_utm_source%22%3A%22desktop%22%2C%22%24latest_utm_medium%22%3A%22not-signed-in-like-button%22%2C%22%24latest_utm_campaign%22%3A%22maleskine%22%2C%22%24latest_utm_content%22%3A%22note%22%7D%2C%22first_id%22%3A%22%22%7DHost: www.jianshu.comPragma: no-cacheReferer: https://www.jianshu.com/c/068668542235Upgrade-Insecure-Requests: 1 123456勾选Regex使用正则来对数据进行匹配批量修改//利用冒号做分割正则表达式：(.*?): ?(.*)//给冒号两边的数据都加上单引号， 并且在末尾增加逗号//$1表示第一组需要替换成：'$1':'$2', js的正则exec 一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。 matchAll 一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。 search 一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。 match()方法stringObj.match(regExp)一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。 stringObj是必选项，对其进行查找的string对象或字符串文字； regExp是必选项，为包含正则表达式模式和可用标志的正则表达式对象。 test()方法一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。RegExpObject.test(string) string是必需。要检测的字符串。 python的re正则模块Python提供了re模块来支持正则表达式相关操作 通用参数pattern : 一个字符串形式的正则表达式 string : 要匹配的内容 flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 w, W, 方形, B, s, S 依赖于当前环境 re.M 多行模式 re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符） re.U 表示特殊字符集 w, W,方形, B, d, D, s, S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和 # 后面的注释如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。 re.compile()re.compile(pattern, flags=0)将正则表达式转化为对象。需要和findall(), search(), match(）搭配使用 re.search(pattern, string)的调用方式就转换为 pattern.search(string)的调用方式，多次调用一个正则表达式就重复利用这个正则对象，可以实现更有效率的匹配 返回Match objectre.search()search(pattern, string, flags=0)搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象(Match object) 否则返回None pattern: 匹配的规则, string : 要匹配的内容 flags : 可选，表示匹配模式， re.match()必须从字符串开头匹配,如果不是起始位置匹配成功的话，match()就返回none match函数的第一个参数是正则表达式字符串或正则表达式对象 第二个参数是要跟正则表达式做匹配的字符串对象 1234567891011121314151617181920212223import re# 用户名必须由字母、数字或下划线构成且长度在6~20个字符之间m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username)# QQ号是5~12的数字且首位不能为0m2 = re.match(r'^[1-9]\\d{4,11}$', qq)``` &gt; **提示：** 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\\\\\\\，例如表示数字的\\\\d得书写成\\\\\\\\d，这样不仅写起来不方便，阅读的时候也会很吃力。### re.fullmatch() re.fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 ### .group()```pyimport recontent = \"abc123def\"rex_compile = re.compile(\"([a-z]*)([0-9]*)([a-z]*)\")rex = rex_compile.search(content)print(rex.group(0)) # group()和group(0) 一样匹配的是整体print(rex.group(1)) # 匹配第一个小括号的内容 abcprint(rex.group(2)) # 匹配第二个小括号的内容 123 findall()findall(pattern, string, flags=0)查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0)函数re.finditer与re.findall做同样的事情，只是它返回一个迭代器，而不是列表。查找字符串所有与正则表达式匹配的模式 返回一个迭代器 split(pattern, string, maxsplit=0, flags=0)用正则表达式指定的模式分隔符拆分字符串 返回列表 12345678910111213141516# 拆分长字符串import redef main(): poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。' sentence_list = re.split(r'[，。, .]', poem) print(sentence_list) # 删除列表中的空字符串 while '' in sentence_list: sentence_list.remove('') print(sentence_list) # ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡']if __name__ == '__main__': main() 替换re.sub(pattern, repl, string, count=0, flags=0)用指定的字符串替换原字符串中与正则表达式匹配的模式 pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 flags : 编译时用的匹配模式，数字形式。 例子查找字符串中有多少个af1234567891011121314151617181920212223242526272829303132333435# 查找字符串中有多少个afimport re s = \"asdfjvjadsffvaadfkfasaffdsasdffadsafafsafdadsfaafd\" ret = re.findall(r'(af)' , s)print(len(ret))``` ### 提取国内手机号码。```Python, import redef main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern = re.compile(r'(?&lt;=\\D)1[34578]\\d{9}(?=\\D)') sentence = ''' 重要的事情说8130123456789遍，我的手机号是13512346789这个靓号， 不是15600998765，也不是110或119，是不是13512346789，王大锤的手机号才是15600998765。 ''' print('查找所有匹配并保存到一个列表中') mylist = re.findall(pattern, sentence) print(mylist) print('--------通过迭代器取出匹配对象并获得匹配的内容--------') for temp in pattern.finditer(sentence): print(temp.group()) # 搜索字符串中第一次出现正则表达式的模式 print('--------通过search函数指定搜索位置找出所有匹配--------') m = pattern.search(sentence) while m: print(m.group()) m = pattern.search(sentence, m.end())if __name__ == '__main__': main() 说明： 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?&lt;=\\D)(1[38]\\d{9}|14[57]\\d{8}|15[0-35-9]\\d{8}|17[678]\\d{8})(?=\\D)，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。 替换字符串中的不良内容1234567891011import redef main(): sentence = '你丫是傻叉吗? 我操你大爷的. Fuck you.' purified = re.sub('[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔', '*', sentence, flags=re.IGNORECASE) print(purified) # 你丫是*吗? 我*你大爷的. * you.if __name__ == '__main__': main() 按规则拆分长字符串1234567891011121314import redef main(): poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。' sentence_list = re.split(r'[，。, .]', poem) print(sentence_list) # 删除列表中的空字符串 while '' in sentence_list: sentence_list.remove('') print(sentence_list) # ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡']if __name__ == '__main__': main() 正则表达式在线工具https://c.runoob.com/front-end/854/ https://deerchao.cn/tools/wegester/","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"正则","slug":"正则","permalink":"https://wenkex.gitee.io/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"数据库-SQLite","slug":"数据库-SQLite","date":"2022-04-23T08:35:42.000Z","updated":"2022-04-23T08:35:42.000Z","comments":true,"path":"2022/042334747.html","link":"","permalink":"https://wenkex.gitee.io/2022/042334747.html","excerpt":"","text":"SQLiteSQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。 sql语句不区分大小写 数据类型SQLite 存储类每个存储在 SQLite 数据库中的值都具有以下存储类之一： NULL 值是一个 NULL 值。INTEGER 值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。REAL 值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。TEXT 值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。BLOB 值是一个 blob 数据，完全根据它的输入存储。 SQLite 的存储类稍微比数据类型更普遍。INTEGER 存储类，例如，包含 6 种不同的不同长度的整数数据类型。 SQLite 亲和(Affinity)类型SQLite支持列的亲和类型概念。任何列仍然可以存储任何类型的数据，当数据插入时，该字段的数据将会优先采用亲缘类型作为该值的存储方式。SQLite目前的版本支持以下五种亲缘类型： 亲和类型 描述TEXT 数值型数据在被插入之前，需要先被转换为文本格式，之后再插入到目标字段中。NUMERIC 当文本数据被插入到亲缘性为NUMERIC的字段中时，如果转换操作不会导致数据信息丢失以及完全可逆，那么SQLite就会将该文本数据转换为INTEGER或REAL类型的数据，如果转换失败，SQLite仍会以TEXT方式存储该数据。对于NULL或BLOB类型的新数据，SQLite将不做任何转换，直接以NULL或BLOB的方式存储该数据。需要额外说明的是，对于浮点格式的常量文本，如”30000.0”，如果该值可以转换为INTEGER同时又不会丢失数值信息，那么SQLite就会将其转换为INTEGER的存储方式。INTEGER 对于亲缘类型为INTEGER的字段，其规则等同于NUMERIC，唯一差别是在执行CAST表达式时。REAL 其规则基本等同于NUMERIC，唯一的差别是不会将”30000.0”这样的文本数据转换为INTEGER存储方式。NONE 不做任何的转换，直接以该数据所属的数据类型进行存储。 基本语句创建表Insert 语句insert or replace：如果不存在就插入，存在就更新insert or ignore：如果不存在就插入，存在就忽略 Delete 语句Update 语句Select 语句SQLite-Python接口SQLite3 可使用 sqlite3 模块与 Python 进行集成 connection对象sqlite3.connect(database [,timeout ,other optional arguments])连接数据库，自动创建 返回一个连接对象。connection对象方法close() 关闭数据库连接commit() 提交事务rollback() 回滚数据库事务cursor() 获得cursor游标对象 cursor游标对象connection.cursor([cursorClass]) 游标对象方法cursor.execute(sql [, optional parameters])执行sql语句 cursor.executemany(sql, seq_of_parameters)cursor.executescript(sql_script) 获取游标的查询结果集cursor.fetchone()返回结果集的下一行(Row对象)，返回一个序列，无数据时，则返回 None。 cursor.fetchmany([size=cursor.arraysize])返回结果集的多行(Row对象列表)，返回一个列表。无数据时，则返回一个空的列表。该方法尝试获取由 size 参数指定的尽可能多的行。 cursor.fetchall()返回结果集中所有（剩余）的行(Row对象列表)，返回一个列表。无数据时，则返回一个空的列表。 创建表1234567891011121314import sqlite3conn = sqlite3.connect('test.db')print (\"数据库打开成功\")c = conn.cursor()c.execute('''CREATE TABLE COMPANY (ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL);''')print (\"数据表创建成功\")conn.commit()conn.close() 数据库的增删改查12345# 创建数据库cursor.execute('CREATE TABLE [exam] ([question] VARCHAR(80) NULL,[Answer_A] VARCHAR(1) NULL,[Answer_B] VARCHAR(1) NULL,[Answer_C] VARCHAR(1) NULL,[Answer_D] VARCHAR(1) NULL,[right_Answer] VARCHAR(1) NULL)')#插入一条数据cursor.execute(\"insert into exam (question, Answer_A,Answer_B,Answer_C,Answer_D,right_Answer) values ('哈雷慧星的平均周期为', '54年', '56年', '73年', '83年', 'C')\") 操作步骤1234567891011# 导入SQLite驱动:import sqlite3path='test.db'conn = sqlite3.connect(path) # 建立数据库连接，返回一个连接对象。print(f\"连接{path}数据库成功\")cursor = conn.cursor() #创建游标对象cursor.close() # 关闭Cursor:conn.commit() # 提交事务:conn.close() # 关闭Connection:","categories":[{"name":"数据库","slug":"数据库","permalink":"https://wenkex.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"https://wenkex.gitee.io/tags/SQLite/"}]},{"title":"web测试","slug":"postman接口自动化测试","date":"2022-04-20T01:36:28.000Z","updated":"2022-04-20T01:36:28.000Z","comments":true,"path":"2022/04205354.html","link":"","permalink":"https://wenkex.gitee.io/2022/04205354.html","excerpt":"","text":"抓包抓包（packet capture）就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进行数据截取等。抓包的目的就是为了获取到想要的原始数据，拿到数据以后，我们就可以做以下一些事情: 分析数据传输协议。 定位网络协议的问题。 从数据包中获取想要的信息。 将截取到的数据包进行修改，伪造，重发。 为什么抓包？ 从功能测试角度，通过抓包查看隐藏字段 Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 CRSF 攻击，防网络爬虫，以及一些其他用途。这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。 通过抓包工具了解协议内容，方便开展接口和性能测试 性能测试方面，性能测试其实就是大量模拟用户的请求，所以我们必须要知道请求中的协议内容和特点，才能更好的模拟用户请求，分析协议就需要用到抓包工具；接口测试方面，在接口测试时，虽然我们尽量要求有完善的接口文档。但很多时候接口文档不可能覆盖所有的情况，或者因为文档滞后，在接口测试过程中，还时需要借助抓包工具来辅助我们进行接口测试。 需要通过抓包工具，检查数据加密 安全测试方面，我们需要检查敏感数据在传输过程中是否加密，也需要借助抓包工具才能检查。 处理前后端 bug 归属之争 在我们提交bug的时候，经常会出现前端（客户端展示）和后端（服务端的逻辑）的争议，那么可以通过抓包工具，确实是数据传递问题还是前端显示的问题。如果抓出来的数据就有问题的话，那么一般是后端的问题；如果抓出来的数据是正确的，那么基本上可以断定是前端显示的问题。 通过抓包分析，可以更好的理解整个系统 经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。 浏览器抓包最简单的抓包工具——浏览器开发者工具 开放apiAPI Hub接口调试工具ApifoxAPI 文档、API 调试、API Mock、API 自动化测试 和市面上的老牌调试工具Postman相比，Apifox毫不逊色——Postman支持的功能它都能支持，并且Apifox还提供了支持可视化断言，连接数据库，调用外部函数与脚本，支持多种语言，环境变量设置等功能，调试起来也很快捷方便。 postman接口测试responseCode ：包含请求的返回的状态信息(如：code)responseBody：为接口请求放回的数据内容（类型为字符串）tests ：为键值对形式，用于表示我们的测试结果是成功与否，最终展示在 Test Results 中。key ：（如：code 200）我们可以用来当做结果的一个描述value：其值为布尔型，ture 表示测试通过， false 表示测试失败。所以上述代码应该不难理解了，而有了返回结果的数据以及表示结果成功与否 (预请求脚本)Pre-request Script","categories":[{"name":"web","slug":"web","permalink":"https://wenkex.gitee.io/categories/web/"}],"tags":[{"name":"postman","slug":"postman","permalink":"https://wenkex.gitee.io/tags/postman/"}]},{"title":"数据库-redis","slug":"数据库-redis","date":"2022-04-19T01:23:48.000Z","updated":"2022-04-19T01:23:48.000Z","comments":true,"path":"2022/041918402.html","link":"","permalink":"https://wenkex.gitee.io/2022/041918402.html","excerpt":"","text":"redisRedis 是键值对(Key-Value)存储数据库，并提供多种语言的 API。 安装 Redis安装 Redis的docker环境123456789101112131415161718192021222324252627282930313233343536# 要确保docker环境已经安装成功docker --versiondocker search redis#拉取最新版本docker pull redis# -d：使用指定的镜像在后台运行容器，（使用守护进程运行）通过 docker ps查看不到的。因为在 docker 中，后台服务必须要有一个前台服务才能运行（前台服务即使用 -it 选项启动的服务）# -it 表示已交互模式运行容器,为容器重新分配一个伪输入终端# -p 6379:6379 将容器的6379端口映射到主机的6379端口# --name=\"myredis\" 表示自定义容器名# --requirepass \"root\"# -v /docker/redis/data:/data: 将主机中当前目录下的data挂载到容器的/data# redis-server : 在容器执行redis-server启动命令，# --appendonly yes 打开redis持久化配置docker run -d redis:latest -p 6379:6379 redis-server --appendonly yes --name=\"myredis\" --requirepass \"root\"docker start 容器名或容器id# 查看运行中的容器docker ps# 进入redis容器并启动一个redis交互式会话docker exec -it redis容器名 /bin/bash# 在redis交互式会话中连接 redis 服务redis-cli# 清理容器(停止 docker-redis 容器并删除)：docker stop redis容器名docker rm redis容器名 使用123456redis-cli #在redis交互式会话中连接 redis 服务config get requirepass #查看现有的redis密码config set requirepass pass_123456 #设置redis密码","categories":[{"name":"数据库","slug":"数据库","permalink":"https://wenkex.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://wenkex.gitee.io/tags/redis/"}]},{"title":"Java高级","slug":"Java高级","date":"2022-04-04T10:57:26.000Z","updated":"2022-04-04T10:57:26.000Z","comments":true,"path":"2022/040423525.html","link":"","permalink":"https://wenkex.gitee.io/2022/040423525.html","excerpt":"","text":"MavenMaven是一个项目管理及自动构建工具,作为依赖管理工具：管理第三方的外部依赖。使用Maven后，依赖对应的jar包能够自动下载作为构建管理工具 基础知识Maven 功能Maven 能够帮助开发者完成以下工作： 构建文档生成报告依赖SCMs发布分发邮件列表 安装配置idea自带mavenidea有捆绑的 Maven 我们只需要搞一个配置文件就行了，无需再官网下载Maven包 以后再在新电脑装环境的时候，只需要下载idea ，网上找一个Maven的配置文件 放到 默认的 包下面就可以了！也省得每次创建项目都要重新配一次Maven了。 如果不想每次新建项目都要重新配置Maven，一种方法就是使用默认的配置，另一种方法就是配置 new Projects Settings(新项目的配置) 配置阿里云中央仓库1.进入到idea安装目录，找到\\plugins\\maven\\lib 目录，可以看到maven有几个2.修改maven2 或maven3 下conf目录下的settings.xml 文件如下\\IntelliJ IDEA 2022.1.2\\plugins\\maven\\lib\\maven3\\conf\\settings.xml找到mirrors，添加以下内容 1234567&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 自行配置mavenhttps://www.runoob.com/maven/maven-setup.html总的来说，使用自带maven能省去繁琐的配置过程，可马上用来使用，但除此之外，还是劣势更多；相反，自行配置maven会显得使用起来更自由方便。自行配置maven的好处：1、如果你是新手的话，建议自行配置maven，有助于你更好的学习和理解maven，毕竟IDE会屏蔽很多细节，不利于新手学习。2、idea自带的maven在它自己的路径和配置中，为避免升级（无论升级idea还是想升级maven）时发生莫名其妙的问题，自定义配置更能少遇到错误。3、不依赖IDEA，你也可以在其他的IDE上开发。如果你恰好还要同时用eclipse，独立出来会更好管理，可在两个环境间共享配置和仓库。4、idea自带的maven配置文件和仓库都在C盘，而且C盘一般不要放东西，自行配置maven，不仅可以自由管理配置文件和仓库的位置，而且可以任意换maven的版本。 Maven 下载地址：http://maven.apache.org/download.cgi 配置环境变量右键此电脑–&gt;属性–&gt;高级系统设置–&gt;环境变量新建变量MAVEN_HOME = E:\\Tools\\Maven\\apache-maven-3.8.1（以自己的安装路径为准）编辑变量Path，添加变量值%MAVEN_HOME%\\bin然后win+R运行cmd，输入mvn -version，如图所示则配置成功 配置本地仓库1.在E:\\Tools\\Maven\\路径下新建maven-repository文件夹，用作maven的本地库。2.在路径E:\\Tools\\Maven\\apache-maven-3.8.1\\conf下找到settings.xml文件3.找到节点localRepository，在注释外添加&lt;localRepository&gt;E:\\Tools\\Maven\\maven-repository&lt;/localRepository&gt; localRepository节点用于配置本地仓库，本地仓库其实起到了一个缓存的作用，它的默认地址是 C:\\Users\\用户名.m2。当我们从maven中获取jar包的时候，maven首先会在本地仓库中查找，如果本地仓库有则返回；如果没有则从远程仓库中获取包，并在本地库中保存。此外，我们在maven项目中运行mvn install，项目将会自动打包并安装到本地仓库中。 配置镜像在settings.xml配置文件中找到mirrors节点添加如下配置（注意要添加在&lt;mirrors&gt;和&lt;/mirrors&gt;两个标签之间，其它配置同理） 12345678&lt;!-- 阿里云仓库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 无法更新仓库：https://blog.csdn.net/m0_67401382/article/details/123939452 https://www.jianshu.com/p/184e19796437https://its301.com/article/Werdio/116549969 文件和目录结构POM.xmlProject Object Model 项目对象模型， maven把项目当做模型处理。 操作这个模型就是操作项目。maven通过pom.xml文件实现 项目的构建和依赖的管理。 学习框架首先要先了解它是干什么的，然后了解它的项目结构即每个文件有什么用 spring使用其核心思想IOC管理组件，使用AOP思想实现功能增强 SpringMVC接受浏览器发送的请求，并响应浏览器数据 SSM整合springbootSpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程 Spring程序缺点 依赖设置繁琐 配置繁琐 SpringBoot程序优点 起步依赖（简化依赖配置） 自动配置（简化常用工程相关配置） 辅助功能（内置服务器，……） Idea中隐藏指定文件或指定类型文件 Setting → File Types → Ignored Files and Folders 输入要隐藏的文件名，支持*号通配符 回车确认添加 创建项目创建SpringBoot工程的四种方式 基于Idea创建SpringBoot工程基于idea开发SpringBoot程序需要确保联网且能够加载到程序框架结构 spring默认服务器：https://start.spring.io 创建新模块，选择Spring Initializr，并配置模块相关基础信息 基于阿里云创建SpringBoot工程1.通过idea创建，可以更改成阿里云镜像服务：https://start.aliyun.com阿里云提供的坐标版本较低，如果需要使用高版本，进入工程后手工切换SpringBoot版本阿里云提供的工程模板与Spring官网提供的工程模板略有不同 基于官网创建SpringBoot工程2.若idea不能联网，通过spring boot官网创建 手工创建Maven工程修改为SpringBoot工程 创建普通Maven工程 继承spring-boot-starter-parentspring-boot-starter-parent中定义了若干个依赖管理继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突继承parent的形式也可以采用引入依赖的形式实现效果 依赖管理 parent所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的spring-boot-starter-parent各版本间存在着诸多坐标版本不同 starterSpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标，以达到减少依赖配置的目的 实际开发使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V如发生坐标错误，再指定Version（要小心版本冲突） 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;springboot-01-quickstart&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 修改服务器使用maven依赖管理变更起步依赖项 内置服务器tomcat(默认) apache出品，粉丝多，应用面广，负载了若干较重的组件jetty 更轻量级，负载性能远不及tomcat.Jetty比Tomcat更轻量级，可扩展性更强（相较于Tomcat）undertow undertow，负载性能勉强跑赢tomcat 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--web起步依赖环境中，排除Tomcat起步依赖--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--添加Jetty起步依赖，版本由SpringBoot的starter控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基础配置在resources目录下面有一个空白的文件，叫做application.properties。这是一个配置文件 优点 SpringBoot程序可以在application.properties文件中进行属性配置 application.properties文件中只要输入要配置的属性关键字就可以根据提示进行设置 SpringBoot将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面 在官方文档里找到application.properties文件，可查看可修改的配置官方文档 配置[SpringBoot内置属性查询] (https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties) SpringBoot中导入对应starter后，提供对应配置属性 书写SpringBoot配置采用关键字+提示形式书写 若自动提示消失，指定SpringBoot配置文件文件-项目结构-Facets-spring-选择配置文件 复制工程原则：保留工程基础结构，抹掉原始工程痕迹 在工作空间中复制对应工程，并修改工程名称 删除与Idea相关配置文件，仅保留src目录与pom.xml文件 修改pom.xml文件中的artifactId与新工程/模块名相同 删除name标签（可选） 保留备份工程供后期使用 三种文件格式properties格式的配置写起来总是觉得看着不舒服，所以就期望存在一种书写起来更简便的配置格式提供给开发者使用。有吗？还真有，SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。分别如下: 1.application.properties（properties格式） 1server.port=80 2.application.yml（yml格式） 12server: port: 81 3.application.yaml（yaml格式） 12server: port: 82 仔细看会发现yml格式和yaml格式除了文件名后缀不一样，格式完全一样，是这样的，yml和yaml文件格式就是一模一样的，只是文件后缀不同，所以可以合并成一种格式来看。那对于这三种格式来说，以后用哪一种比较多呢？记清楚，以后基本上都是用yml格式的，本课程后面的所有知识都是基于yml格式来制作的，以后在企业开发过程中用这个格式的机会也最多，一定要重点掌握。 总结 1. 配置文件间的加载优先级 properties（最高）&gt; yml &gt; yaml（最低） 2. 不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留 yaml后缀使用.yml或者.yaml都行 优点：易阅读易于脚本语言交互以数据为核心，重数据轻格式 语法规则1.大小写敏感2.属性层级关系使用多行描述，每行结尾使用冒号结束3.使用缩进表示层级关系，同层级左侧对齐，只允许使用空格(不允许使用Tab键)4.属性值前面添加空格(属性名与属性值之间使用冒号+空格作为分隔)5.#表示注释6.使用” “括住的内容可以使用转义字符 常用用$进行变量引用path: c:\\user\\bin temp: ${path}\\temp 12345678boolean: TRUE #TRUE,true,True,FALSE,false，False均可float: 3.14 #6.8523015e+5 #支持科学计数法int: 123 #0b1010_0111_0100_1010_1110 #支持二进制、八进制、十六进制null: ~ #使用~表示nullstring: HelloWorld #字符串可以直接书写string2: \"Hello World\" #可以使用双引号包裹特殊字符date: 2018-02-17 #日期必须使用yyyy-MM-dd格式datetime: 2018-02-17T15:02:31+08:00 #时间和日期之间使用T连接，最后使用+代表时区 数据结构对象：键值对的集合，又称为映射(mapping)/ 哈希(hashes) / 字典(dictionary) 数组：一组按次序排列的值，又称为序列(sequence) / 列表(list) 使用一个短横线+一个空格代表一个数组项： 1234567891011121314151617181920212223subject: - Java - 前端 - 大数据enterprise: name: itcast age: 16 subject: - Java - 前端 - 大数据likes: [ 王者荣耀,刺激战场 ] #数组书写缩略格式users: #对象数组格式一 - name: Tom age: 4 - name: Jerry age: 5users: #对象数组格式二 - name: Tom age: 4 - name: Jerry age: 5users2: [ { name:Tom , age:4 } , { name:Jerry , age:5 } ] #对象数组缩略格式 纯量(scalars)：单个的、不可再分的值 读取yml数据12345678910111213141516lesson: SpringBootserver: port: 82enterprise: name: itcast age: 16 tel: 4006184000 subject: - Java - 前端 - 大数据datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC username: root password: root 读取单个数据使用@Value读取单个数据，属性名引用方式：${一级属性名.二级属性名……} 1234567891011@RestController@RequestMapping(\"/books\")public class BookController { @Value(\"${lesson}\") private String lessonName; @Value(\"${server.port}\") private int port; @Value(\"${enterprise.subject[1]}\") private String[] subject_01;} 在配置文件中可以使用属性名引用方式引用属性 123456baseDir: /usr/local/firecenter: dataDir: ${baseDir}/data tmpDir: ${baseDir}/tmp logDir: ${baseDir}/log msgDir: ${baseDir}/msgDir  属性值中如果出现转移字符，需要使用双引号包裹lesson: \"Spring\\tboot\\nlesson\" 读取全部数据封装全部数据到Environment对象 1234567891011121314151617@RestController@RequestMapping(\"/books\")public class BookController { @Autowired //自动装配数据到Environment对象中 private Environment env; @GetMapping(\"/{id}\") public String getById(@PathVariable Integer id) { System.out.println(env.getProperty(\"lesson\")); System.out.println(env.getProperty(\"enterprise.name\")); System.out.println(env.getProperty(\"enterprise.subject[0]\")); return \"hello , spring boot!\"; }} 读取指定数据自定义对象封装指定数据 12345678910@Component@ConfigurationProperties(prefix = \"enterprise\")public class Enterprise { private String name; private Integer age; private String[] subject;} 12345678@RestController@RequestMapping(\"/books\")public class BookController { @Autowired private Enterprise enterprise;} REST风格REST(Representational State Transfer),表现形式状态转换。它是一种针对网络应用的设计风格，只是建议，并不是规范 优点1.隐藏资源的访问行为，无法通过地址得知对资源是何种操作2.书写简化 传统风格资源描述形式：http://localhost/user/getByID?id=1REST风格描述：http://localhost/user/1 根据REST风格对资源进行访问称为RESTful 请求动作映射名称：@GetMapping @PostMapping @PutMapping @DeleteMapping类型：方法注解位置：基于SpringMVC的RESTful开发控制器方法定义上方作用：设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求 GET(查询)POST(新增)PUT(修改/更新)DELECT(删除) @RequestParam@RequestParam用于接收url地址传参或表单传参 应用后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody,应用较广如果发送非json格式数据，选用@RequestParam接收请求参数采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值 @PathVariable类型：位置：springMVC控制器方法形参定义前面作用：绑定url路径参数与处理器方法形参间的关系 12@RequestMapping(value = \"/users/{id}\")public String delete(@PathVariable Integer id){} 案例1.设定http请求动作 1234567891011@Controller //声明是控制器类public class UserController { @RequestMapping(value = \"/users\", method = RequestMethod.POST) @ResponseBody public String save(@ResponseBody User user) { System.out.println(\"user save\"); return \"{'module':'save'}\"; }} 2.设定请求参数(路径变量) 1234567// 路径上要有参数占位{id}@RequestMapping(value = \"/users/{id}\", method = RequestMethod.DELETE)@ResponseBody //用于接收json数据// 形参注解在形参上加@PathVariable用于接收路径参数，使用{参数名称）描述路径参数public String delete(@PathVariable Integer id){ System.out.println(\"user save\"+id); return\"{'module':'delete'}\"; 快速开发@RestController类型：类注解位置：springMVC控制器类定义上方作用：设置当前控制器类为RESTful风格，等同于@Controller + @ResponseBody两个注解组合功能 1234567891011@RestController //@RestController=@Controller + @ResponseBody@RequestMapping(\"/users\")public class UserController { // @RequestMapping(value = \"/users\",method = RequestMethod.POST) //用@PostMapping代替 @PostMapping public String save() { System.out.println(\"user save\"); return \"{'module':'save'}\"; }} lombok工具最常用的用法就是在实体类中使用它的@Data注解，这样实体类就不用写set、get、toString等方法 @Data注解包含了 @ToString、@EqualsAndHashCode、@Getter / @Setter和@RequiredArgsConstructor的功能 引入依赖123456&lt;!-- pom.xml --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.14&lt;/version&gt;&lt;/dependency&gt; controller调用service,service调用dao 实体层entity层即数据库实体层，也被称为model层，pojo层，domain层存放的是实体类，属性值与数据库中的属性值保持一致。 实现set和get方法。 一般数据库一张表对应一个实体类，类属性同表字段一一对应 使用了 Lombok 简化代码 123456789101112131415161718// entity:@TableName(value = \"user\") //value指定表名@Date //使用Lombok插件，这样实体类就不用写set、get、toString等方法public class User implements Serializable { private static final long serialVersionUID = 1L; //value与数据库主键列名一致，若实体类属性名与表主键列名一致可省略value @TableId(value = \"id\", type = IdType.AUTO) //指定自增策略 private Integer id; //若没有开启驼峰命名，或者表中列名不符合驼峰规则，可通过该注解指定数据库表中的列名，exist标明数据表中有没有对应列 @TableField(value = \"last_name\", exist = true) private String lastName; private String name; private String password; private String username;} 数据层(DAO)DAO(Data Access Object) 是数据访问层，也被称为mapper层。即数据持久层，对数据做持久化操作。dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。 使用mybatis-plus后不用写mapper.xml文件 123456// dao/接口名.java// 定义数据层接口与映射配置，继承BaseMapper&lt;把实体类作为泛型传入&gt;@Mapperpublic interface 接口名 extends BaseMapper&lt;实体类&gt; {} 业务层(service)业务层，service层的作用为完成功能设计。存放业务逻辑处理，不直接对数据库进行操作，有接口和接口实现类(定义一个接口，然后再一个或多个类去实现),提供controller层调用的方法。调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。（也就是说对于项目中的功能的需求就是在这里完成的） 快速开发方案使用MyBatisPlus提供有业务层通用接口(ISerivce)与业务层通用实现类(ServiceImpl&lt;M,T&gt;)在通用类基础上做功能重载或功能追加注意重载时不要覆盖原始操作，避免原始提供的功能丢失 创建接口在java内的项目包下 新建 service包（一般接口都放在其中） 然后再其中新建XXXService接口 123// 基于mybatisplus快速开发，ctrl+o查看mp帮你重写或覆盖的方法public interface IBookService extends IService&lt;实体类&gt; {} 创建接口实现类service 包内 新建 impl 包（实现类全部在impl包内） 123456@Service// 继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类// extends ServiceImpl&lt;BookDao,Book&gt; //传入两个泛型(dao层,实体类)public class IBookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService {} 单元测试类123456789101112131415161718192021222324252627package com.ke.bookm.service;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;/** * @author wenke * @Classname BookServiceTestCasde * @Description TODO * @Date 2022/4/7 20:48 */@SpringBootTestpublic class BookServiceTestCase { // 接口有多个实现类时使用@Qualifier注解指定实现类： // @Qualifier(\"qualifierServiceImpl2\") @Autowired private BookService bookService; @Test void testGetById() { bookService.getById(4); }} 表现层/控制器层(controller)controller层的功能为请求和响应控制。controller层负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端。 创建控制器类com.controller.UserController.java 12345678@RestController@RequestMapping(\"/users\")public class UserController { // 添加业务层对象 @Autowired private IUserService userService;} 映射url请求@RequestMapping@RequestMapping注解是用来映射请求的，即指明处理器可以处理哪些URL请求，该注解既可以用在类上，也可以用在方法上。当使用@RequestMapping标记控制器类时，方法的请求地址是相对类的请求地址而言的；当没有使用@RequestMapping标记类时，方法的请求地址是绝对路径。 增删改查 新增：POST请求 删除：DELETE请求 @DeleteMapping 修改：PUT请求 查询：GET请求 @GetMapping 接收参数 实体数据：@RequestBody 路径变量：@PathVariable@RequestMapping的地址可以是url变量，并且通过@PathVariable注解获取作为方法的参数。也可以是通配符来筛选请求地址。 1234@GetMapping(\"/{id}\")public void getById(@PathVariable Integer id){ } @Controller和@ResponseBody注解在一个类上添加@Controller注解，表明了这个类是一个控制器类在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面 若返回json等内容到页面，则需要加@ResponseBody注解@ResponseBody表示方法的返回值直接以指定的格式写入Http response body中，而不是解析为跳转路径。格式的转换是通过HttpMessageConverter中的方法实现的，因为它是一个接口，因此由其实现类完成转换。 @RestController如果需要返回的是数据（如：JSON、XML或自定义的metatype等数据类型）时，@RestController完全等同于@Controller+@Responsebody 如果要求方法返回的是json格式数据，而不是跳转页面，可以直接在类上标注@RestController，而不用在每个方法中标注@ResponseBody，简化了开发过程。但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面 @RestController注解将此类标注为@Controller,并且类方法上面都默认有@ResponseBody @Autowired@Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。 在使用@Autowired时，首先在容器中查询对应类型的bean如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据如果查询的结果不止一个，那么@Autowired会根据名称来查找。 @Override@Override 注解是用来指定方法重写的，只能修饰方法并且只能用于方法重写，不能修饰其它的元素。它可以强制一个子类必须重写父类方法或者实现接口的方法。 controller.utils表现层数据一致性处理 启动类(引导类)运行SpringBoot程序通过运行Application程序入口进行SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean 123456789101112131415161718package com.example.mp;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication// 在SpringBoot启动类上配置mapper接口的扫描路径@MapperScan(\"com.example.mp.mappers\")public class MybatisPlusApplication { public static void main(String[] args) { // 定义容器对象，并启动 SpringApplication.run(MybatisPlusApplication.class, args); }} 整合JUnitdao层src/main/java/com.arts.demo/dao/BookDao.java 123456package com.example.demo_1.dao;public interface BookDao { public void save();} src/main/java/com.arts.demo/dao/impl/BookDaoImpl 123456789101112131415package com.example.demo_1.dao.impl;import com.example.demo_1.dao.BookDao;import org.springframework.stereotype.Repository;@Repositorypublic class BookDaoImpl implements BookDao { @Override public void save() { System.out.println(\"save book\"); }} 测试类src/test/java/com.arts.demo/ApplicationTests 1234567891011121314@SpringBootTest //测试类注解：设置JUnit加载的SpringBoot启动类class Springboot04JunitApplicationTests { //1.注入你要测试的对象 @Autowired private BookDao bookDao; @Test void contextLoads() { //2.执行要测试的对象对应的方法 bookDao.save(); System.out.println(\"two...\"); }} classes属性：设置SpringBoot启动类如果测试类在SpringBoot启动类的包或子包中，可以省略启动类的设置，也就是省略classes的设定 12@SpringBootTest(classes = Springboot05JUnitApplication.class) 整合mybatis导入坐标pom.xml 12345678910111213141516&lt;dependencies&gt; &lt;!-- Mybatis核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 设置数据源参数src/main/resources/applacation.yml 1234567spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/demo_db?serverTimezone=UTC #Mysql驱动版本大于8.0时，需要在url连接串中配置时区, 或者在MySQL数据库端配置时区 username: root password: root 创建表12345678910111213141516171819202122232425262728293031323334353637use bookdb;CREATE TABLE IF NOT EXISTS book( `id` int NOT NULL PRIMARY KEY AUTO_INCREMENT, `name` VARCHAR(100) NOT NULL, `type` VARCHAR(40) NOT NULL, `description` VARCHAR(100) NOT NULL);INSERT INTO book(id, type, name, description)VALUES ('1', '计算机理论', 'Spring?实战第5版', 'Spring入门经典教程，深入理解Spring原理技术内幕');INSERT INTO book(id, type, name, description)VALUES ('2', '计算机理论', 'Spring5核心原理与30个类手写实战', '十年沉淀之作，手写Spring精华思想');INSERT INTO book(id, type, name, description)VALUES ('3', '计算机理论', 'Spring5设计模式', '深入Spring源码剖析Spring源码中蕴含的10大设计模式');INSERT INTO book(id, type, name, description)VALUES ('4', '计算机理论', 'Spring MVC+MyBatis开发从入门到项目实战', '全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手');INSERT INTO book(id, type, name, description)VALUES ('5', '计算机理论', '轻量级Java Web企业应用实战', '源码级剖析Spring框架，适合已掌握ava基础的读者');INSERT INTO book(id, type, name, description)VALUES ('6', '计算机理论', 'Java核心技术卷1基础知识(原书第11版)', 'Core Java第11版，Jolt大奖获奖作品，针对）ava SE9、10、11全面更新');INSERT INTO book(id, type, name, description)VALUES ('7', '计算机理论', '深入理解ava虚拟机', '5个维度全面剖析VM,大厂面试知识点全覆盖');INSERT INTO book(id, type, name, description)VALUES ('8', '计算机理论', 'Java编程思想(第4版)', 'Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉');INSERT INTO book(id, type, name, description)VALUES ('9', '计算机理论', '零基础学）ava（全彩版）', '零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术');INSERT INTO book(id, type, name, description)VALUES ('10', '市场营销', '直播就该这么做：主播高效沟通实战指南', '李子柒、李佳琦、薇娅成长为网红的秘密都在书中');INSERT INTO book(id, type, name, description)VALUES ('11', '市场营销', '直播销讲实战一本通', '和秋叶一起学系列网络营销书籍');INSERT INTO book(id, type, name, description)VALUES ('12', '市场营销', '直播带货：淘宝、天猫直播从新手到高手', '一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+'); 创建实体类src.main/.resources.java.main.com.arts.demo.domain.Book.java 12345678910package com.arts.demo.domain;public class Book { private Integer id; private String type; private String name; private String description; // set/get方法} 定义数据层接口与映射配置src.main/.resources.java.main.com.arts.demo.dao.BookDao.java 123456789101112package com.arts.demo.dao;import com.arts.demo.domain.Book;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;@Mapperpublic interface BookDao { @Select(\"select * from book where id = #{id}\") public Book getById(Integer id);} 测试类中注入dao接口，测试功能1234567891011121314151617181920package com.arts.demo;import com.arts.demo.dao.BookDao;import com.arts.demo.domain.Book;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass ApplicationTests { @Autowired private BookDao bookDao; @Test public void testGetById() { Book book = bookDao.getById(1); System.out.println(book); }} 整合MyBatis-Plus数据库框架：Mybatis Plus &gt; Mybatis代码生成器：Mybatis Plus Generator &gt; Mybatis Generator mybatis-plus是对mybatis的封装，有一些复杂的东西，mybatis-plus可能本身做不到，还是得用回mybatis本身的功能去实现的。 Mybatis Plus针对单表的基本CRUD操作，只需要创建好实体类，并创建一个继承自BaseMapper的接口即可，可谓非常简洁。并且，我们注意到，User类中的managerId，createTime属性，自动和数据库表中的manager_id，create_time对应了起来，这是因为mp自动做了数据库下划线命名，到Java类的驼峰命名之间的转化。 导入依赖坐标1234567&lt;!-- pom.xml --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt; 配置数据库1234567891011# application.yml spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/数据库名?serverTimezone=Asia/Shanghai username: root password: rootmybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #开启SQL语句打印 定义数据层接口与映射配置，继承BaseMapper123456789101112package com.arts.demo.dao;import com.arts.demo.domain.Book;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt; {} 其他同SpringBoot整合MyBatis 测试1234567891011121314151617181920212223package com.arts.demo;import com.arts.demo.dao.BookDao;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass ApplicationTests { @Autowired private BookDao bookDao; @Test void contextLoads() { System.out.println(bookDao.selectById(2)); } @Test void testGetAll() { System.out.println(bookDao.selectList(null)); }} Druid连接池数据源与数据库连接池什么是数据源？JDBC2.0提供了javax.sql.DataSource接口，它负责建立与数据库的连接，当在应用程序中访问数据库时，不必编写连接数据库的代码，直接引用DataSource获取数据库的连接对象即可。用于获取操作数据的Connection对象。 什么是数据库连接池？数据库连接池的思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。可通过设定连接池的最大连接数来防止系统无尽的与数据库连接。更重要的是我们可以通过连接池的管理机制监视数据库的连接的数量、使用情况，为系统开发、测试以及性能调整提供依据。 数据源和数据库连接池的关系？数据源建立多个数据库连接，这些数据库连接将会保存在数据库连接池中，当需要访问数据库时，只需要从数据库连接池中获取空闲的数据库连接，当程序访问数据库结束时，数据库连接会放回数据库连接池中。 为什么要使用数据库连接池？传统的JDBC访问数据库技术，每次访问数据库都需要通过数据库驱动器Driver和数据库名称以及密码等等资源建立数据库连接。 如此就会存在两大问题： 频繁的建立与断开数据库连接，会降低执行效率，增加系统资源的开销。数据库的连接需要用户名和密码等资源，这些也需要一定的内存和CPU的开销。而数据库连接池很好地解决了这些问题。 加载依赖123456789101112&lt;!-- pom.xml --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; &lt;!--log4j--&gt;&lt;dependency&gt;&lt;groupId&gt;log4j&lt;/groupId&gt;&lt;artifactId&gt;log4j&lt;/artifactId&gt;&lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 更改配置12345678spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/demo_db?serverTimezone=UTC #Mysql驱动版本大于8.0时，需要在url连接串中配置时区, #或者在MySQL数据库端配置时区 username: root password: root mybatis封装JDBC，负责访问数据库，完成持久化操作 介绍特性1） MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架2） MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集3） MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old JavaObjects，普通的Java对象）映射成数据库中的记录4） MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架 优缺点缺点： 1、编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如此。 2、SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库。 3、框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。 4、二级缓存机制不佳。 搭建MyBatis注意事项MySQL不同版本的注意事项1、驱动类driver-class-nameMySQL 5版本使用jdbc5驱动，驱动类使用：com.mysql.jdbc.DriverMySQL 8版本使用jdbc8驱动，驱动类使用：com.mysql.cj.jdbc.Driver2、连接地址urlMySQL 5版本的url：jdbc:mysql://localhost:3306/ssmMySQL 8版本的url：jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC否则运行测试用例报告如下错误：java.sql.SQLException: The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized orrepresents more 创建maven工程①打包方式：jar②引入依赖 12345678910111213141516&lt;dependencies&gt; &lt;!-- Mybatis核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建MyBatis的核心配置文件习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息核心配置文件存放的位置是src/main/resources目录下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--MyBatis核心配置文件中，标签的顺序： properties?,settings?,typeAliases?,typeHandlers?, objectFactory?, objectWrapperFactory?,reflectorFactory?, plugins?,environments?,databaseIdProvider?,mappers? --&gt; &lt;!--引入properties文件--&gt; &lt;properties resource=\"jdbc.properties\"/&gt; &lt;!--设置类型别名--&gt; &lt;typeAliases&gt; &lt;!--typeAlias：设置某个类型的别名 属性： type：设置需要设置别名的类型 alias：设置某个类型的别名，若不设置该属性，那么该类型拥有默认的别名，即类名 且不区分大小写 --&gt; &lt;!--&lt;typeAlias type=\"com.atguigu.mybatis.pojo.User\"&gt;&lt;/typeAlias&gt;--&gt; &lt;!--以包为单位，将包下所有的类型设置默认的类型别名，即类名且不区分大小写--&gt; &lt;package name=\"com.atguigu.mybatis.pojo\"/&gt; &lt;/typeAliases&gt; &lt;!--environments：配置多个连接数据库的环境 属性：default：设置默认使用的环境的id --&gt; &lt;environments default=\"development\"&gt; &lt;!--environment：配置某个具体的环境 属性：id：表示连接数据库的环境的唯一标识，不能重复 --&gt; &lt;environment id=\"development\"&gt; &lt;!--transactionManager：设置事务管理方式 属性：type=\"JDBC|MANAGED\" JDBC：表示当前环境中，执行SQL时，使用的是JDBC中原生的事务管理方式，事 务的提交或回滚需要手动处理MANAGED：被管理，例如Spring --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--dataSource：配置数据源 属性：type：设置数据源的类型 type=\"POOLED|UNPOOLED|JNDI\" POOLED：表示使用数据库连接池缓存数据库连接 UNPOOLED：表示不使用数据库连接池 JNDI：表示使用上下文中的数据源 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--设置连接数据库的驱动--&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;!--设置连接数据库的连接地址--&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;!--设置连接数据库的用户名--&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;!--设置连接数据库的密码--&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"test\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssmserverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!--&lt;mapper resource=\"mappers/UserMapper.xml\"/&gt;--&gt; &lt;!--以包为单位引入映射文件 要求： 1、mapper接口所在的包要和映射文件所在的包一致 2、mapper接口要和映射文件的名字一致 --&gt; &lt;package name=\"com.atguigu.mybatis.mapper\"/&gt; &lt;/mappers&gt; 创建mapper接口MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类。 12345// src/main/resources/mappers/UserMapper.javapublic interface UserMapper { /*** 添加用户信息 */ int insertUser();} 创建MyBatis的映射文件相关概念：ORM（Object Relationship Mapping）对象关系映射。对象：Java的实体类对象关系：关系型数据库映射：二者之间的对应关系 1、映射文件的命名规则：表所对应的实体类的类名+Mapper.xml例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml因此一个映射文件对应一个实体类，对应一张表的操作MyBatis映射文件用于编写SQL，访问以及操作表中的数据MyBatis映射文件存放的位置是src/main/resources/mappers目录下 2、 MyBatis中可以面向接口操作数据，要保证两个一致：a&gt;mapper接口的全类名和映射文件的命名空间（namespace）保持一致b&gt;mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致 12345678src/main/resources/mappers/UserMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.atguigu.mybatis.mapper.UserMapper\"&gt; &lt;!--int insertUser();--&gt; &lt;insert id=\"insertUser\"&gt;insert into t_user values (null, 'admin', '123456', 23, '男', '12345@qq.com') &lt;/insert&gt;&lt;/mapper&gt; mybatis-plusmybatis-plus文档 CRUD 接口dao数据层CRUD 接口123456//Dao层 操作数据库的 指定操作Student对象的增删改查基本操作@Mapperpublic interface StudentDao extends BaseMapper&lt;Student&gt; { //继承mybatis-plus的BaseMapper接口} service业务层CRUD 接口IService接口封装了对数据的增删改查泛型中填上实体类 service/UserService.java 12345public interface StudentService extends IService&lt;Student&gt; { //继承mybatis-plus的IService接口// 若封装好的增删改查不能完成我们所需要的操作，我们依然可以在下面进行方法书写，切记不要将方法覆盖} SaveSaveOrUpdateRemoveUpdateGetListPageCountChain List12345678910111213141516171819202122// 查询所有List&lt;T&gt; list(); //返回类型是List&lt;T&gt; // 查询列表 List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询） Collection&lt;T&gt; listByIds(Collection&lt;?extends Serializable&gt; idList);// 查询（根据 columnMap 条件） Collection&lt;T&gt; listByMap(Map&lt;String, Object&gt; columnMap);// 查询所有列表 List&lt;Map&lt;String, Object&gt;&gt;listMaps();// 查询列表 List&lt;Map&lt;String, Object&gt;&gt;listMaps(Wrapper&lt;T&gt; queryWrapper);// 查询全部记录 List&lt;Object&gt; listObjs();// 查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Function&lt;? super Object,V&gt;mapper);// 根据 Wrapper 条件，查询全部记录 List&lt;Object&gt; listObjs(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Wrapper&lt;T&gt; queryWrapper,Function&lt;? super Object,V&gt;mapper); ssmp整合案例数据库脚本1234567891011121314151617181920212223242526272829303132333435363738394041DROP TABLE IF EXISTS `tbl_book`;CREATE TABLE `tbl_book`( `id` int(11) NOT NULL AUTO_INCREMENT, `type` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of tbl_book-- ----------------------------INSERT INTO `tbl_book`VALUES (1, '计算机理论', 'Spring实战 第5版', 'Spring入门经典教程，深入理解Spring原理技术内幕');INSERT INTO `tbl_book`VALUES (2, '计算机理论', 'Spring 5核心原理与30个类手写实战', '十年沉淀之作，手写Spring精华思想');INSERT INTO `tbl_book`VALUES (3, '计算机理论', 'Spring 5 设计模式', '深入Spring源码剖析Spring源码中蕴含的10大设计模式');INSERT INTO `tbl_book`VALUES (4, '计算机理论', 'Spring MVC+MyBatis开发从入门到项目实战', '全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手');INSERT INTO `tbl_book`VALUES (5, '计算机理论', '轻量级Java Web企业应用实战', '源码级剖析Spring框架，适合已掌握Java基础的读者');INSERT INTO `tbl_book`VALUES (6, '计算机理论', 'Java核心技术 卷I 基础知识（原书第11版）', 'Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新');INSERT INTO `tbl_book`VALUES (7, '计算机理论', '深入理解Java虚拟机', '5个维度全面剖析JVM，大厂面试知识点全覆盖');INSERT INTO `tbl_book`VALUES (8, '计算机理论', 'Java编程思想（第4版）', 'Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉');INSERT INTO `tbl_book`VALUES (9, '计算机理论', '零基础学Java（全彩版）', '零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术');INSERT INTO `tbl_book`VALUES (10, '市场营销', '直播就该这么做：主播高效沟通实战指南', '李子柒、李佳琦、薇娅成长为网红的秘密都在书中');INSERT INTO `tbl_book`VALUES (11, '市场营销', '直播销讲实战一本通', '和秋叶一起学系列网络营销书籍');INSERT INTO `tbl_book`VALUES (12, '市场营销', '直播带货：淘宝、天猫直播从新手到高手', '一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+'); 实体类开发根据上述表结构，制作对应的实体类domain层 ​Lombok，一个Java类库，提供了一组注解，简化POJO实体类开发，SpringBoot目前默认集成了lombok技术，并提供了对应的版本控制，所以只需要提供对应的坐标即可， 在pom.xml中添加lombok的坐标。 12345678&lt;dependencies&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ​ 使用lombok可以通过一个注解@Data完成一个实体类对应的getter，setter，toString，equals，hashCode等操作的快速添加 /domain/Book.java 123456789import lombok.Data;@Datapublic class Book { private Integer id; private String type; private String name; private String description;} 数据层开发1.基础CRUD导入坐标​ 数据层开发本次使用MyBatisPlus技术，数据源使用前面学习的Druid，学都学了都用上 步骤①：导入MyBatisPlus与Druid对应的starter，当然mysql的驱动不能少 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 数据源配置步骤②：配置数据库连接相关的数据源配置 12345678910server: port: 80spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC username: root password: root mybatis-plus快速开发/dao/BookDao开发Dao接口（继承BaseMapper） 步骤③：使用MP的标准通用接口BaseMapper加速开发，别忘了@Mapper和泛型的指定 1234@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt; {} 步骤④：制作测试类测试结果，这个测试类制作是个好习惯，不过在企业开发中往往都为加速开发跳过此步，且行且珍惜吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.itheima.dao;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.core.metadata.IPage;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.itheima.domain.Book;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestpublic class BookDaoTestCase { @Autowired private BookDao bookDao; @Test void testGetById() { System.out.println(bookDao.selectById(1)); } @Test void testSave() { Book book = new Book(); book.setType(\"测试数据123\"); book.setName(\"测试数据123\"); book.setDescription(\"测试数据123\"); bookDao.insert(book); } @Test void testUpdate() { Book book = new Book(); book.setId(17); book.setType(\"测试数据abcdefg\"); book.setName(\"测试数据123\"); book.setDescription(\"测试数据123\"); bookDao.updateById(book); } @Test void testDelete() { bookDao.deleteById(16); } @Test void testGetAll() { bookDao.selectList(null); }} 温馨提示 ​ MP技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，和目前的数据库设定规则不相符，需要配置一下使MP使用数据库的主键生成策略，方式嘛还是老一套，做配置。在application.yml中添加对应配置即可，具体如下 12345678910111213141516server: port: 80spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC username: root password: rootmybatis-plus: global-config: db-config: table-prefix: tbl_ #设置表名通用前缀 id-type: auto #设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增 查看MP运行日志 使用配置方式开启日志，设置日志输出方式为标准输出即可查阅SQL执行日志 -​在进行数据层测试的时候，因为基础的CRUD操作均由MP给我们提供了，所以就出现了一个局面，开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你干预开发出来的，所以查看执行期运行的SQL语句就成为当务之急。 SpringBoot整合MP的时候充分考虑到了这点，通过配置的形式就可以查阅执行期SQL语句，配置如下 1234567mybatis-plus: global-config: db-config: table-prefix: tbl_ id-type: auto configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 3.分页功能制作使用IPage封装分页数据前面仅仅是使用了MP提供的基础CRUD功能，实际上MP给我们提供了几乎所有的基础操作，这一节说一下如果实现数据库端的分页操作 MP提供的分页操作API如下 1234567891011@Testvoid testGetPage(){ IPage page=new Page(2,5); //传入当前显示第几页 ,每页显示几条数据 bookDao.selectPage(page,null); //selectPage方法需要传入一个封装分页数据的对象，这个对象包含了分页的信息，如当前页码、每页显示的条数等，还有过滤条件 System.out.println(page.getCurrent()); System.out.println(page.getSize()); System.out.println(page.getTotal()); System.out.println(page.getPages()); System.out.println(page.getRecords()); } 将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象，这又是怎么回事？ 原来这个IPage对象中封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装，一个IPage描述了分页所有的信息。下面5个操作就是IPage对象中封装的所有信息了 12345678910@Testvoid testGetPage(){ IPage page=new Page(2,5); bookDao.selectPage(page,null); System.out.println(page.getCurrent()); //当前页码值 System.out.println(page.getSize()); //每页显示数 System.out.println(page.getTotal()); //数据总量 System.out.println(page.getPages()); //总页数 System.out.println(page.getRecords()); //详细数据 } 分页操作依赖MyBatisPlus分页拦截器实现功能到这里就知道这些数据如何获取了，但是当你去执行这个操作时，你会发现并不像我们分析的这样，实际上这个分页当前是无效的。为什么这样呢？这个要源于MP的内部机制。 对于MySQL的分页操作使用limit关键字进行，而并不是所有的数据库都使用limit关键字实现的，这个时候MP为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，你可以理解为IPhone6与IPhone6S-PLUS的关系。 基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MP将分页操作做成了一个开关，你用分页功能就分页操作是没有的。这个开关是通过MP的拦截器的形式存在的，其中的原理这里不分析了，有兴趣的小伙伴可以学习MyBatisPlus这门课程进行详细解读。具体设置方式如下把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以定义MP拦截器并将其设置为Spring管控的bean 12345678910111213@Configurationpublic class MPConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { //创建MP的拦截器栈，这个时候拦截器栈中没有具体的拦截器 MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //1.定义Mp拦截器 //初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。 interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); //2.添加具体的拦截器 return interceptor; }} 4.条件查询功能制作除了分页功能，MP还提供有强大的条件查询功能。以往我们写条件查询要自己动态拼写复杂的SQL语句，现在简单了，MP将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种套件的拼装。这里给大家普及一下基本格式，详细的操作还是到MP的课程中查阅吧 下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用 123456@Testvoid testGetBy(){ QueryWrapper&lt;Book&gt; qw=new QueryWrapper&lt;&gt;(); qw.like(\"name\",\"Spring\"); bookDao.selectList(qw); } 其中第一句QueryWrapper对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。第二句就是一个条件了，需要什么条件，使用QueryWapper对象直接调用对应操作即可。比如做大于小于关系，就可以使用lt或gt方法，等于使用eq方法，等等，此处不做更多的解释了。 这组API使用还是比较简单的，但是关于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。 MP针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为LambdaQueryWrapper对象，这下就变了上述问题的出现 1234567@Testvoid testGetBy2(){ String name=\"1\"; LambdaQueryWrapper&lt;Book&gt; lqw=new LambdaQueryWrapper&lt;Book&gt;(); lqw.like(Book::getName,name); bookDao.selectList(lqw); } ​ 为了便于开发者动态拼写SQL，防止将null数据作为条件使用，MP还提供了动态拼装SQL的快捷书写方式 12345678@Testvoid testGetBy2(){ String name=\"1\"; LambdaQueryWrapper&lt;Book&gt; lqw=new LambdaQueryWrapper&lt;Book&gt;(); //if(name != null) lqw.like(Book::getName,name); //方式一：JAVA代码控制 lqw.like(name!=null,Book::getName,name); //方式二：API接口提供控制开关 bookDao.selectList(lqw); } ​ 其实就是个格式，没有区别。关于MP的基础操作就说到这里吧，如果这一块知识不太熟悉的小伙伴还是去完整的学习一下MP的知识吧，这里只是蜻蜓点水的用了几个操作而已。 总结 使用QueryWrapper对象封装查询条件 推荐使用LambdaQueryWrapper对象 所有查询操作封装成方法调用 查询条件支持动态条件拼装 业务层其实标准业务层开发很多初学者认为就是调用数据层，怎么说呢？这个理解是没有大问题的，更精准的说法应该是组织业务逻辑功能，并根据业务需求，对数据持久层发起调用。 有什么差别呢？目标是为了组织出符合需求的业务逻辑功能，至于调不调用数据层还真不好说，有需求就调用，没有需求就不调用。 ​ 一个常识性的知识普及一下，业务层的方法名定义一定要与业务有关，例如登录操作 1login(String username,String password); ​ 而数据层的方法名定义一定与业务无关，是一定，不是可能，也不是有可能，例如根据用户名密码查询 1selectByUserNameAndPassword(String username,String password); ​ 我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的 123接口：传入用户名与密码字段，查询出对应结果，结果是单条数据接口：传入ID字段，查询出对应结果，结果是单条数据接口：传入离职字段，查询出对应结果，结果是多条数据 ​ 但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大 1接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对喵喵喵字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO_LOGON_USERNAME_PASSWORD_ERROR ​ 你比较一下，能是一回事吗？差别太大了，所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的ISO标准化文档而已。 业务层接口业务层接口定义如下：/service/BookService.java 12345678910111213public interface BookService { Boolean save(Book book); Boolean update(Book book); Boolean delete(Integer id); Book getById(Integer id); List&lt;Book&gt; getAll(); IPage&lt;Book&gt; getPage(int currentPage, int pageSize);} 业务层实现类/service/Impl/BookServiceImpl.java​业务层实现类如下，转调数据层即可 123456789101112131415161718192021222324252627282930313233343536373839@Servicepublic class BookServiceImpl implements BookService { @Autowired private BookDao bookDao; @Override public Boolean save(Book book) { return bookDao.insert(book) &gt; 0; } @Override public Boolean update(Book book) { return bookDao.updateById(book) &gt; 0; } @Override public Boolean delete(Integer id) { return bookDao.deleteById(id) &gt; 0; } @Override public Book getById(Integer id) { return bookDao.selectById(id); } @Override public List&lt;Book&gt; getAll() { return bookDao.selectList(null); } @Override public IPage&lt;Book&gt; getPage(int currentPage, int pageSize) { IPage page = new Page(currentPage, pageSize); bookDao.selectPage(page, null); return page; }} 测试类​ 别忘了对业务层接口进行测试，测试类如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@SpringBootTestpublic class BookServiceTest { @Autowired private IBookService bookService; @Test void testGetById() { System.out.println(bookService.getById(4)); } @Test void testSave() { Book book = new Book(); book.setType(\"测试数据123\"); book.setName(\"测试数据123\"); book.setDescription(\"测试数据123\"); bookService.save(book); } @Test void testUpdate() { Book book = new Book(); book.setId(17); book.setType(\"-----------------\"); book.setName(\"测试数据123\"); book.setDescription(\"测试数据123\"); bookService.updateById(book); } @Test void testDelete() { bookService.removeById(18); } @Test void testGetAll() { bookService.list(); } @Test void testGetPage() { IPage&lt;Book&gt; page = new Page&lt;Book&gt;(2, 5); bookService.page(page); System.out.println(page.getCurrent()); System.out.println(page.getSize()); System.out.println(page.getTotal()); System.out.println(page.getPages()); System.out.println(page.getRecords()); }} 总结 Service接口名称定义成业务名称，并与Dao接口名称进行区分 制作测试类测试Service功能是否有效 业务层快速开发其实MP技术不仅提供了数据层快速开发方案，业务层MP也给了一个通用接口，个人观点不推荐使用，凑合能用吧，其实就是一个封装+继承的思想，代码给出，实际开发慎用 业务层接口快速开发/service/Impl/IBookService.java 123public interface IBookService extends IService&lt;Book&gt; { //添加非通用操作API接口} 业务层接口实现类/service/Impl/BookServiceImpl.java业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类 1234567@Servicepublic class BookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService { @Autowired private BookDao bookDao; //添加非通用操作API} 如果感觉MP提供的功能不足以支撑你的使用需要，其实是一定不能支撑的，因为需求不可能是通用的，在原始接口基础上接着定义新的API接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的API接口名冲突即可。 总结 使用通用接口（ISerivce）快速开发Service 使用通用实现类（ServiceImpl&lt;M,T&gt;）快速开发ServiceImpl 可以在通用接口基础上做功能重载或功能追加 注意重载时不要覆盖原始操作，避免原始提供的功能丢失 6.表现层开发表现层/控制器层的开发使用基于Restful的表现层接口开发，功能测试通过Postman工具进行 /controller/BookController.java​ 表现层接口如下: 1234567891011121314151617181920212223242526272829303132333435363738@RestController@RequestMapping(\"/books\")public class BookController2 { @Autowired private IBookService bookService; @GetMapping public List&lt;Book&gt; getAll() { return bookService.list(); } @PostMapping public Boolean save(@RequestBody Book book) { return bookService.save(book); } @PutMapping public Boolean update(@RequestBody Book book) { return bookService.modify(book); } @DeleteMapping(\"{id}\") public Boolean delete(@PathVariable Integer id) { return bookService.delete(id); } @GetMapping(\"{id}\") public Book getById(@PathVariable Integer id) { return bookService.getById(id); } @GetMapping(\"{currentPage}/{pageSize}\") public IPage&lt;Book&gt; getPage(@PathVariable int currentPage, @PathVariable int pageSize) { return bookService.getPage(currentPage, pageSize, null); }} ​ 在实用Postman测试时关注提交类型，对应上即可，不然就会报405的错误码了 普通GET请求 PUT请求传递json数据，后台实用@RequestBody接收数据 GET请求传递路径变量，后台实用@PathVariable接收数据 总结 基于Restful制作表现层接口 新增：POST 删除：DELETE 修改：PUT 查询：GET 接收参数 实体数据：@RequestBody 路径变量：@PathVariable 7.表现层消息一致性处理目前我们通过Postman测试后业务层接口功能时通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重 增删改操作结果 1true ​ 查询单个数据操作结果 123456{ \"id\": 1, \"type\": \"计算机理论\", \"name\": \"Spring实战&nbsp;第5版\", \"description\": \"Spring入门经典教程\"} ​ 查询全部数据操作结果 1234567891011121314[ { \"id\": 1, \"type\": \"计算机理论\", \"name\": \"Spring实战&nbsp;第5版\", \"description\": \"Spring入门经典教程\" }, { \"id\": 2, \"type\": \"计算机理论\", \"name\": \"Spring&nbsp;5核心原理与30个类手写实战\", \"description\": \"十年沉淀之作\" }] 每种不同操作返回的数据格式都不一样，而且还不知道以后还会有什么格式，这样的结果让前端人员看了是很容易让人崩溃的，必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为**前后端数据协议** 123456@Datapublic class R { private Boolean flag; private Object data;} ​ 其中flag用于标识操作是否成功，data用于封装操作数据，现在的数据格式就变了 123456789{ \"flag\": true, \"data\": { \"id\": 1, \"type\": \"计算机理论\", \"name\": \"Spring实战&nbsp;第5版\", \"description\": \"Spring入门经典教程\" }} ​ 表现层开发格式也需要转换一下 ​ 结果这么一折腾，全格式统一，现在后端发送给前端的数据格式就统一了，免去了不少前端解析数据的麻烦。 总结 设计统一的返回值结果类型便于前端开发读取数据 返回值结果类型可以根据需求自行设定，没有固定格式 返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议 8.前后端联通性测试​ 后端的表现层接口开发完毕，就可以进行前端的开发了。 ​ 将前端人员开发的页面保存到lresources目录下的static目录中，建议执行maven的clean生命周期，避免缓存的问题出现。 ​ ​ 在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发 12345678//列表getAll(){ axios.get(\"/books\").then((res) =&gt; { console.log(res.data); });}, ​ 只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，也就可以进行下一步的功能开发了 总结 单体项目中页面放置在resources/static目录下 created钩子函数用于初始化页面时发起调用 页面使用axios发送异步请求获取数据后确认前后端是否联通 9.页面基础功能开发列表功能（非分页版）列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用VUE的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可 页面数据模型定义 1234data:{ dataList: [],//当前页要展示的列表数据 ...}, 123456789//列表getAll(){ // 异步请求获取数据，这样在页面加载时就可以获取到数据，并且由VUE将数据展示到页面上了 axios.get(\"/books\").then((res) =&gt; { this.dataList = res.data.data; //将查询数据返回到页面，利用前端数据绑定进行数据展示 });}, 添加功能添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可 准备工作默认状态 1234data:{ dialogFormVisible: false,//添加表单是否可见 ...}, 切换为显示状态 123456//弹出添加窗口handleCreate(){ this.dialogFormVisible = true;}, 由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹 定义清理数据操作 123456//重置表单resetForm(){ this.formData = {};}, ​ 切换弹窗状态时清理数据 1234567//弹出添加窗口handleCreate(){ this.dialogFormVisible = true; this.resetForm();}, ​ 至此准备工作完成，下面就要调用后台完成添加操作了 添加操作1234567891011121314151617//添加handleAdd(){ //发送异步请求 axios.post(\"/books\", this.formData).then((res) =&gt; { //如果操作成功，关闭弹层，显示数据 if (res.data.flag) { this.dialogFormVisible = false; this.$message.success(\"添加成功\"); } else { this.$message.error(\"添加失败\"); } }).finally(() =&gt; { this.getAll(); });}, 将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台 根据返回的操作结果决定下一步操作 如何是true就关闭添加窗口，显示添加成功的消息 如果是false保留添加窗口，显示添加失败的消息 无论添加是否成功，页面均进行刷新，动态加载数据（对getAll操作发起调用） 取消添加操作1234567//取消cancel(){ this.dialogFormVisible = false; this.$message.info(\"操作取消\");}, 总结 请求方式使用POST调用后台对应操作 添加操作结束后动态刷新页面加载数据 根据操作结果不同，显示对应的提示信息 弹出添加Div时清除表单数据 删除功能模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可 删除操作 1234567891011121314// 删除handleDelete(row){ axios.delete(\"/books/\" + row.id).then((res) =&gt; { if (res.data.flag) { this.$message.success(\"删除成功\"); } else { this.$message.error(\"删除失败\"); } }).finally(() =&gt; { this.getAll(); });}, ​ 删除操作提示信息 12345678910111213141516171819202122// 删除handleDelete(row){ //1.弹出提示框 this.$confirm(\"此操作永久删除当前数据，是否继续？\", \"提示\", { type: 'info' }).then(() =&gt; { //2.做删除业务 axios.delete(\"/books/\" + row.id).then((res) =&gt; { if (res.data.flag) { this.$message.success(\"删除成功\"); } else { this.$message.error(\"删除失败\"); } }).finally(() =&gt; { this.getAll(); }); }).catch(() =&gt; { //3.取消删除 this.$message.info(\"取消删除操作\"); });}， 总结 请求方式使用Delete调用后台对应操作 删除操作需要传递当前行数据对应的id值到后台 删除操作结束后动态刷新页面加载数据 根据操作结果不同，显示对应的提示信息 删除操作前弹出提示框避免误操作 F-4.修改功能​ 修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下： 页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗 弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据 查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台 查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据 修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据 所以整体上来看，修改功能就是前面几个功能的大合体 查询并展示数据 1234567891011121314//弹出编辑窗口handleUpdate(row){ axios.get(\"/books/\" + row.id).then((res) =&gt; { if (res.data.flag) { //展示弹层，加载数据 this.formData = res.data.data; this.dialogFormVisible4Edit = true; } else { this.$message.error(\"数据同步失败，自动刷新\"); } });}, ​ 修改操作 12345678910111213141516//修改handleEdit(){ axios.put(\"/books\", this.formData).then((res) =&gt; { //如果操作成功，关闭弹层并刷新页面 if (res.data.flag) { this.dialogFormVisible4Edit = false; this.$message.success(\"修改成功\"); } else { this.$message.error(\"修改失败，请重试\"); } }).finally(() =&gt; { this.getAll(); });}, 总结 加载要修改数据通过传递当前行数据对应的id值到后台查询数据（同删除与查询全部） 利用前端双向数据绑定将查询到的数据进行回显（同查询全部） 请求方式使用PUT调用后台对应操作（同新增传递数据） 修改操作结束后动态刷新页面加载数据（同新增） 根据操作结果不同，显示对应的提示信息（同新增） ​ 10.业务消息一致性处理为什么要一致性处理目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出BUG，如果我们搞一个BUG出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子 123456{ \"timestamp\": \"2021-09-15T03:27:31.038+00:00\", \"status\": 500, \"error\": \"Internal&nbsp;Server&nbsp;Error\", \"path\": \"/books\"} ​ 面对这种情况，前端的同学又不会了，这又是什么格式？怎么和之前的格式不一样？ 123456789{ \"flag\": true, \"data\": { \"id\": 1, \"type\": \"计算机理论\", \"name\": \"Spring实战&nbsp;第5版\", \"description\": \"Spring入门经典教程\" }} 处理数据格式看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理 首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息/controller/util/R.java为了防止链式调用 1234567@Datapublic class R { private Boolean flag; private Object data; private String msg; //用于封装消息} ​ 后台代码也要根据情况做处理，当前是模拟的错误 12345@PostMappingpublic R save(@RequestBody Book book)throws IOException{ Boolean flag=bookService.insert(book); return new R(flag,flag?\"添加成功^_^\":\"添加失败-_-!\"); } ​ 然后在表现层做统一的异常处理，使用SpringMVC提供的异常处理器做统一的异常处理 123456789101112@RestControllerAdvicepublic class ProjectExceptionAdvice { @ExceptionHandler(Exception.class) public R doOtherException(Exception ex) { //记录日志 //发送消息给运维 //发送邮件给开发人员,ex对象发送给开发人员 ex.printStackTrace(); return new R(false, null, \"系统错误，请稍后再试！\"); }} ​ 页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果false，就读取后台传递的消息 1234567891011121314151617//添加handleAdd(){ //发送ajax请求 axios.post(\"/books\", this.formData).then((res) =&gt; { //如果操作成功，关闭弹层，显示数据 if (res.data.flag) { this.dialogFormVisible = false; this.$message.success(\"添加成功\"); } else { this.$message.error(res.data.msg); //消息来自于后台传递过来，而非固定内容 } }).finally(() =&gt; { this.getAll(); });}, 总结 使用注解@RestControllerAdvice定义SpringMVC异常处理器用来处理异常的 异常处理器必须被扫描加载，否则无法生效 表现层返回结果的模型类中添加消息属性用来传递消息到页面 ​ 11.页面功能开发F-5.分页功能​ 分页功能的制作用于替换前面的查询全部，其中要使用到elementUI提供的分页组件 1234567891011&lt;!--分页组件--&gt;&lt;div class=\"pagination-container\"&gt; &lt;el-pagination class=\"pagiantion\" @current-change=\"handleCurrentChange\" :current-page=\"pagination.currentPage\" :page-size=\"pagination.pageSize\" layout=\"total, prev, pager, next, jumper\" :total=\"pagination.total\"&gt;&lt;/el-pagination&gt;&lt;/div&gt; ​ 为了配合分页组件，封装分页对应的数据模型 12345678data:{ pagination: { //分页相关模型数据 currentPage: 1, //当前页码 pageSize:10, //每页显示的记录数 total:0, //总记录数 }}, ​ 修改查询全部功能为分页查询，通过路径变量传递页码信息参数 123456getAll(){ axios.get(\"/books/\" + this.pagination.currentPage + \"/\" + this.pagination.pageSize).then((res) =&gt; { });}, ​ 后台提供对应的分页功能 12345@GetMapping(\"/{currentPage}/{pageSize}\")public R getAll(@PathVariable Integer currentPage,@PathVariable Integer pageSize){ IPage&lt;Book&gt; pageBook=bookService.getPage(currentPage,pageSize); return new R(null!=pageBook,pageBook); } ​ 页面根据分页操作结果读取对应数据，并进行数据模型绑定 12345678910getAll(){ axios.get(\"/books/\" + this.pagination.currentPage + \"/\" + this.pagination.pageSize).then((res) =&gt; { this.pagination.total = res.data.data.total; this.pagination.currentPage = res.data.data.current; this.pagination.pagesize = res.data.data.size; this.dataList = res.data.data.records; });}, ​ 对切换页码操作设置调用当前分页操作 1234567//切换页码handleCurrentChange(currentPage){ this.pagination.currentPage = currentPage; this.getAll();}, 总结 使用el分页组件 定义分页组件绑定的数据模型 异步调用获取分页数据 分页数据页面回显 F-6.删除功能维护​ 由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现BUG，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案 123456789@GetMapping(\"{currentPage}/{pageSize}\")public R getPage(@PathVariable int currentPage,@PathVariable int pageSize){ IPage&lt;Book&gt; page=bookService.getPage(currentPage,pageSize); //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值 if(currentPage&gt;page.getPages()){ page=bookService.getPage((int)page.getPages(),pageSize); } return new R(true,page); } F-7.条件查询功能​ 最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了 页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递2个分页相关的数据转换成2个分页数据加若干个条件 后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是null，现在换成具体条件，差别不大 查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略 经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别 页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递 页面封装查询条件字段 123456789pagination: { //分页相关模型数据 currentPage: 1, //当前页码 pageSize:10, //每页显示的记录数 total:0, //总记录数 name: \"\", type: \"\", description: \"\"}, 页面添加查询条件字段对应的数据模型绑定名称 1234567&lt;div class=\"filter-container\"&gt; &lt;el-input placeholder=\"图书类别\" v-model=\"pagination.type\" class=\"filter-item\"/&gt; &lt;el-input placeholder=\"图书名称\" v-model=\"pagination.name\" class=\"filter-item\"/&gt; &lt;el-input placeholder=\"图书描述\" v-model=\"pagination.description\" class=\"filter-item\"/&gt; &lt;el-button @click=\"getAll()\" class=\"dalfBut\"&gt;查询&lt;/el-button&gt; &lt;el-button type=\"primary\" class=\"butT\" @click=\"handleCreate()\"&gt;新建&lt;/el-button&gt;&lt;/div&gt; 将查询条件组织成url参数，添加到请求url地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求 12345678910getAll() { //1.获取查询条件,拼接查询条件 param = \"?name=\"+this.pagination.name; param += \"&amp;type=\"+this.pagination.type; param += \"&amp;description=\"+this.pagination.description; console.log(\"-----------------\"+ param); axios.get(\"/books/\"+this.pagination.currentPage+\"/\"+this.pagination.pageSize+param).then((res) =&gt; { this.dataList = res.data.data.records; });}, 后台代码中定义实体类封查询条件 123456@GetMapping(\"{currentPage}/{pageSize}\")public R getAll(@PathVariable int currentPage,@PathVariable int pageSize,Book book) { System.out.println(\"参数=====&gt;\"+book); IPage&lt;Book&gt; pageBook = bookService.getPage(currentPage,pageSize); return new R(null != pageBook ,pageBook);} 对应业务层接口与实现类进行修正 123public interface IBookService extends IService&lt;Book&gt; { IPage&lt;Book&gt; getPage(Integer currentPage,Integer pageSize,Book queryBook);} 1234567891011@Servicepublic class BookServiceImpl2 extends ServiceImpl&lt;BookDao,Book&gt; implements IBookService { public IPage&lt;Book&gt; getPage(Integer currentPage,Integer pageSize,Book queryBook){ IPage page = new Page(currentPage,pageSize); LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;Book&gt;(); lqw.like(Strings.isNotEmpty(queryBook.getName()),Book::getName,queryBook.getName()); lqw.like(Strings.isNotEmpty(queryBook.getType()),Book::getType,queryBook.getType()); lqw.like(Strings.isNotEmpty(queryBook.getDescription()),Book::getDescription,queryBook.getDescription()); return bookDao.selectPage(page,lqw); }} 页面回显数据 12345678910111213getAll() { //1.获取查询条件,拼接查询条件 param = \"?name=\"+this.pagination.name; param += \"&amp;type=\"+this.pagination.type; param += \"&amp;description=\"+this.pagination.description; console.log(\"-----------------\"+ param); axios.get(\"/books/\"+this.pagination.currentPage+\"/\"+this.pagination.pageSize+param).then((res) =&gt; { this.pagination.total = res.data.data.total; this.pagination.currentPage = res.data.data.current; this.pagination.pagesize = res.data.data.size; this.dataList = res.data.data.records; });}, 总结 定义查询条件数据模型（当前封装到分页数据模型中） 异步调用分页功能并通过请求参数传递数据到后台 SpringBoot运维实用篇​ 基础篇发布以后，看到了很多小伙伴在网上的留言，也帮助超过100位小伙伴解决了一些遇到的问题，并且已经发现了部分问题具有典型性，预计将有些问题在后面篇章的合适位置添加到本套课程中，作为解决方案提供给大家。 ​ 从此刻开始，咱们就要进入到实用篇的学习了。实用篇是在基础篇的根基之上，补全SpringBoot的知识图谱。比如在基础篇中只给大家讲了yaml的语法格式，但是具体写yaml文件的时候还有很多实用开发过程中的坑，这些在实用篇中都要进行学习。 ​ 实用篇共分为两块内容，分别是运维实用篇和开发实用篇。其实划分的标准是我自己制定的，因为这里面的知识有一些还是比较散的，做两个阶段的划分是为了更好的将同类知识点进行归类，帮助学习者找到知识之间的关联性，这样有助于知识的记忆存储转换，经过一系列的知识反复出现与强化练习，将临时记忆转换成永久性记忆。做课程嘛，不能仅以讲完为目标，要以学习者的学习收获为目标，这也是我这么多年教学秉承的基本理念。 ​ 下面就从运维实用篇开始讲，在运维实用篇中，我给学习者的定位是玩转配置，为开发实用篇中做各种技术的整合做好准备工作。与开发实用篇相比，运维实用篇的内容显得略微单薄，并且有部分知识模块在运维实用篇和开发实用篇中都要讲一部分，这些内容都后置到开发实用篇中了。废话不说了，先看看运维实用篇中都包含哪些内容： SpringBoot程序的打包与运行 配置高级 多环境开发 日志 ​ 下面开启第一部分SpringBoot程序打包与运行的学习 YW-1.SpringBoot程序的打包与运行​ 刚开始做开发学习的小伙伴可能在有一个知识上面有错误的认知，我们天天写程序是在Idea下写的，运行也是在Idea下运行的。 ​ 但是实际开发完成后，我们的项目是不可能运行在自己的电脑上的。 ​ 我们以后制作的程序是运行在专用的服务器上的，简单说就是将你做的程序放在一台独立运行的电脑上，这台电脑要比你开发使用的计算机更专业，并且安全等级各个方面要远超过你现在的电脑。 ​ 那我们的程序如何放置在这台专用的电脑上呢，这就要将我们的程序先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。 温馨提示 ​ 企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。 开发部门使用Git、SVN等版本控制工具上传工程到版本服务器 服务器使用版本控制工具下载工程 服务器上使用Maven工具在当前真机环境下重新构建项目 启动服务 ​ 继续说我们的打包和运行过程。所谓打包指将程序转换成一个可执行的文件，所谓运行指不依赖开发环境执行打包产生的文件。上述两个操作都有对应的命令可以快速执行。 程序打包​ SpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。本操作可以在Idea环境下执行。 1mvn package ​ 打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的。 程序运行​ 程序包打好以后，就可以直接执行了。在程序包所在路径下，执行指令。 1java -jar 工程包名.jar ​ 执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别。 ​ 特别关注：如果你的计算机中没有安装java的jdk环境，是无法正确执行上述操作的，因为程序执行使用的是java指令。 ​ 特别关注：在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 总结 SpringBoot工程可以基于java环境下独立运行jar文件启动服务 SpringBoot工程执行mvn命令package进行打包 执行jar命令：java –jar 工程名.jar SpringBoot程序打包失败处理​ 有些小伙伴打包以后执行会出现一些问题，导致程序无法正常执行，例如下面的现象 ​ 要想搞清楚这个问题就要说说.jar文件的工作机制了，知道了这个东西就知道如何避免此类问题的发生了。 ​ 搞java开发平时会接触很多jar包，比如mysql的驱动jar包，而上面我们打包程序后得到的也是一个jar文件。这个时候如果你使用上面的java -jar指令去执行mysql的驱动jar包就会出现上述不可执行的现象，而我们的SpringBoot项目为什么能执行呢？其实是因为打包方式不一样。 ​ 在SpringBoot工程的pom.xml中有下面这组配置，这组配置决定了打包出来的程序包是否可以执行。 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; ​ 我们分别开启这段配置和注释掉这段配置分别执行两次打包，然后观察两次打包后的程序包的差别，共有3处比较明显的特征 打包后文件的大小不同 打包后所包含的内容不同 打包程序中个别文件内容不同 ​ 先看第一个现象，文件大小不同。带有配置时打包生成的程序包大小如下： ​ 不难看出，带有配置的程序包体积比不带配置的大了30倍，那这里面都有什么呢？能差这么多？下面看看里面的内容有什么区别。 ​ ​ 我们发现内容也完全不一样，仅有一个目录是一样的，叫做META-INF。打开容量大的程序包中的BOOT-INF目录下的classes目录，我们发现其中的内容居然和容量小的程序包中的内容完全一样。 ​ ​ 原来大的程序包中除了包含小的程序包中的内容，还有别的东西。都有什么呢？回到BOOT-INF目录下，打开lib目录，里面显示了很多个jar文件。 ​ ​ 仔细翻阅不难发现，这些jar文件都是我们制作这个工程时导入的坐标对应的文件。大概可以想明白了，SpringBoot程序为了让自己打包生成的程序可以独立运行，不仅将项目中自己开发的内容进行了打包，还把当前工程运行需要使用的jar包全部打包进来了。为什么这样做呢？就是为了可以独立运行。不依赖程序包外部的任何资源可以独立运行当前程序。这也是为什么大的程序包容量是小的程序包容量的30倍的主要原因。 ​ 再看看大程序包还有什么不同之处，在最外层目录包含一个org目录，进入此目录，目录名是org\\springframework\\boot\\loader，在里面可以找到一个JarLauncher.class的文件，先记得这个文件。再看这套目录名，明显是一个Spring的目录名，为什么要把Spring框架的东西打包到这个程序包中呢？不清楚。 ​ 回到两个程序包的最外层目录，查看名称相同的文件夹META-INF下都有一个叫做MANIFEST.MF的文件，但是大小不同，打开文件，比较内容区别 小容量文件的MANIFEST.MF 12345Manifest-Version: 1.0Implementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTBuild-Jdk-Spec: 1.8Created-By: Maven Jar Plugin 3.2.0 大容量文件的MANIFEST.MF 123456789101112Manifest-Version: 1.0Spring-Boot-Classpath-Index: BOOT-INF/classpath.idxImplementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTSpring-Boot-Layers-Index: BOOT-INF/layers.idxStart-Class: com.itheima.SSMPApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.5.4Created-By: Maven Jar Plugin 3.2.0Main-Class: org.springframework.boot.loader.JarLauncher ​ 大文件中明显比小文件中多了几行信息，其中最后一行信息是Main-Class: org.springframework.boot.loader.JarLauncher。这句话什么意思呢？如果使用java -jar执行此程序包，将执行Main-Class属性配置的类，这个类恰巧就是前面看到的那个文件。原来SpringBoot打包程序中出现Spring框架的东西是为这里服务的。而这个org.springframework.boot.loader.JarLauncher类内部要查找Start-Class属性中配置的类，并执行对应的类。这个属性在当前配置中也存在，对应的就是我们的引导类类名。 ​ 现在这组设定的作用就搞清楚了 SpringBoot程序添加配置后会打出一个特殊的包，包含Spring框架部分功能，原始工程内容，原始工程依赖的jar包 首先读取MANIFEST.MF文件中的Main-Class属性，用来标记执行java -jar命令后运行的类 JarLauncher类执行时会找到Start-Class属性，也就是启动类类名 运行启动类时会运行当前工程的内容 运行当前工程时会使用依赖的jar包，从lib目录中查找 ​ 看来SpringBoot打出来了包为了能够独立运行，简直是煞费苦心，将所有需要使用的资源全部都添加到了这个包里。这就是为什么这个jar包能独立运行的原因。 ​ 再来看之前的报错信息： ​ 由于打包时没有使用那段配置，结果打包后形成了一个普通的jar包，在MANIFEST.MF文件中也就没有了Main-Class对应的属性了，所以运行时提示找不到主清单属性，这就是报错的原因。 ​ 上述内容搞清楚对我们编程意义并不大，但是对各位小伙伴理清楚SpringBoot工程独立运行的机制是有帮助的。其实整体过程主要是带着大家分析，如果以后遇到了类似的问题，多给自己提问，多问一个为什么，兴趣自己就可以独立解决问题了。 总结 spring-boot-maven-plugin插件用于将当前程序打包成一个可以独立运行的程序包 命令行启动常见问题及解决方案​ 各位小伙伴在DOS环境下启动SpringBoot工程时，可能会遇到端口占用的问题。给大家一组命令，不用深入学习，备用吧。 12345678910# 查询端口netstat -ano# 查询指定端口netstat -ano |findstr \"端口号\"# 根据进程PID查询进程名称tasklist |findstr \"进程PID号\"# 根据PID杀死任务taskkill /F /PID \"进程PID号\"# 根据进程名称杀死任务taskkill -f -t -im \"进程名称\" ​ 关于打包与运行程序其实还有一系列的配置和参数，下面的内容中遇到再说，这里先开个头，知道如何打包和运行程序。 SpringBoot项目快速启动（Linux版）​ 其实对于Linux系统下的程序运行与Windows系统下的程序运行差别不大，命令还是那组命令，只不过各位小伙伴可能对Linux指令不太熟悉，结果就会导致各种各样的问题发生。比如防火墙如何关闭，IP地址如何查询，JDK如何安装等等。这里不作为重点内容给大家普及了，了解一下整体过程就行了。 YW-2.配置高级​ 关于配置在基础篇讲过一部分，基础篇的配置总体上来说就是让各位小伙伴掌握配置的格式。比如配置文件如何写啊，写好的数据如何读取啊，都是基础的语法级知识。在实用篇中就要集中在配置的应用这个方面了，下面就开始配置高级相关内容的第一部分学习，为什么说第一部分，因为在开发实用篇中还有对应的配置高级知识要进行学习。 YW-2-1.临时属性设置​ 目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。 ​ SpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。 1java –jar springboot.jar –-server.port=80 ​ 上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名=属性值的形式添加对应参数就可以了。记得，这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。 ​ 如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。 1java –jar springboot.jar –-server.port=80 --logging.level.root=debug 属性加载优先级​ 现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。地址奉上：https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config ​ 我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。 ​ 比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。 ​ 我在课程评论区看到小伙伴学习基础篇的时候问这个问题了，就是这个原因造成的。在yaml中配置了user.name属性值，然后读取出来的时候居然不是自己的配置值，因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以SpringBoot最终会加载系统配置属性user.name。 总结 使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性 临时属性添加方式：java –jar 工程名.jar –-属性名=值 多个临时属性之间使用空格分隔 临时属性必须是当前boot工程支持的属性，否则设置无效 开发环境中使用临时属性​ 临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。 ​ 打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。 ​ 做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。 12public static void main(String[] args) {} ​ 原来是这样，通过这个args就可以获取到参数。再来看我们的引导类是如何书写的 123public static void main(String[] args) { SpringApplication.run(SSMPApplication.class,args);} ​ 这个args参数居然传递给了run方法，看来在Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样外部临时属性就无法进入到SpringBoot程序中了。 123public static void main(String[] args) { SpringApplication.run(SSMPApplication.class);} ​ 或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。 12345public static void main(String[] args) { String[] arg = new String[1]; arg[0] = \"--server.port=8082\"; SpringApplication.run(SSMPApplication.class, arg);} 总结 启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性 思考 ​ 现在使用临时属性可以在启动项目前临时更改配置了，但是新的问题又出来了。临时属性好用是好用，就是写的多了会很麻烦。比如我现在有个需求，上线的时候使用临时属性配置20个值，这下可麻烦了，能不能搞得简单点，集中管理一下呢？比如说搞个文件，加载指定文件？还真可以。怎么做呢？咱们下一节再说。 YW-2-2.配置文件分类​ SpringBoot提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这一节要说说配置文件了。其实这个配置文件我们一直在使用，只不过我们用的是SpringBoot提供的4级配置文件中的其中一个级别。4个级别分别是： 类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件） 类路径下config目录下配置文件 程序包所在目录中配置文件 程序包所在目录中config目录下配置文件 ​ 好复杂，一个一个说。其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题。上面4个文件的加载优先顺序为 file ：config/application.yml 【最高】 file ：application.yml classpath：config/application.yml classpath：application.yml 【最低】 ​ 那为什么设计这种多种呢？说一个最典型的应用吧。 场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。 场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。 场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？ ​ 解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？ ​ 级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。 总结 配置文件分为4种 项目类路径配置文件：服务于开发人员本机开发与测试 项目类路径config目录中配置文件：服务于项目经理整体调控 工程路径配置文件：服务于运维人员配置涉密线上环境 工程路径config目录中配置文件：服务于运维经理整体调控 多层级配置文件间的属性采用叠加并覆盖的形式作用于程序 YW-2-3.自定义配置文件​ 之前咱们做配置使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。 ​ 自定义配置文件方式有如下两种： 方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名 方式二：使用临时属性设置配置文件路径，这个是全路径名 ​ 也可以设置加载多个配置文件 ​ 使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚。 温馨提示 ​ 我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。这里不再说这些了，后面再讲这些东西。 总结 配置文件可以修改名称，通过启动参数设定 配置文件可以修改路径，通过启动参数设定 微服务开发中配置文件通过配置中心进行设置 YW-3.多环境开发​ 讲的内容距离线上开发越来越近了，下面说一说多环境开发问题。 ​ 什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。 YW-3-1.多环境开发（yaml单一文件版）​ 那什么是多环境开发？就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下： 12server: port: 80 ​ 如何想设计两组环境呢？中间使用三个减号分隔开 12345server: port: 80---server: port: 81 ​ 如何区分两种环境呢？起名字呗 123456789spring: profiles: proserver: port: 80---spring: profiles: devserver: port: 81 ​ 那用哪一个呢？设置默认启动哪个就可以了 12345678910111213spring: profiles: active: pro # 启动pro---spring: profiles: proserver: port: 80---spring: profiles: devserver: port: 81 ​ 就这么简单，再多来一组环境也OK 123456789101112131415161718spring: profiles: active: pro # 启动pro---spring: profiles: proserver: port: 80---spring: profiles: devserver: port: 81---spring: profiles: testserver: port: 82 ​ 其中关于环境名称定义上述格式是过时格式，标准格式如下 1234spring: config: activate: on-profile: pro 总结 多环境开发需要设置若干种常用环境，例如开发、生产、测试环境 yaml格式中设置多环境使用—区分环境设置边界 每种环境的区别在于加载的配置属性不同 启用某种环境时需要指定启动时使用该环境 YW-3-2.多环境开发（yaml多文件版）​ 将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。 主配置文件 123spring: profiles: active: pro # 启动pro 环境配置文件 12server: port: 80 ​ 环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。 application-pro.yaml 12server: port: 80 application-dev.yaml 12server: port: 81 ​ 文件的命名规则为：application-环境名.yml。 ​ 在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。 主配置文件中设置公共配置（全局） 环境分类配置文件中常用于设置冲突属性（局部） 总结 可以使用独立配置文件定义环境属性 独立配置文件便于线上系统维护更新并保障系统安全性 YW-3-3.多环境开发（properties多文件版）​ SpringBoot最早期提供的配置文件格式是properties格式的，这种格式的多环境配置也了解一下吧。 主配置文件 1spring.profiles.active=pro 环境配置文件 application-pro.properties 1server.port=80 application-dev.properties 1server.port=81 ​ 文件的命名规则为：application-环境名.properties。 总结 properties文件多环境配置仅支持多文件格式 YW-3-4.多环境开发独立配置文件书写技巧​ 作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。 准备工作 ​ 将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下 application-devDB.yml application-devRedis.yml application-devMVC.yml 使用 ​ 使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔 1234spring: profiles: active: dev include: devDB,devRedis,devMVC ​ 比较一下，现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么 注意 ​ 当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效 改良 ​ 但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦了。SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。 1234567spring: profiles: active: dev group: \"dev\": devDB,devRedis,devMVC \"pro\": proDB,proRedis,proMVC \"test\": testDB,testRedis,testMVC ​ 现在再来看，如果切换dev到pro，只需要改一下是不是就结束了？完美！ 总结 多环境开发使用group属性设置配置文件分组，便于线上维护管理 YW-3-5.多环境开发控制​ 多环境开发到这里基本上说完了，最后说一个冲突问题。就是maven和SpringBoot同时设置多环境的话怎么搞。 ​ 要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。 ​ maven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。整个确认后下面就好做了。大体思想如下： 先在maven环境中设置用什么具体的环境 在SpringBoot中读取maven设置的环境即可 maven中设置多环境（使用属性方式区分环境） 1234567891011121314151617&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;env_dev&lt;/id&gt; &lt;properties&gt; &lt;profile.active&gt;dev&lt;/profile.active&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;!--默认启动环境--&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;env_pro&lt;/id&gt; &lt;properties&gt; &lt;profile.active&gt;pro&lt;/profile.active&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; SpringBoot中读取maven设置值 123spring: profiles: active: @profile.active@ ​ 上面的@属性名@就是读取maven中配置的属性值的语法格式。 总结 当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值 基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效 YW-4.日志​ 运维篇最后一部分我们来聊聊日志，日志大家不陌生，简单介绍一下。日志其实就是记录程序日常运行的信息，主要作用如下： 编程期调试代码 运营期记录信息 记录日常运营重要信息（峰值流量、平均响应时长……） 记录应用报错信息（错误堆栈） 记录运维过程数据（扩容、宕机、报警……） ​ 或许各位小伙伴并不习惯于使用日志，没关系，慢慢多用，习惯就好。想进大厂，这是最基本的，别去面试的时候说没用过，完了，没机会了。 YW-4-1.代码中使用日志工具记录日志​ 日志的使用格式非常固定，直接上操作步骤： 步骤①：添加日志记录操作 12345678910111213@RestController@RequestMapping(\"/books\")public class BookController extends BaseClass{ private static final Logger log = LoggerFactory.getLogger(BookController.class); @GetMapping public String getById(){ log.debug(\"debug...\"); log.info(\"info...\"); log.warn(\"warn...\"); log.error(\"error...\"); return \"springboot is running...2\"; }} ​ 上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API了。 步骤②：设置日志输出级别 ​ 日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是： TRACE：运行堆栈信息，使用率低 DEBUG：程序员调试代码使用 INFO：记录运维过程数据 WARN：记录运维过程报警数据 ERROR：记录错误堆栈信息 FATAL：灾难信息，合并计入ERROR ​ 一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。下面就设置一下日志级别： 12# 开启debug模式，输出调试信息，常用于检查系统运行状况debug: true ​ 这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制 1234567# 开启debug模式，输出调试信息，常用于检查系统运行状况debug: true# 设置日志级别，root表示根节点，即整体应用日志级别logging: level: root: debug ​ 还可以再设置更细粒度的控制 步骤③：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别 1234567891011logging: # 设置日志组 group: # 自定义组名，设置当前组中所包含的包 ebank: com.itheima.controller level: root: warn # 为对应组设置日志级别 ebank: debug # 为对包设置日志级别 com.itheima.controller: debug ​ 说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。 总结 日志用于记录开发调试与运维过程消息 日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO,WARN,ERROR 可以通过日志组或代码包的形式进行日志显示级别的控制 教你一招：优化日志对象创建代码​ 写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的lombok技术给我们提供的工具类即可。 12345@RestController@RequestMapping(\"/books\")public class BookController extends BaseClass{ private static final Logger log = LoggerFactory.getLogger(BookController.class); //这一句可以不写了} ​ 导入lombok后使用注解搞定，日志对象名为log 123456@Slf4j //这个注解替代了下面那一行@RestController@RequestMapping(\"/books\")public class BookController extends BaseClass{ private static final Logger log = LoggerFactory.getLogger(BookController.class); //这一句可以不写了} 总结 基于lombok提供的@Slf4j注解为类快速添加日志对象 YW-4-2.日志输出格式控制​ 日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。 ​ 对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID与线程名用于做精准分析。了解这些信息后就可以DIY日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。 123logging: pattern: console: \"%d %clr(%p) --- [%16t] %clr(%-40.40c){cyan} : %m %n\" 总结 日志输出格式设置规则 YW-4-3.日志文件​ 日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。 ​ 对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。这里主要研究日志文件如何记录。 ​ 记录日志到文件中格式非常简单，设置日志文件名即可。 123logging: file: name: server.log ​ 虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式： 12345logging: logback: rollingpolicy: max-file-size: 3KB file-name-pattern: server.%d{yyyy-MM-dd}.%i.log ​ 以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3KB以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。 总结 日志记录到文件 日志文件格式设置 运维实用篇完结​ 运维实用篇到这里就要先告一段落了，为什么不说结束呢？因为运维篇中还有一些知识，但是现在讲解过于分散了。所以要把这些知识与开发实用篇的知识结合在一起讲，也是本课程的教学设计的体现。 ​ 在整体运维实用篇中带着大家学习了4块内容，首先学习了如何运行SpringBoot程序，也就是程序的打包与运行，接下来对配置进行了升级学习，不再局限在配置文件中进行设置，通过临时属性，外部配置文件对项目的配置进行管控。在多环境开发中给大家介绍了多种多环境开发的格式，其实掌握一种即可，此外还给大家讲了多环境开发的一些技巧以及与maven的冲突解决方案。最后给大家介绍了日志系统，老实说日志这里讲的相当的潦草，因为大部分日志相关的知识都不应该在这门课中学习，这里只是告诉大家如何整合实用而已。 ​ 看了各位小伙伴的评论，知道你们再催更，我也在加油，一起努力吧，实用开发篇再会。实用开发篇会提高更新频度，不全部做完给大家更新了，我先把做好的一部分开放出来，随后做完一点就更新一点，额，好吧，就说到这里吧。","categories":[{"name":"java","slug":"java","permalink":"https://wenkex.gitee.io/categories/java/"}],"tags":[{"name":"web","slug":"web","permalink":"https://wenkex.gitee.io/tags/web/"}]},{"title":"前端学习","slug":"前端学习","date":"2022-04-03T14:07:51.000Z","updated":"2022-04-03T14:07:51.000Z","comments":true,"path":"2022/040312750.html","link":"","permalink":"https://wenkex.gitee.io/2022/040312750.html","excerpt":"","text":"好用的网站CODEPENCodePen 是一个基于 Web 的开发平台，允许用户在网页编写 HTML、CSS 和 JavaScript 等前端语言。并且它是实时可见的，这会使故障排除更加容易。开发人员和设计人员还可以与世界其他地方交换代码示例。 Responsively这是一个基于开源项目的网站，它能够将各个设备屏幕展现在同一个页面上，能够让你非常方便的开发响应式网站，大幅提高前端开发的效率。 HTMLHTML:（HyperText Markup Language）【超文本标记语言】 狭义的HTML指的是网页；广义的HTML指的是前端技术（html,css,js,以及各种框架）——网页，移动端网页，小程序，公众号，移动端的app，快应用等。 HTML是一门标记语言，标记语言由一套标记标签组成，学习HTML，就是学习标签。 vscode编辑htmlopen in brower按下快捷键ALT+B 即可在浏览器运行html HTMLHint错误提示 html snippets常用html代码片段模板 live server实时预览html文件 beautify格式化代码工具，美化javascript，JSON，CSS，Sass，和HTML HTML文件结构1.文档类型声明HTML5版本的文档类型声明是：&lt;!DOCTYPE html&gt; 2.根标签html标签是整个文档的根标签，所有其他标签都必须放在html标签里面。上面的文档类型不能当做普通标签看待。 所谓『根』其实是『树根』的意思。在一个树形结构中，根节点只能有一个。 3.头部head标签用于定义文档的头部，其他头部元素都放在head标签里。头部元素包括title标签、script标签、style标签、link标签、meta标签等等。和网页设置相关的内容都写在head标签里； 4.主体body标签定义网页的主体内容，在浏览器窗口内显示的内容都定义到body标签内。 5.注释&lt;!-- 注释内容 --&gt; HTML语法规则根标签有且只能有一个无论是双标签还是单标签都必须正确关闭标签可以嵌套但不能交叉嵌套注释不能嵌套属性必须有值，值必须加引号，单引号或双引号均可标签名不区分大小写但建议使用小写 标签由尖括号包裹单词构成，如：&lt;html&gt;，所以标签不可能以数字开头。标签不区分大小写，但推荐小写。标签也称为元素。 1234567单标签有两种写法： 写法一：只写开标签即可&lt;br&gt; 写法二：在开标签的结尾写一个/，如&lt;br/&gt;双标签：开始标签又称开放标签&lt;a&gt;标签体&lt;/a&gt;结束标签又称闭合标签或关标签自闭合标签/单标签，如：&lt;meta charset=\"UTF-8\"&gt;，&lt;br&gt;等 标题标签12345678910&lt;body&gt; &lt;h1&gt;这是一级标题&lt;/h1&gt; &lt;h2&gt;这是二级标题&lt;/h2&gt; &lt;h3&gt;这是三级标题&lt;/h3&gt; &lt;h4&gt;这是四级标题&lt;/h4&gt; &lt;h5&gt;这是五级标题&lt;/h5&gt; &lt;h6&gt;这是六级标题&lt;/h6&gt;&lt;/body&gt; 注意：标题标签前后有换行。 段落标签&lt;p&gt;There is clearly a need for CSS to be taken seriously by graphic artists. The Zen Garden aims to excite, inspire, and encourage participation. To begin, view some of the existing designs in the list. Clicking on any one will load the style sheet into this very page. The code remains the same, the only thing that has changed is the external .css file. Yes, really.&lt;/p&gt; 超链接12&lt;a href=\"http://www.w3school.com.cn\" &gt;文字说明&lt;/a&gt; 点击后跳转到href属性指定的页面 表格表格由 &lt;table&gt; 标签来定义。&lt;th&gt; 定义表头每个表格均有若干行（由 &lt;tr&gt;标签定义），每行被分割为若干单元格（由 &lt;td&gt; 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。 12345678910&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 无序列表12345&lt;ul&gt; &lt;li&gt;Apple&lt;/li&gt; &lt;li&gt;Banana&lt;/li&gt; &lt;li&gt;Grape&lt;/li&gt; &lt;/ul&gt; 块『块』并不是为了显示文章内容的，而是为了方便结合CSS对页面进行布局。块有两种，div是前后有换行的块，span是前后没有换行的块。 12345&lt;div style=\"border: 1px solid black;width: 100px;height: 100px;\"&gt;This is a div block&lt;/div&gt;&lt;div style=\"border: 1px solid black;width: 100px;height: 100px;\"&gt;This is a div block&lt;/div&gt;&lt;span style=\"border: 1px solid black;width: 100px;height: 100px;\"&gt;This is a span block&lt;/span&gt;&lt;span style=\"border: 1px solid black;width: 100px;height: 100px;\"&gt;This is a span block&lt;/span&gt; 图片src属性用来指定图片文件的路径，这里同样按我们前面说的使用『绝对路径』。 1&lt;img src=\"/aaa/pro01-HTML/./images/mi.jpg\"/&gt; 表单凡是需要用户填写的信息都需要用到表单。 form标签在HTML中我们使用form标签来定义一个表单。而对于form标签来说有两个最重要的属性：action和method。 123&lt;form action=\"/aaa/pro01-HTML/page05-form-target.html\" method=\"post\"&gt; &lt;/form&gt; action 属性规定当提交表单时，向何处发送表单数据。填写服务器端的能够接收表单数据的地址 method属性。用来定义提交表单的『请求方式』。method属性只有两个可选值：get或post，没有极特殊情况的话使用post即可。 input标签input 标签用于搜集用户信息。根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等。&lt;input type=\"表单元素的类型\" name=\"名称\" value=\"默认值\" size=\"宽度\"&gt; type属性text 单行文本框 省略时默认就是textpassword 密码框 输入时以点号显示，安全redio 单选按钮 只能选择其中一个checkbox 多选框 可以同时选择多个submit 提交按钮 提交表单数据reset 重置按钮 重置表单元素的初始值image 图像按钮 可以使用图片作为按钮button 普通按钮 默认情况下无功能file 文件选择器 选择要上传的文件hidden 隐藏域 在页面上不显示，但是会提交，可以用来存储数据 placeholder属性placeholder属性提供可描述输入字段预期值的提示信息 下拉列表1234567你喜欢的运动是：&lt;select name=\"interesting\"&gt; &lt;option value=\"swimming\"&gt;游泳&lt;/option&gt; &lt;option value=\"running\"&gt;跑步&lt;/option&gt; &lt;option value=\"shooting\" selected=\"selected\"&gt;射击&lt;/option&gt; &lt;option value=\"skating\"&gt;溜冰&lt;/option&gt;&lt;/select&gt; 下拉列表用到了两种标签，其中select标签用来定义下拉列表，而option标签设置列表项。name属性在select标签中设置。value属性在option标签中设置。option标签的标签体是显示出来给用户看的，提交到服务器的是value属性的值。通过在option标签中设置selected=”selected”属性实现默认选中的效果 按钮123&lt;button type=\"button\"&gt;普通按钮&lt;/button&gt;&lt;button type=\"reset\"&gt;重置按钮&lt;/button&gt;&lt;button type=\"submit\"&gt;提交按钮&lt;/button&gt; 普通按钮 点击后无效果，需要通过JavaScript绑定单击响应函数重置按钮 点击后将表单内的所有表单项都恢复为默认值提交按钮 点击后提交表单 多行文本框自我介绍：&lt;textarea name=\"desc\"&gt;&lt;/textarea&gt;textarea没有value属性，如果要设置默认值需要写在开始和结束标签之间。 CSS基础设置CSS样式的三种方式在HTML标签内设置仅对当前标签有效 &lt;div style=\"border: 1px solid black;width: 100px; height: 100px;\"&gt;&amp;nbsp;&lt;/div&gt; 在head标签内设置对当前页面有效在&lt;style&gt;&lt;/style&gt;里写 12345678910111213&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=\"text/css\"&gt; .one { border: 1px solid black; width: 100px; height: 100px; background-color: lightgreen; margin-top: 5px; } &lt;/style&gt;&lt;/head&gt; 引入外部CSS样式文件在需要使用这个CSS文件的HTML页面的head标签内加入： &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/aaa/pro01-HTML/style/example.css\" /&gt; CSS代码语法CSS样式由选择器和声明组成，而声明又由属性和值组成。属性和值之间用冒号隔开。多条声明之间用分号隔开。使用/* … */声明注释。 CSS 选择器CSS 选择器用于“查找”（或选取）要设置样式的 HTML 元素。 id选择器:#id id 名称不能以数字开头。 12345/* 这条CSS 规则将应用于 id=\"para1\" 的 HTML 元素 */#para1 { text-align: center; color: red;} 类选择器:如需选择拥有特定 class 的元素，请写一个句点（.）字符，后面跟类名。 12345/* 在此例中，所有带有 class=\"center\" 的 HTML 元素将为红色且居中对齐： */.center { text-align: center; color: red;} 通用选择器通用选择器（*）选择页面上的所有的 HTML 元素。 123456/* 下面的 CSS 规则会影响页面上的每个 HTML 元素： */* { text-align: center; color: blue;} 分组选择器分组选择器选取所有具有相同样式定义的 HTML 元素。 1234h1, h2, p { text-align: center; color: red;} 组合器选择器（根据它们之间的特定关系来选取元素）伪类选择器（根据特定状态选取元素）伪元素选择器（选取元素的一部分并设置其样式）属性选择器（根据属性或属性值来选取元素）css基础属性文字类colorfont-sizetext-decorationtext-align 尺寸类widthheight 背景：background-colorbackground-imagebackground-size:cover 工具谷歌浏览器CSS Overview在 Chrome 的管理面板中，开启CSS Overview面板之后，就可以查看当前网站的样式信息了，包括颜色信息、字体信息、媒体查询等 1.在任意页面打开 Chrome 浏览器的 DevTools；2.单击更多选项 -&gt; More tools -&gt; CSS Overview。 新的字体编辑器工具Chrome DevTools 提供了一个实验性的字体编辑器工具，可以用来改变字体设置。可以用它来改变字体、大小、粗细、行高、字符间距，并实时看到变化 1.在任意页面打开 Chrome 浏览器的 DevTools；2.点击右上角设置图标 -&gt; 选中左侧 Experiments -&gt; 勾选 Enable New Font Editor Tools within Styles Pane；3.重启浏览器的 DevTools；4.选择HTML元素，其中包括想改变的字体，点击字体图标即可。 Thymeleaf模板引擎https://developer.aliyun.com/article/769977 模板引擎模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的html文档。 将模板设计好之后直接填充数据即可而不需要重新设计整个页面。让网站实现界面和数据分离，提高页面、代码的复用性。 介绍Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎 特点1.动静分离： Thymeleaf选用html作为模板页，这是任何一款其他模板引擎做不到的！Thymeleaf使用html通过一些特定标签语法代表其含义，但并未破坏html结构，即使无网络、不通过后端渲染也能在浏览器成功打开，大大方便界面的测试和修改。 2.开箱即用： Thymeleaf提供标准和Spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改JSTL、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 3.Springboot官方大力推荐和支持，Springboot官方做了很多默认配置，开发者只需编写对应html即可，大大减轻了上手难度和配置复杂度。 第一个Thymeleaf程序步骤 创建程序，添加依赖首先，打开你的IDEA创建新项目，选择Spring Initializr方式创建Springboot项目 ，然后点击next，然后填写项目名 勾选其中Web 模块的Spring web依赖以及Template 模块的Thymeleaf依赖。finish 即可： 如果你创建项目时没有勾选依赖也不要紧，在pom.xml中添加以下依赖： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 文件说明pom.xml：是项目中的Maven依赖，因为Springboot使用Maven来管理外部jar包依赖，我们只需填写依赖名称配置即可引入该依赖，在本系统中引入Spring web模块(Springmvc)和Thymeleaf的依赖.我们不需要自己去招相关jar包。application.properties: 编写Springboot与各框架整合的一些配置内容。controller：用来编写控制器，主要负责处理请求以及和视图(Thymeleaf)绑定。static：用于存放静态资源，例如html、JavaScript、css以及图片等。templates：用来存放模板引擎Thymeleaf(本质依然是.html文件) 编写Controller项目基于Springboot框架，且选了Spring web(Springmvc)作为mvc框架，其中Thymeleaf就是v(view)视图层，我们需要在controller中指定Thymeleaf页面的url，然后再Model中绑定数据。 我们在com.Thymeleaf文件下创建controller文件夹，在其中创建urlController.java的controller文件，文件内容(代码)为： 12345678910111213141516package com.Thymeleaf.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class urlController { @GetMapping(\"index\")//页面的url地址 public String getindex(Model model)//对应函数 { model.addAttribute(\"name\",\"bigsai\"); return \"index\";//与templates中index.html对应 }} 部分含义如下：@controller 注解的意思就是声明这个java文件为一个controller控制器。@GetMapping(“index”) 其中@GetMapping的意思是请求的方式为get方式(即可通过浏览器直接请求)，而里面的index表示这个页面(接口)的url地址(路径)。即在浏览器对项目网页访问的地址。getindex() 是@GetMapping(“index”)注解对应的函数，其类型为String类型返回一个字符串，参数Model类型即用来储存数据供我们Thymeleaf页面使用。model.addAttribute(“name”,”bigsai”) 就是Model存入数据的书写方式，Model是一个特殊的类，相当于维护一个Map一样，而Model中的数据通过controller层的关联绑定在view层(即Thymeleaf中)可以直接使用。return “hello”：这个index就是在templates目录下对应模板(本次为Thymeleaf模板)的名称，即应该对应hello.html这个Thymeleaf文件(与页面关联默认规则为：templates目录下返回字符串.html)。 编写Thymeleaf页面咱们在项目的resources目录下的templates文件夹下面创建一个叫index.html的文件，咱们在这个html文件中的标签修改为这样在Thymeleaf中就可以使用Thymeleaf的语法和规范啦。 对于第一个Thymelaf程序，你只需将index.html文件改成这样即可： 1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello 第一个Thymeleaf程序&lt;div th:text=\"${name}\"&gt;name是bigsai(我是离线数据)&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Thymeleaf语法详解常用标签链接表达式: @{…}变量表达式: ${…}选择变量表达式: *{…}消息表达: #{…}Bootstrap组件库Bootstrap:前端页面框架，用于快速开发响应式页面，一套代码就可以适应平板和PC Bootstrap 3 是移动设备优先的，在这个意义上，Bootstrap 代码从小屏幕设备（比如移动设备、平板电脑）开始，然后扩展到大屏幕设备（比如笔记本电脑、台式电脑）上的组件和网格。 教程 Bootstrap 可视化布局系统！ 引入bootstrap框架1、直接引入： 12&lt;link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css\"&gt;&lt;script src=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt; 优点：方便，简单； 缺点：使网页加载缓慢，需要有网络的情况； 2.下载好库再进行引入：优点：加载网页会快点，没有网络的情况也可用； jQueryjQuery菜鸟教程jQuery ：是一个 JavaScript 函数库。使用选择器（$）选取DOM对象，并对其进行赋值、取值、事件绑定等操作；主要是操作DOM 获取国内用百度CDN 1234&lt;head&gt;&lt;script src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; jQuery 语法基础语法： $(selector).action() 美元符号定义 jQuery选择符（selector）”查询”和”查找” HTML 元素jQuery 的 action() 执行对元素的操作 jQuery 选择器jQuery 事件Ajax可实现页面无刷新更新数据 Ajax相当于浏览器发送请求与接受响应的代理人，以实现在不重新加载整个页面下，与服务器交换数据并局部更新网页数据 向服务器发送请求open(method,url,async)规定请求的类型、URL 以及是否异步处理请求。参数 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) 将请求发送到服务器。 string：仅用于 POST 请求 实例1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;script&gt;function loadXMLDoc(){ var xmlhttp; if (window.XMLHttpRequest) { // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 // 创建 XMLHttpRequest 对象 xmlhttp=new XMLHttpRequest(); } else { // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); } xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; } } xmlhttp.open(\"GET\",\"/try/ajax/ajax_info.txt\",true); xmlhttp.send();}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"myDiv\"&gt;&lt;h2&gt;使用 AJAX 修改该文本内容&lt;/h2&gt;&lt;/div&gt;&lt;button type=\"button\" onclick=\"loadXMLDoc()\"&gt;修改内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; axiosaxios实现了对ajax的封装。Axios 是可以发出 http 请求的 JavaScript 库，在 浏览器 和 node.js 环境中都可以运行。 axios与ajax的优缺点1.axios优点：（1）从浏览器中创建 XMLHttpRequest；（2）支持 Promise API；（3）从 node.js 创建 http 请求；（4）转换请求和响应数据；（5）自动转换JSON数据。 1.ajax缺点:（1）基于原生的XHR开发，XHR本身的架构不清晰；（2）JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理；（3）不符合关注分离（Separation of Concerns）的原则；（4）配置和调用方式非常混乱，而且基于事件的异步模型不友好。 GET 请求和POST 请求12345678910111213141516171819202122232425262728293031&lt;script src=\"../js/axios-0.18.0.js\"&gt;&lt;/script&gt;&lt;script&gt;// 1、向给定ID的用户发起GET 请求axios.get('/user?ID=12345') .then(function (response) { // 处理成功情况 console.log(response); }) .catch(function (error) { // 处理错误情况 console.log(error); }) .then(function () { // 总是会执行 });// 2.POST 请求axios.post('/user', { firstName: 'Fred', lastName: 'Flintstone' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); });&lt;/script&gt; Vue.js官方文档：http://vuejs.org/v2/guide/syntax.html 中文文档: https://cn.vuejs.org/v2/guide/syntax.html 搭建环境标签引入本地文件引入基本语法绑定元素属性基本语法v-bind:HTML标签的原始属性名=”表达式” HTML代码 123456789&lt;div id=\"app\"&gt; &lt;!-- v-bind:value表示将value属性交给Vue来进行管理，也就是绑定到Vue对象 --&gt; &lt;!-- vueValue是一个用来渲染属性值的表达式，相当于标签体中加{{}}的表达式 --&gt; &lt;input type=\"text\" v-bind:value=\"vueValue\" /&gt; &lt;!-- 同样的表达式，在标签体内通过{{}}告诉Vue这里需要渲染； --&gt; &lt;!-- 在HTML标签的属性中，通过v-bind:属性名=\"表达式\"的方式告诉Vue这里要渲染 --&gt; &lt;p&gt;{{vueValue}}&lt;/p&gt;&lt;/div&gt; Vue代码 1234567// 创建Vue对象，挂载#app这个div标签var app = new Vue({ \"el\":\"#app\", \"data\":{ \"vueValue\":\"太阳当空照\" }}); v-bind:v-bind用于单向绑定数据和元素属性 123 &lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- 可简写为： --&gt; &lt;a :href=\"url\"&gt;&lt;/a&gt; v-model使用了双向绑定后，就可以实现：页面上数据被修改后，Vue对象中的数据属性也跟着被修改。 双向数据绑定,一般用在表单类元素如：input，select 123456789101112&lt;div id=\"app\"&gt; &lt;!-- v-bind:属性名 效果是从Vue对象渲染到页面 --&gt; &lt;!-- v-model:属性名 效果不仅是从Vue对象渲染到页面，而且能够在页面上数据修改后反向修改Vue对象中的数据属性 --&gt; &lt;input type=\"text\" v-model:value=\"vueValue\" /&gt; &lt;!-- 因为v-model默认收集的就是value值，所以可简写为 --&gt; &lt;input type=\"text\" v-model=\"vueValue\" /&gt; &lt;!-- 考虑到用户在输入数据时，有可能会包含前后空格。而这些前后的空格对我们程序运行来说都是干扰因素，要去掉。在v-model后面加上.trim修饰符即可实现。 --&gt; &lt;input type=\"text\" v-model.trim=\"vueValue\" /&gt; &lt;p&gt;{{vueValue}}&lt;/p&gt;&lt;/div&gt; 12345678// 创建Vue对象，挂载#app这个div标签var app = new Vue({ \"el\":\"#app\", \"data\":{ \"vueValue\":\"太阳当空照\" }}); 条件渲染js表达式与js代码(语句)的区别1.表达式：一个表达式会生成一个值 (1)a+b (2)x===y ‘a’ ? ‘b’ 2.代码 (1)if (){} 使用12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 定义一个容器 --&gt;&lt;div id=\"root\"&gt; &lt;!-- {{ }} 用于输出对象属性和函数返回值。 --&gt; &lt;h1&gt;site : {{site}}&lt;/h1&gt; &lt;h1&gt;url : {{url}}&lt;/h1&gt; &lt;h1&gt;{{details()}}&lt;/h1&gt;&lt;/div&gt;&lt;!-- 对于制作原型或学习，你可以这样导入最新版本： --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; // vue实例 var vm = new Vue({ // el 参数的两种写法 // vm.$mount('#rood'), el: '#rood', // data参数用于定义属性 // 1.data参数的对象式写法 data: { site: \"菜鸟教程\", url: \"www.runoob.com\", alexa: \"10000\" }, // 2.data参数的函数式写法(vue管理的函数，不能用箭头函数) // data:function(){ // return{ // name:'菜鸟' // } // } // methods参数用于定义函数 methods: { details: function() { return this.site + \" - 学的不仅是技术，更是梦想！\"; } } })&lt;/script&gt; 钩子函数created() {}VUE对象初始化完成后自动执行 Element UI组件库Element UI 是一套采用 Vue 2.0 作为基础框架实现的组件库 组件 安装1234&lt;!-- 引入样式 --&gt;&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\"&gt;&lt;!-- 引入组件库 --&gt;&lt;script src=\"https://unpkg.com/element-ui/lib/index.js\"&gt;&lt;/script&gt; 基础Layout 布局Container 布局容器Color 色彩Typography 字体Border 边框Icon 图标Button 按钮Link 文字链接Form 表单Radio 单选框Checkbox 多选框Input 输入框InputNumber 计数器Select 选择器Cascader 级联选择器Switch 开关Slider 滑块TimePicker 时间选择器DatePicker 日期选择器DateTimePicker 日期时间选择器Upload 上传Rate 评分ColorPicker 颜色选择器Transfer 穿梭框Form 表单 数据Table 表格Tag 标签Progress 进度条Tree 树形控件Pagination 分页Badge 标记Avatar 头像Skeleton 骨架屏Empty 空状态Descriptions 描述列表Result 结果 输入框 &lt;el-input v-model=\"input1\"&gt;&lt;/el-input&gt; 输入内容为：{{input1}} Table表格组件el-table:data属性 单向数据绑定 stripe属性可以创建带斑马纹的表格 Table 组件提供了单选的支持，只需要配置highlight-current-row属性即可实现单选。之后由current-change事件来管理选中时触发的事件，它会传入currentRow，oldCurrentRow。如果需要显示索引，可以增加一列el-table-column，设置type属性为index即可显示从 1 开始的索引号。 el-table-columnprop属性来对应对象中的键名即可填入数据，label属性来定义表格的列名。width属性来定义列宽。align=“center”：设置表格内居中 1234567891011121314151617181920212223&lt;el-table size=\"small\" current-row-key=\"id\" :data=\"dataList\" stripe highlight-current-row&gt; &lt;el-table-column type=\"index\" align=\"center\" label=\"序号\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"type\" label=\"图书类别\" align=\"center\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"name\" label=\"图书名称\" align=\"center\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"description\" label=\"描述\" align=\"center\"&gt;&lt;/el-table-column&gt; &lt;el-table-column label=\"操作\" align=\"center\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-button type=\"primary\" size=\"mini\" @click=\"handleUpdate(scope.row)\"&gt;编辑&lt;/el-button&gt; &lt;el-button type=\"danger\" size=\"mini\" @click=\"handleDelete(scope.row)\"&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt;&lt;/el-table&gt; 通知Alert 警告Loading 加载Message 消息提示MessageBox 弹框Notification 通知NavigationNavMenu 导航菜单Tabs 标签页Breadcrumb 面包屑PageHeader 页头Dropdown 下拉菜单Steps 步骤条 导航其他Dialog 对话框Tooltip 文字提示Popover 弹出框Popconfirm 气泡确认框Card 卡片Carousel 走马灯Collapse 折叠面板Timeline 时间线Divider 分割线Calendar 日历Image 图片Backtop 回到顶部InfiniteScroll 无限滚动Drawer 抽屉¶Button 按钮 通过js触发按钮的点击事件1234567891011121314151617&lt;el-button type=\"primary\" size=\"mini\" @click=\"handleUpdate(scope.row)\"&gt;编辑&lt;/el-button&gt;&lt;script&gt; //弹出编辑窗口 handleUpdate(row) { axios.get(\"/books/\"+row.id).then((res)=&gt;{ if(res.data.flag &amp;&amp; res.data.data != null ){ this.dialogFormVisible4Edit = true; this.formData = res.data.data; }else{ this.$message.error(\"数据同步失败，自动刷新\"); } }).finally(()=&gt;{ //2.重新加载数据 this.getAll(); }); },&lt;/script&gt; javawebhttps://heavy_code_industry.gitee.io/code_heavy_industry/read-me/vuepress.htmlhttps://vuepress.vuejs.org/zh/guide/","categories":[{"name":"前端","slug":"前端","permalink":"https://wenkex.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wenkex.gitee.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"qq机器人","slug":"qq机器人","date":"2022-03-26T09:09:00.000Z","updated":"2022-03-26T09:09:00.000Z","comments":true,"path":"2022/032659541.html","link":"","permalink":"https://wenkex.gitee.io/2022/032659541.html","excerpt":"","text":"基础知识WebSocket协议WebSocket 是HTML5 提供的一种在单个TCP连接上进行全双工通信的协议。 WebSocket 只需要完成一次握手，客户端和服务器之间就可以创建持久性的连接，并进行双向数据传输。这就使得客户端和服务器之间的数据交换变得更加简单。 go-cqhttpOneBotgo-cqhttp（一个 QQ 平台的 OneBot 实现） go-cqhttp 文档 搭建建议使用ubuntu服务器下载：64 位 Linux Not available go-cqhttp_linux_amd64.tar.gz Linux下在命令行中输入 tar -xzvf [文件名] 解压到想要的文件夹内 进入对应目录 ./go-cqhttp启动 问题1.第一次无法登录，隔了一天再登录又可以了 使用进入对应目录 ./go-cqhttp前台运行。如果你操作其他命令或者关闭 ssh 工具，程序自然就关闭了 Nonebot2框架是一个可扩展的 Python 异步机器人框架：https://docs.nonebot.dev/ Nonebot2需要先搭建go-cqhttp 搭建可以使用 pip 安装已发布的最新版本：pip install nonebot 在提示选择通信方式时，选择「反向 Websocket 通信」，程序将会自动生成默认配置文件。 打开 go-cqhttp 默认配置文件 config.yml 进行简单配置，修改 QQ 账号以及密码。再次运行 go-cqhttp，可能需要根据提示进行扫码或滑块验证，如果得到以下提示则登录成功： 使用脚手架https://v2.nonebot.dev/docs/start/nb-cli pip install nb-cli 插件插件https://github.com/nonepkg/nonebot-plugin-manager Mirai使用 Kotlin 编写的高效率 QQ 机器人框架github地址 mirai官方生态文档 下载 MCL InstallerMCL Installer支持自动下载Java运行环境 和 Mirai Console Loader MCL Installer安装时自动下载了 Mirai Console Loader（简称 MCL）。Mirai Console Loader它的工作就是简化 console 启动流程，一键帮你下载 jar 文件，自动更新，文件损坏检查…… 你能在手动启动时担心的问题 mirai-console-loader 都帮你想到了 了解运行环境文件夹名称 用途scripts 存放启动器的脚本，一般不需要在意他们plugins 存放插件data 存放插件的数据，一般不需要在意它们config 存放插件的配置，可以打开并修改配置logs 存放运行时的日志，日志默认保留 7 天 插件官方(chat-command，mirai-api-http，mirai-native） 刚刚装好的 Mirai Console 是没有任何功能的。功能将由插件提供。插件发布如果是 JAR 文件的插件，放入 plugins 即可。其他插件一般都有特殊说明如何使用，请参考它们的说明。 PlumPlum Plum-1.0-SNAPSHOT.mirai.jar功能 每天5点：每日句子 + 倒计时（可自定义倒计时事件）每天21点：每日诗词戳一戳：随机一言@ + 问题：AI聊天（默认实现是青云客API，可自行修改）点歌：本插件支持3种主流音乐平台 网易云音乐，酷狗音乐，QQ音乐。默认按照 网易云音乐 -&gt; 酷狗音乐 -&gt; QQ音乐 顺序查找。通过“点歌”指令以卡片形式点歌，通过“唱歌”指令以语音条形式唱歌。 自动定义回复插件https://mirai.mamoe.net/topic/636/console-%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%B9%89%E5%9B%9E%E5%A4%8D%E6%8F%92%E4%BB%B6 浏览器进入http://localhost:20044/index.html 思知机器人插件自己跟自己聊天，不好用https://github.com/thetbw/my-bot 滑动验证助手https://github.com/mzdluo123/TxCaptchaHelper 下载手机客户端在mcl控制台中使用命令login &lt;qq&gt; [password] [protocol]会弹出url,把它复制到滑动验证助手app中 第二种登录方式（将弹出的链接发送给手机QQ打开，会得到一个二维码，使用手机QQ扫码验证） ANDROID_PAD是ipad login 3385642151 密码 ANDROID_PAD 问题搭建在Centos 7错误1./mcl-installer-d5a51f8-linux-amd64: /lib64/libc.so.6: version `GLIBC_2.25' not found (required by ./mcl-installer-d5a51f8-linux-amd64) 根据一些研究，GLIBC_2.25 不能安装在 Centos 7 上 参考https://zhuanlan.zhihu.com/p/411513359 IDEA下载插件：Mirai Console","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"qq","slug":"qq","permalink":"https://wenkex.gitee.io/tags/qq/"}]},{"title":"python高级","slug":"python高级","date":"2022-03-26T01:55:02.000Z","updated":"2022-03-26T01:55:02.000Z","comments":true,"path":"2022/03267198.html","link":"","permalink":"https://wenkex.gitee.io/2022/03267198.html","excerpt":"","text":"FuzzyWuzzy模糊匹配库https://mp.weixin.qq.com/s/Zj6AoQSD4u2KwY6D1PCfew FuzzyWuzzy 是一个简单易用的模糊字符串匹配工具包。它依据 Levenshtein Distance 算法，计算两个序列之间的差异。 Levenshtein Distance算法，又叫 Edit Distance算法，是指两个字符串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越大。 进程和线程Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。 Python中的多进程Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等。 下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。 123456789101112131415161718192021from random import randintfrom time import time, sleepdef download_task(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() download_task('Python从入门到住院.pdf') download_task('Peking Hot.avi') end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 下面是运行程序得到的一次运行结果。 12345开始下载Python从入门到住院.pdf...Python从入门到住院.pdf下载完成! 耗费了6秒开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒总共耗费了13.01秒. 从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。 123456789101112131415161718192021222324252627282930from multiprocessing import Processfrom os import getpidfrom random import randintfrom time import time, sleepdef download_task(filename): print('启动下载进程，进程号[%d].' % getpid()) print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() # Process类创建了进程对象 # 通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。 p1 = Process(target=download_task, args=('Python从入门到住院.pdf', )) p1.start() #启动进程 p2 = Process(target=download_task, args=('Peking Hot.avi', )) p2.start() p1.join() #表示等待进程执行结束 p2.join() end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 在上面的代码中，我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。 1234567启动下载进程，进程号[1530].开始下载Python从入门到住院.pdf...启动下载进程，进程号[1531].开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒Python从入门到住院.pdf下载完成! 耗费了10秒总共耗费了10.01秒. 我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。 123456789101112131415161718192021from multiprocessing import Processfrom time import sleepcounter = 0def sub_task(string): global counter while counter &lt; 10: print(string, end='', flush=True) counter += 1 sleep(0.01) def main(): Process(target=sub_task, args=('Ping', )).start() Process(target=sub_task, args=('Pong', )).start()if __name__ == '__main__': main() 看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共享的队列，底层是通过管道和信号量（semaphore）机制来实现的，有兴趣的读者可以自己尝试一下。 Python中的多线程在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。 123456789101112131415161718192021222324252627from random import randintfrom threading import Threadfrom time import time, sleepdef download(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() # 使用threading模块的Thread类来创建线程 t1 = Thread(target=download, args=('Python从入门到住院.pdf',)) t1.start() t2 = Thread(target=download, args=('Peking Hot.avi',)) t2.start() t1.join() t2.join() end = time() print('总共耗费了%.3f秒' % (end - start))if __name__ == '__main__': main() 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。 1234567891011121314151617181920212223242526272829303132from random import randintfrom threading import Threadfrom time import time, sleepclass DownloadTask(Thread): def __init__(self, filename): super().__init__() self._filename = filename def run(self): print('开始下载%s...' % self._filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (self._filename, time_to_download))def main(): start = time() t1 = DownloadTask('Python从入门到住院.pdf') t1.start() t2 = DownloadTask('Peking Hot.avi') t2.start() t1.join() t2.join() end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from time import sleepfrom threading import Threadclass Account(object): def __init__(self): self._balance = 0 def deposit(self, money): # 计算存款后的余额 new_balance = self._balance + money # 模拟受理存款业务需要0.01秒的时间 sleep(0.01) # 修改账户余额 self._balance = new_balance @property def balance(self): return self._balanceclass AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money)def main(): account = Account() threads = [] # 创建100个存款的线程向同一个账户中存钱 for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() # 等所有存款的线程都执行完毕 for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__': main() 运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from time import sleepfrom threading import Thread, Lockclass Account(object): def __init__(self): self._balance = 0 self._lock = Lock() def deposit(self, money): # 先获取锁才能执行后续的代码 self._lock.acquire() try: new_balance = self._balance + money sleep(0.01) self._balance = new_balance finally: # 在finally中执行释放锁的操作保证正常异常锁都能释放 self._lock.release() @property def balance(self): return self._balanceclass AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money)def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__': main() 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。 多进程还是多线程无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。 但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。 是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到过Python中有嵌入C/C++代码的机制。 除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。 说明： 上面的内容和例子来自于廖雪峰官方网站的《Python教程》，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。 单线程+异步I/O现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下并发编程的一种流行方案。 在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，在后续的课程中会进行讲解。 应用案例将耗时间的任务放到线程中以获得更好的用户体验。如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验 如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243import timeimport tkinterimport tkinter.messageboxfrom threading import Threaddef main(): class DownloadTaskHandler(Thread): def run(self): time.sleep(10) tkinter.messagebox.showinfo('提示', '下载完成!') # 启用下载按钮 button1.config(state=tkinter.NORMAL) def download(): # 禁用下载按钮 button1.config(state=tkinter.DISABLED) # 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行) # 在线程中处理耗时间的下载任务 DownloadTaskHandler(daemon=True).start() def show_about(): tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)') top = tkinter.Tk() top.title('单线程') top.geometry('200x150') top.wm_attributes('-topmost', 1) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text='下载', command=download) button1.pack(side='left') button2 = tkinter.Button(panel, text='关于', command=show_about) button2.pack(side='right') panel.pack(side='bottom') tkinter.mainloop()if __name__ == '__main__': main() 使用多进程对复杂任务进行“分而治之”。我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。 12345678910111213141516from time import timedef main(): total = 0 number_list = [x for x in range(1, 100000001)] start = time() for number in number_list: total += number print(total) end = time() print('Execution time: %.3fs' % (end - start))if __name__ == '__main__': main() 在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839from multiprocessing import Process, Queuefrom random import randintfrom time import timedef task_handler(curr_list, result_queue): total = 0 for number in curr_list: total += number result_queue.put(total)def main(): processes = [] number_list = [x for x in range(1, 100000001)] result_queue = Queue() index = 0 # 启动8个进程将数据切片后进行运算 for _ in range(8): p = Process(target=task_handler, args=(number_list[index:index + 12500000], result_queue)) index += 12500000 processes.append(p) p.start() # 开始记录所有进程执行完成花费的时间 start = time() for p in processes: p.join() # 合并执行结果 total = 0 while not result_queue.empty(): total += result_queue.get() print(total) end = time() print('Execution time: ', (end - start), 's', sep='')if __name__ == '__main__': main() 比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过multiprocessing.managers模块中提供的管理器将Queue对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。 openpyxl模块处理Excel电子表格https://zhuanlan.zhihu.com/p/351814769 https://blog.csdn.net/weixin_44288604/article/details/120731317 Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，由于微软从Office 2007开始使用了新的文件格式，这使得Office Excel和LibreOffice Calc、OpenOffice Calc是完全兼容的，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。 123456789101112import datetimefrom openpyxl import Workbookwb = Workbook()ws = wb.activews['A1'] = 42ws.append([1, 2, 3])ws['A2'] = datetime.datetime.now()wb.save(\"sample.xlsx\") excel文档和创建对象 工作薄(workbook):一个EXCEL文件就称为一个工作薄,一个工作薄中可以包含若干张工作表。打开或者创建一个Excel需要创建一个Workbook对象 工作表(sheet):工作薄中的每一张表格称为工作表,每张工作表都有一个标签,默认为sheet1\\sheet2\\sheet3来命名，(一个工作 薄默认为由3个工作表组成)。获取一个表则需要先创建一个Workbook对象，然后使用该对象的方法来得到一个Worksheet对象 活动表(active sheet)：指当前正在操作的工作表 行(row): 工作表中的每一行行首数字(1、2、3、)称为行标题;一张工作表最多有65536行 列(column): 列标题:工作表中每一列列首的字母(A、B、C)称为列标题;一张工作表最多有256列 单元格(cell): 工作表的每一个格称为单元格。如果要获取表中的数据，那么得到Worksheet对象以后再从中获取代表单元格的Cell对象 Workbook对象123456789101112#1.创建from openpyxl import Workbook #实例化Workbook对象wb = Workbook()# 激活 worksheetws = wb.active# 2.打开已有的excelfrom openpyxl import load_workbook#实例化Workbook对象wb2 = load_workbook('文件名称.xlsx') Workbook对象属性（工作簿操作）sheetnames：获取工作簿中的表（列表）active：获取当前活跃的Worksheetworksheets：以列表的形式返回所有的Worksheet(表格)read_only：判断是否以read_only模式打开Excel文档encoding：获取文档的字符集编码properties：获取文档的元数据，如标题，创建者，创建日期等 Worksheet对象(工作表操作)title：表格的标题max_row：表格的最大行min_row：表格的最小行max_column：表格的最大列min_column：表格的最小列rows：按行获取单元格(Cell对象) - 生成器columns：按列获取单元格(Cell对象) - 生成器values：按行获取表格的内容(数据) - 生成器 12#实例化Worksheet对象worksheet = wb['排序商品信息'] Cell对象（单元格）row：单元格所在的行column：单元格坐在的列value：单元格的值coordinate：单元格的坐标 12#实例化Cell对象cell = sheet['B1'] docx模块处理Word文档https://blog.csdn.net/weixin_44374471/article/details/100010360 Document对象时间处理Time库123456789101112import timetime.time() #获取当前时间戳（计算机内部时间）# 1643336568.9237003time.ctime(time.time()) #可以传入时间戳格式化时间#'Sat Jan 29 15:21:48 2022'time.loaltime() #本地时间 Sat Apr 16 22:34:40 2022print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())) #格式化时间 获取时间： 格式化时间time.strftime(tpl,ts) tpl：定义输出效果 ts：struct_time元组 12345time.strftime(\"%Y-%m-%d %H:%M:%S\",time.gmtime())#'2022-01-28 03:04:00'time.strftime(\"%a %b %d %H:%M:%S\",time.gmtime())#'Fri Jan 28 03:07:14' 将格式化字符串转换为时间戳strptime(str,tpl) str:字符串形式的时间值 tpl：定义输入效果 12345timestr = '2022-01-28 03:04:00' time.strptime(timestr,\"%Y-%m-%d %H:%M:%S\") #time.struct_time(tm_year=2022, tm_mon=1, tm_mday=28, tm_hour=3, tm_min=4, tm_sec=0, #tm_wday=4, tm_yday=28, tm_isdst=-1) 计时器功能datetime库datetime 基于 time 进行了封装，提供了更多实用的函数。 date类只关注日期 time类只关注时间 datetime类同时有时间和日期 12345678910111213141516d=datetime.datetime.now()d.yeard.monthd.dayd.hourd.minuted.secondd.microsecondd.tzinfo d.date() # 返回 date 对象d.time() # 返回 time 对象d.replace(name=value) # 前面所述各项属性是 read-only 的，需要此方法才可更改d.timetuple() # 返回time.struct_time 对象dattime.strftime(format) # 按照 format 进行格式化输出... timedelta类主要用于计算时间跨度 click命令行模块使用@click.command()装饰指定函数，使之成为命令行接口；使用@click.argument()或者@click.option()装饰函数，为其添加命令行选项等。 123456789import click # 装饰器@click.command()会将函数包装成 click 对象@click.command() def main(): click.echo(\"hello click\") if __name__ == '__main__': main() 打包跨平台可执行程序通过click编写了简单的命令行方法后，还需要把.py文件转换成可以在控制台里运行的命令行程序。最简单的方法就是加上如下代码： 12if __name__ == '__main__': command() click支持使用setuptools来更好的实现命令行程序打包，把源码文件打包成系统中的可执行程序，并且不限平台。一般可通过在源码根目录下创建setup.py脚本，下面是一段简单的打包代码： 12345678910111213from setuptools import setupsetup( name='hello', version='0.1', py_modules=['hello'], install_requires=[ 'click', ], entry_points=''' [console_scripts] hello=hello:cli ''',) )留意entry_points字段，在console_scripts下，每一行都是一个控制台脚本，等号左边的是脚本的名称，右边的是click命令的导入路径。 PyScriptPyScript是 Anaconda 团队开发的一个 Javascipt 库，可以在 HTML 标签里嵌入 Python 代码，无需服务端就可以运行 Python 代码。 如何使用 PyScriptPyScript 使用以下三个主要组件在 html 中编写 Python： py-env 定义了运行 Python 代码所需的包。py-script 是在网页中编写 Python 代码的地方。py-repl 创建一个 REPL（读取-评估-打印循环）组件，用于评估用户输入的代码并显示结果。 时间相关1234from datetime import datetime #导入datetime模块中的datetime类# 将时间戳转换为有用的时间格式。time = datetime.fromtimestamp(\"传入时间戳\") 程序运行时间 1234567import timestart_time = time.time()for item in b_tuple: aa = b_tuple[20000]end_time = time.time()print(\"Lookup time for TUPLE: \", end_time - start_time) random库1234567891011121314import randomprint( random.randint(1,10) ) # 产生 1 到 10 的一个整数型随机数 print( random.randrange(1,100,2) ) # 生成从1到100的间隔为2的随机整数print( random.random() ) # 产生 0 到 1 之间的随机浮点数print( random.uniform(1.1,5.4) ) # 产生 1.1 到 5.4 之间的随机浮点数，区间可以不是整数print( random.choice('tomorrow') ) # 从序列中随机选取一个元素random.shuffle(list) #将一个列表内的元素打乱顺序# 多个字符中选取指定数量的字符组成新字符串：''.join(random.sample(['z','y','x','w','v','u','t','s','r','q','p','o','f','e','d','c','b','a'], 5)) random.shuffle([1,3,5,6,7]) # 将序列a中的元素顺序打乱 文件操作文本文件：存储的是普通“字符”文本，默认为unicode字符集，可以使用记本事程序打开 二进制文件：把数据内容用“字节”进行存储，无法用记事本打开，必须使用专用的软件打开，举例：mp3音频文件，jpg图片。doc文档等open(name[, mode[, buffering]])参数： name : 一个包含了你要访问的文件名称的字符串值。 mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 打开模式 描述 r: 只读。这是默认模式。文件不存在将报错 r+: 用于读写。文件指针将会放在文件的开头。 w: 只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |w+: | 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。||wb+:|以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。||a: | 追加写入内容。如果该文件已存在，文件指针将会放在文件的结尾。新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。||a+: | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。| |wb: | 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。||ab+:|以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。||rb: |以二进制格式打开一个文件用于只读,默认模式。||ab: | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。||rb+:|以二进制格式打开一个文件用于读写| 要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可以二进制的形式读取，禁用encoding编码格式；读取时，不知道读多少 with openwth语句可以自动管理上下文资源，不论什么原因跳出with，都能确保文件正确的关闭，以此来达到释放资源的目的 read()会一次性读取文件的全部内容，如果文件有20G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。 如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便： file.write(str) 将字符串写入文件file.writelines(strings) 将字符串序列写入文件 12345with open('Hi.text', 'w') as f: f.write(\"Hello, there\")# with file.open(encoding='utf-8') as f: 文件路径glob.glob同时返回所有匹配的文件路径列表。 1234567import glob#获取指定目录下的所有图片print (glob.glob(r\"/home/qiaoyunhao/*/*.png\"),\"\\n\")#加上r让字符串不转义#获取上级目录的所有.py文件print (glob.glob(r'../*.py')) #相对路径 glob.iglob获取一个可编历对象，使用它可以逐个获取匹配的文件路径名。 shutil 模块(拷贝、删除、移动、压缩和解压)shutil可以简单地理解为sh + util，shell工具的意思。shutil模块是对os模块的补充，主要针对文件的拷贝、删除、移动、压缩和解压操作。 1import shutil 拷贝文件shutil会自动识别拷贝的到底是文件还是文件夹, 如果存在同名的文件将会自动进行覆盖。 shutil.copy($file_path, $dir_path) 移动或重命名文件，但如果路径下已有重名的文件，将报错！1234import shutil shutil.move(r'.\\practice.txt', r'.\\文件夹1/') # 移动到另外一个文件夹中shutil.move(r'.\\practice.txt', r'.\\文件夹1/new.txt') #移动并重命名 拷贝文件夹/删除文件夹shutil.copytree($file_path, $dir_path) # 拷贝所有文件到新的文件夹下，保持原有的文件结构。shutil.rmtree($dir_path) # 删除此路径的文件夹 生成压缩文件:shutil.make_archive(base_name, ‘gztar’, root_dir, [base_dir) base_name : 创建的目标文件名，包括路径，减去任何特定格式的扩展。 format : 压缩包格式。”zip”, “tar”, “bztar”或”gztar”中的一个。 root_dir : 需要打包的文件夹路径。打包完成时存储在上一级目录。 base_dir : 使用后会将base_dir作为路径，解压后有个有层级的文件夹，而仅非只有单独的打包内容。 解压文件:shutil.unpack_archive(filename[, extract_dir[, format]]) filename是压缩文档的完整路径 extract_dir是解压缩路径，默认为当前目录。 format是压缩格式。默认使用文件后缀名代码的压缩格式。”zip”, “tar”, “bztar”或”gztar”中的一个。 pathlib模块多平台使用对于多层文件夹的读取，用os模块只能一层一层读取出文件，要写多个for循环，效率不高，这时我们可以用 Path.glob(**/*) 大法， 12345678910111213141516171819from pathlib import Pathfrom datetime import datetime #导入datetime模块中的datetime类p = Path('E:\\github\\python\\自动化\\打开所有网址.py') #实例化Path对象(可传入绝对路径，当前目录下文件名)print(f\"文件名:{p.name}\") print(f\"文件完整路径:{p.resolve() }\") print(f\"文件后缀:{p.suffix}\") print(f\"文件前缀:{p.stem}\") print(\"-------------------------\")print(p.stat()) # 获取文件详细信息print(p.stat().st_size) # 文件的字节大小print(p.stat().st_ctime) # 文件创建时间戳print(p.stat().st_mtime) # 上次修改文件的时间戳creat_time = datetime.fromtimestamp(p.stat().st_ctime)st_mtime = datetime.fromtimestamp(p.stat().st_mtime)print(f'该文件创建时间：{creat_time}')print(f'上次修改该文件的时间：{st_mtime}') 12345678910111213141516171819from pathlib import Pathp = Path('E:\\github\\python\\自动化\\整理文件.ipynb') #实例化Path对象(可传入绝对路径，当前目录下文件名)p1 = Path .cwd()print(f\"上级文件夹路径:{p.parent}\") print(p.parts) # 将路径通过分隔符分割成一个元组print(\"-------------------------\")# 获取指定文件夹下所有文件和文件夹路径for i in p1.iterdir(): print(i)print(\"-------------------------\")# 返回一个iterable 包含所有父目录for i in p.parents: print(i)print(\"-------------------------\") # 获取该文件目录下所有.py文件路径file_name = p1.glob('**/*.py')for i in file_name: print(i) os库./res是head1.jpg是jpg 1. os库基本介绍用于访问操作系统相关功能 2. os库之路径操作12345678910111213141516171819import os# 如果文件不存在，创建文件if not os.path.exists(folder_path): os.mkdir(folder_path)os.path.isdir() #判断是否为目录os.path.join('annotations', 'xmls') #按照路径的方式拼接字符串os.rename(\"要修改的目录名\", \"修改后的目录名\") #重命名文件或目录，两个参数都要传入路径path =./ res / 1.jpgos.path.split(path) # 将路径划分为head和tail两部分并存为元组 ('./res', '1.jpg')basename = os.path.basename(path) # 获取路径的tail部分 1.jpgname = basename.split('.')[0] #切割出文件名 1 os.listdir(path)12import osos.listdir('.') #返回指定路径下所有文件名的列表。 os.walk遍历文件夹后产生三个参数：当前文件夹路径包含文件夹名称[列表形式]包含文件名称[列表形式] 123456789import os for dirpath, dirnames, filenames in os.walk(r'C:\\\\Program Files (x86)'): print(f'打开文件夹{dirpath}') # 当前文件夹路径 if dirnames: print(dirnames) # 包含文件夹名称[列表形式] if filenames: print(filenames) # 包含文件名称[列表形式] print('-' * 10) os.scandir12345678import ospath = '.'for file in os.scandir(path): print(f\"获取路径下文件名：{file.name}\") print(f\"获取路径下文件路径：{file.path}\\n\") 3. os库之进程管理4. os库之环境参数web自动化selenium安装webdriver各大浏览器webdriver地址可参见：https://docs.seleniumhq.org/download/Firefox：https://github.com/mozilla/geckodriver/releases/Chrome：http://chromedriver.storage.googleapis.com/index.htmlwebdriver安装路径Win：复制webdriver到Python安装目录下Mac：复制webdriver到/usr/local/bin目录下 定位页面元素123456789101112from selenium import webdriverfrom selenium.webdriver.common.by import By#定位一个元素ele = driver.find_element(By.XPATH,'')#表示定位一组元素(元素相同时使用)lis = driver.find_elements(By.XPATH,'')if len(lis)&gt;0: lis[0].click()else： print('没有元素') id 定位name 定位class 定位link定位find_element_by_link_text()此种方法是专门用来定位文本链接的， partial_link定位：find_element_by_partial_link_text() 有时候一个超链接的文本很长很长，我们如果全部输入，既麻烦，又显得代码很不美观，这时候我们就可以只截取一部分字符串，用这种方法模糊匹配了。 xpathxpath定位：find_element_by_xpath() 前面介绍的几种定位方法都是在理想状态下，有一定使用范围的，那就是：在当前页面中，每个元素都有一个唯一的id或name或class或超链接文本的属性，那么我们就可以通过这个唯一的属性值来定位他们。 但是在实际工作中并非有这么美好，有时候我们要定位的元素并没有id,name,class属性，或者多个元素的这些属性值都相同，又或者刷新页面，这些属性值都会变化。那么这个时候我们就只能通过xpath或者CSS来定位了。 xpath 是一种在 XML 文档中定位元素的语言，它拥有多种定位方式 123456789101112&lt;html&gt; &lt;head&gt;...&lt;head/&gt; &lt;body&gt; &lt;div id=\"csdn-toolbar\"&gt; &lt;div class=\"toolbar-inside\"&gt; &lt;div class=\"toolbar-container\"&gt; &lt;div class=\"toolbar-container-left\"&gt;...&lt;/div&gt; &lt;div class=\"toolbar-container-middle\"&gt; &lt;div class=\"toolbar-search onlySearch\"&gt; &lt;div class=\"toolbar-search-container\"&gt; &lt;input id=\"toolbar-search-input\" autocomplete=\"off\" type=\"text\" value=\"\" placeholder=\"C++难在哪里？\"&gt; 根据上面的标签需要定位 最后一行 input 标签，以下列出了四种方式，xpath 定位的方式多样并不唯一，使用时根据情况进行解析即可。 123456789# 绝对路径（层级关系）定位 （绝对路径以/开头）driver.find_element_by_xpath( \"/html/body/div/div/div/div[2]/div/div/input[1]\")# 利用元素属性定位 （相对路径以//开头）driver.find_element_by_xpath(\"//*[@id='toolbar-search-input']\"))# 层级+元素属性定位driver.find_element_by_xpath( \"//div[@id='csdn-toolbar']/div/div/div[2]/div/div/input[1]\")# 逻辑运算符定位driver.find_element_by_xpath(\"//*[@id='toolbar-search-input' and @autocomplete='off']\") 1.相对路径+索引先定位要找的元素，再找它唯一的父标签2.相对路径+属性3.相对路径+通配符定位4.相对路径+部分属性值5.相对路径+文本 css 定位link 定位partial_link 定位 常用操作下拉框的处理12345&lt;!--select标签--&gt; &lt;select name=\"city\" size=\"5\" multiple=\"multiple\"&gt; &lt;option value=\"1\" tabindex=\"1\"&gt;北京&lt;/option&gt; &lt;option value=\"2\" tabindex=\"2\" selected=\"selected\"&gt;河南&lt;/option&gt; 1234567from selenium.webdriver.support.select import Selectele = driver.find_element_by_name(\"city\")#创建Select类对象sel = Select(ele)sel.select_by_value(\"3\") select类中的函数列表options 返回select元素所有的optionsall_selected_options 返回select元素中所有已选中的选项first_selected_option 返回select元素中选中的第一个选项select_by_index(index) 通过索引定位，index索引是从“0”开始select_by_value(value) 通过value属性值定位select_by_visible_text(text)t 通过文本值定位，visible_text是在option标签中间的值，即显示在下拉框的值；deselect_all() 取消全部的已选择项deselect_by_index(index) 取消已选中的索引项deselect_by_value(value) 取消已选中的value值deselect_by_visible_text(text) 取消已选中的文本值 文件上传定位到元素后用.send_keys(r’文件路径’) 1driver.find_element_by_name(\"city\").send_keys(r'文件路径') 处理弹窗alert(只有确定)，confirm(有确认和取消)，prompt(有确认取消还可以输入值) 12345678910111213#alert是一个属性#创建一个alert对象ale = driver.switch_to.alert#点击确定ale.accept()#点击取消ale.dismiss() #获得文本ale.text()#输入值ale.send_keys() 设计模式（封装）pom(page object model)页面对象模式 分三层1.基础层：base 主要放seleni原生的方法2.页面对象层：主要用于放页面的元素和页面的动作3.测试用例层:testcase存放测试用例，测试数据 页面对象层调用基础层的方法，测试用例层调用页面对象的方法 UIautomationhttps://blog.csdn.net/MicalChen/article/details/120296341最新版uiautomation2.0目前只支持Python 3版本，依赖comtypes和typing这两个包，但不要使用3.7.6和3.8.1这两个版本，comtypes在这两个版本中不能正常工作。 UIautomation环境搭建界面元素定位常用的控件类控件类支持的参数常用方法窗口相关方法程序关闭与打开相关方法组合框相关方法鼠标事件键盘事件延时等待滚动条日志粘贴板控件判断相关方法控件矩形坐标截图方法 # pyautogui是一个非常强大的库，可以操作鼠标和键盘 基于坐标操作 1234567891011# https://mp.weixin.qq.com/s/6OJYwnzC1fHyOj_rBFIGxg# https://zhuanlan.zhihu.com/p/302592540import pyautoguifrom datetime import datetimefrom apscheduler.schedulers.blocking import BlockingScheduler # 阻塞当前进程的调度器# blocking类型调度器会阻塞当前进程，若你想要后台运行的调度器，可以使用以下代码：# from apscheduler.schedulers.background import BackgroundSchedulerpyautogui.PAUSE = 1 # 设置每一步操作的间隔（秒），可防止操作太快print(pyautogui.position()) # 打印坐标，Point(x=148, y=879)icon_position = pyautogui.position() # Point(x=148, y=879) Tkinter库(内置GUI库)import tkinter as tk 窗口的创建和设置1234567891011import tkinter as tkroot=tk.Tk() #生成主窗口root.geometry('250x250') #改变窗体大小（‘宽x高’），注意是x不是*root.geometry('+450+450') #改变窗体位置（‘+横坐标+纵坐标’）root.title('标题') #修改框体的名字root.mainloop() #显示主窗口root.resizable(0, 0) 将窗口大小设置为不可变root.resizable(False, False) 将窗口大小设置为不可变 常用控件控件的共同属性height 指定控件的高度，单位为像素(文本控件的单位为行，不是像素) width 指定控件的宽度，单位为像素(文本控件的单位为行，不是像素) bg (background) 控件的背景颜色 fg (foreground) 前景颜色(字体颜色) cursor 鼠标移动到框架时，光标的形状(参数值：arrow[默认箭头], circle, cross[十字], plus，watch[圈圈转动]等） justify 显示多行文本的时候,设置不同行之间的对齐方式（参数值：LEFT, RIGHT, CENTER） bd 加粗（默认 2 像素） 无 padx 设置按钮文本与按钮边框x轴方向的距离 pady 设置按钮文本与按钮边框y轴方向的距离 state 设置按钮状态,参数值：NORMAL、ACTIVE、 DISABLED。默认 NORMAL anchor 控制按钮文本的位置(参数值：S,W,E,N,SE,SW,NW,NE,CENTER,默认为CENTER) image 显示图像与PhotoImage 一起使用，图片只能为gif格式 relief 三维效果 （参数值：FLAT、SUNKEN、RAISED、GROOVE、RIDGE。默认为 FLAT） bitmap 位图 anchor 文本起始位置 CENTER(默认)，E,S,W,N,NE,SE,SW,NW bitmap 黑白二值图标 网上查找 cursor 鼠标悬停光标 网上查找 font 字体 无 Label标签用来显示文字或图片tkinter.Label(text=”文字”) Button按钮控件模块类似标签,但提供额外的功能,例如鼠标掠过、按下、释放以及键盘操作、事件Button ( master, option=value, … )参数 master: 按钮的父容器。 options: 可选项，即该按钮的可设置的属性。 command :按钮关联的函数，当按钮被点击时，执行该函数 1234import tkinterbutton=Button(root,command=绑定的函数,text=\"转换温度\")button.pack() Entry单行文字域参数： show 1. 设置输入框用指定字符显示文本的内容 例如： “*”，单行文字域用来收集键盘输入 1234567891011121314root=tk.Tk()entry=Entry(root) #创建Entry对象entry.pack() #显示 entry.get() #获取当前输入框的文本entry.config() #修改相应属性def eventhandler(event): entry.focus() #(聚焦)文本框entry=Entry(root,bd=4)entry.bind_all('&lt;Control-f&gt;', eventhandler ) # 绑定快捷键Ctrl-f texts属性绑定变量在Button，Lable，Entry 这3个组件，有一个属性：textvariable 这个属性绑定一个变量后，它们的Text就会以变量方法来呈现。 123var.set('初始文本') # 设置变量 la1=Label(root,textvariable=var) # 将变量var跟文本绑定在一起 Text多行文字区域可用来收集(或显示)用户输入的文字 Listbox列表框：一个选项列表,用户可以从中选择 Menu菜单点下菜单按钮后弹出的一个选项列表,用户可以从中选择菜单栏(menu bar)、菜单(menu)、菜单项(menu item)菜单属性tearoff的作用就是可以将每个菜单分离出去，单独形成一个子窗口。默认是打开的状态1，通常将tearoff设置为0。activebackground设置活动背景色。当鼠标移动到菜单选项上时，该菜单项的背景色。activeforeground设置活动前景色。当鼠标移动到菜单选项上时，该菜单项文字显示的颜色。菜单方法add_command() 通常用于 给菜单添加普通的菜单项。add_cascade() 通常用于 给menu对象添加一个瀑布菜单，点击menu对象就会弹出多个菜单项。add_radiobutton() 给菜单添加radiobutton菜单项。add_checkbutton() 给菜单添加checkbutton菜单项add_separator() 给菜单添加分割线add() 给菜单添加指定类型的菜单项，前面5中添加菜单项的方法其实都是在add函数的基础上做一个封装。type() 查看菜单项的类型。通常菜单项的类型有”cascade”, “checkbutton”, “command”, “radiobutton”, “separator”, “tearoff”。 Canvas画布控件模块create_polygon(x0, y0, x1, y1, … , xn, yn, options) 绘制一个至少三个点的多边形 Frame 框架 包含其他组件的纯容器Checkbutton 选择按钮 一组方框,可以选择其中的任意个Menubutton 菜单按钮 用来包含菜单的组件(有下拉式、层叠式等等)Message 消息框 类似于标签,但可以显示多行文本Radiobutton 单选按钮 一组按钮,其中只有一个可被“按下” (类似 HTML 中的 radio)Scale 进度条 线性“滑块”组件,可设定起始值和结束值,会显示当前位置的精确值Scrollbar 滚动条 对其支持的组件(文本域、画布、列表框、文本框)提供滚动功能Toplevel 顶级 类似框架,但提供一个独立的窗口容器对话框在tkinter中有三种标准对话框：messageboxfiledialogcolorchooser 弹窗messageboxfrom tkinter import messagebox 消息提示框 messagebox.showinfo(‘弹窗名称’,’弹窗内容 ‘)消息警告框 messagebox.showwarning(‘弹窗名称’,’弹窗内容 ‘)错误消息框 messagebox.showerror(‘弹窗名称’,’弹窗内容 ’ )对话框 messagebox.askokcancel(‘弹窗名称’, ‘弹窗内容 ‘) 确定/取消，返回值true/false对话框 messagebox.askquestion (‘弹窗名称’, ‘弹窗内容 ‘) 是/否，返回值yes/no对话框 messagebox.askyesno (‘弹窗名称’,’弹窗内容 ‘) 是/否， 返回值true/false对话框 messagebox.askretrycancel (‘弹窗名称’,’弹窗内容 ‘) 重试/取消，返回值true/false filedialog模块如果你的应用程序会需要到打开文件、保存文件、选择目录等关于文件的操作，那么就必须要用到 filedialog 。 askopenfilename 打开文件、asksaveasfilename 保存文件 对话输入框Python的tkinter模块中，有一个子模块simpledialog.py，这个子模块里有这样三个函数：askinteger，askfloat，askstring。他们通过GUI窗口的方式，让用户输入一个整数，浮点数，或者字符串，并且自带输入合法性检测！使用非常方便。 from tkinter.simpledialog import askinteger,askfloat,askstring PhotoImage图片对象为了解决PhotoImage不支持jpg等格式问题，可以使用Image+ImageTk实现多种格式图片的载入。 123456from PIL import Image, ImageTkimport tkinter as tkimg = Image.open('1.jpg')photo = ImageTk.PhotoImage(img)tk.Label(paned, image=photo).grid(row=0, column=0) 控件几何状态管理方法pack和grid请参考：https://www.jianshu.com/p/91844c5bca78 pack()是一种简单的布局方法，如果不加参数的默认方式，将按布局语句的先后，以最小占用空间的方式自上而下地排列控件实例，并且保持控件本身的最小尺寸。 使用pack()方法可设置 fill、side 等属性参数。其中，参数fill 可取值：fill=X,fill=Y或fill=BOTH，分别表示允许控件向水平方向、垂直方向或二维伸展填充未被占用控件。参数 side 可取值：side=TOP(默认)，side=LEFT,side=RIGHT,side=BOTTOM,分别表示本控件实例的布局相对于下一个控件实例的方位。 Button(root,text=’A’).pack(side=LEFT,expand=YES,fill=Y) grid()是基于网格的布局。先虚拟一个二维表格，再在该表格中布局控件实例。由于在虚拟表格的单元中所布局的控件实例大小不一，单元格也没有固定或均一的大小，因此其仅用于布局的定位。pack()方法与grid()方法不能混合使用。grid()方法常用布局参数如下： column: 控件实例的起始列，最左边为第0列。columnspan: 控件实例所跨越的列数，默认为1列。ipadx,ipady: 控件实例所呈现区域内部的像素数，用来设置控件实例的大小。padx,pady: 控件实例所占据空间像素数，用来设置实例所在单元格的大小。row: 控件实例的起始行，最上面为第0行。rowspan: 控件实例的起始行数，默认为1行。 place()绝对布局当使用 Place 布局管理容器中的组件时，需要设置组件的 x、y 或 relx、rely 选项，Tkinter 容器内的坐标系统的原点 (0,0) 在左上角，其中 X 轴向右延伸，Y 轴向下延伸控件对象.place() x,y：控件实例在根窗体中水平和垂直方向上的其实位置（单位为像素）。注意，根窗体左上角为0,0,水平向右，垂直向下为正方向。 relx,rely：控件实例在根窗体中水平和垂直方向上起始布局的相对位置。即相对于根窗体宽和高的比例位置，取值在0.0~1.0之间。 height,width：控件实例本身的高度和宽度（单位为像素）。 relheight,relwidth：控件实例相对于根窗体的高度和宽度比例，取值在0.0~1.0之间。 利用place()方法配合relx,rely和relheight,relwidth参数所得的到的界面可自适应根窗体尺寸的大小。place()方法与grid()方法可以混合使用。 图像处理库PIL，cv2，plt的使用与区别 建议使用opencv的库来进行图像处理的基本操作，数据格式为numpy，可以直接进行numpy的处理； 进行折线图这类图绘制的时候，一般使用matplotlib库。 Opencv默认为 BGR顺序，而其他软件（PIL、scopy.misc）一般使用RGB。 1234567891011121314151617181920212223242526272829from PIL import Imageimport cv2import matplotlib.pyplot as pltimport numpy as np# 比较三者的打开图片、显示图片、打开图片的类型# ************PIL************PIL_img = Image.open('D:/images/Rimi.jpg')print(type(PIL_img)) # &lt;class 'PIL.JpegImagePlugin.JpegImageFile'&gt;print(PIL_img.size) # (1152, 720) (w,h)print(np.array(PIL_img).shape) # (720, 1152, 3) (h,w,c)PIL_img.show()# ************cv2************cv2_img = cv2.imread('D:/images/Rimi.jpg')print(type(cv2_img)) # &lt;class 'numpy.ndarray'&gt;print(cv2_img.shape) # (720, 1152, 3) (h,w,c)cv2.imshow('cv2', cv2_img)# cv2.waitKey()# ************plt***********plt_img = plt.imread('D:/images/Rimi.jpg')print(type(plt_img)) # &lt;class 'numpy.ndarray'&gt;print(plt_img.shape) # (720, 1152, 3) (h,w,c)plt.imshow(plt_img) # PIL_img也可以显示plt.show() OpenCVOpenCV中已经包含如下应用领域功能：二维和三维特征工具箱、运动估算、人脸识别系统、姿势识别、人机交互、移动机器人、运动理解、对象鉴别、分割与识别、立体视觉、运动跟踪、增强现实（AR技术）。基于上述功能实现需要，OpenCV中还包括以下基于统计学机器学习库：Boosting算法、Decision Tree(决策树)学习、Gradient Boosting算法、EM算法(期望最大化)、KNN算法、朴素贝叶斯分类、人工神经网络、随机森林、支掌向量机。 cv2默认为 BGR顺序，而其他（PIL、scopy.misc）一般使用RGB 导入的时候采用 import cv2。 cv2.imread(filepath,flags)加载图片 filepath：要读入图片的完整路径，路径中不要有中文名flags：读入图片的标志 cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道 cv2.IMREAD_GRAYSCALE：读入灰度图片 cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道 cv2.cvtColor()颜色空间转换：其实就是数学运算 1234img = cv2.imread() 读取图片，默认是BGR通道img2 = cv2.cvtColor(img,cv2.COLOR_BGR2RGB) #BGR通道转为RGB通道#img2 = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY) #灰度化：彩色图像转为灰度图像#img3 = cv2.cvtColor(img,cv2.COLOR_GRAY2RGB) #彩色化：灰度图像转为彩色图像 cv2.COLOR_X2Y，其中X,Y = RGB, BGR, GRAY, HSV, YCrCb, XYZ, Lab, Luv, HLS cv2.imshow(wname,img)#显示图像 第一个参数是显示图像的窗口的名字第二个参数是要显示的图像（imread读入的图像），窗口大小自动调整为图片大小cv2.imshow(‘image’,img) cv2.waitKey(0) #等待键盘输入，单位为毫秒，即等待指定的毫秒数看是否有键盘输入，若在等待时间内按下任意键则返回按键的ASCII码，程序继续运行。 #若没有按下任何键，超时后返回-1。参数为0表示无限等待。不调用waitKey的话，窗口会一闪而逝，看不到显示的图片。 cv2.destroyAllWindow() #销毁所有窗口 cv2.destroyWindow(wname) #销毁指定窗口 cv2.imwrite(file，img，num) #保存一张图像 第一个参数是要保存的文件名第二个参数是要保存的图像。可选的第三个参数，它针对特定的格式：对于JPEG，其表示的是图像的质量，用0 - 100的整数表示，默认95。第三个参数表示的是压缩级别。默认为3.img.copy() #图像复制 cv2.resize(image, image2,dsize) #图像缩放：(输入原始图像，输出新图像，图像的大小)cv2.flip(img,flipcode) #图像翻转，flipcode控制翻转效果。 flipcode = 0：沿x轴翻转；flipcode &gt; 0：沿y轴翻转；flipcode &lt; 0：x,y轴同时翻转cv2.warpAffine(img, M, (400, 600)) #图像仿射变换 ：平移；裁剪、剪切、旋转、仿射变换，M、M_crop、M_shear、M_rotate cv2.putText(img,’text’,(50,150) #图像添加文字：(照片，添加的文字，左上角坐标，字体，字体大小，颜色，字体粗细) cv2.putText(image, caption, (b[0], b[1] - 10), cv2.FONT_HERSHEY_PLAIN, 1, (255, 0, 0), 1) cv2.putText(I,’there 0 error(s):’,(50,150),cv2.FONT_HERSHEY_COMPLEX,6,(0,0,255),25) cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2) #画出矩行：img原图、(x，y)是矩阵的左上点坐标、(x+w，y+h)是矩阵的右下点坐标、(0,255,0)是画线对应的rgb颜色、2是所画的线的宽度。 cv2.boundingRect(img) #返回图像的四值属性：img是一个二值图，即是它的参数； 返回四个值，分别是x，y，w，h； x，y是矩阵左上点的坐标，w，h是矩阵的宽和高。 固定阈值分隔PIL库PIL（Python Imaging Library）是Python常用的图像处理库，而Pillow是PIL的一个友好Fork，提供了了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。相比opencv更为轻巧。Image模块是在Python PIL图像处理中常见的模块，对图像进行基础操作的功能基本都包含于此模块内。如open、save、show等功能。 https://www.osgeo.cn/pillow/reference/index.html 使用#安装pillowpip install pillow from PIL import ImageImage模块 是 PIL 库中代表一个图像的类（对象） ImageDraw 模块ImageDraw.text()ImageDraw.text(xy, text, fill=None, font=None, anchor=None, spacing=4, align=’left’, direction=None, features=None, language=None, stroke_width=0, stroke_fill=None, embedded_color=False)在给定位置绘制字符串。 xy -- 文本的锚点坐标。 text -- 要绘制的字符串。如果它包含任何换行符，则文本将传递到 multiline_text() 。 fill -- 用于文本的颜色。 Matplotlib库Matplotlib是一个Python 2D绘图库，它可以在不同的平台上以各种硬拷贝格式和交互环境生成发布质量数据。Matplotlib可以用于Python脚本、Python和IPython shell、Jupyter notebook、web应用服务器和四个图形用户界面工具包。对于简单的绘图，pyplot模块提供了一个类似于matlab的接口，特别是与IPython结合使用时。对于power用户，您可以通过面向对象的界面或通过MATLAB用户熟悉的一组函数来完全控制线样式、字体属性、轴属性等. matplotlib.pylot是绘制各类可视化图形的命令字库 更多学习，可参考Matplotlib中文网：https://www.matplotlib.org.cn #安装pip install matplotlib#导库import matplotlib.pyplot as plt pyplot模块方法1.plt.imread(fname， format=None)将图像从文件读取到数组中。返回一个numpy.array fname: 要读取的图像文件：文件名、URL 或以读取二进制模式打开的类似文件的对象。 不推荐传递 URL。请打开URL进行阅读并将结果传递给Pillow format: 用于读取数据而假定的图像文件格式。如果格式设置为”png”，如果 fname 是扩展名为”.png”的路径或打开的文件，或者如果它是 URL，则图像将作为 PNG 文件加载。在所有其他情况下，格式将被忽略，PIL 会自动检测格式 2.plt.imshow(numpy.array)将数据显示为图像3.plt.show()显示所有打开的图表 NumPy数学矩阵知识https://paul.pub/the-matrix/#id-%E6%A0%87%E9%87%8F%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BC%A0%E9%87%8F 矩阵算术加减法矩阵的加减法只在两个矩阵具有相同大小时才有意义。 两个矩阵的加（减）法通过对应元素相加（减）得到 标量乘法设A为一矩阵，b为一标量，则bA为将A中的每一个元素乘以b而构成的一个矩阵 转置矩阵的转置是以对角线为轴的镜像。 这条从左上角到右下角的对角线被称之为主对角线 矩阵乘法第一个矩阵的列要等于第二个矩阵的行，则两矩阵可以相乘。一个m∗n的的A矩阵，和一个n∗p的B矩阵相乘，将得到一个m∗p的矩阵C 逆逆(Inverse)设A为n阶方阵，如果存在一个n阶方阵B，使得AB=BA=InAB=BA=In 则称A为可逆矩阵，B为A的逆阵，记作 B=A−1B=A−1(A−1)−1=A(A−1)−1=A(kA)−1=1kA−1(k≠0)(kA)−1=1kA−1(k≠0)A、B均是同阶可逆矩阵，则(AB)−1=B−1A−1A、B均是同阶可逆矩阵，则(AB)−1=B−1A−1(A−1)T=(AT)−1(A−1)T=(AT)−1 求逆矩阵一般有三种方法。1、方阵的逆矩阵等于方阵的伴随矩阵与方阵对应的行列式的值的倒数的积； 即A^-1=A*/(|A|). 只有当|A|≠0时，方阵A才可逆。 这种方法并不简便。 2、利用初等变换求逆矩阵； 一般是将矩阵(A,E)化为(E,A^-1)的形式；从而得到A逆矩阵； 创建数组为了创建一个2D（二维）数组，我们传递一个列表的列表（或者是一个序列的序列）给array()函数。如果我们想要一个3D（三维）数组，我们就要传递一个列表的列表的列表，如果是一个4D（四维）数组，那就是列表的列表的列表的列表，以此类推。 多维数组切片通过对每个以逗号分隔的维度执行单独的切片，你可以对多维数组进行切片。因此，对于2D数组，我们的第一片定义了行的切片，第二片定义了列的切片。 函数np.zeros():可以创建指定长度或者形状的全0数组 ones():可以创建指定长度或者形状的全1数组 empty():创建一个数组，其初始内容是随机的,取决于内存的状态 为了创建数字组成的数组，NumPy提供了一个类似于range的函数，该函数返回数组而不是列表。array = np.arange( 10, 31,5 ) -&gt;array([10, 15, 20, 25, 30]) 数组属性array = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]]) #数组维度print(array.ndim) #数组形状print(array.shape) #数组元素个数print(array.size) #数组元素类型print(array.dtype) 数组的计算数组很重要，因为它可以使我们不用编写循环即可对数据执行批量运算。这通常叫做矢量化 基础运算对应位置的数相运算 12345678910arr1 = np.array([[1,2,3],[4,5,6]])arr2 = np.ones([2,3],dtype=np.int64)print(arr1 + arr2)print(arr1 - arr2)print(arr1 * arr2)print(arr1 / arr2)print(arr1 ** 2) print(np.dot(arr3,arr4)) pandaspandas是python第三方库，提供高性能易用数据类型和分析工具。 pandas基于numpy实现，常与numpy和matplotlib一同使用 更多学习，请参考pandas中文网：https://www.pypandas.cn/ SeriesSeries是一种类似于一维数组的对象，它由一维数组（各种numpy数据类型）以及一组与之相关的数据标签（即索引）组成. 可理解为带标签的一维数组，可存储整数、浮点数、字符串、Python 对象等类型的数据。 Seris中可以使用index设置索引列表。 12345678910111213import pandas as pdimport numpy as np#与字典不同的是：Series允许索引重复s = pd.Series(['a','b','c','d','e'],index=[100,200,100,400,500])#Series 可以用字典实例化d = {'b': 1, 'a': 0, 'c': 2}pd.Series(d)#通过Series的values和index属性获取其数组表示形式和索引对象print(s)print(s.values)print(s.index) DataFrameDataFrame是一个表格型的数据结构，类似于Excel或sql表 它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）DataFrame可以进行行索引和列索引，它可以被看做由Series组成的字典（共用同一个索引） 123456789101112#用多维数组字典、列表字典生成 DataFramedata = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'], 'year': [2000, 2001, 2002, 2001, 2002], 'pop': [1.5, 1.7, 3.6, 2.4, 2.9]}frame = pd.DataFrame(data) print(frame)frame2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'], index=['one', 'two', 'three', 'four', 'five'])print(frame2)#列可以通过赋值的方式进行修改,例如，给那个空的“delt”列赋上一个标量值或一组值frame2['debt'] = 16.5print(frame2) 内部库sys通过它可以获取命令行参数，从而实现从程序外部向程序内部传递参数的功能，也可以获取程序路径和当前系统平台等信息。 B. platformC. mathD. time 邮箱SMTP（Simple Mail Transfer Protocol）是简单传输协议，它是一组用于用于由源地址到目的地址的邮件传输规则。 smtplib模块 python中对SMTP进行了简单的封装，可以发送纯文本邮件、HTML邮件以及带附件的邮件。两个核心模块如下： email模块：负责构建邮件smtplib模块：负责发送邮件 二、邮件发送协议介绍什么是POPO3、SMTP和IMAP?服务器地址和端口是什么？ 2.1、POP3 POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离 线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循 POP3协议的接收邮件服务器，用来接收电子邮件的。(与IMAP有什么区别？) 2.2、SMTP SMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。 SMTP 认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。 增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰。 2.3、IMAPIMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留 在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端 软件登录邮箱，看到的邮件以及状态都是一致的。（与POP3有什么区别？） jsonJSON 的本质是字符串。是一种通用的，跨平台的数据交换格式。类似python的字典 json数据类型json 类型转换到 python 的类型对照表：| JSON | Python ||—————|————|| object | dict || array | list,tuple || string | str || number (int) | int, long || number (real) | float || true，false | True,False || null | None | 12345678import jsonjson.load() #读取json文件,转换为python字典json.loads() #将json字符串转换为python对象如字典json.dumps()# 将python数据转换为json字符串","categories":[{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/tags/python/"}]},{"title":"python-pandas","slug":"python-pandas","date":"2022-03-22T13:29:33.000Z","updated":"2022-03-22T13:29:33.000Z","comments":true,"path":"2022/03226351.html","link":"","permalink":"https://wenkex.gitee.io/2022/03226351.html","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/categories/python/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"https://wenkex.gitee.io/tags/pandas/"}]},{"title":"python-NumPy","slug":"python-NumPy","date":"2022-03-22T06:42:45.000Z","updated":"2022-03-22T06:42:45.000Z","comments":true,"path":"2022/032261592.html","link":"","permalink":"https://wenkex.gitee.io/2022/032261592.html","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/categories/python/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://wenkex.gitee.io/tags/numpy/"}]},{"title":"python爬虫学习","slug":"python爬虫学习","date":"2022-03-16T23:56:59.000Z","updated":"2022-03-16T23:56:59.000Z","comments":true,"path":"2022/031717083.html","link":"","permalink":"https://wenkex.gitee.io/2022/031717083.html","excerpt":"","text":"网络数据采集概述爬虫（crawler）也经常被称为网络蜘蛛（spider），是按照一定的规则自动浏览网站并获取所需信息的机器人程序（自动化脚本代码），被广泛的应用于互联网搜索引擎和数据采集。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接，网络爬虫正是通过网页中的超链接信息，不断获得网络上其它页面的地址，然后持续的进行数据采集。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为爬虫或者网络蜘蛛。 爬虫的应用领域爬虫的应用领域其实非常广泛，下面我们列举了其中的一部分 搜索引擎 新闻聚合 社交应用 舆情监控 行业数据爬虫合法性探讨 经常听人说起“爬虫写得好，牢饭吃到饱”，那么编程爬虫程序是否违法呢？关于这个问题，我们可以从以下几个角度进行解读。 网络爬虫这个领域目前还属于拓荒阶段，虽然互联网世界已经通过自己的游戏规则建立起了一定的道德规范，即 Robots 协议（全称是“网络爬虫排除标准”），但法律部分还在建立和完善中，也就是说，现在这个领域暂时还是灰色地带。 “法不禁止即为许可”，如果爬虫就像浏览器一样获取的是前端显示的数据（网页上的公开信息）而不是网站后台的私密敏感信息，就不太担心法律法规的约束，因为目前大数据产业链的发展速度远远超过了法律的完善程度。 在爬取网站的时候，需要限制自己的爬虫遵守 Robots 协议，同时控制网络爬虫程序的抓取数据的速度；在使用数据的时候，必须要尊重网站的知识产权（从Web 2.0时代开始，虽然Web上的数据很多都是由用户提供的，但是网站平台是投入了运营成本的，当用户在注册和发布内容时，平台通常就已经获得了对数据的所有权、使用权和分发权）。如果违反了这些规定，在打官司的时候败诉几率相当高。 适当的隐匿自己的身份在编写爬虫程序时必要的，而且最好不要被对方举证你的爬虫有破坏别人动产（例如服务器）的行为。 不要在公网（如代码托管平台）上去开源或者展示你的爬虫代码，这些行为通常会给自己带来不必要的麻烦。 相关工具下面我们先介绍一些开发爬虫程序的辅助工具，这些工具相信能帮助你事半功倍。 Chrome Developer Tools：谷歌浏览器内置的开发者工具。该工具最常用的几个功能模块是： 元素（ELements）：用于查看或修改 HTML 元素的属性、CSS 属性、监听事件等。CSS 可以即时修改，即时显示，大大方便了开发者调试页面。 控制台（Console）：用于执行一次性代码，查看 JavaScript 对象，查看调试日志信息或异常信息。控制台其实就是一个执行 JavaScript 代码的交互式环境。 源代码（Sources）：用于查看页面的 HTML 文件源代码、JavaScript 源代码、CSS 源代码，此外最重要的是可以调试 JavaScript 源代码，可以给代码添加断点和单步执行。 网络（Network）：用于 HTTP 请求、HTTP 响应以及与网络连接相关的信息。 应用（Application）：用于查看浏览器本地存储、后台任务等内容，本地存储主要包括Cookie、Local Storage、Session Storage等。 Postman：功能强大的网页调试与 RESTful 请求工具。Postman可以帮助我们模拟请求，非常方便的定制我们的请求以及查看服务器的响应。 HTTPie：命令行HTTP客户端。 安装。 1pip install httpie 使用。 1234567891011121314http --header http --header https://movie.douban.com/HTTP/1.1 200 OKConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html; charset=utf-8Date: Tue, 24 Aug 2021 16:48:00 GMTKeep-Alive: timeout=30Server: daeSet-Cookie: bid=58h4BdKC9lM; Expires=Wed, 24-Aug-22 16:48:00 GMT; Domain=.douban.com; Path=/Strict-Transport-Security: max-age=15552000Transfer-Encoding: chunkedX-Content-Type-Options: nosniffX-DOUBAN-NEWBID: 58h4BdKC9lM builtwith库：识别网站所用技术的工具。 安装。 1pip install builtwith 使用。 123456import sslimport builtwithssl._create_default_https_context = ssl._create_unverified_contextprint(builtwith.parse('http://www.bootcss.com/')) python-whois库：查询网站所有者的工具。 安装。 1pip3 install python-whois 使用。 123import whoisprint(whois.whois('https://www.bootcss.com')) 爬虫的基本工作流程获取网页获取网页源代码 提取信息获取网也源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。 由于网页的结构有一定的规侧，所以还有一些根据网页节点属性、CSS选择器或XPath来提取网顶信息的库，如Beautifu1Soup、pyquery、1xm1等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。 保存数据提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为TXT文本或json文本，也可以保存到数据库，如MySQL和MongoDB等，也可保存至远程服务器，如借助SFTP进行操作等。 代理ip基本原理代理实际上指的就是代理服务器，英文叫作proxy server，它的功能是代理网络用户去取得网络信息。形象地说，它是网络信息的中转站。在我们正常请求一个网站时，是发送了请求给Web服务器，Web服务器把响应传回给我们。如果设置了代理服务器，实际上就是在本机和服务器之间搭建了一个桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发出请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机。这样我们同样可以正常访问网页，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP了，就成功实现了IP伪装，这就是代理的基本原理。 代理的作用突破自身IP访问限制，访问一些平时不能访问的站点。访问一些单位或团体内部资源：比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP，防止自身的IP被封锁。 requests库Python爬虫时，更建议用requests库。因为requests比urllib更为便捷，requests可以直接构造get，post请求并发起，而urllib.request只能先构造get，post请求，再发起。 添加请求头在发起一个 HTTP 请求的时候，会有一个请求头 Request Headers，如果不设置Request Headers 信息，某些网站会发现这不是一个正常的浏览器发起的请求，网站可能会返回异常的结果，导致网页抓取失败。 123456使用 headers 参数来指定请求头headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36',}requests.get(url, headers=headers) Response对象1r = requests.get(url) #返回一个repose对象 Response对象的方法r.text() Response对象的属性1234567891011r.status_code： #HTTP请求的返回状态码，200表示连接成功，404表示失败r.text：# HTTP响应内容的字符串形式，即，url对应的页面内容r.encoding：#从HTTP header中猜测的响应内容编码方式r.apparent_encoding：#从内容中分析出的响应内容编码方式（备选编码方式）r.content： #返回HTTP响应内容的bytes(二进制)，有中文时，用这个r.content.decode('utf-8') #将二进制内容解码json.loads(r.content.decode()) #将json格式转换为字典 抓取二进制数据图片、音频、视频这些文件本质上都是由二进制码组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。 123import requests r = requests.get('https://github.com/favicon.ico')with open('favicon.ico', 'wb') as f: f.write(r.content) 文件上传1234import requestsfiles = {'file': open('favicon.ico', 'rb')} r = requests.post('http://httpbin.org/post', files=files) print(r.text) 下载urllib.request.urlretrieve(url, filename=None, reporthook=None, data=None)参数说明 url：外部或者本地url filename：指定了保存到本地的路径,文件夹必须已有（如果未指定该参数，urllib会生成一个临时文件来保存数据）； reporthook：是一个回调函数，当连接上服务器、以及相应的数据块传输完毕的时候会触发该回调。我们可以利用这个回调函数来显示当前的下载进度。 data：指post到服务器的数据。该方法返回一个包含两个元素的元组(filename, headers)，filename表示保存到本地的路径，header表示服务器的响应头。 获取和设置 Cookies12345678import requests # 获取r = requests.get('http://www.baidu.com') # 先调用 cookies 属性即可成功得到 Cookies，可以发现它是 RequestCookieJar 类型print(r.cookies) # 用 items 方法将其转化为元组组成的列表，遍历输出每一个 Cookie 的名称和值，实现 Cookie 的遍历解析。for key, value in r.cookies.items(): print(key + '=' + value) Session维持在 requests 中，如果直接利用 get 或 post 等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的 Session，相当于你用两个浏览器打开了不同的页面。 设想这样一个场景，第一个请求利用 post 方法登录了某个网站，第二次想获取成功登录后的自己的个人信息，你又用了一次 get 方法去请求个人信息页面。实际上，这相当于打开了两个浏览器，是两个完全不 相关的 Session，能成功获取个人信息吗？当然不能。 有人会问，我在两次请求时设置一样的 Cookies 不就行了？可以，但这样做起来很烦琐，我们有更简单的解决方法。 解决这个问题的主要方法就是维持同一个 Session，相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但我又不想每次设置 Cookies，那该怎么办呢？这时候就有了新的利器 ——Session对象。 利用它，我们可以方便地维护一个 Session，而且不用担心 Cookies 的问题，它会帮我们自动处理好。 编码问题提取html内容Python中解析网页HTML内容的四种方法：BeautifulSouplxml的XPathrequests-html正则表达式 lxml库http://c.biancheng.net/python_spider/lxml.htmllxml 是 Python 的第三方解析库，完全使用 Python 语言编写，它对 Xpath 表达式提供了良好的支持，因此能够使用Xpath 表达式高效地解析 HTML/XML 文档，从中提取想要的内容 123#pip3 install lxml #安装 xpathxpath是一种HTML与XML的查询语言，能在HTML与XML的树状结构中寻找节点 开头是单斜杠就是从文档开头匹配，双斜杠就是任意位置匹配 获取文本//标签一[@属性1=”属性值一”]/标签二[@属性2=”属性值2”]/…/text() 获取属性值//标签一[@属性1=”属性值一”]/标签二[@属性2=”属性值2”]/.../@属性n BeautifulsoupBeautiful Soup 4.4.0 文档一个灵活又方便的HTML解析库，处理高效，支持多种解析器，利用它不使用正则表达式也能抓取网页内容。pip install brautiful4安装解析器Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 lxml .根据操作系统不同,可以选择下列方法来安装lxml: $ apt-get install Python-lxml $ easy_install lxml $ pip install lxml 另一个可供选择的解析器是纯Python实现的 html5lib , html5lib的解析方式与浏览器相同,可以选择下列方法来安装html5lib: $ apt-get install Python-html5lib $ easy_install html5lib $ pip install html5lib BeautifulSoup类的基本元素 1234567891011121314151617181920212223from bs4 import BeautifulSoup# 实例化Beautifulsoup对象，可以传入一段字符串(html字符串)或一个文件句柄(html文件).soup = Beautifulsoup(html,'lxml')'''通过点号操作符，可以直接访问文档中的特定标签这样的方式每次只会返回文档中的第一个标签，对于多个标签，则通过find_all方法返回多个标签构成的列表。'''soup.head.tltle soup.find_all('a')[0]&gt;&gt;&gt; soup.a&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;soup.a['class'] #['sister']soup.a.get('class') #['sister'] 获取a标签的class属性的值soup.a.name 'a'soup.a.string #获取a标签的文本 'Elsie' soup.find()find(name, attrs, recursive, text, **wargs) 只返回第一个匹配到的对象参数： name 标签名 attrs ：属性{‘class’: ‘img’} {“属性名”:”属性值”} text 查找文本 soup.findAll() 12pid = soup.find(attrs={\"id\":\"aa\"})pid = soup.findAll('a',{'class':'sister'})","categories":[{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://wenkex.gitee.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"flask学习笔记","slug":"flask学习笔记","date":"2022-03-15T12:00:45.000Z","updated":"2022-03-15T12:00:45.000Z","comments":true,"path":"2022/031560473.html","link":"","permalink":"https://wenkex.gitee.io/2022/031560473.html","excerpt":"","text":"参考文章https://www.w3cschool.cn/flask/ flask中文文档 https://www.imooc.com/wiki/flasklesson/flaskormoverview.html https://www.w3cschool.cn/flask/flask-kbid3h91.html 知了传课 步骤https://blog.csdn.net/asd529735325/article/details/103011940 web前置MVC模式M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式model：模型view：视图controler:控制器 WSGI(Python Web Server Gateway Interface)指定了web服务器和Python web应用或web框架之间的标准接口，以提高web应用在一系列web服务器间的移植性 HTTP协议超文本传输协议（HTTP）因为我们在网页上看到的内容通常是浏览器执行 HTML （超文本标记语言）得到的结果，而 HTTP 就是传输 HTML 数据的协议。HTTP 和其他很多应用级协议一样是构建在 TCP（传输控制协议）之上的，它利用了 TCP 提供的可靠的传输服务实现了 Web 应用中的数据交换。 关于 HTTP 的详细信息以及目前的发展状况，大家可以阅读《HTTP 协议入门》、《互联网协议入门》、《图解 HTTPS 协议》等文章进行了解。 reques请求请求头（headers）请求头由若干键值对构成，包含了浏览器、编码方式、首选语言、缓存策略等信息； 请求体（request body） 请求行请求方法有8种：GET（完整请求一个资源）、POST（提交表单）PUT（上传文件）DELETE（删除）、 repose响应响应行包含了协议版本和响应状态码 响应头响应头与 HTTP 请求中的请求头类似，同样由头部字段名、冒号、空格和值组成响应头中包含了一系列服务器的信息，以及服务器对请求的响应。 响应体HTTP 响应中同样使用空行来表示响应头结束。响应体则是服务器根据客户端的请求返回给客户端的具体数据。可能是 HTML 页面，也有可能是JSON或二进制数据等 flask安装pip install flask flask应用12345678910111213141516# 导入Flask模块from flask import Flask#创建Flask实例对象，这是一个WSGI应用程序。# 使用当前模块（__name __）的名称作为参数。#作用一，寻找模板时以当前文件为参考app = Flask(__name__)# route装饰器将url绑定一个函数@app.route('/')def hello_world(): return 'Hello World'if __name__ == '__main__': app.run(debug = True) Flask类的run()方法在本地开发服务器上运行应用程序。 app.run(host, port, debug, options) host要监听的主机名。 默认为127.0.0.1（localhost）。设置为“0.0.0.0”以使服务器在外部可用 port默认值为5000 debug默认为false。 如果设置为true，则提供调试信息 options要转发到底层的Werkzeug服务器。 @app.route()路由使用@app.route()装饰器，并传入URL规则作为参数，将函数绑定到URL，这个过程便将一个视图函数注册为路由 变量规则通过把 URL 的一部分标记为 &lt;variable_name&gt; 就可以在 URL 中添加变量。标记的 部分会作为关键字参数传递给函数。通过使用 &lt;converter:variable_name&gt; ，可以 选择性的加上一个转换器，为变量指定规则。 12345678910# app.py@app.route('/hello/&lt;name&gt;') #路由def hello_name(name): #视图函数 return 'Hello %s!' % name#调试模式,如果代码更改，服务器将自行重新加载。会在终端提示错误app.run(host=\"127.0.0.1\",post='',debug = True) 还可以使用转换器构建规则 @app.route('/blog/&lt;int:postID&gt;') int 接受正整数 float 接受正浮点数 path 类似 string ，但可以包含斜杠 uuid 接受 UUID 字符串 string （缺省值） 接受任何不包含斜杠的文本 唯一的URL/重定向行为1@app.route('/user/') 尾部有/，无论请求的Url是否带有/，都可以执行视图函数，访问一个没有斜杠结尾的 URL 时 Flask 会自动进行重定向，帮你在尾部加上一个斜杠。 尾部没有/，如果访问这个 URL 时添加了尾部斜杠就会得到一个 404 错误。这样可以保持 URL 唯一，并帮助 搜索引擎避免重复索引同一页面。 URL 构建url_for()函数用于构建指定函数的 URL。 接受函数的名称作为第一个参数， 任意个关键字参数，每个参数对应于URL的变量部分。 123456789101112131415from flask import Flask, redirect, url_forapp = Flask(__name__)@app.route('/admin')def hello_admin(): return 'Hello Admin'@app.route('/user/&lt;name&gt;')def hello_user(name): if name =='admin': # 如果匹配，则使用url_for()将应用程序重定向到hello_admin()函数 return redirect(url_for('hello_admin')) else: return redirect(url_for('hello_guest', guest = name)) 为什么不在把 URL 写死在模板中，而要使用反转函数 url_for() 动态构建？ 1.URL反转：根据视图函数名称得到当前所指向的url,函数名一般很少更改，当更改url时就不用改全部辣 2.url_for() 函数最简单的用法是以视图函数名作为参数，返回对应的url，还可以用作加载静态文件，如在模版中加载css静态文件.&lt;link rel=\"stylesheet\" href=\"{{url_for('static',filename='css/index.css')}}\"&gt; 页面跳转和重定向：redirect 是重定向函数，输入一个URL后，自动跳转到另一个URL所在的地址 永久性重定向：http的状态码是301，多用于旧网址被废弃了要转到一个新的网址确保用户的访问，最经典的就是京东网站，你输入www.jingdong.com的时候，会被重定向到www.jd.com，因为jingdong.com这个网址已经被废弃了，被改成jd.com，所以这种情况下应该用永久重定向。 暂时性重定向：http的状态码是302，表示页面的暂时性跳转。比如访问一个需要权限的网址，如果当前用户没有登录，应该重定向到登录页面，这种情况下，应该用暂时性重定向。 在flask中，重定向是通过flask.redirect(location,code=302)这个函数来实现的，location表示需要重定向到的URL，应该配合之前讲的url_for()函数来使用，code表示采用哪个重定向，默认是302也即暂时性重定向，可以修改成301来实现永久性重定向。 以下来看一个例子，关于在flask中怎么使用重定向： 123456789101112131415161718from flask import Flask,url_for,redirectapp = Flask(__name__)app.debug = True@app.route('/login/',methods=['GET','POST'])def login(): return 'login page'@app.route('/profile/',methods=['GET','POST'])def profile(): name = request.args.get('name') if not name: # 如果没有name，说明没有登录，重定向到登录页面 return redirect(url_for('login')) else: return name HTTP 方法Web 应用使用不同的 HTTP 方法处理 URL 。 缺省情况下，一个路由只回应 GET 请求。 可以使用 route() 装饰器的 methods 参数来处理不同的 HTTP 方法: 1.从服务器获取数据一般用Get请求2.把数据发送给服务器用Post请求 12345678from flask import request@app.route('/login', methods=['GET', 'POST'])def login(): if request.method == 'POST': return do_the_login() else: return show_the_login_form() 如果当前使用了 GET 方法， Flask 会自动添加 HEAD 方法支持，并且同时还会 按照 HTTP RFC 来处理 HEAD 请求。同样， OPTIONS 也会自动实现。 Jinja模板视图函数只负责业务逻辑和数据处理(业务逻辑方面)而模板则取到视图函数的数据结果进行展示(视图展示方面) 在项目下创建 templates 文件夹，用于存放所有html模板文件 Flask渲染Jinja模板当访问/about/的时候，about()函数会在当前目录下的templates文件夹下寻找about.html模板文件。如果想更改模板文件地址，应该在创建app的时候，给Flask传递一个关键字参数template_folder，指定具体的路径，再看以下例子： 12345678from flask import Flask,render_template#在C盘的templates文件夹中寻找模板文件。app = Flask(__name__,template_folder=r'C:\\templates')@app.route('/about/')def about(): #要渲染一个模板，通过render_template方法即可 return render_template('about.html')``` 静态文件的配置Web应用中会出现大量的静态文件来使得网页更加生动美观。类似于CSS样式文件、JavaScript脚本文件、图片文件、字体文件等静态资源。在Jinja中加载静态文件非常简单，只需要通过url_for全局函数就可以实现，看以下代码： &lt;link href=\"{{ url_for('static',filename='about.css') }}\"&gt;url_for函数默认会在项目根目录下的static文件夹中寻找about.css文件，如果找到了，会生成一个相对于项目根目录下的/static/about.css路径。当然我们也可以把静态文件不放在static文件夹中，此时就需要具体指定了，看以下代码： app = Flask(__name__,static_folder='C:\\static')那么访问静态文件的时候，将会到/static这个文件夹下寻找。 模板变量 如果想要传递变量到模板中，那么可以把变量定义成字典，然后在render_template中，通过关键字参数的方式传递过去。render_template('',**context)。代码中传入字符串，列表，字典到模板中 1234567891011121314151617181920from flask import Flask, render_templateapp = Flask(__name__)@app.route('/')def index(): # 往模板中传入的数据 my_str = 'Hello Word' my_int = 10 my_array = [3, 4, 2, 1, 7, 9] my_dict = { 'name': 'xiaoming', 'age': 18 } return render_template('hello.html', my_str=my_str, my_int=my_int, my_array=my_array, my_dict=my_dict ) 模板中代码 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 我的模板html内容 &lt;br /&gt;{{ my_str }} &lt;br /&gt;{{ my_int }} &lt;br /&gt;{{ my_array }} &lt;br /&gt;{{ my_dict }}&lt;/body&gt;&lt;/html&gt; Jinja2模版概述1234567891011121314151617181. &lt;html lang=\"en\"&gt;2. &lt;head&gt;3. &lt;title&gt;My Webpage&lt;/title&gt;4. &lt;/head&gt;5. &lt;body&gt;6. &lt;ul id=\"navigation\"&gt;7. {% for item in navigation %}8. &lt;li&gt;&lt;a href=\"{{ item.href }}\"&gt;{{ item.caption }}&lt;/a&gt;&lt;/li&gt;9. {% endfor %}10. &lt;/ul&gt;11.12. {{ a_variable }}13. {{ user.name }}14. {{ user['name'] }}15.16. {# a comment #}17. &lt;/body&gt;18.&lt;/html&gt; 以上示例有需要进行解释： 123456789101112131415 第12~14行的{{ ... }}：用来装载一个变量，模板渲染的时候，会把这个变量代表的值替换掉。并且可以间接访问一个变量的属性或者一个字典的key。关于点.号访问和[]中括号访问，没有任何区别，都可以访问属性和字典的值。 第7~9行的{% ... %}：用来装载一个控制语句，以上装载的是for循环， 第14行的{# ... #}：用来装载一个注释，模板渲染的时候会忽视这中间的值。二、属性访问规则：比如在模板中有一个变量这样使用：foo.bar，那么在Jinja2中是这样进行访问的：先去查找foo的bar这个属性，也即通过getattr(foo,'bar')。如果没有，就去通过foo.__getitem__('bar')的方式进行查找。如果以上两种方式都没有找到，返回一个undefined。在模板中有一个变量这样使用：foo['bar']，那么在Jinja2中是这样进行访问：通过foo.__getitem__('bar')的方式进行查找。如果没有，就通过getattr(foo,'bar')的方式进行查找。如果以上没有找到，则返回一个undefined。 模版过滤器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Jinja2模版过滤器相当于是一个函数，把当前的变量传入到过滤器中，然后过滤器根据自己的功能，再返回相应的值，之后再将结果渲染到页面中。在html中使用，{{ }}过滤器是通过管道符号（|）进行使用的，例如：{{ name|length }}，将返回name的长度。Jinja2中内置了许多过滤器，在这里可以看到所有的过滤器，现对一些常用的过滤器进行讲解：abs(value)：返回一个数值的绝对值。 例如：-1|abs。default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。name|default('xiaotuo')——如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。escape(value)或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。例如：content|escape或content|e。first(value)：返回一个序列的第一个元素。names|first。format(value,*arags,**kwargs)：格式化字符串。例如以下代码：`{{ \"%s\" - \"%s\"|format('Hello?',\"Foo!\") }}`将输出：Helloo? - Foo!last(value)：返回一个序列的最后一个元素。示例：names|last。length(value)：返回一个序列或者字典的长度。示例：names|length。join(value,d=u'')：将一个序列用d这个参数的值拼接成字符串。safe(value)：如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例：content_html|safe。int(value)：将值转换为int类型。float(value)：将值转换为float类型。lower(value)：将字符串转换为小写。upper(value)：将字符串转换为小写。replace(value,old,new)： 替换将old替换为new的字符串。truncate(value,length=255,killwords=False)：截取length长度的字符串。striptags(value)：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格。trim：截取字符串前面和后面的空白字符。string(value)：将变量转换成字符串。wordcount(s)：计算一个长字符串中单词的个数。 flask模版继承一个系统网站往往需要统一的结构，这样看起来比较“整洁”。比如说，一个页面中都有标题、内容显示、底部等几个部分。如果在每一个网页中都进行这几部分的编写，那么这个网站将会有很多冗余部分，这时可以采用模板继承，即将相同的部分提取出来，形成一个base.html，具有这些相同部分的网页通过继承base.html来得到对应的模块。 基本模板直接在templates目录中，蓝图的模板将放置在与蓝图同名的目录中。例如：flaskr/templates/auth/register.html 12345{% extends \"base.html\" %}{% block 模板名称 %} ....{% endblock %} base.html作为基类（父模块），index.html和product.html文件作为子类（子模块），子类去继承基类的基本内容。 base.html文件内容如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;{% block title %}{% endblock %} -我的网站&lt;/title&gt;&lt;/head&gt;&lt;body&gt;{% block body %} 这是基类（base.html）中的内容{% endblock %}&lt;/body&gt;&lt;/html&gt; 子模版 123456789{% extends \"base.html\" %}{% block title %}产品列表页{% endblock %}{% block body %}&lt;h4&gt;这是产品列表页（product.html）的内容！&lt;/h4&gt;获取网页标题内容：&lt;h4&gt;{{ self.title() }}&lt;/h4&gt;{% endblock %} 配置文件所有的内置配置项在Flask项目中，有四种方式进行项目的配置： 123456# 通过加载模块的方式进行配置# 1. 通过模块字符串app.config.from_object('settings')# 2. 通过模块对象import settingsapp.config.from_object(settings) 123# 通过app.config对象来进行配置app = Flask(__name__)app.config['SECRET_KEY'] = \"xxx\" 123456# 因为app.config是flask.config.Config的实例，而Config类是继承自dict，因此可以通过update方法：app.config.update( DEBUG=True, SECRET_KEY='...') 123# app.config.from_pyfile()，该方法传入一个文件名，通常是以.py结尾的文件，但也不限于只使用.py后缀的文件：app.config.from_pyfile('settings.py',silent=True)# silent=True表示如果配置文件不存在的时候不抛出异常，默认是为False，会抛出异常。 蓝图技术蓝图技术(BluePrint )，可以帮助你实现flask应用的模块划分,一个模块拥有一个属于自己的文件目录，与之相关的代码都将写在这里 它是一个存储视图方法的集合，Flask 程序通过 Blueprint 来组织 URL 以及处理请求。 功能式架构按照 功能结构 组织。模板在一个文件夹中，静态文件在另外一个文件夹中，视图在第三个文件夹中。如果应用的组件之间联系较为紧密，则建议使用功能式架构。project/ forms/ myform.py … models/ init.py mymodel.py … routes/ init.py myroute.py … static/ … services/ init.py … templates/ index.html … init.py config.py manage.py forms(表单): 存放表单对象models(模型): 存放数据模型，即库表在程序中的映射对象，以及对象之间的关系routes(路由): 存放请求路由以及处理逻辑static(静态文件): flask约定存放静态文件的目录templates(模板): flask约定存放页面模板的目录services(服务): 存放业务逻辑或者其他服务类功能init.py: flask app初始化方法config.py: 项目配置文件manage.py: 启动一个开发服务器，但是不会在生产环境中用到 分区式架构基于应用的结构如果应用是由独立的且仅仅共享模型和配置的各组件组成，建议选择分区式；按照基于应用组织。同一个功能的模板，静态文件，视图都在一个文件夹内。project/ init.py db.py auth/ init.py route.py models.py templates/ static/ blog/ init.py route.py models.py templates/ static/…每个目录都对应一个应用。Django 默认是使用这种方式来组织目录。当然这并不意味该方式是很好的，你需要按照项目来选择目录结构。某些时候，你将不得不使用一个混合模式。 使用蓝图步骤1.创建一个蓝图对象12345678910111213141516171819202122# user/__init__.pyfrom flask import Blueprint# 创建一个蓝图对象'''参数1：蓝图名字2.模块名3.蓝图前缀4.template_folder :设置模板目录;蓝图对象默认的模板目录为系统的模版目录,如果存在同名模板文件,则系统会优先使用 系统的模版目录中的文件'''bp = Blueprint('user',__name__,url_prefix='/user/')@bp.route('/')def index(): return \"用户首页\"@bp.route('profile/')def profile(): return \"个人简介\" 2.主程序上注册这个蓝图对象然后我们在主程序中，通过app.register_blueprint()方法将这个蓝图注册进url映射中，看下主app的实现： 12345678from flask import Flaskimport userapp = Flask(__name__)app.register_blueprint(user.bp)if __name__ == '__main__': app.run(host='0.0.0.0',port=9000) 以后访问/user/，/user/profile/，都是执行的user.py文件中的视图函数，这样就实现了项目的模块化。 注意1.1. 寻找静态文件：默认不设置任何静态文件路径，Jinja2会在项目的static文件夹中寻找静态文件。也可以设置其他的路径，在初始化蓝图的时候，Blueprint这个构造函数，有一个参数static_folder可以指定静态文件的路径，如： bp = Blueprint('admin',__name__,url_prefix='/admin',static_folder='static')static_folder可以是相对路径（相对蓝图文件所在的目录），也可以是绝对路径。在配置完蓝图后，还有一个需要注意的地方是如何在模板中引用静态文件。在模板中引用蓝图，应该要使用蓝图名+.+static来引用，如下所示： &lt;link href=\"{{ url_for('admin.static',filename='about.css') }}\"&gt; 1.2. 寻找模板文件：跟静态文件一样，默认不设置任何模板文件的路径，将会在项目的templates中寻找模板文件。也可以设置其他的路径，在构造函数Blueprint中有一个template_folder参数可以设置模板的路径，如下所示： bp = Blueprint('admin',__name__,url_prefix='/admin',template_folder='templates')模板文件和静态文件有点区别，以上代码写完以后，如果你渲染一个模板return render_template(‘admin.html’)，Flask默认会去项目根目录下的templates文件夹中查找admin.html文件，如果找到了就直接返回，如果没有找到，才会去蓝图文件所在的目录下的templates文件夹中寻找。 1.3. url_for生成url：用url_for生成蓝图的url，使用的格式是：蓝图名称+.+视图函数名称。比如要获取admin这个蓝图下的index视图函数的url，应该采用以下方式： url_for('admin.index')其中这个蓝图名称是在创建蓝图的时候，传入的第一个参数。bp = Blueprint(‘admin’,name,url_prefix=’/admin’,template_folder=’templates’) 组织扩展(Extensions)一般推荐将所有扩展在app/extensions.py中进行实例化，如以下代码： 12345678910## app/extensions.pyfrom flask_bootstrap import Bootstrapfrom flask_sqlalchemy import SQLAlchemyfrom flask_login import LoginManagerbootstrap = Bootstrap()db = SQLAlchemy()login_manager = LoginManager()login_manager.login_view = 'auth_bp.login' 然后在实例化Flask时，进行绑定： 1234567891011121314151617181920212223242526272829## app/__init__.pyimport osfrom flask import Flaskfrom config import configfrom app.extensions import bootstrap, db, login_managerdef create_app(config_name): app = Flask(__name__) app.config.from_object(config[config_name]) config[config_name].init_app(app) bootstrap.init_app(app) db.init_app(app) login_manager.init_app(app) ## register blueprint from .main import main_bp app.register_blueprint(main_bp) from .auth import auth_bp as auth_blueprint app.register_blueprint(auth_blueprint) from .api import api_bp as api_blueprint app.register_blueprint(api_blueprint, url_prefix='/api') return app 子域名子域名在许多网站中都用到了，比如一个网站叫做xxx.com，那么我们可以定义一个子域名cms.xxx.com来作为cms管理系统的网址，子域名的实现一般也是通过蓝图来实现，在之前章节中，我们创建蓝图的时候添加了一个url_prefix=/user作为url前缀，那样我们就可以通过/user/来访问user下的url。但使用子域名则不需要。另外，还需要配置SERVER_NAME，比如app.config[SERVER_NAME]=’example.com:9000’。并且在注册蓝图的时候，还需要添加一个subdomain的参数，这个参数就是子域名的名称，先来看一下蓝图的实现(admin.py)： 123456from flask import Blueprintbp = Blueprint('admin',__name__,subdomain='admin')@bp.route('/')def admin(): return 'Admin Page' 这个没有多大区别，接下来看主app的实现： 12345678910from flask import Flaskimport admin# 配置`SERVER_NAME`app.config['SERVER_NAME'] = 'example.com:8000'# 注册蓝图，指定了subdomainapp.register_blueprint(admin.bp)if __name__ == '__main__': app.run(host='0.0.0.0',port=8000,debug=True) 写完以上两个文件后，还是不能正常的访问admin.example.com:8000这个子域名，因为我们没有在host文件中添加域名解析，你可以在最后添加一行127.0.0.1 admin.example.com，就可以访问到了。另外，子域名不能在127.0.0.1上出现，也不能在localhost上出现。 request和reposr对象1234567891011121314151617## request 封装了请求消息，可以获取请求的各种参数。from flask import Flask, requestapp = Flask(__name__)## 定义处理路径 /login 的函数 login，装饰器 @app.route(’/login’, methods = [‘GET’]) 表示使用 GET 方法处理路径 /login 的请求。@app.route('/login', methods = ['GET'])## 函数 login 返回一段用于登录的 HTML 表单，表单包括 2 个字段: name 和 password。在第 4 行，指定使用 POST 方法提交表单给服务端的 /check_login 页面。def login(): return '''&lt;form action=\"/check_login\" method=\"POST\"&gt; &lt;p&gt;&lt;input type=\"text\" name=\"name\"/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"password\" name=\"password\"/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"submit\"/&gt;&lt;/p&gt;&lt;/form&gt;''' 12345678910## 使用 POST 方法处理路径 /check_login 的请求。@app.route('/check_login', methods = ['POST'])def check_login(): name = request.form['name'] password = request.form['password'] if name == 'guest' and password == '123': return 'Login succeed' else: return 'Login failed' setting.py1234#app.pyimport settingapp.config.from_object(setting) #导入配置文件 一键安装依赖包##requirements.txt 用来记录项目所有的依赖包和版本号pip freeze &gt; requirements.txt ##一次性安装 requirements.txt 里面所有的依赖包，pip install -r requirements.txt abort函数返回异常12345678910111213141516171819from flask import Flask, make_response,json,request,render_template,abortapp = Flask(__name__)@app.route('/index',methods=['GET','POST'])def index(): if request.method == 'GEt': ##渲染模板 return render_template('index.html') if request.method == 'POST': name = request.form.get('name') password = request.form.get('password') if name == 'zhangsan' and password=='123': return 'login success' else: abort(404)if __name__ == '__main__': app.run(debug = True) 返回json数据给前端12345678910111213from flask import Flask, make_response,jsonapp = Flask(__name__)@app.route('/index')def index(): data = { 'name':'张三' } return make_response(json.dumps(data,ensure_ascii=False))if __name__ == '__main__': app.run(debug = True) Flask结合Bootstrap框架pip install flask-bootstrap 123# 导入bootstrap并进行初始化from flask_bootstrap import Bootstrapbootstrap=Bootstrap() flask扩展Flask扩展是一个Python模块，它向Flask应用程序添加了特定类型的支持。 Flask Extension Registry（Flask扩展注册表）是一个可用的扩展目录。 Flask常用扩展包：Flask-SQLalchemy：操作数据库； Flask-script：插入脚本； Flask-migrate：管理迁移数据库； Flask-Session：Session存储方式指定； Flask-WTF：表单； Flask-Mail：邮件； Flask-Bable：提供国际化和本地化支持，翻译； Flask-Login：认证用户状态； Flask-OpenID：认证； Flask-RESTful：开发REST API的工具； Flask-Bootstrap：集成前端Twitter Bootstrap框架； Flask-Moment：本地化日期和时间； Flask-Admin：简单而可扩展的管理接口的框架 每种类型的扩展通常提供有关其用法的大量文档。 由于扩展是一个Python模块，因此需要导入它才能使用它。 Flask 的扩展通常命名为“ Flask-Foo ”或者“ Foo-Flask ” 。可以在 PyPI 搜索 标记为 Framework :: Flask 扩展包。 命令行控制启动安装pip install flask-script 使用 12345678910# 导入类库from flask_script import Managerapp = Flask(__name__)# 创建对象manager = Manager(app)# 启动程序if __name__ == '__main__': # app.run() # 命令行控制启动 manager.run() 参数： 12345678启动：python manager.py runserver [-d] [-r]-? &amp; --help 查看帮助-d 开启调试模式-r 修改文件自动加载-h --host 指定主机-p --port 指定端口--threaded 使用多线程 Flask-SQLAlchemy库SQLAlchemy 是 Python 中一个通过 ORM 操作数据库的框架。SQLAlchemy 对象关系映射器提供了一种方法，用于将用户定义的 Python 类与数据库表相关联，并将这些类实例与其对应表中的行相关联。SQLAlchemy 可以让开发者使用类和对象的方式操作数据库，从而从繁琐的 sql 语句中解脱出来。 Flask-SQLAlchemy是对SQLAlchemy进行了一个简单的封装，使得我们在flask中使用sqlalchemy更加的简单。只能在flask中使用 1234pip install flask-sqlalchemy # 安装#如果使用 mysql 数据库，还需要安装 mysqldb 驱动。pip install pymysql ORM 模型概念对象 - 关系映射 (Object Relation Mapping) 模型ORM 模型定义了关系数据库和对象的映射关系，使得访问数据库的代码简单清晰、易于维护。 关系数据库中的概念 面向对象中的概念 表 类 表记录 对象 字段 属性 假设关系数据库中存在一张表 Students，包括 sno、name 和 age 等字段，使用如下 SQL 语句进行创建： 123456CREATE TABLE students( sno VARCHAR(255), name VARCHAR(255), age INT); 在 ORM 模型中，存在一个类 Student 与关系数据库中的表 students 相对应，代码如下所示： 1234567891011#类Student映射表studentsclass Student: def __init__(self, sno, name, age): # 属性 sno、name 和 age映射字段 sno、name 和 age self.sno = sno self.name = name self.age = age#对象tom映射表students中的一条记录 tom = Student('1918001', 'tom', 12) 数据库连接配置 配置选项 说明 SQLALCHEMY_DATABASE_URI 连接数据库。示例：mysql://username:password@host/post/db?charset=utf-8 SQLALCHEMY_BINDS 一个将会绑定多种数据库的字典。 更多详细信息请看官文 绑定多种数据库. SQLALCHEMY_ECHO 调试设置为true SQLALCHEMY_POOL_SIZE 数据库池的大小，默认值为5。 SQLALCHEMY_POOL_TIMEOUT 连接超时时间 SQLALCHEMY_POOL_RECYCLE 自动回收连接的秒数。 SQLALCHEMY_MAX_OVERFLOW 控制在连接池达到最大值后可以创建的连接数。当这些额外的连接回收到连接池后将会被断开和抛弃。 SQLALCHEMY_TRACK_MODIFICATIONS 如果设置成 True (默认情况)，Flask-SQLAlchemy 将会追踪对象的修改并且发送信号。这需要额外的内存， 如果不必要的可以禁用它。 dialect+driver://username:password@host:port/database?charset=utf8 dialect是数据库的实现，比如MySQL、PostgreSQL、SQLite，并且转换成小写 driver是Python对应的驱动，如果不指定，会选择默认的驱动，比如MySQL的默认驱动是MySQLdb username是连接数据库的用户名 password是连接数据库的密码 host是连接数据库的域名 port是数据库监听的端口号 database是连接哪个数据库的名字。 123456789101112131415161718192021\"\"\"@file: config.py@author: wenke@software: PyCharm@time: 2022/7/19 11:23@Description: 数据库连接配置\"\"\"DIALCT = \"mysql\"DRIVER = \"pymysql\"USERNAME = \"root\"PASSWORD = \"root\"HOST = \"127.0.0.1\"PORT = \"3306\"DATABASE = \"bookdb\"# 定义数据库连接字符串DB_URIDB_URI = \"{}+{}://{}:{}@{}:{}/{}?charset=utf8\".format(DIALCT,DRIVER,USERNAME,PASSWORD,HOST,PORT,DATABASE)SQLALCHEMY_DATABASE_URI = DB_URISQLALCHEMY_TRACK_MODIFICATIONS = FalseSQLALCHEMY_ECHO = True model对象循环引用循环引用这个问题出现的原因是 数据库脚本和主视图脚本不写在同一个脚本，数据库对象class一起写在同一个脚本下，主视图脚本调用数据库脚本需要先定义db对象才能创建，因为要继承db.Model和使用db.Column等操作db对象的定义在主视图脚本，因为需要传入的app在主视图脚本，但是主视图脚本在最开始就要导入数据库脚本因此造成主视图脚本在启动一开始就需要数据库脚本，但是数据库脚本在一开始就需要主视图脚本，导致报错解决方案 将db对象的定义单独放在一个脚本，并且先不指定app数据库定义单独写一个脚本，其中调用db脚本中的空db对象，先保证语法正确，调用合法在主视图函数中调用db和数据库对象，调用db.init_app(app)将app填充给空db代码实现如下：分别创建db脚本exts.py，数据库脚本models.py，主视图脚本app.py 创建db对象123456789101112# -*- coding: utf-8 -*-\"\"\"@file: exts.py@author: wenke@software: PyCharm@time: 2022/7/19 11:34@Description:创建一个第三方文件，来放db对象,因为当db放在app.py时，from models import User,会从models模型中导入模型类User，但是在models模型又需要导入db,这就会导致循环引用，所以把db放在exts.py中\"\"\"from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy() 创建ORM模型类(建表)，并映射在定义模型的时候，可以不写__tablename__，那么flask_sqlalchemy会默认将类名小写化，然后映射成表名。并且如果这个模型的名字用到了多个单词并且使用了驼峰命名法，那么会在多个单词之间使用下划线来进行连接，但是不推荐使用。（增强代码可读性，提高团队合作效率）app.config[‘SQLALCHEMY_TRACK_MODIFICATIONS’] = False 映射模型到数据库表：使用Flask-SQLAlchemy所有的类都是继承自db.Model，并且所有的Column和数据类型也都成为db的一个属性。但是有个好处是不用写表名了， Flask-SQLAlchemy会自动将类名小写化，然后映射成表名。写完类模型后，要将模型映射到数据库的表中，使用以下代码创建所有的表：db.create_all() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263\"\"\"@file: models.py@author: wenke@software: PyCharm@time: 2022/7/19 11:28 @Description: 模型类\"\"\"from exts import dbclass Student(db.Model): # 表示将类 Student 映射到数据库中的表 students。 __tablename__ = 'students' # 将属性映射到表的字段 sno = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(255)) age = db.Column(db.Integer)class User(db.Model): __tablename__ = \"user\" id = db.Column(db.Integer, primary_key=True, autoincrement=True) username = db.Column(db.String(200),nullable=False)class UserExtension(db.Model): __tablename__ = \"user_extension\" id = db.Column(db.Integer, primary_key=True, autoincrement=True) school = db.Column(db.String(100)) user_id = db.Column(db.Integer,db.ForeignKey(\"user.id\")) # db.backref # 1. 在反向引用的时候，如果需要传递一些其他的参数，那么就需要用到这个函数，否则不需要使用，只要在relationship的backref参数上，设置反向引用的名称就可以了。 # 2. uselist=False：代表反向引用的时候，不是一个列表，而是一个对象。 user = db.relationship(\"User\",backref=db.backref(\"extension\",uselist=False))class Article(db.Model): __tablename__ = \"article\" id = db.Column(db.Integer,primary_key=True,autoincrement=True) title = db.Column(db.String(200),nullable=False) content = db.Column(db.Text,nullable=False) # 外键： # 1. 外键的数据类型一定要看，所引用的字段的类型 # 2. db.ForeignKey(\"表名.字段名 \") # 3. 外键是属于数据库层面的，不推荐直接在ORM中使用 author_id = db.Column(db.Integer,db.ForeignKey(\"user.id\")) # relationship： # 1. 第一个参数是模型的名字，必须要和模型的名字保持一致 # 2. backref（back reference）：代表反向引用，代表对方访问我的时候的字段名称 author = db.relationship(\"User\",backref=\"articles\")# 将模型映射到数据库#db.create_all() # 创建数据库表#db.drop_all() # 删除数据库表： 主程序中使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#app.pyfrom flask import Flaskimport configfrom models import Book, Authorfrom exts import dbapp.config.from_object(config) # 导入数据库连接配置db.init_app(app) # 初始化db,把db对象放到app中# app.app_context()上下文with app.app_context(): db.drop_all() # 删除表 db.create_all() # 创建数据库表@app.route(\"/otm\")def one_to_many(): # 插入数据进Article表 article1 = Article(title=\"111\",content=\"xxx\") article2 = Article(title=\"222\", content=\"yyy\") # 插入数据进User表 user = User(username=\"zhiliao\") article1.author = user article2.author = user db.session.add(article1,article2) db.session.commit() print(user.articles) return \"one to many数据操作成功\"@app.route(\"/oto\")def one_to_one(): # 插入数据进User表 user = User(username=\"zhiliao\") # 插入数据进UserExtension表 extension = UserExtension(school=\"清华大学\") user.extension = extension db.session.add(user) db.session.commit() return \"one to one\"@app.route(\"/article\")def article_view(): # 1. 添加数据进Article表 article = Article(title=\"钢铁是怎样炼成的\",content=\"xxx\") db.session.add(article) # 做一个提交操作 db.session.commit() # 2. 查询数据 # filter_by：返回一个类列表的对象 article = Article.query.filter_by(id=1)[0] print(article.title) # 3. 修改数据 article = Article.query.filter_by(id=1)[0] article.content = \"yyy\" db.session.commit() # 4. 删除数据 Article.query.filter_by(id=1).delete() db.session.commit() return \"数据操作成功\"@app.route('/')def hello_world(): # 写一个测试代码来验证是否连接成功 engine = db.get_engine() with engine.connect() as conn: result = conn.execute(\"select 1\") print(result.fetchone()) return 'Hello World!'if __name__ == '__main__': app.run() flask-migrate(数据库迁移)flask-migrate是基于Alembic进行的一个封装，并集成到Flask中，而所有的迁移操作其实都是Alembic做的，在开发过程中，需要修改数据库模型，比如新增字段，修改字段类型，重命名等,而且还要在修改之后更新数据库。由于db.create_all()只能在表不存在时生效，所以必须删除原表，创建新表从头开始，但这样会丢失数据。更好的解决办法是使用数据库迁移框架，它可以追踪数据库模式的变化，然后把变动应用到数据库中。 多数情况下 Flask-Migrate pip install flask-migrate是会和命令行工具插件 Flask-Scriptpip install Flask-Script 和数据库插件 flask_sqlalchemy 一起使用的 使用步骤linux下flask db init #创建迁移仓库flask db migrate # 创建迁移脚本flask db upgrade #更新数据库 window下需要重写迁移脚本文件(1) 编写数据库迁移脚本manager.py(2) 准备好数据模型(3) 执行迁移命名首先编写迁移脚本manager.py，这个是固定写法 12345678910from flask_migrate import Migrate, MigrateCommandfrom flask_script import Managerfrom main import app, dbmigrate = Migrate(app, db) # 指定迁移的app和dbmanager = Manager(app)manager.add_command('db', MigrateCommand)if __name__ == '__main__': manager.run() 创建迁移仓库和迁移脚本数据库迁移时，初始化命令只需要执行一次，如果在一开始发现执行有问题，需要重新初始化，要先删除 migrations 目录才行。如果已经执行迁移命令，需要重新初始化，要先删除 migrations 目录和到数据库中删除 alembic_version 表。 1234567891011121314151617181920#第一次运行迁移需要执行init命令，会在目录下新生成migrations目录，在目录下versions子目录下的py脚本记录了每次迁移的变化，#migrations 里面有一个 versions 文件夹，这个文件夹用于存放迁移脚本，执行迁移命令后会自动生成迁移脚本保存在里面。#env.py 是迁移环境的相关信息。python manager.py db init #创建迁移仓库--------------------------------------------------------------python manage.py db migrate -m \"first commit\"-------------------------------------------------------------#执行 upgrade 命令后，会在数据库中创建一张 alembic_version 表，这张表是 Alembic 自动创建的，里面保存的是当前数据库的版本 id ，alembic_version 表不能删除，删除后就不能继续执行数据库迁移操作了，除非重新初始化。# 同时，执行 upgrade 命令后，会根据代码中定义的模型类创建对应的表，表的字段与模型类中定义的一致。# 如果数据库中有其他表(没有对应模型类的表)，会被删除。，数据库迁移时最好使用一个新的数据库(不要与其他项目用同一个数据库)，避免造成数据丢失。python manager.py db upgrade #更新数据库 回退数据库回退数据库时，需要指定回退版本号，由于版本号是随机字符串，为避免出错，建议先使用python3 db_database.py db history命令查看历史版本的具体版本号，然后复制具体版本号执行回退。 python3 db_database.py db downgrade 版本号 Flask-WTF表单验证在 Web 页面中，表单是一种常见的元素，表单包含有多个字段，通常字段的取值需要在一定的范围内，例如：QQ 注册时，名称不可以为空，密码的长度至少是 8 个字符,将表单提交给服务端处理时，服务端需要验证表单中的字段的取值是否符合要求。Flask-WTF是简化了WTForms操作的一个第三方库。WTForms表单的两个主要功能是验证用户提交数据的合法性以及渲染模板。当然还包括一些其他的功能：CSRF保护，文件上传等。安装Flask-WTF默认也会安装WTForms，因此使用以下命令来安装Flask-WTF: pip install flask-wtf flask-email邮箱使用登录注册模块flask-login管理已登录用户的用户会话 werkzeug计算密码散列值并进行核对 itsdangerous生成并核对加密安全令牌 部署到云服务器 在pycharm中项目虚拟环境的终端运行pip freeze &gt;requirements.txt 出错AttributeError: module ‘time‘ has no attribute ‘clock‘的解决方法 主要原因是因为python3.8之后不支持clock了, 需要替换成 time.pref_counter() 替换就可以了 12345678910111213# cpmpat.py文件：if win32 or jython: time_func = time.clockelse: time_func = time.time#改为：if win32 or jython: time_func = time.perf_counter()else: time_func = time.time","categories":[{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/categories/python/"}],"tags":[{"name":"flask","slug":"flask","permalink":"https://wenkex.gitee.io/tags/flask/"}]},{"title":"matlab学习","slug":"matlab学习","date":"2022-03-15T07:15:30.000Z","updated":"2022-03-15T07:15:30.000Z","comments":true,"path":"2022/031551719.html","link":"","permalink":"https://wenkex.gitee.io/2022/031551719.html","excerpt":"","text":"https://www.w3cschool.cn/matlab/matlab-5use28gb.html 常用命令matlab常用命令 % 这是一行注释 ,ctrl +r 快捷注释 在命令行中，以逗号或分号分隔多条命令 变量变量名长度不超过63位区分大小写在使用变量之前，必须进行赋值。 123456789101112MATLAB可以多个赋值`a = 2; b = 7; c = a * b`显示所有已经使用的变量名。who显示变量信息whos删除所有（或指定）从内存中的变量（S）。clearclear s matlab数据类型数字字符和字符串单引号括起来 结构体数组Matlab中结构体数组与python中字典概念差不多，使用方法也类似 直接定义1234567students.name = 'John';students.sex = 'Boy';%输出结果为 包含以下字段的 struct:name: 'John'sex: 'Boy' 矩阵https://blog.csdn.net/weixin_49167174/article/details/119939748 矩阵的规则矩阵元素必须在”[ ]”内； 矩阵的同行元素之间用空格（或”,”）隔开； 矩阵的行与行之间用”;”（或回车符）隔开； 矩阵的元素可以是数值、变量、表达式或函数； 利用函数创建矩阵(1) ones()函数：产生全为1的矩阵，ones(n)：产生nn维的全1矩阵，ones(m,n)：产生mn维的全1矩阵； (2) zeros()函数：产生全为0的矩阵； (3) rand()函数：产生在（0，1）区间均匀分布的随机阵； (4) eye()函数：产生单位阵； (5) randn()函数：产生均值为0，方差为1的标准正态分布随机矩阵。 冒号表达式(初始值：步长：终止值） linspace(a, b, n)产生行向量（a：第一个元素, b：最后一个元素, n：元素总数）若元素总数n省略，则自动默认产生100个元素 矩阵元素的引用1.通过下标引用矩阵元素：第几行，第几列 2.通过序号引用矩阵元素在matlab中，矩阵的元素是按列存储的即首先存储第一列元素、第二列…一直到最后一列。 矩阵元素的序号就是矩阵元素在内存中的排列顺序。 矩阵拆分利用冒号表达式获得子矩阵： (1) A(:,j)表示取A矩阵的第j列全部元素；A(i,:)表示A矩阵第i行的全部元素；A(i,j)表示取A矩阵第i行、第j列的元素。 (2) A(i:i+m,:)表示取A矩阵第ii+m行的全部元素；A(:,k:k+m)表示取A矩阵第kk+m列的全部元素，A(i:i+m,k:k+m)表示取A矩阵第ii+m行内，并在第kk+m列中的所有元素。此外，还可利用一般向量和end运算符来表示矩阵下标，从而获得子矩阵。end表示某一维的末尾元素下标。 利用空矩阵[]删除矩阵的元素： 在MATLAB中，定义[]为空矩阵。给变量X赋空矩阵的语句为X=[]。注意，X=[]与clear X不同，clear是将X从工作空间中删除，而空矩阵则存在于工作空间中，只是维数为0。 常用命令求矩阵的大小size() 求矩阵某个元素的下标[row,col]=find(a==5) (下标变序号)D=sub2ind(size(a),[I],[J]) I是行下标，J是列下标 (序号变下标)[I,J]=ind2sub(S,D)D是序号 结构矩阵结构矩阵名.成员名=表达式 元胞数组(cell)是由可以包括任何数据类型的元胞组成的数组。也叫单元矩阵通过元胞数组的使用，可以在同一个变量中存储不同数据类型的数据。单元矩阵元素用大括号括起来 当要将数据放入一个元胞数组中时，请使用元胞数组构造运算符 {} 创建该数组。 结构体函数function [输出参数列表] = 函数名（输入参数列表） 匿名函数函数文件文件第一行必须以function开头，文件名字必须以函数名.m命名function 应变量名= 函数名(自变量名) 基本绘图函数点运算点运算是处理元素之间的运算矩阵计算和作图都是点运算 plot()plot(xn,yn,sn,…)s参数为线型 如果 X 和 Y 均为矩阵，则它们的大小必须相同。plot 函数绘制 Y 的列对 X 的列的图。 subplot()分割figure，创建子坐标系subplot（m,n,p）m表示是图排成m行，n表示图排成n列， ezplot(f)ezplot(f) 在默认区间[-2pi,2pi]上绘制函数f=f(x) f 可以是定义函数的M文件名或者一个匿名函数或者一个字符串 图形标注1.title设置图像标题2.annotate标注文字3.text设置文字说明在绘制图形时，可以对图形加上一些说明，如图形的名称、坐标轴说明以及图形某一部分的含义等，这些操作称为添加图形标注。title(‘图的题目’)xlabel(‘横轴的名称’)ylabel(‘纵轴的名称’)text(0.5,25,’说明示例’) 坐标、图形和图层窗口控制在绘制图形时，Matlab可以自动根据要绘制曲线数据的范围选择合适的坐标刻度，使得曲线能够尽可能清晰的显示出来。所以，一般情况下用户不必选择坐标轴的刻度范围。但是，如果用户对坐标不满意，可以利用axis函数对其重新设定。 axis equal %纵横坐标轴采用等长刻度axis square %产生正方形坐标系（默认为矩形）axis auto %使用默认设置axis off %取消坐标轴axis on %显示坐标轴grid on %显示网格grid off %不显示网格box on %显示其他轴(上、右)box off %不显示其他轴(上、右)hold on %继续在同一图层绘图figure(1) %新生成一个图层","categories":[{"name":"学习","slug":"学习","permalink":"https://wenkex.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://wenkex.gitee.io/tags/matlab/"}]},{"title":"深度学习","slug":"深度学习","date":"2022-03-08T10:41:51.000Z","updated":"2022-03-08T10:41:51.000Z","comments":true,"path":"2022/030811061.html","link":"","permalink":"https://wenkex.gitee.io/2022/030811061.html","excerpt":"","text":"人工智能、机器学习、深度学习的关系人工智能 &gt; 机器学习 &gt; 深度学习。 迁移学习神经网络需要用数据来训练，它从数据中获得信息，进而把它们转换成相应的权重。这些权重能够被提取出来，迁移到其他的神经网络中，我们“迁移”了这些学来的特征，就不需要从零开始训练一个神经网络了 预训练模型预训练模型(pre-trained model)是前人为了解决类似问题所创造出来的模型。你在解决问题的时候，不用从零开始训练一个新模型，可以从在类似问题中训练过的模型入手。 当在训练经网络的时候我们的目标是什么？我们希望网络能够在多次正向反向迭代的过程中，找到合适的权重。 通过使用之前在大数据集上经过训练的预训练模型，我们可以直接使用相应的结构和权重，将它们应用到我们正在面对的问题上。这被称作是“迁移学习”，即将预训练的模型“迁移”到我们正在应对的特定问题中。 实践平台如果学员想了解更多关于飞桨、深度学习、机器学习或Python课程，可以通过如下三个途径获取。 AI Studio：https://aistudio.baidu.com/飞桨官网：https://www.paddlepaddle.org.cn/百度技术学院：http://bit.baidu.com/index 机器学习机器学习是专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构，使之不断改善自身的性能。 机器学习的实现机器学习的实现可以分成两步：训练和预测，类似于归纳和演绎： 归纳： 从具体案例中抽象一般规律，机器学习中的“训练”亦是如此。从一定数量的样本（已知模型输入XXX和模型输出YYY）中，学习输出YYY与输入XXX的关系（可以想象成是某种表达式）。演绎： 从一般规律推导出具体案例的结果，机器学习中的“预测”亦是如此。基于训练得到的YYY与XXX之间的关系，如出现新的输入XXX，计算出输出YYY。通常情况下，如果通过模型计算的输出和真实场景的输出一致，则说明模型是有效的。 预测问题对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。下面我们尝试用最简单的线性回归模型解决这个问题，并用神经网络来实现这个模型。 构建模型 模型结构三要素（模型假设、评价函数和优化算法） paddleHub工具端到端的预训练模型管理与迁移学习工具模型一键下载、管理、预测,十行代码完成迁移学习,一键自动超参搜索,一键模型服务化部署 精选效果优秀的算法，提供了百亿级大数据训练的预训练模型，方便用户不用花费大量精力从头开始训练一个模型。 #安装 -i指定镜像源pip install paddlehub -i http://pypi.douban.com/simple/#更新pip install –upgrade paddlehub -i http://pypi.douban.com/simple/ 自然语言处理(NLP)NLP 的4个典型应用情感分析 聊天机器人 语音识别 机器翻译 paddlenlp安装pip install –upgrade paddlenlphttps://aistudio.baidu.com/aistudio/projectdetail/3696243?channelType=0&amp;channel=0 中文分词分词作为许多NLP任务的第一道工序,Taskflow提供了多种中文分词模式供大家选择 文档级输入支持超长文本输入，无需担心『文本截断』问题 12345678910from paddlenlp import Taskflow# 首次调用会有模型下载的额外时间开销seg = Taskflow(\"word_segmentation\")doc = \"苏锦一直记得那个午后，明晃晃的光线穿过教室的窗玻璃洒到自己脸上，有种特别暖和的感觉。那阳光仿佛是能够钻进人的\"print(\"1. 输入长度：\", len(doc))print(\"2. 分词结果：\", seg(doc)) 快速模式分词示例如何通过快速模式分词对数据集进行词频统计、构建词表 精确模式分词用户词典快速配置用户词典来对分词结果进行干预 词性标注，，依存句法分析123456789101112from paddlenlp import Taskflow# 基于百度词法分析工具LAC，训练语料包含近2200万句子，覆盖多种场景# 词性标注tag = Taskflow(\"pos_tagging\")print(tag(\"第十四届全运会在西安举办\")) 命名实体识别基于百度解语的精确模式：最全中文实体标签的命名实体识别工具 精确模式基于百度解语的精确模式：最全中文实体标签的命名实体识别工具，不仅适用于通用领域，也适用于生物医疗、教育等垂类领域。包含66种词性及专名类别标签（同类产品的标签数是15个左右） 12345from paddlenlp import Taskflowner = Taskflow(\"ner\")print(ner([\"李伟拿出具有科学性、可操作性的《陕西省高校管理体制改革实施方案》\", \"诺戴商务咨询（上海）有限公司于2016年08月22日成立\"])) 快速模式基于百度词法分析工具LAC，训练语料包含近2200万句子，覆盖多种场景 123456from paddlenlp import Taskflowner_fast = Taskflow(\"ner\", mode=\"fast\")print(ner_fast(\"三亚是一个美丽的城市\")) 依存句法分析123456789101112131415from paddlenlp import Taskflow# 使用BiLSTM作为编码器，速度最快ddp = Taskflow(\"dependency_parsing\")print(ddp(\"2月8日谷爱凌夺得北京冬奥会第三金\"))# # 编码器部分将BiLSTM替换为ERNIE，模型准确率更高！# ddp = Taskflow(\"dependency_parsing\", model=\"ddparser-ernie-1.0\")# print(ddp(\"2月8日谷爱凌夺得北京冬奥会第三金\"))# 输出概率值和词性标签ddp = Taskflow(\"dependency_parsing\", prob=True, use_pos=True)print(ddp(\"2月8日谷爱凌夺得北京冬奥会第三金\")) 定制化训练利用自己的数据训练/微调模型，通过Taskflow一键装载并使用 数据准备和训练参考PaddleNLP SKEP情感分析训练示例完成数据准备和模型训练。 使用定制化模型通过task_path指定自定义模型路径一键加载即可。 12345from paddlenlp import Taskflowmy_senta = Taskflow(\"sentiment_analysis\", model=\"skep_ernie_1.0_large_ch\", task_path=\"/home/aistudio/custom_model\")print(my_senta(\"不错的酒店,服务还可以,下次还会入住的~\")) 深度学习基础人工神经网络包括多个神经网络层，如：卷积层、全连接层、LSTM等，每一层又包括很多神经元，超过三层的非线性神经网络都可以被称为深度神经网络。通俗的讲，深度学习的模型可以视为是输入到输出的映射函数，如图像到高级语义（美女）的映射，足够深的神经网络理论上可以拟合任何复杂的函数。因此神经网络非常适合学习样本数据的内在规律和表示层次，对文字、图像和语音任务有很好的适用性。这几个领域的任务是人工智能的基础模块，因此深度学习被称为实现人工智能的基础也就不足为奇了。 神经元： 神经网络中每个节点称为神经元，由两部分组成： 加权和：将所有输入加权求和。 非线性变换（激活函数）：加权和的结果经过一个非线性函数变换，让神经元计算具备非线性的能力。 多层连接： 大量这样的节点按照不同的层次排布，形成多层的结构连接起来，即称为神经网络。 前向计算： 从输入计算输出的过程，顺序从网络前至后。 计算图： 以图形化的方式展现神经网络的计算逻辑又称为计算图，也可以将神经网络的计算图以公式的方式表达：Y=f3(f2(f1(w1⋅x1+w2⋅x2+w3⋅x3+b)+…)…)…)​神经网络并没有那么神秘，它的本质是一个含有很多参数的“大公式” 构建神经网络/深度学习模型的基本步骤数据处理数据导入、 数据形状变换、 数据集划分、 数据归一化处理 封装load data函数 图像和文本数据处理模型设计（模型要素1）网络结构设计，相当于模型假设空间，即模型能够表达的关系集合。 训练配置模型要素2）设定模型采用的寻解方法，即优化器，并指定计算资源。PS：神经网络学习的目的是寻找合适的参数，使得损失函数的值尽可能小。解决这个问题的过程为称为最优化。解决这个问题使用的算法叫做优化器。接触到的优化器有：随机梯度下降法（Stachastic gradient desent 简称 SGD）和AdaGrad AdaGard主要是为了解决 SGD 遇到鞍点或者极小值点后学习变慢的问题。我们知道超参数学习率是一个很重要的参数，不同的参数对学习结果的影响很大，如果设置的值较小，会导致学习花费较多的时间，学习率大了就会导致学习发散而不能正常的进行。所以我们可以考虑避免人为的介入，根据需要让程序自己动态地设置学习率。例如对于遇到鞍点的情况，参数变化很小，基本不会改变，那么这个方法就会设置一个较大的学习率，跨过鞍点。 训练过程模型要素3）循环调用训练过程，每轮都包括前向计算、损失函数（优化目标）和后向传播三个步骤。 PS：前向计算是指把输入数据传入模型，然后得到输出；后向传播是指根据前向计算得到的输出通过梯度下降，从后向前优化网络中的参数。（因为梯度下降就是从后向前计算） 模型保存将训练好的模型保存，模型预测是调用。 数据集coco数据集目录结构train2017、test2017、val2017文件夹中保存的是用于训练、测试、验证的图片，annotations文件夹保存的是这些图片对应的标注信息，分别存在instance_test2017、instance_test2017、instance_val2017三个json文件中。 VOC数据集目录结构Annotations/ #存放xml文件，与JPEGImages中的图片一一对应，解释图片的内容等等JPEGImages/labels.txttrain_list.txttest_list.txtval_list.txt paddleX划分数据集123456#使用paddleX快速划分数据集!pip install \"paddlex&lt;=2.0.0\" -i https://mirror.baidu.com/pypi/simple!paddlex --split_dataset --format VOC --dataset_dir roadsign --val_value 0.1 --test_value 0.1#--format VOC VOC格式的数据集#按照8：1：1的比例划分为训练集，验证集(--val_value)和测试集(--test_value) PaddlePaddle安装 运行PaddlePaddle需要COCO-API，安装方式如下： 12345678910pip install pycocotools # linux安装pycocotools# 若Cython未安装，请安装Cythonpip install Cython#windows用户安装COCO-API方式：# 由于原版cocoapi不支持windows，采用第三方实现版本，该版本仅支持Python3pip install git+https://github.com/philferriere/cocoapi.git#subdirectory=PythonAPI PaddleClas和PaddleDetection分别是PaddlePaddle的两个开源项目，关注不同的技术领域。 PaddleClas以图像识别和图像分类为主，同时关注基础的骨干网络模型；PaddleClas对小样本区分、识别目标不固定等疑难问题效果更好，整体精度上限更高； 目标检测PaddleX2.1PaddleDetection套件paddledetection的github主页PaddleDetection套件文档 以检测技术为主，同时关注关键点、跟踪等方向。PaddleDetection在超轻量模型上更有优势，在移动端设备上速度更快。https://blog.smslit.cn/2021/04/15/paddle-detection-train-log/ 选择模型模型丰富: 包含目标检测、实例分割、人脸检测、关键点检测、多目标跟踪等250+个预训练模型 支持现有的RCNN、SSD、YOLO等系列模型，快速的完成不同模型的训练体验，就是需要依靠配置文件的切换。configs文件夹中都是模型文件，模型文件内可选择骨架网络 安装PaddleDetection在安装PaddleDetection之前要先安装依赖项PaddlePaddle 12345678910#安装PaddleDetection!git clone https://gitee.com/PaddlePaddle/PaddleDetection.git# 安装依赖包%cd PaddleDetection!pip install -r requirements.txt!python setup.py install# 测试是否安装成功!python ppdet/modeling/tests/test_architectures.py 数据集准备基于标注好的图片生成数据集常用的目标检测数据集有两种格式，分别是VOC和COCO。 如果使用COCO格式，建议使用PaddleDetection中的x2coco将标注好的文件转为COCO格式的数据集。转换代码如下： 12345678python tools/x2coco.py \\ --dataset_type labelme \\ --json_input_dir ./labelme_annos/ \\ --image_input_dir ./labelme_imgs/ \\ --output_dir ./cocome/ \\ --train_proportion 0.8 \\ --val_proportion 0.2 \\ --test_proportion 0.0 如果使用VOC格式的数据集，可以使用labelme自带的labelme2voc.py完成，需要先创建labels.txt文件,labels.txt文件的前两行分别为__ignore__和_background_，其余行为类别名称。转换代码如下： ./labelme2voc.py data_annotated data_dataset_voc --labels labels.txt 修改参数配置COCO数据集： dataset: !COCODataSet image_dir: val2017 # 图像数据基于数据集根目录的相对路径 anno_path: annotations/instances_val2017.json # 标注文件基于数据集根目录的相对路径 dataset_dir: dataset/coco # 数据集根目录 with_background: true # 背景是否作为一类标签，默认为true。 选择模型并修改配置文件,属于小物体检测范畴，我们选择Faster-Rcnn系列模型。然后基于configs/faster_rcnn_r50_fpn_1x.yml文件进行修改 开始训练若是训练过程当中自动下载数据集，那确定是你的yml路径配置错了，写绝对路径。使用PaddleDetection时的配置信息是采用yml文件描述的，这里使用的是yolov3_darknet53_270e_voc.yml文件. 123456# 设置PYTHONPATH路径export PYTHONPATH=$PYTHONPATH:.# GPU训练 支持单卡，多卡训练，通过CUDA_VISIBLE_DEVICES指定卡号export CUDA_VISIBLE_DEVICES=0,1,2,3,4,5,6,7python tools/train.py -c configs/faster_rcnn_r50_1x.yml --eval -o use_gpu=true --use_vdl=True --vdl_log_dir=./vdl_dir/scalar 可选参数列表可以通过–help查看https://paddledetection.readthedocs.io/tutorials/GETTING_STARTED_cn.html#id2 -c 指定配置文件 -o 设置配置文件里的参数内容 None 使用-o配置相较于-c选择的配置文件具有更高的优先级。例如：-o use_gpu=False max_iter=10000 -r/–resume_checkpoint train 从某一检查点恢复训练 –eval 是否边训练边测试 False –output_eval 编辑评测保存json路径 当前路径 –output_eval ./json_result –fp16 是否使用混合精度训练模式 False 需使用GPU训练 –loss_scale 设置混合精度训练模式中损失值的缩放比例 –use_vdl 是否使用VisualDL记录数据，进而在VisualDL面板中显示 –vdl_log_dir 指定 VisualDL 记录数据的存储路径 -r 模型暂存路径/接着训练的轮数（接着第几轮训练）-r ./output/faster_rcnn_r50_vd_fpn_ssld_2x_coco/5 预训练模型的参数确实有助于提高训练的准确率加载预训练模型-o pretrain_weights=output/faster_rcnn_r50_1x/model_final \\ 加载部分预训练模型-o pretrain_weights=output/faster_rcnn_r50_1x/model_final finetune_exclude_pretrained_params=[‘cls_score’,’bbox_pred’] 训练信息loss_bbox :衡量预测边界框与真实对象的“紧密程度”的损失(通常是回归损失，L1，smoothL1 等)。loss_cls :衡量每个预测边界框分类正确性的损失:每个框可能包含一个对象类，或一个“背景”。这种损失通常称为交叉熵损失。 FasterRCNNFasterRCNN的训练日志除了通用统计信息外，还包括loss_cls、loss_bbox、loss_rpn_cls和loss_rpn_bbox，这些字段的含义如下: 字段 含义loss_cls RCNN子网络中分类损失函数值loss_bbox RCNN子网络中检测框回归损失函数值loss_rpn_cls RPN子网络中分类损失函数值loss_rpn_bbox RPN子网络中检测框回归损失函数值loss 所有子网络损失函数值之和 评估评估配置 预测图像使用预训练模型预测图像 123456!python tools/infer.py -c ../configs/yolov3_darknet53_270e_voc.yml \\ --infer_img=/home/aistudio/fortest.jpg \\ --output_dir=/home/aistudio/infer_output/ \\ --draw_threshold=0.1 \\ -o weights=output/yolov3_darknet53_270e_voc/model_final \\ --use_vdl=Ture Notebook中Notebook中使用Shell命令!ls /home/aistudio/data/ Magic命令Magic命令是Notebook的高级用法了. 可以运行一些特殊的指令. Magic 命令的前面带有一个或两个百分号（% 或 %%），分别代表行 Magic 命令和单元格 Magic 命令。行 Magic 命令仅应用于编写 Magic 命令时所在的行，而单元格 Magic 命令应用于整个单元格。 #显示全部可用的Magic命令%lsmagic1","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://wenkex.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"django学习","slug":"django学习","date":"2022-03-06T13:02:52.000Z","updated":"2022-03-06T13:02:52.000Z","comments":true,"path":"2022/030664874.html","link":"","permalink":"https://wenkex.gitee.io/2022/030664874.html","excerpt":"","text":"Python 加 Django 是快速开发、设计、部署网站的最佳组合。 安装pip install django -i http://pypi.douban.com/simple --trusted-host pypi.douban.com 创建项目在想要创建的文件夹中，进入终端执行命令创建项目'django-admin startproject 项目名称 项目文件介绍manage.py 项目的管理，启动项目，创建app,数据管理urls.py url和函数的对应关系asgi.py 和wsgi.py 接受网络请求 创建一个apppython manage.py startapp 名称 Uvicorn 运行 djangodjango 内置的开发服务器在修改代码后的热重载非常缓慢，我发现 uvicorn 的重载速度要快得多，所以新项目第一件事，就是使用在开发环境下使用 uvicorn 运行 django。 首先当然要安装 uvicorn。pip install uvicorn Uvicorn 安装好后，可以在命令行使用 uvicorn 命令来运行 django。但是，每次输命令启动 django 会非常麻烦！最好的做法是创建一个脚本，启动 django 只需要执行脚本就可以了。 在 项目根目录 创建一个 run_uvicorn.py 的脚本（脚本名可以自己随便取），代码如下： 1234567891011121314151617import uvicornimport osdef main(): os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"mysite.settings\") uvicorn.run( \"mysite.asgi:application\", host=\"0.0.0.0\", port=8000, log_level=\"debug\", reload=True, )if __name__ == \"__main__\": main() 运行脚本后，应用已在 8000 端口启动，现在访问 localhost:8000，可以看到熟悉的 django 项目初始页面。 创建views.py 写函数","categories":[{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/categories/python/"}],"tags":[{"name":"web","slug":"web","permalink":"https://wenkex.gitee.io/tags/web/"}]},{"title":"Linux","slug":"Linux","date":"2022-02-26T12:50:16.000Z","updated":"2022-02-26T12:50:16.000Z","comments":true,"path":"2022/022615691.html","link":"","permalink":"https://wenkex.gitee.io/2022/022615691.html","excerpt":"","text":"使用linux的好处使用linux的好处在 linux 下，apt install 或者 yum install 之类的命令，就能搞定整个软件安装。 Linux 不需要选择软件是放 c 盘还是 d 盘，已经定义好了哪些文件该放在哪些地方，不需要杀毒软件，不需要清理垃圾，不需要释放内存，不需要激活系统，它是开源免费的，不需要磁盘优化，没有烦人的弹窗，没有强制更新。 linux环境VMware搭建linux安装Vmware Tools工具。可以为虚拟机提供更好的显卡性能（游戏玩家最爱的）同步物理主机时间自动捕获和释放鼠标光标（不用按下Ctrl + Alt键来释放鼠标）实现物理主机和虚拟机或者虚拟机和虚拟机之间进行复制和粘贴操作（文件传输）点击Vmware Workstation 菜单栏的“虚拟机”点击“安装 Vmware Tools（T） 设置虚拟机快照。虚拟机的快照可以把当前虚拟机的状态保存下来，方便以后可以还原到这个状态，理论上快照可以设置很多个，但是设置过多的快照会影响虚拟机的性能，并在会增大物理磁盘的存储空间，快照的常见的应用是：安装大型专业软件时，害怕安装失败，那么在安装之前设置一个快照，方面以后还原虚拟机的状态，重新测试安装软件，或者是在虚拟机设置一系列很复杂的系统配置，担心设置不成功，那么在设置之前可以做一个快照，万一配置系统不顺，可以还原到快照之前的状态，重新做配置。 虚拟机网络的使用网络模式：映射网络驱动器虚拟机的克隆克隆虚拟机可以把一个虚拟机复制成多个虚拟机，那么就不用重新安装虚拟机了，克隆虚拟机需要在虚拟机关机的状态下进行，在虚拟机关机的情况下，右键虚拟机》管理》克隆通过Vmware导出虚拟机有时候，我们设置好的虚拟机需要在其他电脑上面使用，那么可以使用虚拟机迁移功能，把自己电脑的虚拟机，导出，再到其他电脑上面使用Vmware Workstation进行导入（版本最好一致） 在菜单栏点击“文件”》点击“导出为OVF（E）…” 使用虚拟机VMware中的CentOS字符命令界面和图形界面切换ctrl+f1 ctrl+f2 VMWare 和 Hyper-V 共存将 Windows 版本升级到 Windows 10 20H1 或更高版本。将 VMWare Workstation/Player 升级到 15.5.5 或更高版本在安装时，勾选“自动安装 Windows Hypervisor Platform (WHP)”。打开虚拟机的设置选项，找到“处理器”，去掉如图所示的三个选项前面的钩，点击“确定” 网络连接方式NAT模式（默认）：网络地址转换方式，linux可以访问外网，不会造成ip冲突 桥接模式：可以与其它系统进行通信，但可能造成ip冲突 主机模式：你的Linux是一个独立的主机，不能访问外网 WSL2搭建Linux官方文档WSL2采用在Hyper-V虚拟机中运行的方案,实现了与 windows 的高度集成,wsl2 的开启速度有了非常明显的提升，几乎无需等待。 启用适用于 Linux 的 Windows 子系统 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启用虚拟机平台功能 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 以管理者模式进入cmd安装wsl --install 切换WSL的默认版本为WSL2。wsl --set-default-version 2 以管理者cmd进行更新操作wsl --update 重启，更新才能生效wsl --shutdown Microsoft Store 中找一个 Linux 发行版进行安装 查看系统版本wsl -l -v 修改默认安装目录命令格式：wsl –import &lt;文件位置&gt; &lt;安装位置&gt; 查看已安装的linux发行版本 wsl -l --all -v 导出分发版为tar文件到d盘wsl --export Ubuntu-20.04 D:\\data\\WSL2\\Ubuntu-20.04.tar 注销当前分发版wsl --unregister Ubuntu-20.04 重新导入并安装WSL在D盘wsl --import Ubuntu-20.04 D:\\data\\WSL2\\Ubuntu-20.04 D:\\data\\WSL2\\Ubuntu-20.04.tar --version 2 设置默认登陆用户为安装时用户名ubuntu config --default-user USERNAME 删除wsl-ubuntu20.04.tardel d:\\wsl-ubuntu.tar 设置 Linux 用户名和密码若要更改或重置密码，请打开 Linux 发行版并输入命令：passwd如果忘记了 Linux 分发版的密码：1.请打开 PowerShell，并使用以下命令进入默认 WSL 分发版的根目录：wsl -u root 如果需要在非默认分发版中更新忘记的密码，请使用命令：wsl -d Debian -u root，并将 Debian 替换为目标分发版的名称。 2.在 PowerShell 内的根级别打开 WSL 发行版后，可使用此命令更新密码：passwd ，其中 是发行版中帐户的用户名，而你忘记了它的密码。 关闭WSL2WSL2实际上是在虚拟机中运行。我们一旦进入WSL2 Linux的命令行，虚拟机会自动启动运行。如果我们查看任务管理器，会发现一个Vmmem进程,它比较占内存。不使用WSL2的时候我们可以关闭它以节省内存。关闭WSL2 Linux的方法如下。使用管理员打开CMD，运行：wsl --shutdown 为发行版linux更换国内源https://blog.csdn.net/weixin_41529012/article/details/117226884 打开\\wsl.localhost\\Ubuntu\\etc\\apt地址下的sources.list文件，更改国内源中科大 1234567891011deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 123sudo apt update &amp;&amp; sudo apt upgrade #更新镜像源列表 使用vscode操作wsl在window的vscode上安装Remote Development扩展包包括Remote - SSH ， Remote - Containers ，Remote - WSL扩展 Remote - WSL 扩展：使你能够打开容器中、远程计算机上或 WSL 中的任何文件夹。 打开 WSL 项目1.从 WSL 发行版打开项目，请打开发行版的命令行并输入：code . 2.从 VS Code 中打开项目，通过使用 VS Code 中的快捷方式 CTRL+SHIFT+P 调出命令面板，以访问更多 VS Code 远程选项。 如果随后键入 Remote-WSL，将看到可用的 VS Code 远程选项列表，使你可以在远程会话中重新打开文件夹，指定要在哪个发行版中打开，等等。 wsl安装Docker1.下载 Docker Desktop 并按照安装说明进行操作。 2.安装后，从 Windows 开始菜单启动 Docker Desktop，然后从任务栏的隐藏图标菜单中选择 Docker 图标。 右键单击该图标以显示 Docker 命令菜单，然后选择“设置”。 3.确保在“设置”“常规”中选中“使用基于 WSL 2 的引擎”。 4.通过转到“设置”“资源”“WSL 集成”，从要启用 Docker 集成的已安装 WSL 2 发行版中进行选择。 5.若要确认已安装 Docker，请打开 WSL 发行版（例如 Ubuntu），并通过输入 docker –version 来显示版本和内部版本号 linux云服务器云服务器可以做什么 云服务器（Elastic Compute Service, 简称ECS），是一种简单高效，处理能力可以弹性伸缩的计算服务。ECS的相关术语说明如下： 实例（Instance）：是一个虚拟的计算环境，由CPU、内存、系统盘和运行的操作系统组成；ECS实例作为云服务器最为核心的概念，其他资源，比如磁盘、IP、镜像、快照等，只有与ECS结合后才具有使用意义。 地域（Region）：指ECS实例所在的物理位置。地域内的ECS实例内网是互通的，不同的地域之间ECS实例内网不互通。 可用区（Zone）：指在同一地域内，电力和网络互相独立的物理区域。 磁盘（Disk）：是为ECS实例提供数据块级别的数据存储。可以分为4类： 普通云盘、SSD云盘、高效云盘和本地SSD磁盘 快照（Snapshot）：是某一个时间点上某个磁盘的数据拷贝。 镜像（Image）：是ECS实例运行环境的模板，一般包括操作系统和预装的软件。 安全组（Security Group）：是一种虚拟防火墙，具备状态检测包过滤功能。每个实例至少属于一个安全组。同一个安全组内的实例之间网络互通，不同安全组的实例之间默认内网不通，但是可以授权两个安全组之间互访。 虚拟主机、ECS云服务器、VPS区别汇总1、虚拟主机 虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。 2、VPS 先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。 3、ECS云服务器 现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下： 使用VScode连接阿里云远程服务器安装Remote-ssh插件在云服务器控制台选择安全组配置，加入ssh(22)的端口 shell常见的 Shell 有 sh、bash、csh、tcsh、ash 等。#!/bin/bash是指此脚本使用/bin/bash来解释执行。脚本文件后缀是.sh100个shell脚本 系统操作篇帮助命令man 帮助man 是 manual 的缩写 • # man ls help 帮助shell（命令解释器）⾃带的命令称为内部命令，其他的是外部命令• 内部命令使⽤ help 帮助• # help cd• 外部命令使⽤help帮助• # ls –helpinfo 帮助 info 帮助⽐ help 更详细，作为 help 的补充• # info ls 文件管理⽂件查看1234567891011121314151617pwd #显示当前的⽬录名称ls #查看当前⽬录下的⽂件 #参数： #-l ⻓格式显示⽂件 #-a 显示隐藏⽂件 #-r 逆序显示 #-t 按照时间顺序显示 #-R 递归显示cd #更改当前的操作⽬录cat #⽂本内容显示到终端head #查看⽂件开头tail #查看⽂件结尾wc #统计⽂件内容信息 ⽬录⽂件的创建与删除123mkdir #建⽴⽬录rmdir #删除空⽬录rm -r #删除⾮空⽬录 通配符123456常⽤通配符• * 匹配任何字符串• ？ 匹配1个字符串• [xyz] 匹配xyz任意⼀个字符• [a-z] 匹配⼀个范围• [!xyz] 或 [^xyz] ⽂件操作123456789101112cp #复制⽂件和⽬录 #常⽤参数 #-r 复制⽬录 #-p 保留⽤户、权限、时间等⽂件属性 #-a 等同于 -dpRmv [选项] 源⽂件 ⽬标⽂件/⽬录 #移动⽂件rm [选项] #删除⽂件 #常⽤参数 #-r 删除⽬录（包括⽬录下的所有⽂件） #-f 删除⽂件不进⾏提示 删除123456789# Linux删除文件夹命令rm -rf /var/log/httpd/access将会删除/var/log/httpd/access目录以及其下所有文件、文件夹# Linux删除文件命令rm -f /var/log/httpd/access.log将会强制删除/var/log/httpd/access.log这个文件 vim使用基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是： 命令模式：用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。x 删除当前光标所在处的字符。切换到底线命令模式，以在最底一行输入命令。若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。• i I a A o O 进⼊插⼊模式• v V ctrl+v 进⼊可视化模式• ： 进⼊命令模式• esc 从其他模式回到正常模式 ggdG 插入模式（Insert mode）只有在插入模式下，才可以做文字输入，按「ESC」键可回到命令行模式。在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符ENTER，回车键，换行BACK SPACE，退格键，删除光标前一个字符DEL，删除键，删除光标后一个字符方向键，在文本中移动光标HOME/END，移动光标到行首/行尾Page Up/Page Down，上/下翻页Insert，切换光标为输入/替换模式，光标将变成竖线/下划线ESC，退出输入模式，切换到命令模式 底行命令模式将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。在命令行模式下，按冒号「:」键，进入底行模式 :w filename 文件以filename为文件名保存 :wq 文件存盘并退出vim :q 文件不存盘并退出vim :q! 文件不存盘强制退出vim• :w 写⼊• :q 退出• :! 执⾏ Shell 命令• :s 替换• / 查找• :set 设置命令 常用命令行模式下 ？ :s 命令来替换字符串 :s/gald/glad/ :s/java/Linux/g :X 设置密码 Vi编辑文件无法保存退出的解决方法解决方法：第一种：：w!!直接保存并退出 或者 ：wq!!第二种：强制退出后，用sudo vi +文件重新编辑，此时便是以root权限进行修改文件，可以正常保存并退出第三：用此命令进行:w !sudo tee %进行保存退出 软件包管理器软件包管理器是⽅便软件安装、卸载，解决软件依赖关系的重要⼯具 linux系统基本上分两大类： RedHat系列：Redhat、Centos、Fedora等使⽤ yum 包管理器，软件安装包格式为 rpm，安装rpm包的命令是 “rpm -参数”包管理工具 yum支持tar包 Debian系列：Debian、Ubuntu等使⽤ apt 包管理器，软件安装包格式为 deb，安装deb包的命令是 “dpkg -参数”包管理工具 apt-get支持tar包 yumyum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令 12345678910111213141516171819201. 列出所有可更新的软件清单命令：yum check-update2. 更新所有软件命令：yum update3. 仅安装指定的软件命令：yum install &lt;package_name&gt;4. 仅更新指定的软件命令：yum update &lt;package_name&gt;5. 列出所有可安裝的软件清单命令：yum list6. 删除软件包命令：yum remove &lt;package_name&gt;7. 查找软件包命令：yum search &lt;keyword&gt;8. 清除缓存命令:yum clean packages: 清除缓存目录下的软件包yum clean headers: 清除缓存目录下的 headersyum clean oldheaders: 清除缓存目录下旧的 headersyum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers 配置yum仓库yum就是一个硕大的软件仓库，里面保存了几乎所有的常用工具，只需要为系统提供软件包名称即可。 1234# 先切换到yum源中的配置目录cd /etc/yum.repos.d/ yum无法使用yum服务使用的默认python版本是python2更换yum源 12345678vim /usr/bin/yum #先看下/usr/bin/yum文件内容#查看系统默认安装的yumrpm -qa|grep yumyum update wgetwget是Linux中的一个下载文件的工具，后来被移植到包括Windows在内的各个平台上。 1234#安装wgetyum install -y wget#查看帮助手册wget --help ⼆进制安装源代码编译安装Linux 的备份压缩gzip命令gzip是用来压缩和解压.gz文件的命令。gzip命令只能压缩单个文件，而不能把一个文件夹压缩成一个文件（与打包命令的区别） 1234567891011#会将文件压缩为文件 test.txt.gz，原来的文件则没有了gzip /home/aistudio/work/test.txt#解压文件,原来的文件则没有了gzip -d /home/aistudio/test.gz#参数-r或--recursive：递归压缩指定文件夹下的文件（该文件夹下的所有文件被压缩成单独的.gz文件）；-v或--verbose：显示指令执行过程。 tar命令用来打包或者解包 后缀名为.tar 12345678#参数 -c或--create：建立新的备份文件； -x或--extract或--get：从备份文件中还原文件 (解包)； -v：显示指令执行过程； -f或--file：指定备份文件； -C：指定目的目录； -z：通过gzip指令处理备份文件； -j：通过bzip2指令处理备份文件。 zip和unzipzip命令和unzip命令用在在Linux上处理.zip的压缩文件。 12345678910#常用参数#zip:-v：显示指令执行过程；-m：不保留原文件；-r：递归处理。#unzip: -v：显示指令执行过程； -d：解压到指定目录。 用户与权限管理多⽤户操作系统的⽬的是隔离• ⽤户权限隔离• 系统资源隔离• root ⽤户与普通⽤户的区别 ⽤户管理常⽤命令12345678910111213141516171819202122232425# 增加用户，并创建主目录useradd -m 用户名# 删除用户所有信息，并删除主目录userdel -r 用户名#在root 账户修改普通用户的密码passwd [选项] 用户名passwd #修改root密码chage #修改⽤户属性#使用sudo命令可简单快速禁用用户sudo passwd -l new #重新启用用户账户sudo passwd -u new#组管理命令groupadd #新建⽤户组groupdel #删除⽤户组 ⽤户切换123su #切换⽤户su root #切换到 root 用户sudo #以其他⽤户身份执⾏命令 ⽤户配置⽂件• /etc/passwd ⽤户配置⽂件• /etc/shadow ⽤户密码相关配置⽂件• /etc/group ⽤户组配置⽂件 -rw-r-xr– 1 userame groupname mtime filename • rw- ⽂件属主的权限 • r-x ⽂件属组的权限 • r– 其他⽤户的权限 文件权限⽂件权限的表示⽅法 • r = 4 ：读 • w = 2 ：写 • x(execute)= 1 :执行 文件调用权限分为三级 : 文件所有者/属主（Owner）、用户组/属组（Group）、其它用户（Other Users）。 1234# 查看当前目录下所有文件权限ls -l #简写 ll ll |grep 文件名 #查看指定文件权限 修改权限命令要通过su进入到root权限中 1234chmod abc filename #修改⽂件、⽬录权限chown #更改属主、属组 指令中的a、b、c分别表示一个数字，其中a对应文件所有者权限，b对应文件所有者所在组权限，c对应其他身份权限。 • r = 4 ：读 • w = 2 ：写 • x(execute)= 1 :执行 chmod 777 xxxx，第1个7表示文件对于文件所有者来说可读可写可执行；第2个7表示文件对于文件所有者所在组来说可读可写可执行；第3个7表示文件对于其他身份的用户来说可读可写可执行。 系统管理⽹络管理⽹络状态查看1. net-tools• ifconfig• route• netstat2. iproute2• ip• ss ⽹络配置路由命令⽹络故障排除⽹络服务管理常⽤⽹络配置⽂件linux使用linux文件目录理解/home存放所有用户文件的根目录，是用户主目录的基点 比如用户user的主目录就是/home/user，可以用~user表示 /usr用于存放系统应用程序，可以理解为C:/Windows/ /usr/local用户级的程序目录，可以理解为C:/Progrem Files/ 用户自己编译的软件默认会安装到这个目录下 本地系统管理员软件安装目录（安装系统级的应用） 这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录 用的是root的空间。 Linux开机自动启动软件/可执行程序首先关注几个脚本/etc/rc.d/rc.local：该脚本在系统启动时被执行一次；/etc/profile:该脚本在所有用户登陆时会被执行一次；~/.bashrc:该脚本在用户登陆时被执行一次，与/etc/profile不同的是，bashrc文件每个用户拥有独立的一个。 若设置开机启动，应该修改：/etc/rc.d/rc.local文件。 环境变量1、修改 /etc/profile 文件，如果你的计算机仅仅作为开发使用时推存使用这种方法，因为所有用户的shell都有权使用这个环境变量，可能会给系统带来安全性问题。这里是针对所有的用户的，所有的shell vi /etc/profile 在/etc/profile的最下面添加： export PATH=”$PATH:/NEW_PATH” 针对当前特定的用户起作用的环境变量 2、修改bashrc文件，这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，这里是针对某一特定的用户，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的 .bashrc文件就可以了。 vi ~/.bashrc 在下面添加： Export PATH=”$PATH:/NEW_PATH” xshellXShell是一个强大的安全终端模拟软件,可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。安装参考 远程连接选择导航菜单的文件 –&gt; 新建，输入名称和主机IP，协议默认SSH，端口默认22，如果不知道主机IP可以登录虚拟机的Linux系统，输入命令ifconfig查看(inet addr) 然后在左侧用户身份验证中输入用户名和密码，这样下次就可以直接连接了，当然如果为了安全考虑也可以不输入密码，在每次连接时再输入。 Xshell怎么与云服务器连接打开Xshell，新建一个会话 主机填服务器ip,点击连接 用户名默认为root,而不是实例名，也不是你服务器中Linux的用户名；密码则为服务器实例密码 centos内核1234# 版本信息cat /etc/centos-release # 查看Linux内核信息uname -a 网络配置1234567#使用图形界面配置网络命令nmtui#重新启动网络服务命令systemctl restart network#显示你所有操作的历史命令history NAT配置检查环境: 能上网，安装了net-tools.（1）能否上网（ping www.baidu.com)如不能上网。配置/etc/sysconfig/network-scripts/ifcfg-ens33（2）是否安装了 net-tools. (因为需要使用命令 route )如没有， yum -y install net-tools 搭建网络一台Sever (2张网卡） + 一台 Client（一张网卡） 安装（或克隆）一台虚拟机名为：Client. 原来那台可改名叫（Server)。Server 上再安装一张网卡，并配成“仅主机模式”。（原来应该那一张应该为NAT模式）。Client 网卡配成 “仅主机模式” 配置NAT（1）开启Server 和 Client, 用 root 登录。（2）在Server 上运行： ip addr记录下 ens37 (也就是Server 的第二张网卡） 的ip：192.168.221.128（3）设置Client网关，在Client 上 运行:route add default gw 192.168.221.128 #添加一条默认网关（如要查看网关 是否设置成功，可以运行：route -n) （4）在Server设置地址伪装 ， 运行： (5）重启防火墙systemctl restart firewalld.service (6)在Client 上ping测试是否成功 (7)在Client上配置本地DNS:去到目录 /etc 下， 用vi 编辑 文件 “resolv.conf” 宝塔Linux面板https://blog.csdn.net/vpssws/article/details/117136583?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3 安装12345678910111213141516# Centos安装命令：yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh# Ubuntu/Deepin安装命令：wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh#显示面板的使用帮助菜单选项。bt#卸载面板wget http://download.bt.cn/install/bt-uninstall.sh#执行脚本：sh bt-uninstall.sh 安装软件时，推荐使用编译安装 面板特色功能：一键配置服务器环境（LAMP/LNMP）一键安全重启一键创建管理网站、ftp、数据库一键部署SSL证书一键部署源码（discuz、wordpress、dedecms、z-blog、微擎等等）一键配置（定期备份、数据导入、伪静态、301、SSL、子目录、反向代理、切换PHP版本）一键安装常用PHP扩展(fileinfo、intl、opcache、imap、memcache、apc、redis、ioncube、imagick)数据库一键导入导出系统监控（CPU、内存、磁盘IO、网络IO）防火墙端口放行SSH开启与关闭及SSH端口更改禁PING开启或关闭方便高效的文件管理器（上传、下载、压缩、解压、查看、编辑等等）计划任务（定期备份、日志切割、shell脚本）软件管理（一键安装、卸载、版本切换） 添加站点添加站点就是添加一个域名进去，通过这个域名可以访问你的网页，或者直接填写你的ip进去，然后浏览器输入你的ip访问一下就看到结果了 LNMP 环境LNMP 是 Linux、Nginx、MariaDB 和 PHP 的缩写，这个组合是最常见的 Web 服务器的运行环境之一。用宝塔面板一键安装 ftp服务centos搭建dhcp服务器DHCP是一种局域网协议，当我们搭建好DHCP服务器后，它可以自动分发IP地址和网关给客户机 1.准备两台虚拟机就可以，一台做服务器，一台做客户机·。 2.开始配置服务器，右击打开终端。进入管理员模式（命令为su root），先安装DHCP服务器的软件包（虚拟机要联网），用 yum install dhcp -y 命令安装（-y 表示接下来系统弹出是请求都默认是yes）dhcp-4.2.5-83.el7.centos.1.x86_64 这个软件包一定要有。里面有默认的配置文件。 然后用vim /etc/dhcp/dhcpd.conf命令进入默认的主配置文件， 复制/usr/share/doc/dhcp*/dhcpd.conf.example这个路径cp /usr/share/doc/dhcp*/dhcpd.conf.example /etc/dhcp/dhcpd.conf CentOS7配置本地yum源脚本配置本地源vim /root/auto_source.sh #创建脚本文件,编辑内容如下 1234567891011121314151617181920212223242526#!/bin/bash# 创建本地源文件夹,作为光盘的挂载点mkdir -p /media/centos/# 挂载镜像文件至指定的目录mount /dev/cdrom /media/centos# 备份原本地源cp -rf /etc/yum.repos.d /etc/yum.repos.d_$(date '+%Y%m%d_%H%M%S')# 删除默认原本地源rm -rf /etc/yum.repos.d/*# 配置本地源,创建Media.repo文件,并配置如下内容cd /etc/yum.repos.d/&gt;Media.repoecho '[iso]' &gt;&gt; Media.repoecho 'name=Media' &gt;&gt; Media.repo#地址为你自己的光盘挂载地址echo 'baseurl=file:///media/centos/' &gt;&gt; Media.repoecho 'gpgcheck=0' &gt;&gt; Media.repo#enabled=1, 让这个yum源配置文件生效echo 'enabled=1' &gt;&gt; Media.repo# 清除yum缓存yum clean all# 缓存本地yum源yum makecache chmod +x /root/auto_source.sh # 赋予脚本可执行的权限/root/auto_source.sh #执行脚本文件，即可 编写脚本","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wenkex.gitee.io/tags/linux/"}]},{"title":"python数据结构","slug":"数据结构与算法","date":"2022-02-19T04:04:47.000Z","updated":"2022-02-19T04:04:47.000Z","comments":true,"path":"2022/02191106.html","link":"","permalink":"https://wenkex.gitee.io/2022/02191106.html","excerpt":"","text":"https://www.yiibai.com/python/py_data_structure/python_data_structure_introduction.html 线性数据结构这些是以顺序方式存储数据元素的数据结构。例如 - 数组: 它是与数据元素的索引配对的数据元素的顺序排列。链表: 每个数据元素都包含一个指向另一个元素的链接及其中的数据。链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据。链表中每一个节点都包含此节点的数据和指向下一节点地址的指针。由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。 这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点。不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用。 一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。 链表和数组对比链表和数组在实际的使用过程中需要根据自身的优劣势进行选择。链表和数组的异同点也是面试中高频的考察点之一。这里对单链表和数组的区别进行了对比和总结。 堆栈: 这是一种仅遵循特定操作顺序的数据结构。LIFO(后进先出)或FILO(先进先出)。队列: 与堆栈(Stack)类似，但操作顺序仅为FIFO(先进先出)。矩阵: 它是二维数据结构，其中数据元素由一对索引引用。 非线性数据结构这些数据结构中没有数据元素的顺序链接。任何一对或一组数据元素都可以相互关联，并且可以在没有严格顺序的情况下进行访问。 二叉树:它是一个数据结构，每个数据元素可以连接到最多两个其他数据元素，并以一个根节点开始。堆: 这是树形数据结构的特殊情况，其中父节点中的数据严格大于/等于子节点或严格小于其子节点。哈希表: 它是一个数据结构，它由使用散列函数相互关联的数组构成。它使用键而不是数据元素的索引来检索值。图: 它是顶点和节点的排列，其中一些节点通过链接彼此连接。 数组数组可以说是最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。 跳表从上面的对比中可以看出，链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。 图片 跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前redis和levelDB都有用到跳表。 从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查询的目的。 栈栈是一种比较简单的数据结构，常用一句话描述其特性，后进先出。栈本身是一个线性表，但是在这个表中只有一个口子允许数据的进出。这种模式可以参考腔肠动物…即进食和排泄都用一个口… 栈的常用操作包括入栈push和出栈pop，对应于数据的压入和压出。还有访问栈顶数据、判断栈是否为空和判断栈的大小等。由于栈后进先出的特性，常可以作为数据操作的临时容器，对数据的顺序进行调控，与其它数据结构相结合可获得许多灵活的处理。 图片 队列队列是栈的兄弟结构，与栈的后进先出相对应，队列是一种先进先出的数据结构。顾名思义，队列的数据存储是如同排队一般，先存入的数据先被压出。常与栈一同配合，可发挥最大的实力。 图片 树树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。常见的数的表示形式更接近“倒挂的树”，因为它将根朝上，叶朝下。 树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。 这意味着树是具备层次关系的，父子关系清晰，家庭血缘关系明朗；这也是树与图之间最主要的区别。 图片 别看树好像很高级，其实可看作是链表的高配版。树的实现就是对链表的指针域进行了扩充，增加了多个地址指向子结点。同时将“链表”竖起来，从而凸显了结点之间的层次关系，更便于分析和理解。 树可以衍生出许多的结构，若将指针域设置为双指针，那么即可形成最常见的二叉树，即每个结点最多有两个子树的树结构。二叉树根据结点的排列和数量还可进一度划分为完全二叉树、满二叉树、平衡二叉树、红黑树等。 图片 完全二叉树：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。 满二叉树：除了最后一层，其它层的结点都有两个子结点。 平衡二叉树平衡二叉树又被称为AVL树，它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 二叉排序树：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。 树的高度：结点层次的最大值 平衡因子：左子树高度 - 右子树高度 二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点&lt;根节点&lt;右结点，这表明二叉排序树的中序遍历结果是有序的。（还不懂二叉树四种遍历方式[前序遍历、中序遍历、后序遍历、层序遍历]的同学赶紧补习！） 图片 平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。 图片 平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。 在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。 左旋：S为当前需要左旋的结点，E为当前结点的父节点。 图片 左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。可用动画表示： 图片 右旋：S为当前需要左旋的结点，E为当前结点的父节点。右单旋是左单旋的镜像旋转。 图片 左旋的操作同样可以用一句话简单表示：将当前结点S的左孩子E的右孩子旋转为当前结点S的左孩子，同时将当前结点S旋转为左孩子E的右孩子。可用动画表示： 图片 红黑树平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致AVL的插入和删除效率并不高。 为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。 红黑树具有五个特性： 每个结点要么是红的要么是黑的。根结点是黑的。每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。如果一个结点是红的，那么它的两个儿子都是黑的。对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。图片红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。 红黑树VS平衡二叉树图片 除了上面所提及的树结构，还有许多广泛应用在数据库、磁盘存储等场景下的树结构。比如B树、B+树等。这里就先不介绍了诶，下次在讲述相关存储原理的时候将会着重介绍。（其实是因为懒） 7 堆了解完二叉树，再来理解堆就不是什么难事了。堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。 对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此可以直接用数组来表示一个堆。 不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 图片 堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如堆排序、topK问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。 8 散列表散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射。散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。 图片 散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数： 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。 数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。 平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。 取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。 除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。 确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。 冲突在发生之后，当在对不同的key值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。 常用的冲突处理方式有很多，常用的包括以下几种： 开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。 再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。 链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。 公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。 目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。 图片 左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。 9 图图相较于上文的几个结构可能接触的不多，但是在实际的应用场景中却经常出现。比方说交通中的线路图，常见的思维导图都可以看作是图的具体表现形式。 图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。 图片 图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。 邻接矩阵目前常用的图存储方式为邻接矩阵，通过所有顶点的二维矩阵来存储两个顶点之间是否相连，或者存储两顶点间的边权重。 图片 无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，若能从此顶点能够到达彼顶点，那么彼顶点自然也能够达到此顶点。此外，由于顶点本身与本身相连没有意义，所以在邻接矩阵中对角线上皆为0。 图片 有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。用邻接矩阵可以直接从二维关系中获得任意两个顶点的关系，可直接判断是否相连。但是在对矩阵进行存储时，却需要完整的一个二维数组。若图中顶点数过多，会导致二维数组的大小剧增，从而占用大量的内存空间。 而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。 因此，为了解决上述问题，一种可以只存储相连顶点关系的邻接表应运而生。 邻接表在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点。相较于无向图，有向图的情况更为复杂，因此这里采用有向图进行实例分析。 图片在邻接表中，每一个顶点都对应着一条链表，链表中存储的是顶点能够达到的相邻顶点。存储的顺序可以按照顶点的编号顺序进行。比如上图中对于顶点B来说，其通过有向边可以到达顶点A和顶点E，那么其对应的邻接表中的顺序即B-&gt;A-&gt;E，其它顶点亦如此。 通过邻接表可以获得从某个顶点出发能够到达的顶点，从而省去了对不相连顶点的存储空间。然而，这还不够。对于有向图而言，图中有效信息除了从顶点“指出去”的信息，还包括从别的顶点“指进来”的信息。这里的“指出去”和“指进来”可以用出度和入度来表示。 入度：有向图的某个顶点作为终点的次数和。 出度：有向图的某个顶点作为起点的次数和。 由此看出，在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。 逆邻接表逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。 图片 邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。 十字链表十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。 图片 但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。 十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端） data：用于存储该顶点中的数据； firstin指针：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点； firstout指针：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点； 边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接： tailvex：用于存储作为弧尾的顶点的编号； headvex：用于存储作为弧头的顶点的编号； headlink 指针：用于链接下一个存储作为弧头的顶点的节点； taillink 指针：用于链接下一个存储作为弧尾的顶点的节点； 图片 以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边AE（即边04）指向顶点E，顶点A的firstout指针需要指向边04的tailvex。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边AB（即边10）指向B，顶点A的firstin指针需要指向边10的弧头，即headlink指针。依次类推。 十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。 10 总结数据结构博大精深，没有高等数学的讳莫如深，也没有量子力学的玄乎其神，但是其在计算机科学的各个领域都具有强大的力量。本文试图采用图解的方式对九种数据结构进行理论上的介绍，但是其实这都是不够的。 即便是简单的数组、栈、队列等结构，在实际使用以及底层实现上都会有许多优化设计以及使用技巧，这意味着还需要真正把它们灵活的用起来，才能够算是真正意义上的熟悉和精通。但是本文可以作为常见数据结构的一个总结，当你对某些结构有些淡忘的时候，不妨重新回来看看。 算法常见的题型面试或者白板编程，由于形式的限制，题目的选择范围其实并不大。并不难理解，毕竟面试的时间有限，也不能全拿来做题，而太困难太复杂的问题候选人一点思路也没有，大部分人都做不上来，也完全起不到考察和筛选的意义。 所以拿来当做面试和白板编程的问题，不会很复杂，至少会保证绝大多数的候选人都听说过。就好像打游戏一样，哪怕是玩家津津乐道的魂游戏，总要有过关的可能。如果上来就考察一个问题，结果你连正解用到的算法都没听说过，一开始就没有做出来的可能，这种问题问了就只能浪费时间。 根据我的经验，面试当中常问的问题基本上就这几种：二分、递归、分治、排序、动态规划。 这几种算法只要是科班出身，基本上都或多或少听说过，理论上来说都应该能做出来。并且这些算法除了比较基础之外，它们的代码量都不大，一般核心代码都不会超过30行，确保编码的时间不会太长。第二是比较考验思维，通过你对这几个算法的理解深度，就足以看出来你的思维能力和算法能力了。 解题套路1.缩小问题规模有可能问题里问的是一个规模很大的问题，比如汉诺塔问题，要移动64个圆盘，这太复杂了，我们根本无法思考。不妨把问题的规模缩小，比如缩小到3个圆盘，然后我们就可以列举一下情况，找找规律和套路了。 即使是在acm赛场当中，这个方法也非常管用。 2.确定复杂度在acm赛场上题目当中都会标明数据的大小范围，除了起到限制作用之外也是一个很大的提示。我们可以根据数据的规模反推出正解的复杂度范围，从而排除掉一些不可能的算法。 比如说要在个数当中寻找某个数，由于计算机每秒的运行次数在这个量级，这么大的规模遍历一遍都有些扛不住，那么显然正解的复杂度一定在及以下。这么一来，我们就可以根据算法的复杂度排除掉一大批达不到要求的算法，排除错误的选项。 在面试的时候面试官往往不会明确给出数据的规模，我们可以自己结合实际情况分析，当然直接提问也是一个不错的选择。 3.优化思路面试不是比赛，并不是一定要给出正解。有的时候，我们一时陷入误区没想到解法也是常有的。重要的并不是我们是否想出了解法，而是我们能否展现我们思维的能力，打动面试官。 所以有的时候一下子没有想到最优解也没有关系，我们可以先易后难，先把一些简单可行的解法说出来，然后再进行优化。 比如LeetCode第4题，寻找两个有序数组的中位数。我们当然很难一下子想出的正解，但是我们可以先从最简单的方法说起。比如重新排序直接寻找，这样操作的复杂度是。说出这个方法之后，我们接着从不使用排序解决问题的角度继续思考，如此一步步逐渐深入，即使最终没能找到正解，也体现出了我们的思考是有章法的，并且思考和分析问题的能力是有的。 建议1.贵精不贵多如果是为了准备面试，就像我前面列举的一样，其实并不会涉及很多内容。相比去研究很多高大上面试的时候用不到的高大上算法，倒不如好好把这几个算法啃扎实。 就拿排序来说，想要全部搞明白就很不简单。我随便写几个问题，大家不妨对照一下看看能不能回答上来。 冒泡排序和选择排序有什么区别？ 为什么说快速排序和归并排序都基于分治算法，但它们的最差复杂度不同？ 排序的稳定性是什么？哪些算法是稳定的，哪些不是？ 关于快速排序算法的最差复杂度，有哪些优化？ 如果都能不仅仅满足原理，而是可以深入到细节的方方面面去钻研，那么即使只是准备了几个算法，应付一般的面试都不在话下。 2.成体系化训练算法的学习过程是比较痛苦的，尤其是如果我们漫无目的地去训练和学习，进展非常缓慢，非常劝退。很多同学都有刷题刷了一堆，但是水平好像没什么提升的情况。 我个人感觉比较有效的方法是成体系化的训练，不要按照题目顺序刷题，而是以算法划分专题，按照专题刷题。一个算法一个算法的硬啃，一个算法吃透再吃下一个。这样训练下来印象会非常深刻，对于算法的理解也会深刻得多，也不容易忘记。要比题目刷了一堆， 算法也用了一堆， 看起用得多，但也忘得多要好得多。 复杂度 时间复杂度有几次循环就有o(n的几次方) 空间复杂度用来评估算法内存占用大小的一个式子 递归简单说程序调用自身的编程技巧叫递归。递归的思想是把一个大型复杂问题层层转化为一个与原问题规模更小的问题，问题被拆解成子问题后，递归调用继续进行，直到子问题无需进一步递归就可以解决的地步为止。 使用递归需要避免出现死循环，为了确保递归正确工作，递归程序应该包含2个属性： 终止条件：用于保证程序调用及时返回，不在继续递归，保证了程序可终止。 递推关系（recurrentce relation），可将所有其他情况拆分到基本案例。 动态规划动态规划问题的一般形式就是求最值。比如说让你求最长递增子序列呀，最小编辑距离呀等等。 求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。 而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。 另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」才能正确地穷举。 以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程： 明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义。 动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。 要详细考虑的问题 dp数组初始化以及下标的定义 递推公式 遍历顺序 打印dp数组 步骤1.划分问题：按照问题的特征，把问题分为若干阶段。注意：划分后的阶段一定是有序的或者可排序的 2.确定状态和状态变量：将问题发展到各个阶段时所处的各种不同的客观情况表现出来。状态的选择要满足无后续性 3.写出状态转移方程：状态转移就是根据上一阶段的决策和状态来导出本阶段的状态。根据相邻两个阶段状态之间的联系来确定决策方法和状态转移方程 4.边界条件：状态转移方程是一个递推式，因此需要找到递推终止的条件 1或2时即： 【初始状态】→【决策1】→【决策2】→…→【决策n】→【结束状态】 背包问题01背包 打家劫舍股票问题子序列问题斐波那契数列123sum = dp[0]+dp[1]dp[0]=dp[1]dp[1]=sum 二分查找https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/ 一个范围，具有单调性质，因此可以使用二分来做。 在升序数组 nums 中寻找目标值 target，对于特定下标 i，比较nums[i] 和 target 的大小： 如果 nums[i]=target，则下标 i即为要寻找的下标； 如果 nums[i]&gt;target，则 target 只可能在下标 i的左侧； 如果 nums[i]&lt;target，则 target 只可能在下标 i的右侧。 二分查找的做法是，定义查找的范围 [left,right]，初始查找范围是整个数组。每次取查找范围的中点mid，比较nums[mid] 和 target 的大小，如果相等则mid 即为要寻找的下标，如果不相等则根据nums[mid] 和 target 的大小关系将查找范围缩小一半。 由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(logn)，其中 n 是数组的长度。 二分查找的条件是查找范围不为空，即left≤right。如果 target 在数组中，二分查找可以保证找到 target，返回 target 在数组中的下标。如果 target 不在数组中，则当{left} &gt;{right}left&gt;right 时结束查找，返回−1。 12345678910111213141516171819202122class Solution: def isPerfectSquare(self, num: int) -&gt; bool: left, right = 0, num #定义二分查找搜索区间的初始边界。 #在移动左侧边界left和右侧边界right时，新的搜索区间都不会包含被检查的下标mid，所以搜索边界始终没有检查过， #当left=right时，我们仍需要检查mid=(right+right)//2 while left &lt;= right: #循环直至区间左右端点相同 #mid = (left + right) // 2 #设定中间值 #括号内的值要为0 mid = (right-left)//2+left #防止整型溢出，python则不需要这句，应为int可任意放大 if square &lt; num: left = mid + 1 elif square &gt; num: right = mid - 1 else: return mid return left #此时有left==right,区间缩为一个点，即为答案# 时间复杂度：)O(logn)，其中 n为正整数 num 的最大值。# 空间复杂度：O(1)。 二分查找模板查找过程首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 边界问题总结为一句话：左闭左+1，右闭右-1，开区间选mid 二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。相信很多同学都和我一样，在条件判断时总是不知道是 while(left &lt; right) 还是 while(left &lt;= right)，到底是right = mid呢，还是要right = mid - 1呢？ 大家写二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 写二分法，区间的定义有以下四种，左闭右闭即[left, right]，或者左闭右开即[left, right)，或者左开右闭即(left, right]，或者左开右开即(left, right)，其中左闭右闭即[left, right]比较常用，基本思路不变只是控制了一些变量选择 下面我用这四种区间的定义分别讲解四种不同的二分写法。 以下分析基于理论情况，实际题目中我们比较常用第一种情况和第二种情况 左闭右闭即[left, right]第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] （这个很重要非常重要）。 区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间： 1234567891011121314151617181920// 版本一while(left &lt;= right)// 因为left == right的时候，在[left, right]是有效的空间，即相等时可以取到该元素，所以使用 &lt;={ int mid = (left + right)/2; //如果left+right过大，导致和溢出，可以用mid = left + (right - left) / 2,防止溢出left+right if(nums[mid] &gt; target) //right 要赋值为 mid - 1，因为当前这个nums[mid]一定不是target，那么接下来要查找的左区间结束下标位置就是 mid - 1，因为区间 -1了，所以取不到mid了 { right = mid - 1;// target 在左区间，所以[left, mid - 1] } else if(nums[mid] &lt; target) //left 要赋值为 mid +1，因为当前这个nums[mid]一定不是target，那么接下来要查找的右区间结束下标位置就是 mid + 1，因为区间 +1了，所以取不到mid了 { left = mid + 1;// target 在右区间，所以[mid + 1, right] } else if(nums[mid] == target) { return mid;// 数组中找到目标值，直接返回下标 }}//当 2.左闭右开即[left, right) 1234567891011121314151617181920// 版本二while(left &lt; right)// 因为left == right的时候，在[left, right)是无效的空间，即相等时取不到该元素，所以使用 &lt;{ int mid = (left + right)/2; //如果left+right过大，导致和溢出，可以用mid = left + (right - left) / 2,防止溢出left+right if(nums[mid] &gt; target) { right = mid;// target 在左区间，所以[left, mid) } else if(nums[mid] &lt; target) { left = mid + 1;// target 在右区间，所以[mid + 1, right) } else if(nums[mid] == target) { return mid;// 数组中找到目标值，直接返回下标 }} 3.左开右闭即(left, right] 1234567891011121314151617181920// 版本三while(left &lt; right)// 因为left == right的时候，在(left, right]是无效的空间，即相等时取不到该元素，所以使用 &lt;{ int mid = (left + right)/2; //如果left+right过大，导致和溢出，可以用mid = left + (right - left) / 2,防止溢出left+right if(nums[mid] &gt; target) { right = mid - 1;// target 在左区间，所以(left, mid] } else if(nums[mid] &lt; target) { left = mid;// target 在右区间，所以(mid + 1, right] } else if(nums[mid] == target) { return mid;// 数组中找到目标值，直接返回下标 }} 4.左开右开即(left, right) 1234567891011121314151617181920// 版本四while(left &lt; right)// 因为left == right的时候，在(left, right)是无效的空间，即相等时取不到该元素，所以使用 &lt;{ int mid = (left + right)/2; //如果left+right过大，导致和溢出，可以用mid = left + (right - left) / 2,防止溢出left+right if(nums[mid] &gt; target) { right = mid;// target 在左区间，所以(left, mid) } else if(nums[mid] &lt; target) { left = mid;// target 在右区间，所以(mid, right) } else if(nums[mid] == target) { return mid;// 数组中找到目标值，直接返回下标 }}","categories":[{"name":"pytohn","slug":"pytohn","permalink":"https://wenkex.gitee.io/categories/pytohn/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wenkex.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"微信小程序","slug":"微信小程序","date":"2022-01-24T09:33:43.000Z","updated":"2022-01-24T09:33:43.000Z","comments":true,"path":"2022/012435506.html","link":"","permalink":"https://wenkex.gitee.io/2022/012435506.html","excerpt":"","text":"目录结构pages用来存放所有小程序的页面utils用来存放工具性质的模块(例如：格式化时间的自定义模块)app. js小程序项目的入口文件app.json小程序项目的全局配置文件app.Wxss小程序项目的全局样式文件project. config. json项目的配置文件sitemap json用来配置小程序及其页面是否允许被微信索引","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkex.gitee.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://wenkex.gitee.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"window使用","slug":"window使用","date":"2022-01-22T01:09:49.000Z","updated":"2022-01-22T01:09:49.000Z","comments":true,"path":"2022/012246677.html","link":"","permalink":"https://wenkex.gitee.io/2022/012246677.html","excerpt":"","text":"输入法不认识的汉字怎么打u+汉字各部分的拼音 扩展屏幕如何在笔记本盖上盖子时，扩展显示屏也能显示。在设置中搜索打开控制面板，然后找到电源选项打开，找到选择关闭笔记本计算机盖的功能 文件无法删除解决Windows10中“其中文件夹或文件已在另一程序中打开”引起的文件删不掉问题 打开任务管理器打开资源监视器1.切换任务管理器到“性能”选项页，点击最下方的“打开资源监视器”字。2.搜索与该文件关联的程序并关闭 以删除word文件“文件123.docx”为例：删除桌面上“文件123.docx”文件，显示该文件已被其他程序打开，暂时无法删除。 此时在资源监视器搜索句柄处填上文件123，即可搜索与这个文件相关联的应用程序句柄。点击与文件123相关联的句柄，然后点击鼠标右键，选择结束进程此时会弹出结束进程确认对话框。点击“结束进程”关闭与“文件123.docx”关联的进程。 怎样关闭Win10安装软件、改变设置时的弹窗？打开更改用户账户设置 Windows系统hosts文件路径为：C:\\Windows\\System32\\drivers\\etc Win10电脑设置定时关机命令：Win +r 输入：shutdown -s -t 3600 一小时后关机 Win10进入开机自启文件夹Win+r进入运行，输入shell:startup 快捷键汇总win+上下箭头键：【最大化】【还原】【最小化】当前窗口 win+左右箭头键：将窗口靠左、靠右。如果有两个窗口则并列 按住ctrl 可多选文件 Win+Shift+S 截图、 Win+g 截图录屏 在英文输入状态下，按住shift输入字母可以大写 按住alt双击文件 快速打开属性 Ctrl+shift+Esc 一键打开任务管理器 Ctrl +shift+n 快速新建文件夹 按住ctrl拖动文件 就是复制 Alt+F4键：关闭当前窗口，如果没有活动窗口就带开【关闭计算机】对话框 win+A键：快速打开【系统通知和控制中心】 Win+E键：快速打开【资源管理器】 win+G键：快速打开【Xbox工具】，这个工具非常实用，包含了截图、录屏等功能 win+I键：快速打开【计算机设置】 win+K键：快速打开【无线连接】 win+L键：快速【锁定屏幕】，如果你要暂时离开电脑，这个快捷键一定要知道 win+P键：快速打开【投影】，如果你要连接第二块屏幕或投影，这是最快捷的方法 win+Q键或者win+S键：快速打开【搜索】 win+R键：快速打开【运行】 win+T键：在【任务栏程序】中进行切换 win+V键：快速打开【剪贴板】 win+W键：快速打开【全屏截图】 win+X键：打开【系统快捷菜单】，这个菜单继承了巨大部分的系统功能。 win+数字键：打开【任务栏】上相应顺序的应用程序 win+加号：启动【放大镜】，加号放大，减号缩小 win+Tab键：打开【任务视图】，还可以按时间线查看近期任务 Alt+Tab键：在打开的程序间进行切换，这是笔者最常用的快捷键 网页ctrl + w 关闭一个网页Ctrl + Tab 切换网页Ctrl+h 打开历史记录 远程微软自带的远程连接联想小新pro16win10专业版两台设备都连着校园网，测试时，控制端不能连着电脑的热点。控制端要下载：RDclient成功后，你就可以不用带上你的电脑去机房上课了，直接在机房控制你的电脑，体验感翻倍 注意1.window要用微软账号登录2.用户名是自己设置的，可以是中文，打开图二密码中的更新安全问题选项也可以看到3. 密码是你的账户密码，不是PIN码哦4. 显示屏关闭后，微软远程就连接不上的原因 联想小新pro16可能是因为开了智能感知功能的原因，因此显示屏关闭或者盖上屏幕，控制端就无法连接上电脑 快捷键打开远程桌面，win+r 输入mstsc查询ip地址：win+r进入cmd,输入ipconfig ToDeskToDesk目前还是免费的且支持三台设备，而且界面简洁大气。 向日葵特点1.控制端和被控制端使用同一账号即可2.可以实时查看远程主机摄像头周围的情况3.方便快捷的让远程文件或本地文件互相传输和同步，安全稳定。4.无需内网穿透即可实现外网连接。需求①是在需要被控的电脑上安装被控端;②在手机上安装向日葵主控端③注册一个向日葵账号。在两端同时登录就可以远程控制了。 Windows Terminal是管理各种命令行的工具，它把目前 Windows 上的 PowerShell、CMD 以及 Windows Linux 子系统（WSL）三大环境实现了统一。 安装打开系统自带的 Microsoft Store，搜索 Windows Terminal 直接安装就可以了。 PowerShell是命令行程序，真正执行指令的程序， 在 Windows 上安装 PowerShellhttps://docs.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.1 安装 oh-my-posh 和 posh-gitoh-my-posh 是 PowerShell 主题管理工具posh-git 可以实现类似 oh-my-zsh 一样的 Git 命令增强工具（命令别名和显示分支信息等） 12Install-Module posh-gitInstall-Module oh-my-posh 配置 PowerShell1234# 这是开启默认配置的Set-Prompt# 设置主题，Agnoster 是主题名Set-Theme Agnoster 美化安装Scoop强大的 Windows 包管理工具 ScoopScoop 可以帮你一行命令安装 git 工具、java 环境、chrome 浏览器、vscode 等等，统一目录管理，而且自动配置环境变量，卸载也只需要一行命令，方便的不能在方便了设置安装路径（可选）。默认 Scoop 是安装在 C 盘的，以及通过 Scoop 安装的软件也是在 C 盘的。如果你的 C 盘空间不够或想安装到其他盘，可以执行以下操作。 123# 设置 scoop 安装路径为 D:\\scoop$env:SCOOP='D:\\scoop'[environment]::setEnvironmentVariable('SCOOP',$env:SCOOP,'User') 安装 Scoop 1234# 将执行权限改为本地无需签名Set-ExecutionPolicy RemoteSigned -scope CurrentUser# 下载并执行脚本iwr -useb get.scoop.sh | iex git bash是Windows下的命令行工具。有git分布式版本控制工具，也主要用于git。 1 在windows下使用linux命令操作 2 登陆远程linux服务器&nbsp;ssh 在window terminal中添加git bashhttps://www.cnblogs.com/cong-wang/p/15026535.html打开设置文件settings.json，在profiles的list中添加一项： 123456{ \"guid\" : \"{5D1F95DF-36E8-56AD-C203-EA75CE06422C}\", \"name\" : \"Git Bash\", \"commandline\" : \"D:\\\\ruanjian\\\\Git\\\\bin\\\\bash.exe --login -i\", \"icon\" : \"D:\\\\ruanjian\\\\Git\\\\git-bash.png\"}, guid：唯一标识本命令行配置，可以使用在线guid工具随机生成一个和list中其他配置不一样的guid即可name：本命令行配置的名字，会显示在菜单中commandline：表示怎么启动一个命令行，这里填的是”E:\\Git\\bin\\bash.exe –login -i”，需要找到你的Git的安装目录，将E:\\Git\\bin\\bash.exe替换成你自己的路径icon：显示在菜单中的图标 沙盒控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能 打开沙盒（在开始菜单中）,直接将要运行的程序，不确定安全性的程序复制粘贴进去就行,关机就清空数据了 Win10进入开机自启文件夹Win+r进入运行，输入shell:startup 联想小新pro16出现问题记录1.蓝牙问题在开启wifi热点时，再连接蓝牙耳机，声音会断断续续；解决：设置wifi热点为5G频道即可 2.wifi 问题电脑连接wifi时开的热点，手机已经连上；当你的电脑切换到以太网连接时，wifi热点不可用解决方法，关掉热点，重新开，电脑将识别到以太网，切换到以太网共享网络 环境变量高级系统设置-环境变量 cmd中一般设置在系统变量的PATH在cmd中，一般先在当前路径下寻找文件，然后再在PATH中设置的目录中寻找 在运行窗口直接进入 变量名可以是英文，也可以是中文，但是推荐使用便于记忆的英文字母或者拼音。 变量值分为两大类，一是目录，二是具体的文件。利用cmd直接进入程序， 接下来在win+r运行窗口输入【％相应设置的变量名％】即可快速打开刚刚设置好的目录或者是文件。","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkex.gitee.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"window","slug":"window","permalink":"https://wenkex.gitee.io/tags/window/"}]},{"title":"python自动化办公库","slug":"python自动化办公库","date":"2022-01-21T13:57:05.000Z","updated":"2022-01-21T13:57:05.000Z","comments":true,"path":"2022/012151162.html","link":"","permalink":"https://wenkex.gitee.io/2022/012151162.html","excerpt":"","text":"原文 微信自动化库wxpy 库官网：https://wxpy.readthedocs.io/zh/latest/ 特点：微信机器人/可能是最优雅的微信个人号API，wxpy 在 itchat 的基础上，通过大量接口优化提升了模块的易用性，并进行丰富的功能扩展。Excel自动化库 // 1.xlwings 库官网：https://www.xlwings.org/ 特点：xlwings 是开源且免费的，预装了 Anaconda 和 WinPython，可在 Windows 和 macOS 上运行。通过 Python 脚本或 Jupyter notebook 自动化 Excel，通过宏从 Excel 调用 Python，并编写用户定义的函数（UDF 仅适用于 Windows） // 2.openpyxl 库官网：https://openpyxl.readthedocs.io 特点：openpyxl 是一个用于读取 / 编写 Excel 2010 xlsx/xlsm/xltx/xltm 文件的 Python 库。它是由于缺乏从 Python 中读取 / 编写 Office Open XML 格式的现有库而诞生的。 // 3.xlrd 库官网：https://pypi.python.org/pypi/xlrd 特点：在 python 中，xlrd 库是一个很常用的读取 excel 文件的库，其对 excel 文件的读取可以实现比较精细的控制。 // 4.xlwt 库官网：https://pypi.org/project/xlwt/ 特点：类比于 xlrd 的 reader，那么 xlwt 就相对于 writer，而且很纯正的一点就是它只能对 Excel 进行写操作。xlwt 和 xlrd 不光名字像，连很多函数和操作格式也是完全相同。 // 5.xlutils 库官网：https://pypi.org/project/xlutils/ 特点：xlutils（excel utilities）是一个提供了许多操作修改 excel 文件方法的库。xlutils 库也仅仅是通过复制一个副本进行操作后保存一个新文件，xlutils 库就像是 xlrd 库和 xlwt 库之间的一座桥梁，因此，xlutils 库是依赖于 xlrd 和 xlwt 两个库的。 // 6.xlsxwriter 库官网：https://xlsxwriter.readthedocs.io/ 特点：xlsxwriter 是用于创建 Excel XLSX 文件的 Python 模块，可用于将文本、数字、公式和超链接写入 Excel2007 + XLSX 文件中的多个工作表。它支持格式化等功能。可以说除了 Excel 本身，就属这个功能最齐全了。 // 7.pandas 库官网：https://www.pypandas.cn/docs/ 特点：pandas 是基于 NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。 // 8.Marmir 库官网：https://github.com/brianray/mm 特点：Marmir 采用 Python 数据结构并将其转换为电子表格。它是类固醇上的 xlwt 和 google 电子表格。目标是使用最少的配置轻松生成多种类型的有用表文件。 Python Word自动化库 // 9.python-docx 库官网：https://python-docx.readthedocs.io/en/latest/ 特点：python-docx 是一个用于创建和更新 Microsoft Word (.docx) 文件的 Python 库。快速开始、处理文档、处理文本、使用截面、使用页眉和页脚、API基础理、解样式、使用样式理解图片和其他形状。只对 windows 平台有效。 // 10.textract 库官网：https://gitee.com/mirrors/textract 特点：它同时兼顾 “doc” 和 “docx”，但安装过程需要一些依赖。你可以批量的用 python 生成 word 文件，推荐使用 docx，不需要会太多。 Python PPT自动化库 // 11.python-pptx 库官网：https://python-pptx.readthedocs.io 特点：python-pptx 是一个用于创建和更新 PowerPoint (.pptx) 文件的 Python 库。典型用途是从数据库内容生成自定义 PowerPoint 演示文稿，可通过单击 Web 应用程序中的链接下载。 Python ODF自动化库 // 12.Relatorio 库官网：https://pypi.org/project/relatorio/ 特点：Relatorio 是一个模板库，它提供了一种轻松输出多种文件（odt、ods、png、svg 等）的方法。通过为它们创建插件可以轻松添加对更多文件类型的支持。Relatorio 还提供了一个报告存储库，允许您将 python 对象和报告链接在一起，按 mimetype/name/python 对象查找报告。ODF：开放文档格式（外文名：OpenDocument Format，外语简称：ODF）是一种规范，基于 XML（标准通用标记语言的子集）的文件格式，因应试算表、图表、演示稿和文字处理文件等电子文件而设置。 Python PDF自动化库 // 13.PyPDF2 库官网：https://github.com/mstamy2/PyPDF2 特点：PyPDF2 是一个纯 Python PDF 库，能够拆分、合并、裁剪和转换 PDF 文件的页面。它还可以向 PDF 文件添加自定义数据、查看选项和密码。它可以从 PDF 中检索文本和元数据，也可以将整个文件合并在一起。 // 14.ReportLab 库官网：https://www.reportlab.com/opensource/ 特点：ReportLab 是久经考验、超强大的开源引擎，用于创建复杂的、数据驱动的 PDF 文档和自定义矢量图形。它是免费的、开源的，并且是用 Python 编写的。 // 15.PDFminer 库官网：https://github.com/euske/pdfminer 特点：PDFMiner 是一款用于 PDF 文档的文本提取工具。 Python 邮件自动化库 // 16.Django Celery SES 库官网：https://github.com/StreetVoice/django-celery-ses 特点：这个包提供了一个 EmailBackend 来利用 django-celery 发送电子邮件。您可以将 EmailBackend 插入您的项目中，而无需对代码进行任何修改。 // 17.Envelopes 库官网：http://tomekwojcik.github.io/envelopes/ 特点：Envelopes 是 Python 的电子邮件和 smtplib 模块的包装器。它旨在使在 Python 中处理外发电子邮件变得简单而有趣。 // 18.Flanker 库官网：https://github.com/mailgun/flanker 特点：由 mailgun 开源的 Flanker - email address and MIME parsing for Python 是一个解析高效、容错率不错的 python 第三方扩展库。python 3 也可以正常使用，该库包含了邮件地址解析和邮件 mime 格式解析。 // 19.imbox 库官网：https://github.com/martinrusev/imbox 特点：用于读取 IMAP 邮箱并将电子邮件内容转换为机器可读数据的 Python 库 // 20.inbox.py 库官网：https://github.com/billzhong/inbox.py 特点：这是您见过的最简单的 SMTP 服务器。它是异步的。一个实例每秒应该处理一千多封电子邮件。 // 21.sync-engine 库官网：https://github.com/nylas/sync-engine 特点：Nylas 同步引擎在强大的电子邮件同步平台之上提供了一个 RESTful API，可以轻松地在电子邮件之上构建应用程序。 // 22.Lamson 库官网：https://github.com/zedshaw/lamson 特点：Lamson 是一个纯 Python SMTP 服务器，旨在以现代 Web 框架（如 Django）的风格创建强大而复杂的邮件应用程序。 // 23.Marrow Mailer 库官网：https://github.com/marrow/mailer 特点：Marrow Mailer 是一个 Python 库，可以轻松地从您的应用程序发送电子邮件。通过使用 Marrow Mailer，您可以：轻松构建纯文本和 HTML 电子邮件；提高电子邮件传递的可测试性；使用不同的邮件投递管理策略；例如立即，延迟，甚至多服务器等。 // 24.Modoboa 库官网：https://github.com/modoboa/modoboa 特点：Modoboa 是一个邮件托管和管理平台，包括一个现代和简化的 Web 用户界面。它提供了有用的组件，例如管理面板或网络邮件。 // 25.smtplib 库官网：https://docs.python.org/zh-cn/3/library/smtplib.html 特点：smtplib 模块是 python 中 smtp (简单邮件传输协议) 的客户端实现。我们可以使用 smtplib 模块，轻松的发送电子邮件。 Python 文件处理自动化库 // 27.os 库官网：https://docs.python.org/zh-cn/3/library/os.html?highlight=os#module-os 特点：本模块提供了一种使用与操作系统相关的功能的便捷式途径。如果你只是想读写一个文件，请参阅 open()，如果你想操作文件路径，请参阅 os.path 模块，如果你想读取通过命令行给出的所有文件中的所有行，请参阅 fileinput 模块。为了创建临时文件和目录，请参阅 tempfile 模块，对于高级文件和目录处理，请参阅 shutil 模块。 Python 综合功能自动化库 // 28.win32com 库官网：https://pypi.org/project/pywin32/ 特点：win32com 模块主要为 Python 提供调用 windows 底层组件对 word 、Excel、PPT 等进行操作的功能，只能在 Windows 环境下使用，并且需要安装 office 相关软件才行（WPS 也行）。 // 29.unoconv 库官网：https://github.com/unoconv/unoconv 特点：是一个命令行工具，可以将 LibreOffice 可以导入的任何文档格式转换为 LibreOffice 可以导出的任何文档格式。它利用 LibreOffice 的 UNO 绑定进行文档的非交互式转换，也支持 OpenOffice。 // 30.Tablib 库官网：https://www.osgeo.cn/tablib/ 特点：Python tablib 模块是第三方模块，主要作用是将数据导出为各种不同的格式，包括 excel，json，html，yaml，csv，tsv 等格式，怎么样，有点心动了吧，当然这个模块使用起来也是超级简单的。 // 31.SnowNLP 库官网：https://github.com/isnowfy/snownlp 特点：SnowNLP 是一个 python 写的类库，可以方便的处理中文文本内容，是受到了 TextBlob 的启发而写的，由于现在大部分的自然语言处理库基本都是针对英文的，于是写了一个方便处理中文的类库，并且和 TextBlob 不同的是，这里没有用 NLTK，所有的算法都是自己实现的，并且自带了一些训练好的字典。注意本程序都是处理的 unicode 编码，所以使用时请自行 decode 成 unicode。 // 32.TextBlob 库官网：https://textblob.readthedocs.io 特点：TextBlob 是一个用于处理文本数据的 Python（2 和 3）库。它提供了一个简单的 API，用于深入研究常见的自然语言处理 (NLP) 任务，例如词性标注、名词短语提取、情感分析、分类、翻译等。 // 33.TextGrocery 库官网：https://textgrocery.readthedocs.io 特点：TextGrocery 是一个基于 LibLinear 和结巴分词的短文本分类工具，特点是高效易用，同时支持中文和英文语料。 // 34.NumPy 库官网：https://www.numpy.org.cn/ 特点：NumPy 是 Python 中科学计算的基础包。它是一个 Python 库，提供多维数组对象，各种派生对象（如掩码数组和矩阵），以及用于数组快速操作的各种 API，有包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数，基本统计运算和随机模拟等等。","categories":[{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/categories/python/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"https://wenkex.gitee.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"markdown语法","slug":"markdown语法","date":"2022-01-09T03:24:32.000Z","updated":"2022-01-09T03:24:32.000Z","comments":true,"path":"2022/010947193.html","link":"","permalink":"https://wenkex.gitee.io/2022/010947193.html","excerpt":"","text":"markdown常用语法概述Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。 Markdown 是 HTML 的一种简写，在显示时会『解压缩』成 HTML。理论上你可以在 Markdown 里直接插入合法的 HTML 块，他们会成为最终的 HTML 的一部分，做到 Markdown 本身做不到的事。Markdown 的格式可以由 CSS 描述 参考文章慕课教程 官方文档 生成目录自动生成在 Markdown 中，自动生成目录非常简单，只需要在恰当的位置添加[TOC]符号，凡是以 # 定义的标题都会被编排到目录中。 手动书写目录我们也难免有自定义目录的需求，如只显示一二级大标题等。 手动添加目录的方法就是将「列表」和「页内超链接」相结合。 1234567891011121314151617181920212223242526- [一级标题](#一级标题) - [标题 1-1](#二级标题 1-1) - [标题 1-2](#二级标题 1-2)- [二级标题](#二级标题) - [标题 2-1](#二级标题 2-1) - [标题 2-2](#二级标题 2-2)- [一级标题](#一级标题) - [标题 1-1](#二级标题 1-1) - [标题 1-2](#二级标题 1-2)- [二级标题](#二级标题) - [标题 2-1](#二级标题 2-1) - [标题 2-2](#二级标题 2-2)# 一级标题一些内容……## 二级标题 1-1一些内容……## 二级标题 1-2一些内容……# 二级标题一些内容……## 二级标题 2-1一些内容……## 二级标题 2-2一些内容…… 描点跳转1234html标签实现定义一个锚(id)： &lt;span id=\"jump\"&gt;跳转到的地方&lt;/span&gt;使用markdown语法：[点击跳转](#jump) 标题语法要创建标题，请在单词或短语前面添加## 。##的数量代表了标题的级别用一个空格在##和标题之间进行分隔。 强调语法粗体（Bold）加斜体（Italic） 要加粗文本，请在单词或短语的前后各添加三个星号（asterisks） 删除线删除线就是给文本加上删除线，在文本两端使用两个波浪线~ 1~~文本~~ 文本 引用语法要创建块引用，请在段落前添加一个&gt;符号。 列表语法要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 围栏代码块在代码块之前和之后的行上使用三个反引号（(```）或三个波浪号（~~~）。 在反引号后面加上语言的名字就可以享受到对应语言的语法高亮。 用反引号括起来，反引号是英文输入下，tab的上一个键 分隔线在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。为了兼容性，请在分隔线的前后均添加空白行 链接语法超链接Markdown语法代码：[超链接显示名](超链接地址 “超链接title”)使用尖括号可以很方便地把URL或者email地址变成可点击的链接。 转义字符语法要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 。 图片语法12![ddfdfd](图片链接 \"图片title\") 表格Markdown表格工具Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 hexo文章表格要与正文空两行才可以渲染 表格的对齐方式-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。 1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 任务列表任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。 Write the press release Update the website Contact the media使用 Emoji 表情复制使用https://emojipedia.org/ https://gist.github.com/rxaviers/7360908 工具vscode微信Markdown编辑器这个项目名doocs-md，在编写时，Markdown 文档自动即时渲染为微信图文，让你不再为微信文章排版而发愁！项目地址：https://github.com/doocs/md 在线体验地址： • Gitee Pages：https://doocs.gitee.io/md • GitHub Pages：https://doocs.github.io/md 功能特性• 支持自定义 CSS 样式 • 支持 Markdown 所有基础语法 • 支持浅色、暗黑两种主题模式 • 支持 Ctrl + F 快速格式化文档 • 支持色盘取色，快速替换文章整体色调 • 支持多图上传，可自定义配置图床 • 支持自定义上传逻辑 • 支持在编辑框右键弹出功能选项卡 • 支持批量转换本地图片为线上图片 使用 Docker 镜像docker run -d -p 8080:80 doocs/md:latest容器运行起来之后，打开浏览器，访问 http://localhost:8080 即可。 使用 npm cli通过我们的 npm cli 你可以轻易搭建属于自己的微信 Markdown 编辑器。 1234567891011121314## 安装npm i -g @doocs/md-cli## 启动md-cli## 访问open http://127.0.0.1:8800/md/## 启动并指定端口md-cli port=8899## 访问open http://127.0.0.1:8899/md/ Marktext项目地址适用于 Linux、MacOS 和 Windows。 支持实时预览和干净简单的界面，以获得无干扰的写作体验； 支持 Markdown 扩展，例如：数学表达式（KaTeX）、表情符号等； 支持段落和内联样式快捷方式，从而提高写作效率； 支持导出 HTML 和 PDF 格式的文件； 支持多种主题，例如：Cadmium Light、Dark、Graphite Light、Material Dark、One Dark、UIysses Light； 支持多种模式，例如：源代码模式、打字机模式、专注模式； 支持可直接从剪贴板粘贴图像； markdown编辑器🧾 Markdown 编辑器 1.Typora[付费]一款轻便简洁的Markdown编辑器，支持即时渲染技术网站：https://typoraio.cn/学习版：https://wwc.lanzoul.com/i7bBz09yhk8j Arya - 在线 Markdown 编辑器一款基于 Vue、Vditor，为未来而构建的在线 Markdown 编辑器；轻量且强大：内置粘贴 HTML 自动转换为 Markdown，支持流程图、甘特图、时序图、任务列表，可导出携带样式的图片、PDF、微信公众号特制的 HTML 等等网站：https://markdown.lovejade.cn/项目：https://github.com/nicejade/markdown-online-editor react-markdown-editor-lite一款轻量的基于React的markdown编辑器网站：https://harrychen0506.github.io/react-markdown-editor-lite/项目：https://github.com/HarryChen0506/react-markdown-editor-lite 墨滴软件-mdnice[付费]跨平台Markdown排版、编辑软件网站：https://product.mdnice.com/ 妙言-Mac轻灵的 Markdown 笔记本伴你写出妙言~只有Mac版网站：https://miaoyan.app/项目：https://github.com/tw93/MiaoYan Editor开源在线 Markdown 编辑器网站：https://pandao.github.io/editor.md/网站：http://editor.md.ipandao.com/项目：https://github.com/pandao/editor.md Obsidian一款本地 Markdown 编辑工具网站：https://obsidian.md/中文论坛：https://forum-zh.obsidian.md/ 思源笔记[付费]一款个人知识管理系统，融合 Markdown、双向链接、大纲和块级引用功能。支持 Win / Mac / iOS / 安卓等平台，本地优先可离线使用，并提供设备间端到端加密同步网站：https://b3log.org/siyuan/项目：https://github.com/siyuan-note/siyuan Doocs一款在线高度简洁的微信 Markdown 编辑器支持 Markdown 语法、色盘取色、多图上传、一键下载文档、自定义 CSS 样式、一键重置等特性网站：https://doocs.github.io/md/项目：https://github.com/doocs/md WeChat Format微信公众号排版编辑器，转换 Markdown 到微信特制的 HTML网站：https://lab.lyric.im/wxformat/项目：https://github.com/lyricat/wechat-format MWeb Pro for Mac, iPad and iPhone[付费]专业的 Markdown 写作、记笔记、静态博客生成软件网站：https://zh.mweb.im/ MarkText开源免费，支持windows、苹果、linux系统平台，支持实时预览、数学表达式、代码高亮,可输出 HTML 和 PDF 文件,也可以直接从剪贴板粘贴图像网站：https://marktext.app/ [目前打不开，去GitHub下载]项目：https://github.com/marktext/marktext MarkdocMarkdown 前端开发库网站：https://markdoc.dev/项目：https://github.com/markdoc/markdoc LetsMarkdown一个轻量级的网页版 Markdown 编辑器，支持实时协作编辑、语法高亮、自动补全、主题设置等功能网站：https://letsmarkdown.com/项目：https://github.com/Cveinnt/LetsMarkdown.com QOwnNotes开源记事本，具有针对GNU/Linux，macOS和Windows的markdown支持和待办事项列表管理器，可与Nextcloud Notes和ownCloud Notes一起使用网站：https://www.qownnotes.org/项目：https://github.com/pbek/QOwnNotes MDX Editor微信排版编辑器，使用MDX，可自定义组件、样式、生成二维码、代码 diff 高亮，可导出 markdown 和 PDF网站：https://editor.runjs.cool/项目：https://github.com/maqi1520/mdx-editor effie支持Markdown的极简写作应用，支持Windows和MacOS。网站：https://www.effie.co/ md-editor-v3vue3 环境的 Markdown 编辑器，支持暗黑模式网站：https://imzbf.github.io/md-editor-v3/index项目：https://github.com/imzbf/md-editor-v3 MarkPad一个Metro风格的轻量级开源Markdown编辑器项目：https://github.com/Code52/DownmarkerWPF网站：http://code52.org/DownmarkerWPF/ 可能吧 Markdown to 公众号一键转换器网站：https://knb.im/mp/ Md2ALLMarkdown排版利器网站：http://md.aclickall.com/ mdfmt一款 Markdown 格式化工具，和 gofmt 比较类似，不过格式化的对象是 Markdown 文本项目：https://github.com/elliotxx/mdfmt Zettlr一款非常适合撰写专业文本的 MarkDown 编辑器，无论是大学生、科研人员、记者还是作家，Zettlr 特有的文献引用、聚焦模式、热图搜索、代码高亮、组织结构几大特色都可以让 MarkDown 从编辑器变身生产力工具网站：https://www.zettlr.com/项目：https://github.com/Zettlr/Zettlr Notable开源免费的跨平台Markdown编辑器，适用于MacOS，Windows，Linux。还可以快速的将自己的笔记通过链接的方式分享出去网站：https://notable.app/#项目：https://github.com/notable/notable 24.Milkdown插件驱动的所见即所得的Markdown编辑器框架网站：https://milkdown.dev/项目：https://github.com/Saul-Mirone/milkdown HedgeDoc网站：https://hedgedoc.org/项目：https://github.com/hedgedoc/hedgedoc ShowDoc[付费]一个非常适合IT团队的在线API文档、技术文档工具网站：https://www.showdoc.com.cn/项目：https://github.com/star7th/showdoc Pine一个用 Swift 编写的，轻量、现代的 macOS 上的 markdown 编辑器网站：https://lukakerr.github.io/Pine/项目：https://github.com/lukakerr/Pine","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkex.gitee.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://wenkex.gitee.io/tags/markdown/"}]},{"title":"IDE配置及使用","slug":"IDE配置及使用","date":"2022-01-09T03:18:05.000Z","updated":"2022-01-09T03:18:05.000Z","comments":true,"path":"2022/01093653.html","link":"","permalink":"https://wenkex.gitee.io/2022/01093653.html","excerpt":"","text":"vscode设置保存后格式化1234567// vscode保存后的动作 \"editor.codeActionsOnSave\": { // 保存后自动格式化js,css代码，需要安装插件(ESLint,StyleLint) \"source.fixAll.eslint\": true, \"source.fixAll.stylelint\": true }, 括号对着色Editor › Bracket Pair Colorization: Enabled控制是否已启用括号对着色。使用 Workbench: Color Customizations 替代括号高亮颜色。 使用多行编辑按住鼠标中键/alt+shift：多光标选中多行alt+左键选择多个编辑位点 常用F1 或 Ctrl+Shift+P（俗称万能键） ：打开命令面板 ctrl+y 取消撤销 1.查看函数或者类的定义Ctrl+鼠标左键点击函数名或者类名即可跳转到定义处，在函数名或者类名上按F12也可以实现同样功能 重命名变量：f2 单行注释&nbsp; Ctrl +/块注释:Alt + Shift + A 编辑器与窗口管理新建文件: Ctrl+N 文件之间切换: Ctrl+Tab 打开一个新的VS Code编辑器: Ctrl+Shift+N 关闭当前窗口: Ctrl+W 关闭当前的VS Code编辑器: Ctrl+Shift+W 切出一个新的编辑器窗口(分屏–最多3个): Ctrl+\\ 切换左中右3个编辑器窗口的快捷键: Ctrl+1 Ctrl+2 Ctrl+3 格式调整代码行向左或向右缩进: Ctrl+[ 、 Ctrl+] 复制或剪切当前行/当前选中内容: Ctrl+C 、 Ctrl+V 代码格式化: Shift+Alt+F 向上或向下移动一行: Alt+Up 或 Alt+Down 向上或向下复制一行: Shift+Alt+上键 或 Shift+Alt+下键 在当前行下方插入一行: Ctrl+Enter 在当前行上方插入一行: Ctrl+Shift+Enter 光标相关移动到行首: Home移动到行尾: End 移动到文件结尾: Ctrl+End 移动到文件开头: Ctrl+Home 移动到定义处: F12 查看定义处缩略图(只看一眼而不跳转过去): Alt+F12 选择从光标到行尾的内容: Shift+End 选择从光标到行首的内容： Shift+Home 删除光标右侧的所有内容(当前行): Ctrl+Delete 扩展/缩小选取范围： Shift+Alt+Right 和 Shift+Alt+Left 多行编辑(列编辑): Alt+Shift+鼠标左键 或 Ctrl+Alt+Down/Up 同时选中所有匹配编辑(与当前行或选定内容匹配): Ctrl+Shift+L 下一个匹配的也被选中: Ctrl+D 回退上一个光标操作: Ctrl+U 撤销上一步操作: Ctrl+Z 手动保存: Ctrl+S 重构代码找到所有的引用: Shift+F12 重命名变量: Ctrl+F2 查找替换查找: Ctrl+F 查找替换: Ctrl+H 显示相关全屏显示(再次按则恢复): F11 放大或缩小(以编辑器左上角为基准): Ctrl +/- 侧边栏显示或隐藏： Ctrl+B 显示资源管理器(光标切到侧边栏中才有效): Ctrl+Shift+E 显示搜索(光标切到侧边栏中才有效): Ctrl+Shift+F 显示源代码管理(光标切到侧边栏中才有效): Ctrl+Shift+G+G 插件推荐 美化文件图标：Material Icon Theme： 实时预览图片：Image Preview 项目管理：Project Manager用来快速打开项目 路径补充：Path Intellisense ,模块导入, 智能提示 绘图工具：vscode-drawio 展示数据结构形成过程：debug-visualizer database-client支持MySQL/MariaDB, PostgreSQL, SQLite, Redis, ClickHouse, 达梦以及ElasticSearch的管理, 且可以作为一个SSH客户端, 最大程度地提高你的生产力! CodeTour 允许我们为代码添加备注，并且将这些备注串联起来，动态地展示我们的思路以及代码逻辑。 管理.ignore files文件：AnGitIgnored Luna Paint — Image Editor：一个内置在 VS Code 中的图像编辑器，支持 png，jpg，webp，bmp 和 ico 格式。 缩进带颜色：Indent-Rainbow 可视化模块依赖关系：Dependency Cruiser Extension 删除空行：Remove empty lines AI辅助-单元测试:Ponicode koroFileHeader：用于生成文件头部注释和函数注释 ctrl+shift+t：函数注释 Code-runner在设置中搜索Code-runner: File Directory As Cwd这个选项的作用是将我们运行的py文件所在目录设置为当前工作目录 change-casectrl + shift + p 调出命令面板:搜索change-case snack 更改当前选择的单词的格式, 比如 大小写, js的驼峰camel, python的蛇形snake, css的串式kebab, java的匈牙利HN 文件头部注释快捷键记录文件信息/文件的传参/出参，设置个性签名、留下QQ、微信联系方式、输入空行等等支持用户高度自定义注释选项, 适配各种需求的注释形式。保存文件的时候，自动更新最后的编辑时间和编辑人 window：ctrl+win+i, mac：ctrl+cmd+i, linux: ctrl+meta+i, Ubuntu: ctrl+super+i 函数注释注释快捷键更多关于函数参数自动请查阅配置-函数注释自动提取函数的参数文档将光标放在函数行或者将光标放在函数上方的空白行。自动解析函数参数，生成函数参数注释。快捷键： window：ctrl+win+t, mac：ctrl+cmd+t, linux: ctrl+meta+t, Ubuntu: ctrl+super+t 快捷键不生效在vscode界面输入 ctrl+shift+p ， 搜索找到键盘快捷方式,再搜索 cursortip （函数注释快捷键） background加入设置的setting.json 12345678910111213141516171819 \"background.enabled\": true, \"background.useDefault\": false, \"background.customImages\": [ \"file:///E:/wenke_source/my picture/壁纸.jpg\" ], \"background.style\": { \"content\": \"''\", \"pointer-events\": \"none\", \"position\": \"absolute\", \"top\": \"0\", \"right\": \"0\", \"background-size\": \"cover\", \"opacity\": 0.1, \"z-index\": \"99999\", \"width\": \"100%\", \"height\": \"100%\", \"background-repeat\": \"no-repeat\",},\"bracketPairColorizer.depreciation-notice\": false 同步配置。Settings Sync 1.用Github账户登录2.创建一个新的GIST或选择存在的GIST3.上传配置按下 Shift + Alt + U4.下载配置按下 Shift + Alt + D 开发用户代码片段 snippets 语法原文 12345678910{ \"alpha\": { \"prefix\": [\"a\", \"z\"], \"body\": [ \"abcdefghijklmnopqrstuvwxyz\" ], \"description\": \"字母\", \"scope\": \"javascript\" }} prefix 是触发的前缀，可以指定多个body 是插入到编辑器中的内容，支持很多语法description 是描述scope 是生效的语言，不指定的话就是所有语言都生效 vscode代码片段生成器utools插件 python环境运行python代码在终端中运行python代码:在VSCode终端显示运行结果，它会默认显示当前环境和被执行文件的路径 在python终端中运行选定内容：在python交互窗口执行文件，执行的过程中我们可以通过输入框进行输入交互。它类似Jupyter, 每次运行都是独立的单元格，方便观察结果 python代码输出中文乱码在”文件”－“首选项”－”用户设置”中搜索code-runner.executorMap选项，提示需要在setting.json中修改“code-runner.executorMap”: {“python”: “set PYTHONIOENCODING=utf8 &amp;&amp; python -u”} 设置关闭 vscode 的自动导入包功能，经常导错设置搜索Python › Analysis: Auto Import Completions，并关闭 用户代码片段12345678910111213141516171819202122232425{ \"python\":{ \"prefix\": \"!py\", \"body\": [ \"#!/usr/bin/env python3.8.8\", \"# -*- encoding: utf-8 -*-\", \"'''\", \"@File : $TM_FILENAME\", \"@Time : $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\", \"@Author : wenke \", \"@Version : 1.0\", \"@Contact : 1184664659@qq.com\", \"@WebSite : https://wenkexia.github.io\", \"@Desc : None\", \"'''\", \"\", \"if __name__ == '__main__':\", \"\", \"$0\" ], } } python插件AI Doc write:ai帮你写注释只要选中函数代码，然后按一个快捷键就会自动生成该方法的注释，可用来生成函数文档， Sourcegraph你可以直接从 VS Code IDE 免费搜索数百万个开源存储库。从有用的代码示例中学习，搜索最佳实践，并从开源宇宙中数百万个存储库中重用代码。 Krinql如果你看不懂代码，可以让 Krinql 来回答，或者让它编写文档字符串： JetBrains系列配置文件安装目录下的bin目录，可以看到一个idea.properties文件，核心配置文件参数： 1.idea.config.path 这个目录是我们在File\\settings标签下做的一些配置，例如CodeStyle、KeyMaps等。 2.idea.system.path 这个目录下的配置很关键，主要存放的是一些缓存。编译工具、本地历史、工作空间配置等都在这里。 3.idea.plugins.path 这里放的是我们安装的一些插件，如果你需要增加插件，除了在IDEA的操作界面添加，把插件移动到这个目录然后重启也可以安装成功，这就是离线安装。 4.idea.log.path 这个目录保存了IDEA产生的log。如果你觉得占用空间过大，也可以删掉部分过期的log。 jetbrains系列产品激活使用服务器激活方式，不过不稳定 pycharm备份配置配置信息导出到文件：点击file，选择export settings配置文件的导入：点击file，选择import settings 小技巧临时文件是一种临时性文件，借助这种文件，不必创建任何项目文件，即可在编辑器中进行实验和原型设计。要创建临时文件，请按 Ctrl+Alt+Shift+Insert ，然后选择要使用的语言。 快捷键ctrl + alt + L ：一键格式化代码ctrl +shift +f :全局查找ctrl +shift +f ：全局替换shift +f10:运行shift + Enter :换行CTRL + SHIFT + F10 运行当前编辑区的程序文件 搜索在当前文件中搜索代码段：在 Mac 系统中使用 Cmd+F 键，在 Windows 或 Linux 系统中使用 Ctrl+F 键。 在整个项目中搜索代码段：在 Mac 系统中使用 Cmd+Shift+F 键，在 Windows 或 Linux 系统中使用 Ctrl+Shift+F 键。 搜索类：在 Mac 系统中使用 Cmd+O 键，在 Windows 或 Linux 系统中使用 Ctrl+N 键。 搜索文件：在 Mac 系统中使用 Cmd+Shift+O 键，在 Windows 或 Linux 系统中使用 Ctrl+Shift+N 键。 如果你不知道要搜索的是文件、类还是代码段，则搜索全部：按两次 Shift 键。 快速导航导航可使用以下快捷键： 前往变量的声明：在 Mac 系统中使用 Cmd 键，在 Windows 或 Linux 系统中使用 Ctrl 键，然后单击变量。 寻找类、方法或文件的用法：使用 Alt+F7 键。 查看近期更改：使用 Shift+Alt+C 键，或者在主菜单中点击 View → Recent Changes。 查看近期文件：在 Mac 系统中使用 Cmd+E 键，在 Windows 或 Linux 系统中使用 Ctrl+E 键，或者在主菜单中点击 View → Recent Files。 多次跳转后在导航历史中前进和后退：在 Mac 系统中使用 Cmd+[ / Cmd+] 键，在 Windows 或 Linux 系统中使用 Ctrl+Alt+Left / Ctrl+Alt+Right 键。 Intelligent Coding AssistancePyCharm 提供 Intelligent Coding Assistance 功能，可以执行代码补全、代码检查、错误高亮显示和快速修复建议。比如键入 main 并点击 tab 键，PyCharm 会自动补全整个 main 从句。 文件头注释PyCharm”→“File”→“Settings”→“Editor”→“File and Code Templates 123456789# -*- coding: utf-8 -*-\"\"\"@author: ${USER}@software: ${PRODUCT_NAME}@file: ${NAME}.py@time: ${DATE} ${TIME}\"\"\" docstring方法注释https://blog.csdn.net/dkjkls/article/details/88933950 File -&gt; Settings -&gt; Tools -&gt; Python Integrated Tools -&gt; Docstrings -&gt; Docstring format设置包括五种风格：Plain、Epytext、reStructuredText、Numpy、Google。 使用方式为，在方法名下方输入三个双（单）引号，回车，自动生成。 debug断点即程序运行到这一行时会自动停止，你可以探索断点处之后的代码有什么错误。 注意 Debugger 标签右侧有一个 Console 标签。Console 标签和 Debugger 标签相互独立。你可以在 Console 中与程序进行交互，在 Debugger 中执行 debug 动作。 点击 F8 执行当前代码行，并执行到下一行代码 进行代码测试不经单元测试的应用都不可靠。PyCharm 可以帮助你快速舒适地写单元测试并运行。默认情况下，unittest 被用作测试运行器，而 PyCharm 还支持其他测试框架，如 pytest、nose、doctest、tox 和 trial。例如，你可以按照以下步骤为项目选择 pytest 测试运行器： 打开 Settings/Preferences → Tools → Python Integrated Tools 设置对话框。在默认测试运行器字段中选择 pytest。点击 OK 保存该设置。 使用版本控制在 Windows 或 Linux 系统中使用 Alt+` 键进入vcs操作 插件推荐Key Promoter X它就相当于一个快捷键管理大师，它时刻地在： 教导你，当下你的这个操作，应该使用哪个快捷操作来提高效率？ 提醒你，当下你的这个操作，还没有设置快捷键，赶紧设置一个？ Regex Tester可以测试正则表达式。安装完成后，无需重启 PyCharm ，点击 PyCharm 界面左下方的小矩形按钮，就能找到 Regex Tester 选项。匹配到的字符串背景会被高亮。右上方还有一些选项如大小写敏感，多行模式等，可根据需要进行选择。Regex Tester 还提供了Split，Replace功能等。 插件下载位置更改(改完后各种错)原来的配置和下载的插件:C:\\Users\\wenke\\AppData\\Roaming\\PyCharm2022.1 找到如下图所示关系配置项。修改为自己设定的文件位置 12345idea.config.path=D:/data/pycharm/configidea.system.path=D:/data/pycharm/systemidea.plugins.path=D:/data/pycharm/plugins #插件原来保存在configidea.log.path=D:/data/pycharm/log idea设置设置-&gt;编辑器-&gt;常规-&gt;自动导入 (开启自动导包，删包) 更改用户保存目录原来的配置和下载的插件，可以将原来C盘（C:\\Users\\xxx.IntelliJIdea）对应的文件或者在C:\\Users\\wenke\\AppData\\Roaming\\JetBrains\\PyCharm2022.1 在你的IDEA安装目录下的bin目录，可以看到一个idea.properties文件，这个文件是IDEA的核心配置文件找到如下图所示关系配置项。修改为自己设定的文件位置 12345idea.config.path=D:/data/IDEA/configidea.system.path=D:/data/IDEA/systemidea.plugins.path=D:/data/IDEA/plugins idea.log.path=D:/data/IDEA/log maven用户设置文件：C:\\Users\\wenke.m2\\settings.xml本地仓库：C:\\Users\\wenke.m2\\repository 我设置成用户设置文件：D:\\data\\IDEA.IntelliJIdea.m2\\settings.xml本地仓库：D:\\data\\IDEA.IntelliJIdea.m2\\repository 快捷键ctrl + d 快速复制这行到下一行 alt + insert ：自动生成get,set方法 注释行注释Ctrl+/、块注释Ctrl+Shift+/文档注释 /**+enter 比较文件按住ctrl选中多个文件，右击选比较文件或者ctrl+d 自动生成psvm:main()方法 “内容”.sout :输出语句 fori:for循环语句 flag.whil + 回车：while语句 flag.if + 回车 ：if语句 new 类名.var + 回车 ：自动生成对象 推荐插件Alibaba Java Coding Guidelines（阿里巴巴Java开发规范） Key Promoter X（IDEA快捷键提示） Save Actions（当程序员将代码保存后，插件会自动进行格式化） Codota AI Autocomplete（代码自动提示和推荐） Auto filling Java call arguments（自动填充调用方法参数）在调用函数时，通过alt+enter键，触发联想功能，选择”auto fill call parameters”自动填充调用的函数的形参名。 GenerateAllSetter（自动生成调用对象的set方法） Maven Helper（Maven依赖分析工具）该插件可以查看maven的依赖树，分析版本冲突，并提供maven常用命令模板。 File Expander它能在Idea里直接打开Jar包，并且反编译代码查看。甚至于能打开tar.gz，zip等压缩格式。 GitToolBox他能在项目上提示你还有多少文件没提交，远程还有多少文件没更新下来。还能在每一行代码上提示上次提交的时间。查版本提交问题的时候尤其方便。 Easy javadoc 注释快捷键ctrl +\\ 代码模板自定义代码模板第一个是代码模板快捷输入语句，第二个是说明，第三个就是我们自己定义的代码模板，$END$是回车后光标自动跳转的地方。 自动生成类注释1.按照顺序打开File–&gt;settings–&gt;Editor–&gt;File and Code Templates–&gt;Includes-&gt;File Header2.输入类注释模板 123456/** * @Classname ${NAME} * @author ${USER} * @Date ${DATE} ${TIME} * @Description ${TODO} */ 自动生成方法注释https://zhuanlan.zhihu.com/p/3863922491.按照顺序打开File–&gt;Settings–&gt;Editor–&gt;Live Templates2.点击右边的”+“号,选择Template Group,创建自己的组名3.选择自己的组名，点击”+”号，选择Live Template4.填写Abbreviation(你设定的关键字)，Description(对模板的描述，会在调用时提示;)5.点击 Define(模板作用的位置) 选择java 6.Template text(要显示的完整代码;) 12345678910/** * @author: $USER$ * @data: $date$-$time$ * @update_at $date$ $time$ * @params: $params$ * @return: $return$ * @Description: 描述 **/ 7.编辑模板变量,然后将每一行最后的“Skip if defined”勾选。 DataGrip删除一整行：Ctrl + Y 代码格式化相关：大小写转化： Ctrl + Shift + U代码格式化： Ctrl + Alt + L 刷新表：Ctrl + F5 调整表中的列宽：Ctrl + Shift + 左/右箭头 调整显示窗口的高度：Ctrl + Shift + 上/下箭头","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://wenkex.gitee.io/tags/vscode/"}]},{"title":"python基础","slug":"python基础","date":"2022-01-08T14:30:18.000Z","updated":"2022-01-08T14:30:18.000Z","comments":true,"path":"2022/010834543.html","link":"","permalink":"https://wenkex.gitee.io/2022/010834543.html","excerpt":"","text":"配置python开发环境Linux下配置pythonlinux安装ancondaAnaconda 是一个用于python/R科学计算和机器学习的开源工具(也称为Python的一种发行版)，支持 Linux, macOS, Windows, 包含了conda等众多工具包及其依赖项，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题 直接使用linux命令行下载 安装anaconda#首先安装wgetsudo apt-get install wget # Ubuntusudo yum install wget # CentOS #然后使用wget从清华源上下载Anaconda3-2021.05-Linux-x86_64.shwget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.05-Linux-x86_64.sh #安装Anaconda：sh Anaconda3-2021.05-Linux-x86_64.sh#查看许可时可输入q来退出 将conda加入环境变量加入环境变量是为了让系统能识别conda命令 #1.在终端中打开~/.bashrc：vim ~/.bashrc #2.在/.bashrc中将conda添加为环境变量：#先按i进入编辑模式在第一行输入：export PATH=”/anaconda3/bin:$PATH”#若安装时自定义了安装位置，则将~/anaconda3/bin改为自定义的安装目录下的bin文件夹 3.修改完成后，先按esc键退出编辑模式，再输入:wq!并回车，以保存退出 4.验证是否能识别conda命令： 在终端中输入source ~/.bash_profile以更新环境变量再在终端输入conda info --envs，若能显示当前有base环境，则conda已加入环境变量 Windows下安装Anaconda下载：https://docs.anaconda.com/anaconda/install/windows/ 环境变量123E:\\anacondaE:\\anaconda\\ScriptsE:\\anaconda\\Library\\bin 浏览器驱动放在D:\\ruanjian\\anaconda\\Scripts 管理虚拟环境virtualenvwrapper管理python虚拟环境window下安装并配置virtualenvwrapper由于 virtualenvwrapper 是 virtualenv 的一组扩展，所以如果要使用 virtualenvwrapper，就必须先安装 virtualenv。 123pip install virtualenvpip install virtualenvwrapper-win 默认创建的虚拟环境位于C:\\Users\\username\\envs,可以通过环境变量 WORKON_HOME 来定制。 通过计算机–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;在系统变量中新建“变量名”：WORKON_HOME,变量值：“你自定义的路径”。 Linux下安装并配置123pip install virtualenvwrapper # 安装find / -name virtualenvwrapper.sh #先find一下virtualenvwrapper.sh文件的位置 在~/.bashrc 文件新增配置 1234export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$HOME/workspaceexport VIRTUALENVWRAPPER_SCRIPT=/usr/bin/virtualenvwrapper.shsource /usr/bin/virtualenvwrapper.sh 通用命令直接在命令行使用更好 12345678910111213141516171819202122232425262728293031323334353637383940414243# 列出所有的虚拟环境，两种方法workonlsvirtualenv #同时列出虚拟环境路径#创建虚拟环境mkvirtualenv 虚拟环境名称 mkvirtualenv --python=D:\\Python\\python.exe test4 #指定python版本workon 虚拟环境名称 # 进入虚拟环境,进入后使用pip将安装在虚拟环境下deactivate # 退出虚拟环境# 在虚拟环境内直接切换到其他环境workon my_env02rmvirtualenv my_env01 # 删除虚拟环境# 列出帮助文档 virtualenvwrapper# 拷贝虚拟环境cpvirtualenv ENVNAME [TARGETENVNAME]# 在所有的虚拟环境上执行命令allvirtualenv pip install -U pip# 删除当前环境的所有第三方包wipeenv# 进入到当前虚拟环境的目录 cdsitepackages# 进入到当前虚拟环境的site-packages目录 cdvirtualenv# 显示 site-packages 目录中的内容$ lssitepackages conda管理python虚拟环境conda 创建虚拟环境有个好处，它可以换python版本。如果你使用的virtualenv，它虽然也可以创建虚拟环境，但python版本无法换 下载anaconda安装的python直接可以使用conda工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 列出系统存在虚拟环境：conda env list# 创建虚拟环境conda create -n xxx python=3.9# 切换虚拟环境activate xxx #on windowssource activate xxx #on linux#conda 版本查看conda --versionconda update conda #更新conda：conda update python #更新python版本需要进入指定指定的虚拟环境：conda upgrade --all #更新第三方所有包：#退出虚拟环境deactivate #on windowssource deactivate #on linux#删除虚拟环境conda remove --name xxx --all# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n xxx# 查找package信息conda search numpy# 安装packageconda install -n xxx numpy# 如果不用-n指定环境名称，则被安装在当前激活环境# 也可以通过-c指定通过某个channel安装# 更新packageconda update -n xxx numpy# 删除packageconda remove -n xxx numpy 添加清华源123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 说明 12345678#查看当前channelconda config --show#删除channel：conda config –remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free#增加channel：conda config ‐‐add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ venv自 3.6 版本之后，成为官方推荐的多环境管理工具。也就是说，你不需要安装任何第三方库就可以实现多环境管理了 优缺点分析：1、venv是python3自带的，不需要额外安装库就能运行。2、只能在3.3版本以后，2.x用不了3、venv过于简单，没有额外的api。只能创建个虚拟环境，不能指定系统不存在的python环境版本，不能查看环境列表。 1234567python3 -m venv D:\\ruanjian\\python #使用venv创建虚拟隔离环境：cd /data/myproj source ./bin/activate #激活虚拟环境:#退出虚拟环境：(myproj) [root@ops-130 myproj] deactivate 注释单行注释 # 一般放在代码右边多行注释 使用三个连续的单引号’’’或者三个连续的双引号”””注释多行内容，多行注释通常用来为 Python 文件、模块、类或者函数等添加版权或者功能描述信息。 快速生成注释vscode插件python docstring generator功能快速生成文档字符串 (docstring) 片段。可供选择的多种文档字符串格式。通过pep484类型提示、默认值和变量名称自动推断参数类型。支持普通参数、关键字参数、装饰器、错误和参数类型的识别。用法光标必须位于函数定义正下方的行上，才能生成完全自动填充的文档字符串。共有如下的三种调用方式： 先输入三个双引号（”””）然后回车也可以直接使用快捷键Ctrl+Shift+2调用（修改快捷键：Keyboard Shortcuts -&gt; generateDocstring）或者右键菜单选项卡：Generate Docstring Jupyter Notebook使用Anaconda已经自动为你安装了Jupter Notebook及其他工具 Jupyter Notebook是以网页的形式打开，可以在网页页面中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示的程序。如在编程过程中需要编写说明文档，可在同一个页面中直接,编写支持Markdown语法。 Jupyter Notebook中所有交互计算、编写说明文档、数学公式、图片以及其他富媒体形式的输入和输出，都是以文档的形式体现的。这些文档是保存为后缀名为.ipynb的JSON格式文件，不仅便于版本控制，也方便与他人共享。此外，文档还可以导出为：HTML、LaTeX、PDF等格式。 以富媒体格式展示计算结果。富媒体格式包括：HTML，LaTeX，PNG，SVG等。 支持使用LaTeX编写数学性说明。 命令模式编辑模式下按esc键进入命令模式。命令模式下，单元格边框为灰色，且左侧边框线为蓝色粗线条。 ctrl+回车 运行当前cell dd 删除当前cell y 切换cell类型为Code m 切换cell类型为Markdown b 下方插入cell 编辑模式命令模式下按enter或return键进入编辑模式。编辑模式下，单元格边框和左侧边框线均为绿色。 魔法命令加个‘！’就可以执行shell命令，可以直接在单元格内执行”!pwd”, “!ls” 等Linux里面的命令呢，但是windows环境中，要把”!”改成魔法命令“%”即可执行 单元格内执行shell命令还有一个高频操作就是安装需要的第三方库!pip install you-package==version %who会输出当前notebook中已经存在的变量 %whos除了输出变量外，变量的类型以及当前值也会显示 一个单元格多输出例如我们使用pandas读取一个文件生成dataframe后，想了解这个df的size, columns, 前5行等信息，正常情况下df.head, df.shape, df.info等内容要分成三个单元格来完成。但其实有更好的方法，可以让一个单元格内输出多个内容。具体方法是「增加一个单元格」执行下面两行代码即可： 1from IPython.core.interactiveshell import InteractiveShell InteractiveShell.ast_node_interactivity = \"all\" Mito插件官方文档Mito是Jupyter notebook的一个插件，作用是编辑电子表格，并在编辑表格（带格式转换功能）时，可以生成相对应的Python代码。 格式化输出12345678910111213# 1.%做占位符name = \"wenke\"age =21print(\"我的名字是%s,年龄是%d\"%(name,age))# 2.{}做占位符 print(\"我的名字是{0},年龄是{1}\".format(name,age))# 3.f-stringprint(f'我的名字是{name},年龄是{age }') pprint当打印的字符（character）小于 80 时，pprint () 基本上等同于内置函数 print ()，当字符超出时，它会作美化，进行格式化输出：from pprint import pprint 路径相关123# path = 'E:\\\\新建文件夹' # path = 'E:/新建文件夹' path = r'E:\\新建文件夹' 文件命名规则如下： 1、 允许文件或者文件夹名称不得超过255个字符。2、 文件名除了开头之外任何地方都可以使用空格。3、 文件名中不能有下列符号：“？”、“、”、“╲”、“*”、““”、“”“、“&lt;”、“&gt;”、“|”。4、 文件名不区分大小写，但在显示时可以保留大小写格式。5、 文件名中可以包含多个间隔符，如“我的文件.我的图片.001”。 变量Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。 为多个变量赋值例如：a = b = c = 1为多个对象指定多个变量。例如：a, b, c = 1, 2, \"runoob\" 123456a = 3b = 10print(\"a = {}, b = {}\".format(a,b) )# 在Python中,交换变量的值，我们无需定义临时变量来操作a,b= b,aprint(\"a = {}, b = {}\".format(a,b) ) 变量命名规则硬性规则：变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。大小写敏感（大写的a和小写的A是两个不同的变量）。不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。错误命名： my-scorePEP 8要求：用小写字母拼写，多个单词用下划线连接。受保护的实例属性用单个下划线开头（后面会讲到）。私有的实例属性用两个下划线开头（后面会讲到）。 变量的作用域局部变量和全局变量局部变量：在一个函数中定义的变量就是局部变量（包括形参），其作用域是从定义局部变量的位置至函数结束的位置。全局变量：在所有函数外定义的变量就是全局变量，其在所有的函数中都能使用。 global关键字如果我们想要在一个函数中对全局变量进行修改，怎么办呢？这个时候就可以使用 global 关键字了。在函数体内定义，并且使用global关键字修饰后，该变量也就变为全局变量。在函数体外也可以访问到该变量，并且在函数体内还可以对其进行修改。 tip: 尽管Python允许全局变量和局部变量重名，但是在实际开发时，不建议这么做，因为这样容易让代码混乱，很难分清哪些是全局变量，哪些是局部变量。 nonlocal 关键字在 Python 中，函数的定义可以嵌套，即在一个函数中包含另一个函数的定义。通过 nonlocal 关键字，可以使内层的函数直接使用外层函数中定义的变量。 12345678910def outer(): x = 10 def inner(): nonlocal x x = 20 print('inner 函数中 x 的值为', x)#20 inner() print('outer 函数中 x 的值为', x) #20outer() 闭包闭包的定义：如果在一个内部函数里，对在外部函数内（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure) 函数嵌套/闭包中的作用域： 变量的类型在Python中可以使用type函数对变量的类型进行检查。 12345678910a = 100b = 12.345c = 1 + 5jd = 'hello, world'e = Trueprint(type(a)) # &lt;class 'int'&gt;print(type(b)) # &lt;class 'float'&gt;print(type(c)) # &lt;class 'complex'&gt;print(type(d)) # &lt;class 'str'&gt;print(type(e)) # &lt;class 'bool'&gt; 可以使用Python中内置的函数对变量类型进行转换。 int()：将一个数值或字符串转换成整数，可以指定进制。float()：将一个字符串转换成浮点数。str()：将指定的对象转换成字符串形式，可以指定编码。chr()：将整数转换成该编码对应的字符串（一个字符）。ord()：将字符串（一个字符）转换成对应的编码（整数）。 运算符Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，运算符的优先级指的是多个运算符同时出现时，先做什么运算然后再做什么运算。除了我们之前已经用过的赋值运算符和算术运算符，我们稍后会陆续讲到其他运算符的使用。 运算符的优先级()优先级最高 运算符 描述 [] ,[:] 下标，切片 ** 指数运算符(幂运算) ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ | 按位异或，按位或 (按照二进制进行逻辑运算 ) &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is , is not 身份运算符 in, not in 成员运算符 not, or ,and 逻辑运算符 = += -= *= /= %= //= **= &amp;= ` = ^= &gt;&gt;= &lt;&lt;=` 算数运算符12346 // 4 = 1 #整除6 / 4 =1.528 % 45 = 28 #求余 说明： 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。 比较运算符(关系运算符)包括==、!=、&lt;、&gt;、&lt;=、&gt;=，比较运算符会产生布尔值，要么是True要么是False。 比较两个值是否相等用的是==，请注意这个地方是两个等号，因为=是赋值运算符，==才是比较相等的比较运算符。 12345# 一行中的多个比较0&lt;n&lt;100# 代替(n&gt;0)and (n&lt;100) 逻辑运算符逻辑运算符有三个，分别是and、or和not。 and字面意思是“而且”，所以and运算符会连接两个布尔值，如果两个布尔值都是True，那么运算的结果就是True；如果and左边的布尔值是False，不管右边的布尔值是什么，最终的结果都是False，所以在做运算的时候右边的值会被跳过（短路处理）即右边的表达式根本不会执行。 or字面意思是“或者”，如果两个布尔值有任意一个是True，那么最终的结果就是True。当然，or运算符也是有短路功能的，在它左边的布尔值为True的情况下，右边的表达式根本不会执行。 not运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值， 逻辑运算符|运算 |表达式 |结果||——|——-|—–||或运算 |x or y |两个变量只要有一个为True则为True。||与运算 |x and y| 两个变量都为True时结果才为True。||非运算 |not x| not的优先级比非布尔运算符低，not a == b解释为not (a == b)| 12345678910\"\"\"比较运算符和逻辑运算符的使用\"\"\"flag0 = 1 == 1 #Trueflag1 = 3 &gt; 2 # flag1 = Trueflag2 = 2 &lt; 1 # flag2 = Falseflag3 = flag1 and flag2 # flag3 = Falseflag4 = flag1 or flag2 # flag4 = Trueflag5 = not (1 != 2) # flag5 = False 说明：比较运算符的优先级高于赋值运算符，所以flag0 = 1 == 1先做1 == 1产生布尔值True，再将这个值赋值给变量flag0。 12345678# 有多个 and 条件时使用 all()conditions = [ size == \"lg\", color == \"blue\", price &lt; 100,]if all(conditions): print(\"Yes, I want to but the product.\") 12345678# 有多个 or 条件时使用 any()conditions = [ size == \"lg\", color == \"blue\", price &lt; 100,]if any(conditions): print(\"Yes, I want to but the product.\") 赋值运算符赋值运算符优先级最低，它的作用是将右边的值赋给左边的变量 12345678\"\"\"赋值运算符和复合赋值运算符\"\"\"a = 10b = 3a += b # 相当于：a = a + ba *= a + 2 # 相当于：a = a * (a + 2)print(a) # 算一下这里会输出什么 三目运算符（三元表达式）为真时的结果 if 判断条件 else 为假时的结果（注意，没有冒号） 1234567max = a if a &gt; b else b# 实现一个基础版本（递归版本）的斐波那契数列：def fn(n): return n if n &lt; 2 else fn(n-1)+fn(n-2) 序列map()map(func, seq1[, seq2,…]) 将func作用于seq中的每一个元素，返回一个Iterator(迭代器)需要用list()函数获得所有结果并返回list。 func参数接受一个函数名 seq参数接受一个或多个可迭代的序列，返回的是一个集合。 12345reversed() 将一个序列翻转, 返回翻转序列的迭代器slice() 列表的切片random.choice() #可以从序列中获取一个随机元素； filter()过滤序列filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。返回一个Iterator(迭代器)需要用list()函数获得所有结果并返回list。关键在于正确实现一个“筛选”函数。把一个序列的空字符串删掉 1234567# 把一个序列的空字符串删掉def not_empty(s): return s.strip()L2 = filter(not_empty, ['A', '', 'B', 'C', ' '])print(list(L2)) 删掉偶数，只保留奇数 1234567#在一个list中，删掉偶数，只保留奇数def is_odd(n): return n%2==1 L1=filter(is_odd,[1,2,3,4,5,6,7,8,9,10,15])print(list(L1)) reduce()reduce(function, iterable[, initializer])参数 function – 函数，有两个参数 iterable – 可迭代对象 initializer – 可选，初始参数用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。 类型转换list() 将一个可迭代对象转换成列表tuple() 将一个可迭代对象转换成元组str() 将数据转化成字符串bytes() 把字符串转化成bytes类型 迭代切片sorted()排序sorted(iterable, cmp=None, key=None, reverse=False) 函数对所有可迭代的对象进行排序操作。返回一个列表 参数： iterable – 可迭代对象。 cmp – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。 计数可迭代对象.count(‘’) #返回元素在列表中出现的次数。 拼接序列支持+和*操作，不修改原有序列，构建一个新的序列 生成器表达式列表生成式是一种漂亮优雅的东西，然而它有一个致命的缺点：它一次性把所有元素加载到内存中，当列表过长的时候，便会占据过多的内存资源，而且，我们通常仅需要使用少数的元素，这样未使用的元素所占据的绝大部分的内存，就成了不必要的支出。 生成器是一种更高级更优雅的东西，它使用“懒加载”的原理，并不生成完整的列表，而是迭代地、即时地、按需地生成元素，这样不仅能极大地节省内存空间，而且，在理论上，它可以生成一个无穷大的列表！ 大多数生成器是以函数来实现的，然而，它并不返回（return）一个值，而是生成（yield）一个值，并挂起程序。然后，通过next()方法生成并马上返回一个元素，或者通过for循环，逐一生成和返回全部元素。 next()效率太低，且调用次数越界时会抛出StopIteration的异常，而for循环会自动捕捉这个异常，并停止调用，所以使用更佳。 生成器表达式与列表生成式极其形似，只是把[]改成了()，但背后的原理大不相同。 12345678910111213141516l = [x*2 for x in range(5)] # 列表生成式，4以内整数的2倍数g = (x*2 for x in range(5)) # 生成器表达式type(l) # 结果：&lt;type 'list'&gt;type(g) # 结果：&lt;type 'generator'&gt;print(l) # 结果：[0,2,4,6,8]print(g) # 结果：&lt;generator object at 0x000002173F0EBC50&gt;next(g) # 0next(g) # 2next(g) # 4next(g) # 6next(g) # 8next(g) # Traceback (most recent call last): ....StopIterationfor x in g:print(x, end=' ') # 结果：0 2 4 6 8 迭代器迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 next()。 数据类型（8种）字符串string(不可变) Python 中单引号 ‘ 和双引号 “ 使用完全相同。 转义符 ,反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \\n” 则 \\n会显示，并不是换行。 Python 不支持单字符类型，一个字符就是长度为 1 的字符串。 123456789101112131415#替换某个字符a=a.replace('-','') #用空字符串代替-#转义字符 \\print(\"The \\t is a tab\")print('I\\'m going to the movies')#Python三引号#保证字符串的格式是所见即所得print('''I'm going to \\nthe movies''') 字符串运算符123456789a = \"He-ll-o \"b = \"World \"print(a + b) #字符串连接：+print(a * 3) #重复输出字符串：*#成员运算符判断字符串中是否包含给定的字符print('e' in a)print('e' not in a) 索引与截取123456789#通过索引获取字符串中字符a[0] #从前面索引a[-1] #从后面索引#变量[头下标:尾下标:步长]#字符串截取[:] 牢记：左闭右开str=\"hello\"str[1:4]=\"ell\"str[:]=str[0:] 字符串驻留机制对相同字符串，只保留一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的相同字符串对应的变量 驻留机制的几种情况：字符串长度为0或1时符合标识符的字符串字符串只在编译时进行驻留，而非运行时[-5,256]之间的整数 优缺点当需要值相同的字符串时，可以直接从字符池里拿来用，避免频繁的创建和销毁，提升效率和节约内存 去除指定字符s.strip(rm) 删除s字符串中头尾指定字符s.lstrip(rm) 删除s字符串中开头处s.rstrip(rm) 删除s字符串中结尾处 replace()去除中间字符print(str.replace('\\n', '')) 1line.strip().split(',') #链式函数写法，strip()，就是去掉改行头尾空格和换行符。然后对strip()的结果进行split(',')，对结果以逗号的进行切分形成一个数组。 分隔字符串存为列表str.split(str=””, num=string.count指定字符串中某个字符作为分隔符对字符串进行分隔，存为列表。 12str = \"he-el\"str.split(\"-\") #['he', 'el'] join()12345678910# 以指定字符作为拼接符，将字符串中所有的元素合并为一个新的字符串new_str = '-'.join('Hello')H-e-l-l-o#元组转字符串turple=('he', 'olle')new_str = ''.join(turple)#列表转字符串print(''.join(['he', 'el'])) 字符串拼接时建议使用str类型的join方法，而非+，因为join()是先计算出所有字符中的长度，然后再拷贝，只new一次对象，效率更高 字符串解码str.decode(encoding=’UTF-8’,errors=’strict’) 该方法返回解码后的字符串。 encoding -- 要使用的编码，如\"UTF-8\"。 errors -- 设置不同错误的处理方案。默认为 'strict',意为编码错误引起一个UnicodeError。 其他可能得值有 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' 以及通过 codecs.register_error() 注册的任何值。 list（列表）List（列表）类似于栈 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。 特点1.查找和插入的时间随着元素的增加而增加；2.占用空间小，浪费内存很少。有序可重复集合，有序指按照元素的添加顺序来储存 创建列表12345678list_a = [1, 2, 3]list_b = list(\"abc\") # ['a', 'b', 'c'] 字符串转列表list_c = list((4, 5, 6)) # [4, 5, 6] 元组转列表# 结合range()函数，range(start, stop[, step])list_k = list(range(3,100,3)) # list_k == [3, 6, 9, ..., 96, 99] # 找出100以内的能够被3整除的正整数 列表生成式12345678910111213141516lst = [[0]*10 for t in range(k)] #输出一个k行10列的矩阵l=['H','Q']# 将一个列表中所有字符串变小写a = [s.lower() for s in l]# 生成扑克所有组合a =['黑桃','草花','红桃','方块']b=['A','1','2','3','4','5','6','7','8','9','10','J','K','Q']print([m+n for m in a for n in b ])list_d = [i for i in list_a] # list_d == [1, 2, 3]list_e = [i*j for i in list_a for j in list_c] # list_e == [4,5,6,10,12,12,15,18]list_f = [i*j for i,j in zip(list_a,list_c)] # list_f == [4, 10, 18]list_g = [i for i in list_a if i%2 == 0] # list_g == [2] 列表的索引和截取和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。列表截取的语法格式如下：变量[头下标:尾下标] 12345# 获得列表中元素和下标lst = [\"blue\", \"lightblue\", \"pink\", \"orange\", \"red\"]for idx, item in enumerate(lst): print(idx, item) 扩充列表123456789101112# 1.append()函数无返回值，但是会修改原本的列表。在列表尾部添加单个新元素。lst = [3, 2, 1]lis.append('4') # 在末尾添加元素lst.append(lst) #[3, 2, 1, […]]，其中“…”表示无穷递归# 2.insert()方法，在列表中指定位置添加元素。如果指定的下标不存在，就在末尾添加list1.insert(2, 'o') # 3.用 “+” 运算符，将两个列表拼接出一个新列表。# 4.用extend()方法，在一个列表后面拼接进另一个列表。list1.extend(list2) #将list2合并到list1，list2不变 删减列表12345678910111213141516171819list_1 = list_2 = list_3 = list_4 = ['I', 'am', 'very', 'happy']del list_1[0] # 1.删除指定索引m处的元素。list_2.remove('I') # 2.删除指定值的元素（第一个匹配项）。list_3.pop() # 3.取出并删除列表末尾的单个元素。list_4.pop(0) # 4.取出并删除索引值为m的元素。# 清空与销毁list_a = [1, 2, 3]list_b = [1, 2, 3]# 5.用clear()方法，清空列表的元素。list_b.clear() # list_b == []# 6.用del list 语句，销毁整个列表。del list_a # 没有list_a了，再使用则会报错 列表切片：基本格式：[i : i+n : m] ；从第i位索引起，向右取到后n位元素为止，按m间隔过滤i 是切片的起始索引值，为列表首位时可省略；i+n 是切片的结束位置，为列表末位时可省略；m 可以不提供，默认值是1，不允许为0，当m为负数时，列表翻转。注意：这些值都可以大于列表长度，不会报越界。 123456789101112131415161718li = [1, 4, 5, 6, 7, 9, 11, 14, 16]# 以下写法都可以表示整个列表，其中 X &gt;= len(li)li[0:X] == li[0:] == li[:X] == li[:] == li[::] == li[-X:X] == li[-X:]li[1:5] == [4,5,6,7] # 从1起，取5-1位元素li[1:5:2] == [4,6] # 从1起，取5-1位元素，按2间隔过滤li[-1:] == [16] # 取倒数第一个元素li[-4:-2] == [9, 11] # 从倒数第四起，取-2-(-4)=2位元素li[:-2] == li[-len(li):-2] == [1,4,5,6,7,9,11] # 从头开始，取-2-(-len(li))=7位元素# 注意列表先翻转，再截取li[::-1] == [16,14,11,9,7,6,5,4,1] # 翻转整个列表li[::-2] == [16,11,7,5,1] # 翻转整个列表，再按2间隔过滤li[:-5:-1] == [16,14,11,9] # 翻转整个列表，取-5-(-len(li))=4位元素li[:-5:-3] == [16,9] # 翻转整个列表，取-5-(-len(li))=4位元素，再按3间隔过滤li[::0] # 报错（ValueError: slice step cannot be zero） 其他操作1list.index() #查找指定值的元素的索引位置（第一个匹配项）。 用len()方法，统计全部元素的个数。 列表对象.count(‘’)方法，返回元素在列表中出现的次数。 用max()方法，统计元素中的最大值（要求元素类型相同；数字类型直接比较，其它类型比较id） 用min()方法，统计元素中的最小值（要求元素类型相同；数字类型直接比较，其它类型比较id） 用reverse()方法，翻转列表中的元素。 用copy()方法，浅拷贝并生成新的列表。 用deepcopy()方法，深拷贝并生成新的列表。 用sort()方法，在原列表基础上进行排序。 用sorted()方法，将新列表基础上对原列表的元素进行排序。 1234567891011121314151617181920212223242526272829303132a = [1,1,1,2,2,3,6,56,3,2]b = set(a) #列表去重(删除list中的重复元素)c = a[::-1] #反转列表list_1 = [2018, 10, '2018-10-1', ['hi', 1, 2], (33, 44)]len(list_1) == 5list_1.count(10) == 1 # 元素10的数量为1list_1.index(10) == 1 # 元素10的索引为1list_1.reverse() # list_1 == [(33, 44), ['hi', 1, 2], '2018-10-1', 10, 2018]# 比较浅拷贝与深拷贝import copylist_a = [2018, 10, '2018-10-1', ['hi', 1, 2], (33, 44)]list_b = ['hi', 1, 2]list_c = list_a.copy() # list_c == [2018, 10, '2018-10-1', ['hi', 1, 2], (33, 44)]list_d = copy.deepcopy(list_a) # list_d == [2018, 10, '2018-10-1', ['hi', 1, 2], (33, 44)]# 改变原列表中的可变对象元素list_a[3].append('new') # list_a == [2018, 10, '2018-10-1', ['hi', 1, 2, 'new'], (33, 44)]# 浅拷贝中的可变对象会随原列表变化而变化list_c == [2018, 10, '2018-10-1', ['hi', 1, 2, 'new'], (33, 44)]# 深拷贝中的可变对象不会随原列表变化而变化list_d == [2018, 10, '2018-10-1', ['hi', 1, 2], (33, 44)]# 比较sort() 与 sorted()list_1 = list_2 = [2,1,4,6,5,3]list_1.sort() # 原列表变化：list_1 == [1,2,3,4,5,6]list_3 = sorted(list_2) # 原列表不变：list_2 == [2,1,4,6,5,3]; list_3 == [1,2,3,4,5,6] 排序list.sort(cmp=None, key=None, reverse=False) [cmp] -- 可选参数, 如果指定了该参数会使用该参数的方法进行排序。 [key] 排序规则(排序函数), 在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数. 根据函数运算的结果进行排序。 [reverse] -- 排序规则，默认升序，True为降序 12345678910li = [[1, 7], [1, 5], [2, 4], [1, 1]]def fun(li): return li[1]# 传入了key参数的sort()函数对li中的每个子元素[1,7],[1,5],[2,4],[1,1]都执行了fun()函数，返回它们的第1个数# 分别为7,5,4,1。然后再排序得到1,4,5,7。使的出的结果对本来的li进行排序最后就得到了[[1,1],[2,4],[1,5],[1,7]]。# 指定第二个元素排序li.sort(key=fun)print(li) tuple（元组）与列表类似，但是元组中的内容不可修改 元组比列表更节省内存。 在时间效率方面，元组再次比列表有一点优势，尤其是在考虑查找值时。 如果有最初不打算更改的数据，则应选择元组数据类型而不是列表。但是，如果知道数据会在应用程序运行时增长和缩小，则需要使用列表数据类型。 123456789101112131415161718192021222324252627#元组中只有一个元素时，需要在后面加逗号！tup = ('hello',)#将列表转换成元组list = [14, 10, 9, 15, 6, 10, 12, 5, 15, 8]t = tuple(list)#tuple转换为list：list(tupl) #接受一个元组并返回一个列表#元组的修改：t1 = (1,2,3)+(4,5) #(1, 2, 3, 4, 5)t2 = (1,2) * 2 #(1, 2, 1, 2)#统计元组中4的个数print(t1.count(4))#元组中4所对应的下标，如果不存在，则会报错print(t.index(4))#判断元组中是否存在1这个元素print(4 in t)#返回元组中4所对应的下标,不会报错if(4 in t): print(t.index(4)) 元组的拆包与装包123456789101112131415161718#定义一个元组t3 = (1,2,3)#将元组赋值给变量a,b,ca,b,c = t3#打印a,b,cprint(a,b,c)#当元组中元素个数与变量个数不一致时#定义一个元组，包含5个元素t4 = (1,2,3,4,5)#将t4[0],t4[1]分别赋值给a,b;其余的元素装包后赋值给ca,b,*c = t4print(a,b,c)print(c)print(*c) 字典(dict)使用键-值（key-value）存储 1.查找和插入的速度极快，不会随着key的增加而变慢；2.需要占用大量的内存，内存浪费多。但键必须是不可变的，如字符串，数字或元组。 增删改查1234567891011121314151617181920212223242526272829303132# 添加键值对dic={}dic['name']='zhangsan'# 删除del dict['key'] #删除某个键值del dit #删除整个字典dit.clear() #将字典置空dit.get(key,default) #返回一个值，若没有返回defaultdit[key]='' #修改字典的值dit[key]=value #添加值dit[key] # 由键访问字典的值dit.keys() #返回所有键的列表dit.values() #返回所有 valuel的列表dit.items() #返回所有键值对的列表#同时迭代key和valuefor k,v in dit.items():a = {'a':1,'b':2}b = {'c':3}c = {**a,**b} #合并两个字典 将列表转换为字典1234567891011# 使用两个list生成一个字典keys = ['a', 'b', 'c']vals = [1, 2, 3]dic = dict(zip(keys, vals))#list可以转成字典，但前提是列表中元素都要成对出现lis=[('name','杨超越'),('weight',45)]dic = dict(lis) 按value排序123456789d = { \"v1\": 80, \"v2\": 20, \"v3\": 40, \"v4\": 20, \"v5\": 10,}sorted_d = dict(sorted(d.items(), key=lambda item: item[1]))print(sorted_d) 字典推导number（数字）Number 数据类型用于存储数值，包括整数、浮点型、复数 int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。float (浮点数), 如 1.23、3E-2complex (复数), 如 1 + 2j、 1.1 + 2.2j 2 / 4 # 除法，得到一个浮点数0.52 // 4 # 除法，得到一个整数017 % 3 # 取余 22 ** 5 # 乘方 32 math 模块Python 中数学运算常用的函数基本都在 math 模块 1234567891011import mathprint(math.ceil(4.1)) #返回数字的上入整数print(math.floor(4.9)) #返回数字的下舍整数print(math.fabs(-10)) #返回数字的绝对值print(math.sqrt(9)) #返回数字的平方根print(math.exp(1)) #返回e的x次幂 Python随机数1234567import random#随机生成[0,1)的实数ran1 = random.random()#从指定范围内，按指定基数递增的集合中 获取一个随机数random.randrange ([start], stop, step]) set（集合）是一个无序不重复的序列,无序即每添加一个元素，都会按照内部算法将元素添加到合适位置用于成员关系测试，删除重复元素a=set (‘abcd’) #与a={‘a’,’b’,’c’,’d’}等价 创建空集合只能使用set()，因为{}用来创建空字典。 Boolean（布尔值）总结一下为假的情况有： None, False数值中的0, 0.0, 0j(虚数), Decimal(0), Fraction(0, 1)空字符串(‘’)、空元组(())、空列表([])空字典({})、空集合(set())对象默认为True，除非它有bool()方法且返回False或len()方法且返回0. 函数参数(位置参数、默认参数、可变参数、关键字参数、命名关键字参数、参数组合） 实参和形参实参与形参存储在各自的内存空间中，是两个不相关的独立变量在参数内部改变形参的值，实参的值一般是不会改变的。 默认参数可变参数(*参数与**参数)是Python参数中的重点知识，他们都被称为可变参数（任意参数） 可变参数，必须定义在普通参数（也称位置参数、必选参数、选中参数等名称）以及默认值参数的后面，这是因为可变参数会收集所有【未匹配】的参数，如果将可变参数定义在前面，那么普通参数与默认值参数就无法匹配到传入的参数，因为全都收集到可变参数中了 可变参数出现在函数的不同的位置上时，具备不同的功能在函数定义时：表示可变参数函数定义时，二者同时存在，一定需要将args放在**kwargs之前1、参数收集所有未匹配的位置参数组成一个tuple对象，局部变量args指向此tuple对象2、*参数收集所有未匹配的关键字参数组成一个dict对象，局部变量kwargs指向此dict对象1、args表示可接受任意个（包含0个）位置参数，当函数调用时，所有未使用（未匹配）的位置参数会在函数内自动组装进一个tuple对象中，此tuple对象会赋值给局部变量args 2、**kwargs表示可接受任意个（包含0个）关键字参数，当函数调用时，所有未使用（未匹配）的关键字参数会在函数内组装进一个dict对象中，此dict对象会赋值给局部变量kwargs 在函数调用时：表示解包功能 1、*args表示解包元组对象中的每个元素作为位置参数传入到被调用函数中2、**kwargs表示解包字典对象中的每个元素作为关键字参数传入到被调用函数中 函数调用时传入的参数，会按照从左到右的顺序依次在函数中使用，最左侧的参数先由位置参数first使用（匹配），剩下的所有未匹配的参数会被自动收集到1个新的tuple对象中，而局部变量second会指向这个新的tuple对象 12345def print_str(first, *second): print(first) print(second)print_str(\"hello\",\"美女\",\"小猫\",\"青蛙\") 解包numbers_strings出现在函数调用时，称为解包（一个“”字符后面紧挨着1个tuple对象），numbers_strings自身是一个tuple对象，所以也称为元组的解包，tuple中的元素解包成一个一个的位置参数传入到函数中， 12345678def print_str(first, *second): print(first) print(second)numbers_strings = (\"1\",\"2\",\"3\",\"4\",\"5\")print_str(*numbers_strings) #注意这里的*numbers_strings 解包功能不只是tuple、还有list、str、range return返回值函数使用return返回值，也可以使用lambda表达式作为函数的返回值 一个函数只有一个返回值，但是可以通过返回列表或元组的方式将返回的多个值保存到序列中，从而间接达到返回多个值的目的。默认以元组返回 return语句只能出现在函数体内，执行到return这一步时，会退出函数，即使是在一个循环体内，程序也不会再执行 print仅仅是打印在控制台，return则是将return后面的部分作为返回值：作为函数的输出，可以用变量接走，继续使用该返回值做其它事。 如果一个函数没有reutrn语句，其实它有一个隐含的return语句，返回值是None，类型也是’NoneType’。 内置函数zip()zip() 函数是 Python 内置函数之一，它可以将多个序列（列表、元组、字典、集合、字符串以及 range() 区间构成的列表）“压缩”成一个 zip 对象。所谓“压缩”，其实就是将这些序列中对应位置的元素，生成一个个新的元组。 123print([x for x in zip({31:2,32:4,33:5})]) #[(31,), (32,), (33,)]print([x for x in zip(\"python\",\"shell\")]) #[('p', 's'), ('y', 'h'), ('t', 'e'), ('h', 'l'), ('o', 'l')] range1234range(5) #0-4range(1, 101) #产生1到100范围的整数，相当于前面是闭区间后面是开区间。range(1, 101, 2) #产生1到100的奇数，其中2是步长，即每次数值递增的值。range(100, 0, -2) #产生100到1的偶数，其中-2是步长，即每次数字递减的值。 进制转换bin() 将给的参数转换成二进制otc() 将给的参数转换成八进制hex() 将给的参数转换成十六进制 数学运算1234567abs() 返回绝对值round() 四舍五入pow(a, b) 求a的b次幂, 如果有三个参数. 则求完次幂后对第三个数取余sum() 求和min() 求最小值max() 求最大值divmod(20,3) # 求商和余数:(6,2) setset() 函数创建一个无序不重复元素集合，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等set([iterable])参数： iterable – 可迭代对象对象；返回值： 返回新的集合对象。 lambda表达式匿名函数lambda：是指一类无需定义函数名的函数，可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值。lambda 参数 : 表达式 12345lambda x:x# 第一个x，在冒号前，表示判断等效于 if x : ,后面则为返回x ,也可以对x进行操作if x ： return x 高阶函数接受函数为参数，或者把函数作为结果返回值的函数 装饰器装饰器函数的参数是一个函数，返回值也是一个函数。 特殊方法(双下方法)导包模块（module）Python 模块(Module)，是一个 Python 文件，以 .py 结尾，文件名就是模块名。包含了 Python 对象定义和Python语句。 使用python模块大大提高了代码的可维护性和代码复用性,避免了函数名与变量名冲突。 if name == ‘main‘的意思是：当.py文件被直接运行时，if name == ‘main‘之下的代码块将被运行； 当.py文件以模块形式被导入时，if name == ‘main‘之下的代码块不被运行。 包( package)在比較大型的项目中常常需要编写、用到大量的模块，此时我们可以使用包( Package)来管理这些模块。 包是一个分层次的文件目录结构，简单来说，包就是文件夹，但该文件夹下必须存在 init.py 文件, 该文件的内容可以为空。init.py 用于标识当前文件夹是一个包。 我们在导入包的时候，实际上是导入了它的 init.py文件文件。 库对于库的定义，和包（Package）有点类似。一般能定义成库的，基本上都是完成了特定功能的实现，并得到使用者的肯定，但库的本质是“包”/“模块”。 例如django库，对于使用的人来说，他是一个库；但是对于该库作者来说，django就是他写的一个包。 1234567891011121314import somemodule #导入整个模块from somemodule import * #导入库中的所有类、函数、变量等信息,调用相关函数或变量时，就不需要加somemodule前缀from somemodule import somefunction #从某个模块中导入某个函数from somemodule import firstfunc, secondfunc, thirdfunc #从某个模块中导入多个函数 import 包名[.模块名[as别名]from 包名 import 模块名[as别名]from 包名.模块名 import成员名[as别名] pip123456789101112131415pip 安装第三方库速度太慢,可设置 pip 从国内的镜像源下载安装阿里云 http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/豆瓣 http://pypi.douban.com/simple/清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/# 临时使用pip install -i https://pypi.tuna.tsinghua.edu.cn/simple xxxxxxx# 永久设置pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 依赖包导入导出在terminal中输入： 123456pip freeze &gt; requirements.txt #1.将依赖包导出至requirements文件pip install -r requirements.txt #2.从requirements文件中导入依赖包 面向对象定义类在Python中可以使用class关键字定义类 123456789101112131415161718class Student(object): # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print('%s正在学习%s.' % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_movie(self): if self.age &lt; 18: print('%s只能观看《熊出没》.' % self.name) else: print('%s正在观看岛国爱情大电影.' % self.name) 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。 类的属性属性(成员变量)有两种：实例属性和类属性 实例属性是在构造函数__init__中定义，定义时以self作为前缀，实例属性属于各个实例所有，互不干扰； 类属性：直接在类中定义属性，绑定在类本身。类属性属于类所有，所有实例共享一个属性 12345678910111213141516171819class Student(object): name = 'Student' #类属性 def __init__(self,age): self.age=age # 实例属性s = Student() # 创建类的实例对象ss.age #只能这样访问实例属性print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找类的name属性print(f'类的name属性:{Student.name}') s.name = 'Michael' # 给实例绑定name属性print(f'实例属性:{s.name}') # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问del s.name # 如果删除实例的name属性print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了 在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。 类的私有属性__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 类的方法在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数， 1234567class Cylinder: num=3.14 def __init__(self,a,b): self.r=a self.h=b def volume(self): self.v=r*r*h*Cylinder.num #在类方法中调用实例属性和类属性 self参数self 表示当前类自身，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。可以使用它来引用类中的成员变量和成员函数。 类实例化后，self即代表着实例（对象）本身。Python的类不能直接使用，只有通过创建实例（对象）才能发挥它的功能，每个实例（对象）都是独一无二的，它可以调用类的方法、属性。 构造方法__init__方法是一种特殊的方法，被称为类的初始化方法，当创建这个类的对象实例时调用该方法进行初始化操作 __init__方法的第一个参数永远是self，表示创建的实例本身，有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传， 123def __init__(self, name, age): self.name = name self.age = 静态方法@staticmethod 静态方法只是名义上归属类管理，但是不能使用类变量和实例变量，是类的工具包放在函数前（该函数不传入self或者cls），所以不能访问类属性和实例属性 类的私有方法__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。 类的专有方法：1234567891011121314__init__ : 构造函数，在生成对象时调用__del__ : 析构函数，释放对象时使用__repr__ : 打印，转换__setitem__ : 按照索引赋值__getitem__: 按照索引获取值__len__: 获得长度__cmp__: 比较运算__call__: 函数调用__add__: 加运算__sub__: 减运算__mul__: 乘运算__truediv__: 除运算__mod__: 求余运算__pow__: 访问可见性在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头 1234567891011121314151617181920class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar')def main(): test = Test('hello') # AttributeError: 'Test' object has no attribute '__bar' test.__bar() # AttributeError: 'Test' object has no attribute '__foo' print(test.__foo)if __name__ == \"__main__\": main() 但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是”We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。 在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻 创建和使用对象实例实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 123456# 创建一个实例stu1 = Student('骆昊', 38)stu1.study('Python程序设计')# 给对象发watch_av消息stu1.watch_movie() @property装饰器之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。 我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。 12345678910111213141516171819202122232425262728293031323334class Person(object): # __slots__魔法限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') def __init__(self, name, age): self._name = name self._age = age # 访问器 - getter方法 @property def age(self): return self._age # 修改器 - setter方法 @age.setter def age(self, age): self._age = age def play(self): if self._age &lt;= 16: print('%s正在玩飞行棋.' % self._name) else: print('%s正在玩斗地主.' % self._name)def main(): person = Person('王大锤', 12) person.play() person.age = 22 person.play() # person.name = '白元芳' # AttributeError: can't set attributeif __name__ == '__main__': main() __slots__魔法:Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 继承,重写与多态我们可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person(object): \"\"\"人\"\"\" def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): print('%s正在愉快的玩耍.' % self._name) def watch_av(self): if self._age &gt;= 18: print('%s正在观看爱情动作片.' % self._name) else: print('%s只能观看《熊出没》.' % self._name)class Student(Person): \"\"\"学生\"\"\" def __init__(self, name, age, grade): super().__init__(name, age) self._grade = grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade = grade def study(self, course): print('%s的%s正在学习%s.' % (self._grade, self._name, course))class Teacher(Person): \"\"\"老师\"\"\" def __init__(self, name, age, title): super().__init__(name, age) self._title = title @property def title(self): return self._title @title.setter def title(self, title): self._title = title def teach(self, course): print('%s%s正在讲%s.' % (self._name, self._title, course))def main(): stu = Student('王大锤', 15, '初三') stu.study('数学') stu.watch_av() t = Teacher('骆昊', 38, '砖家') t.teach('Python程序设计') t.watch_av()if __name__ == '__main__': main() 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。 12345678910111213141516171819202122232425262728293031323334353637from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta): \"\"\"宠物\"\"\" def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): \"\"\"发出声音\"\"\" passclass Dog(Pet): \"\"\"狗\"\"\" def make_voice(self): print('%s: 汪汪汪...' % self._nickname)class Cat(Pet): \"\"\"猫\"\"\" def make_voice(self): print('%s: 喵...喵...' % self._nickname)def main(): pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')] for pet in pets: pet.make_voice()if __name__ == '__main__': main() 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。 抽象类12345678910111213from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta): \"\"\"宠物\"\"\" def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): \"\"\"发出声音\"\"\" pass 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。 五大基本语句赋值语句赋值语句的作用:将变量绑定到对象 标识符第一个字符必须是字母表中字母或下划线 _ 。标识符的其他的部分由字母、数字和下划线组成。标识符对大小写敏感。在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。 输入输出语句（print, input函数）输入123# 处理用户的多个输入n1, n2, n3 = input(\"输入三个数，以空格分隔 \").split()input()得到的都是str类型 格式化输出123print(\"{} {}\".format(\"hello\", \"world\") ) # 不设置指定位置，按默认顺序print(\"{1} {0} {1}\".format(\"hello\", \"world\")) # 设置指定位置 条件判断语句pyhton 只有if-else语句没有switchif-elif-else语句 三目运算符（三元表达式）为真时的结果 if 判断条件 else 为假时的结果（注意，没有冒号） 123# 实现一个基础版本（递归版本）的斐波那契数列：def fn(n): return n if n &lt; 2 else fn(n-1)+fn(n-2) 循环语句for/else循环for…else 语句块可以被理解为当循环条件不满足时，我们来处理我们需要做的事，伪代码逻辑如下： 1234567for i in range(n): if condition: you_find_your_stuff() breakelse: you_did_not_find_your_stuff() else字句运行有两种情况 1.使用 break 跳出循环 2.循环自然结束 条件循环while-else如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环。while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True则继续循环；表达式的值为False则结束循环。 123456789#无限循环while True:#while 循环使用 else 语句while (): passelse； pass else子句else：在循环中可以使用else语句，else语句在for遍历结束或者while语句为Flase时候执行，循环被break终止时不执行 break/continuebreak 语句 在语句块执行过程中终止循环，并且跳出整个循环continue 语句 在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。 异常处理语句(try-except-else-finally)调试 断点调试其实就是在程序自动运行的过程中，你在代码某一处打上了断点，当程序跑到你设置的断点位置处，则会中断下来，此时你可以看到之前运行过的所有程序变量。 step over（F8快捷键）：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。在不存在子函数的情况下是和step into效果一样的。简单的说就是，程序代码越过子函数，但子函数会执行，且不进入。 step into（F7快捷键）：在单步执行时，遇到子函数就进入并且继续单步执行，有的会跳到源代码里面去执行。 step into my code（Alt+Shift+F7快捷键）：在单步执行时，遇到子函数就进入并且继续单步执行，不会进入到源码中。 step out（Shift+F8快捷键）：假如进入了一个函数体中，你看了两行代码，不想看了，跳出当前函数体内，返回到调用此函数的地方，即使用此功能即可。 Resume program(F9快捷键)：继续恢复程序，直接运行到下一断点处。 一般操作步骤就是，设置好断点，debug运行，然后 F8 单步调试，遇到想进入的函数 F7 进去，想出来在 shift + F8，跳过不想看的地方，直接设置下一个断点，然后 F9 过去。 思想使用辅助函数简化复杂表达式123456789101112131415def the_max(x, y): return x if x &gt; y else ya = int(input('a = '))b = int(input('b = '))c = int(input('c = '))print('The max is:', the_max(the_max(a, b), c))# 复杂the_max = a &gt; b and a or bthe_max = c &gt; the_max and c or the_maxprint('The max is:', the_max) 工具 可视化代码执行 代码规范PEP标准PEP（Python增强提案：Python Enhancement Proposals）PEP-8","categories":[{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/tags/python/"}]},{"title":"AutoJS","slug":"AutoJS","date":"2022-01-08T09:17:39.000Z","updated":"2022-01-08T09:17:39.000Z","comments":true,"path":"2022/010827358.html","link":"","permalink":"https://wenkex.gitee.io/2022/010827358.html","excerpt":"","text":"autojspro基于控件控件属性className 类名。类名表示一个控件的类型packageName 包名。包名表示控件所在的应用包名bounds 控件在屏幕上的范围。drawingOrder 控件在父控件的绘制顺序。indexInParent 控件在父控件的位置。clickable 控件是否可点击。longClickable 控件是否可长按。checkable 控件是否可勾选。checked 控件是否可已勾选。scrollable 控件是否可滑动。selected 控件是否已选择。editable 控件是否可编辑。visibleToUser 控件是否可见。enabled 控件是否已启用。depth 控件的布局深度。fullId: app包名:id/对应的id名称 ，内容一样要写在id里，例如id(“fullld的内容”) UiSelector控件选择器我们使用UiSelector选择器筛选出所需要的控件，筛选的依据就是通过控件的各种属性选取屏幕上的控件通常用一个唯一的属性来定位一个控件depth-desc-id-classname等控件的常规的唯一属性findone.parent().child(xx)等控件的父子依存顺序关系 .findOne(timeout)根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，直到屏幕上出现满足条件的一个控件为止，并返回该控件；如果在timeout毫秒的时间内没有找到符合条件的控件，则终止搜索并返回null。 .find()找到所有满足条件的控件集合并返回。这个搜索只进行一次，并不保证一定会找到，因而会出现返回的控件集合为空的情况 1234567// 可以通过empty()函数判断找到的是否为空。例如：var c = className(\"AbsListView\").find();if(!c.empty()){ toast(\"找到啦\");}else{ toast(\"没找到╭(╯^╰)╮\");} .findOnce(i).untilFind() .exists().waitFor().filter(f) 其他algorithm(algorithm) 指定选择器的搜索算法。 广度优先在控件所在层次较低时，或者布局的层次不多时，通常能更快找到控件 (text,desc,id,className,packageName)都可以像下面一样创建选择器textContains(str) “text需要包含字符串str”的筛选条件。textStartsWith(prefix)textEndsWith(suffix)textMatches(reg) UiSelector.untilFind()UiSelector.exists()UiSelector.waitFor() UiSelector.filter(f)f {Function} 过滤函数，参数为UiObject，返回值为boolean为当前选择器附加自定义的过滤条件。 UiObject控件对象UiObject表示一个控件，可以通过这个对象获取到控件的属性，也可以对控件进行点击、长按等操作。 获取一个UiObject通常通过选择器的findOne(), findOnce()等函数，也可以通过UiCollection来获取，或者通过UiObject.child(), UiObject.parent()等函数来获取一个控件的子控件或父控件。 1text(\"微信\").findOne() //返回一个控件对象，想要操作这个控件，其属性必须为true click(text[, i])text {string} 要点击的文本i {number} 如果相同的文本在屏幕中出现多次，则i表示要点击第几个文本, i从0开始计算 click() 点击。点击一个控件，前提是这个控件的clickable属性为truelongClick() 长按。长按一个控件，前提是这个控件的longClickable属性为truesetText() 设置文本，用于编辑框控件设置文本。scrollForward();scrollBackward() 滑动。滑动一个控件(列表等), 前提是这个控件的scrollable属性为trueexits() 判断控件是否存在waitFor() 等待控件出现 bounds()坐标返回控件在屏幕上的范围，其值是一个Rect对象。 如果一个控件本身无法通过click()点击，那么我们可以利用bounds()函数获取其坐标，再利用坐标点击。总体来说，基于坐标来确定要操作的控件比较简单，核心是确定要操作的控件的坐标即可。Auto.JS里可以直接获取控件的坐标，每一个控件包含其“.bounds()”属性，bounds()其实表示的是一个范围矩阵。此处还是以右下角的“+”号按钮为例，查看控件属性信息，包含“.bounds()”属性如下图： bounds()属性是四个坐标值，其分别为(left, top, right, buttom) left：控件左边缘与屏幕左边的距离 top：控件上边缘与屏幕上边的距离 right：控件右边缘与屏幕左边的距离 buttom ： 控件下边缘与屏幕上边的距离 因此，在获得控件的坐标bounds()属性后，就可以对控件执行基于坐标的操作，常见的操作有： 12345678910bounds().left：长方形左边界的x坐标bounds().right：长方形右边界的x坐标bounds().top：长方形上边界的y坐标bounds().bottom：长方形下边界的y坐标bounds().centerX()：长方形中点x坐标bounds().centerY()：长方形中点y坐标bounds().width()：长方形宽度也就是控件宽度bounds().height()：长方形高度也就是控件高度click(x,y)：坐标(x,y)处执行点击操作 //注意:安卓7以下点击需要root权限且函数为Tap(x,y)bounds(left, right, top, bottom).clickable().click()：点击该长方形区域 基于控件属性确定控件通过查看这些属性，我们不难发现有其中一项属性desc(“更多选项”)，很可能是不和其他控件相同的，也就是此控件属性具有唯一性，能唯一的确定此控件，这个属性就是我们要找的。因此，我们想要对其进行操作只需要： 12345if(desc(\"更多选项\").exists()){ sleep(1000); desc(\"更多选项\").findonce().click(); } 上述代码执行后，在该界面时，desc(“更多选项”)首先会被查找(findonce)，查找后执行点击(click)，从而【⋮】按钮也就被点击了。总结下无非就是我们找到了此按钮的唯一控件属性desc(“更多选项”)从而再对其操作，仅此而已。 另外，加上“.exist()”是为了增加程序鲁棒性，万一控件不存在或者没找到，则程序不会执行，否则对不存在(或没找到)的控件操作会抛出异常。基于此，往往要判定控件存在与否后再进行操作，而“.exist()”返回的是一个布尔值，方便后续进行判断和操作。另外一个常用的操作就是加上“while(!)”死循环等待控件出现，如： 12345678910//当\"更多选项\"不存在等价于此按钮还没出现while(!desc(\"更多选项\").exists()){ //继续循环等待，直到按钮出现 sleep(1000);} //执行到这里说明\"更多选项\"存在了，对该按钮执行点击操作desc(\"更多选项\").findonce().click();return; 当分析了很多控件后不难发现，控件的文本信息往往是以desc或text属性来呈现的，比如一个该按钮名为”更多选项”，其控件的desc属性或text属性就是其按钮名字，确定其名字也就确定了此控件，针对此按钮具体来说，就是其desc属性是”更多选项”。（此处要说的意思就是要具体问题具体分析，文本信息不是desc就是text，如果是desc属性就操作desc，是text属性就操作text）但是，往往就有时候我们只知道包含的部分desc或text，这时候可用这四个函数来确定： 1234567891011//descContains即desc包含部分信息即可匹配if(descContains(\"选项\").exists()){ //需要执行的操作} //descStartsWith即desc以此信息开头即可匹配if(descStartsWith(\"更多\").exists()){ //需要执行的操作} 同理，text也有对应的两个函数,比如一个按钮text属性为(“我的学习积分”)/ 1234567891011//textContains即text包含部分信息即可匹配if(textContains(\"学习积分\").exists()){ //需要执行的操作} //textStartsWith即text以此信息开头即可匹配if(textStartsWith(\"我的\").exists()){ //需要执行的操作} 当然，更多情况是desc和text属性并不能唯一确定要操作的控件，我们往往用其他属性(常用的有className、id、depth等)一起叠加使用来尽可能的使之唯一，比如： 123//往往是诸多控件属性一起才可唯一确定待操作的控件var myObject = className(“XXX”).depth(xx).id(“XXX”).text(“XXX”).findone();myObject.click(); 需要注意的是：在不同的Android系统上，同一版本的app的控件属性可能会变化。同样，app版本更新后，控件属性、布局也可能发生变化，所以，若要对不同版本不同系统具有兼容性，应尽可能选择不变化的控件属性。 基于控件父子关系确定控件有时候，控件属性是变化的、随机的，这时候我们便不能通过控件的本身固有属性如id，className，depth等来唯一的确定出需要的控件，这时候我们可以通过控件之间的上下级关系(也叫父子关系)来确定出需要操作的控件。 首先需要了解的是控件间的依存关系，还是以之前的app界面为例，我们这次来分析右下角的的“+”号按钮，和之前一样利用Auto.JS分析控件布局，我们点击右下角的“+”号按钮，点击[在布局层次中查看]，便可以查看当前控件在整个布局层次中的上下级关系(父子关系)，如图1.6所示，不难发现，从上到下，左侧五颜六色的竖棍丨就代表着其层级关系，竖棍丨越多也就越处于底层，该“+”号按钮控件名为“ImageButton”，对应着拥有8根竖棍丨，所以其是在第八级。 另外，和“ImageButton”平级的控件是图1.6所示的8.2—“ImageView”控件，“ImageButton”的父控件也就是它的上级控件是图1.6所示的7.3—“android.view.View”控件，所以我们可以建立以下关系： 123456789101112138.1中“ImageButton”的parent() = 7.3中“android.view.View”7.3中“android.view.View”的child(0) = 8.1中“ImageButton”7.3中“android.view.View”的child(1) = 8.2中“ImageView”7.3中“android.view.View”的parent() = 6中“android.view.View”6中“android.view.View”的child(0) = 7.1中“LinearLayout”6中“android.view.View”的child(1) = 7.2中“android.view.View”6中“android.view.View”的child(2) = 7.3中“android.view.View” 建立了以上隶属关系，我们就可以通过唯一确定任意其中一个不变的固定控件，便可通过控件间的隶属关系来确定我们想要的控件，从而规避了我们要找的控件属性动态变化这一情况。 在这里，我们假定以之前右上角的【⋮】按钮为固定控件(因为”更多选项”这几个字基本不会变化)，通过【⋮】按钮来和控件间的父子关系来确定出右下角的“+”号按钮。 首先分析右上角的【⋮】按钮的层级关系，如图1.7所示，【⋮】按钮位于第10级，它的父级parent是图1.7所示的9.3—“android.support.v7.widget.LinearLayoutCompat”，9.3的父级是8—“android.view.View”,以此类推，发现我们想要操作的控件也就是“ImageButton”控件(8.1)和右上角的【⋮】按钮即“ImageView”控件(10)关系是： 12345“ImageView”控件(10)是从7.1—“LinearLayout”继承下来的；“ImageButton”控件(8.1)是从7.3—“android.view.View”继承下来的； 而7.1和7.3是平级关系，拥有共同的父级6—“android.view.View” 图1.7 控件的布局层次分析2 明白了这一点，我们便可通过【⋮】按钮(10)来确定右下角的“+”号按钮(8.1)，如下所示： 1234567891011121314151617181920//首先，通过desc属性确定出【⋮】按钮(图1.7所示的10)//属性.findone()首先找到一个控件，再在此基础上加.parent等var moreButton = desc(\"更多选项\").findone(); //其次，找到【⋮】按钮和右下角“+”号按钮共同的父级parent//在这里是一层层往上找是为了方便理解，实际操作可一步到位var 9_3Supportv7 = moreButton.parent(); //找到图1.7所示的9.3控件var 8viewView = moreButton.parent().parent(); //找到图1.7所示的8控件var 7_1LinearLayout = moreButton.parent().parent().parent(); //找到图1.7所示的7.1控件var 6viewView = moreButton.parent().parent().parent().parent(); //找到图1.7所示的6控件 //最后，通过共同的父级parent找到右下角“+”号按钮//在这里是一层层往下找是为了方便理解，实际操作可一步到位var 7_3viewView = 6viewView.child(2); //找到图1.7所示的7.3控件var plusButton = 6viewView.child(2).child(0); //找到图1.7所示的8.1控件（也就是+号按钮） //所以，如果一步到位，总结如下：var plusButton = moreButton.parent().parent().parent().parent().child(2).child(0);//再对+号按钮进行点击plusButton.click(); 此处例子里的的两个控件【⋮】按钮(10)和右下角的“+”号按钮(8.1)之间相差了很多层，因此显着有些复杂，在实际情况中，我们往往不需要跨越这么多的层级来确定控件，一般情况下不会那么复杂。实际上，父子关系嵌套两三层往往即可确定出另一控件。最后，在这里需要注意的是，确定控件时要加上“.findone()”，此方法调用后会返回所有符合条件的控件集合。因此，首先要找到一个不容易变化的或容易找的控件“.findone()”后再在此基础上进行“.parent()”“.child(index)”操作找到另一控件。 滑动当然，基于坐标的操作不仅有click()操作，常用的还有swipe()滑动操作，gesture()手势滑动操作等，具体可查看官方文档，在这里仅对swipe()，gesture()这两个函数进行介绍。 swipe(x1,y1,x2,y2,time)：(x1,y1)代表起始点坐标，(x2,y2)代表终点坐标，time代表滑动所需要的时间 //注意：安卓7以下的滑动需要root权限，且函数名变为Swipe(x1,y1,x2,y2,time) gesture(time,[x1,y1],[x2,y2],[x3,y3]…)：time同，(x1,y1)是起始点坐标，(x2,y2)是途径点坐标，最后一个坐标是终点 下面以一个某APP注册时的滑动验证为例(为防止被人恶意利用，在此打上码。再次声明，此处做仅举例用，所有代码仅供学习交流！)，如图2.0所示，当我们输入手机号点击注册时，此时需要将滑块拖动到指定位置处才可以发送验证码从而进行下一步的注册。在这里，我们将想要拖动的滑块称为控件①，想要拖到的目标处称为控件②。那么，如果想要实现一个自动化拖动首先就要确定的是控件①和控件②的坐标，又因为其坐标每次都是随机的，所以只需要根据两个控件的特有属性唯一确定出控件①和控件②，再每次获取其坐标即可。 通过对两个控件的属性分析，如图2.1所示，我们不难发现，控件①和控件②的indexInParent()不同，因此可通过此分别唯一的定位出两个控件，确定控件后，我们再调用swipe()或gesture()函数来执行滑动，从而实现自动滑动的操作。 具体实现代码如下： 1234567891011121314151617181920212223242526272829303132//首先判断是否进入了\"滑动验证\"界面if(text(\"滑动验证\").exists()){ sleep(2000); //判断控件1是否存在 if(className(\"android.widget.Button\").depth(8).indexInParent(1).exists()) { //控件1存在，获取其坐标bounds()属性 var Button1 = className(\"android.widget.Button\").depth(8).indexInParent(1).findOne().bounds(); sleep(500); console.log(\"Button1的坐标为:\"+ Button1); } //判断控件2是否存在 if(className(\"android.widget.Button\").depth(8).indexInParent(3).exists()) { var Button2 = className(\"android.widget.Button\").depth(8).indexInParent(3).findOne().bounds(); sleep(500); console.log(\"Button2的坐标为:\"+ Button2); } //两个控件的坐标都获取到后，执行swipe或gesture操作 sleep(2000); //swipe(x1,y1,x2,y2,[time]) swipe(Button1.left, Button1.top, Button2.left, Button2.top, [random(500,1200)]); sleep(2000); //gesture(time,[x1,y1],[x2,y2]) console.log(\"Swipe完成！\"); gesture(random(500,1200), [Button1.left, Button1.top], [Button2.left, Button2.top]); console.log(\"gesture完成！\"); //结束} find()函数会找出所有满足条件的控件并返回一个控件集合,之后可以对控件集合进行操作 var findAssemble = textContains(“2020-07-15”).find(); //找到所有包含”2020-07-15”的控件集合findAssemble findone()函数会对屏幕上的控件进行搜索，直到屏幕上出现满足条件的一个控件为止，并返回该控件 如果找不到控件，当屏幕内容发生变化时会重新寻找，直至找到注意：如果findone不加限制时间且屏幕上一直没有出现所描述的控件，则该函数会阻塞，直到找到为止 12var findoneAssem1 = textContains(\"2020-07-15\").findone(); //找到一个包含\"2020-07-15\"的控件findoneAssem1var findoneAssem2 = textContains(\"2020-07-15\").findone(500); //在500毫秒内找到一个包含\"2020-07-15\"的控件findoneAssem，若找不到，终止搜索返回null findonce(i)函数会根据当前所确定的筛选条件，对屏幕上的控件进行搜索，并返回第 i + 1 个符合条件的控件 如果没有找到符合条件的控件，或者符合条件的控件个数 &lt; i, 则返回null 12var findonce1 = textContains(\"2020-07-15\").findonce(0); //搜索第一个包含\"2020-07-15\"的控件findonce1var findonce2 = textContains(\"2020-07-15\").findonce(1); //搜索第二个包含\"2020-07-15\"的控件findonce2 滑动在很多时候，我们经常会见到className名为“.ListView”的控件，实际上其往往是充当装在很多list的集合，以此控件为例，我们可以实现对此控件的上下滑动， 12345//scrollForward()函数会对控件执行向前滑动的操作，并返回是否操作成功//scrollBackward()函数会对控件执行向后滑动的操作，并返回是否操作成功var listView = ClassName(“ListView”).id(XXX).findone();ListView.scrollForward(); //向前滑动ListView.scrollBackward(); //向后滑动 在此只是以“.ListView”的控件进行举例，实际使用过程中，只要控件是可上下滑动的，都可以调用函数“scrollForward()”和“scrollBackward()”来实现对控件的滑动操作。 基于坐标前置屏幕坐标系，屏幕左上角为原点（0，0），向右为x轴正向，向下为y轴正向,单位为px gesturesgestures([delay1, duration1, [x1, y1], [x2, y2], …], [delay2, duration2, [x3, y3], [x4, y4], …], …) 同时模拟多个手势。每个手势的参数为[delay, duration, 坐标], delay为延迟多久(毫秒)才执行该手势；duration为手势执行时长；坐标为手势经过的点的坐标。 其中delay参数可以省略，默认为0。 例如手指捏合： 123456// 三指下滑截屏gestures( [0, 500, [230, 452], [230, 1000]], [0, 500, [500, 452], [500, 1000]], [0, 500, [755, 452], [755, 1000]]); 屏幕缩放1234567891011121314// serScreenMetrics(width,height) //aj自带屏幕缩放函数// var h = device.height 获取屏幕高度px// var w = device.width 获取屏幕宽度px//屏幕缩放函数 适配多机型function clicks(x,y){//注意,测试机型为1080*2340,你可以根据自己的机型修改x1=device.width/1080 //屏幕宽度，单位像素y1=device.height/2340 //屏幕高度，单位像素click(x*x1,y*y1)} Autojs 本地验证（一机一码）1、一机一码的实现原理12345机器码：设备的唯一标识注册机：用于激活设备，生成激活码。激活码：用于激活设备 2、一机一码UI界面的开发12345678910111213141516171819202122\"ui\";ui.layout( &lt;vertical padding='10'&gt; &lt;horizontal&gt; &lt;text text=\"机器码：\"/&gt; &lt;input id=\"machineCode\" w='*'/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;text text=\"激活码：\"/&gt; &lt;input id=\"activationCode\" w='*'/&gt; &lt;/horizontal&gt; &lt;button id='activation' text=\"激活\"/&gt; &lt;/vertical&gt;);ui.activation.on('click',function(){ alert('激活成功！');}) 3、注册机UI界面的开发1234567891011121314151617181920\"ui\";ui.layout( &lt;vertical padding='10'&gt; &lt;horizontal&gt; &lt;text text=\"机器码：\"/&gt; &lt;input id=\"machineCode\" w='*'/&gt; &lt;/horizontal&gt; &lt;button id='activation' text=\"生成激活码\"/&gt; &lt;text text=\"激活码：\" textColor=\"red\"/&gt; &lt;text id='activationCode' text='未生成'/&gt; &lt;/vertical&gt;);ui.activation.on('click',function(){ ui.activationCode.setText('123456')}) 4、获取手机唯一标识12345// var uuid = device.fingerprint;var imei = device.getIMEI()toast(imei) 5、完成第一个脚本注册机验证1234567891011121314151617181920212223242526272829303132333435363738394041424344脚本端\"ui\";ui.layout( &lt;vertical padding='10'&gt; &lt;horizontal&gt; &lt;text text=\"机器码：\"/&gt; &lt;input id=\"machineCode\" w='*' text=''/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;text text=\"激活码：\"/&gt; &lt;input id=\"activationCode\" w='*'/&gt; &lt;/horizontal&gt; &lt;button id='activation' text=\"激活\"/&gt; &lt;/vertical&gt;);var uuid = device.fingerprint;ui.machineCode.setText(uuid)ui.activation.on('click',function(){ //取算法得到的值 var res = ui.machineCode.text() +\"aaa\" // log(typeof(ui.activationCode.text())) // log(typeof(res.toString())) if(ui.activationCode.text() === res.toString()){ alert('激活成功！'); }else{ alert('激活失败！'); } // alert('激活成功！');}) 123456789101112131415161718192021222324252627282930313233343536373839注册机端\"ui\";ui.layout( &lt;vertical padding='10'&gt; &lt;horizontal&gt; &lt;text text=\"机器码：\"/&gt; &lt;input id=\"machineCode\" w='*'/&gt; &lt;/horizontal&gt; &lt;button id='activation' text=\"生成激活码\"/&gt; &lt;text text=\"激活码：\" textColor=\"red\"/&gt; &lt;text id='activationCode' text='未生成'/&gt; &lt;/vertical&gt;);//算法是 uuid+\"aaa\" ui.activation.on('click',function(){ var machineCode = ui.machineCode.text(); var activationCode = machineCode + 'aaa' // toast(activationCode) ui.activationCode.setText(activationCode.toString()) setClip(activationCode.toString()) toast('激活码已复制')}) 6、对手机唯一标识符进行加密12345function md5(string){ var res=java.math.BigInteger(1,java.security.MessageDigest.getInstance(\"MD5\").digest(java.lang.String(string).getBytes())).toString(16); while(res.length&lt;32)res=\"0\"+res; return res;} 7、增加时间验证12345678910111213141516171819//格式化时间function dateFormat(thisDate, fmt) { var o = { \"M+\": thisDate.getMonth() + 1, \"d+\": thisDate.getDate(), \"h+\": thisDate.getHours(), \"m+\": thisDate.getMinutes(), \"s+\": thisDate.getSeconds(), \"q+\": Math.floor((thisDate.getMonth() + 3) / 3), \"S\": thisDate.getMilliseconds() }; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (thisDate.getFullYear() + \"\").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmt;} 8、增加时间验证（二）9、开发日卡、月卡、年卡功能1234&lt;horizontal&gt; &lt;text textSize=\"16sp\"&gt;充值类型&lt;/text&gt; &lt;spinner id=\"sp1\" entries=\"月卡|年卡\" textColor=\"red\"/&gt;&lt;/horizontal&gt; 1ui.sp1.getSelectedItemPosition(); 10、激活码限制脚本运行12345678910111213141516171819function validTime(ntime) { if (toTime() &lt; ntime || IntTime() &lt; ntime) { return true; } else { return false; }}function toTime() { return new java.text.SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());}function IntTime() { try { var recode_suning = http.get(\"http://quan.suning.com/getSysTime.do\"); var suningTime = recode_suning.body.json(); return suningTime.sysTime1; } catch (e) {}} 11、保存激活状态到本地1var storage = storages.create('activation'); 12、解决时间验证bug方法13、完善激活码交互逻辑12345678910111213dialogs.build({ title: \"机器码：\", content: uuid, negative: \"输入激活码\", positive: \"复制机器码\" }).on(\"positive\", ()=&gt;{ setClip(uuid); toast(\"机器码已复制\"); }).on(\"negative\", ()=&gt;{ rawInput(\"请输入激活码\", \"\", 激活码 =&gt; { }); }).show(); 14、封装验证激活码函数(一)12345678910111213141516171819//验证激活码function validateCode(uuid,activation){ //取算法得到的值 var res = uuid +\"aaa\"; //解密激活码 var res2 = activation.split('&amp;'); var activationCode = res2[0]; var timestamp = res2[1]; //获取未来的格式化时间 var timestamp2 = dateFormat(new Date(parseInt(timestamp)), \"yyyyMMddhhmmss\"); if(activationCode === res.toString() &amp;&amp; validTime(timestamp2)){ return true; }else{ return false; }} 15、封装验证激活码函数(二)12345678910111213141516171819202122//验证激活码function validateCode(uuid,activation){ //取算法得到的值 var res = uuid +\"aaa\"; //解密激活码 var res2 = activation.split('&amp;'); var activationCode = res2[0]; var timestamp = res2[1]; //获取未来的格式化时间 var timestamp2 = dateFormat(new Date(parseInt(timestamp)), \"yyyyMMddhhmmss\"); if(activationCode === res.toString()){ if(validTime(timestamp2)){ return 1; }else{ return 2; } }else{ return 0; }} 16、封装注册机加密函数12345678//算法函数function encrypt(machineCode,timestamp){ var activationCode = machineCode + 'aaa&amp;'+timestamp; return activationCode;} 17、升级加密复杂度（一）12345var 加密字符串1 = md5(uuid+timestamp);var 加密时间 = ((timestamp-0+10000)*903)/100000;var 加密字符串2 = md5((md5(\"litikj\" +加密字符串1 +\"litikj\")+\"litikj\") +加密时间 +md5(uuid)+\"112233\");var 激活码 = 加密字符串1+\"&amp;\"+加密时间+\"&amp;\"+加密字符串2 18、升级加密复杂度（二）123456789101112131415161718192021222324252627282930313233343536//验证激活码function validateCode(uuid,activation){ var codeArr = activation.split(\"&amp;\"); var str1 = codeArr[0]; var encryptTime = codeArr[1]; var str2 = codeArr[2]; var timestamp = (Number(encryptTime) * 100000) / 903 -10000; //格式化时间 var timestamp2 = dateFormat(new Date(parseInt(timestamp)), \"yyyyMMddhhmmss\"); //判断激活码是否有效 if(str1 === md5(uuid+timestamp) &amp;&amp; str2 === md5((md5(\"litikj\" +md5(uuid+timestamp) +\"litikj\")+\"litikj\") +encryptTime +md5(uuid)+\"112233\")){ //算法一样 if(validTime(timestamp2)){ //时间正常 ui.end.setText('到期时间:'); ui.time.setText(dateFormat(new Date(parseInt(timestamp)), 'yyyy年MM月dd日 hh:mm:ss')) return 1; }else{ //时间过期 ui.end.setText('时间过期:'); ui.time.setText(dateFormat(new Date(parseInt(timestamp)), 'yyyy年MM月dd日 hh:mm:ss')) return 2; } }else{ //算法不一样 return 0; }} 19、增加运行脚本时的验证方法12345678910111213141516171819function check(){ if(storage.get('activation')){ var res = validateCode(uuid,storage.get('activation')) switch(res){ case 0: scriptStatus = false; break; case 1: scriptStatus = true; break; case 2: scriptStatus = false; break; } }} 20、给脚本添加一机一码功能（一）21、给脚本添加一机一码功能（二）如何写游戏脚本触摸模拟 sleep(n)：暂停运行n毫秒，游戏脚本中最常出现的一个命令；有一些操作必须给它一定的缓冲时间才能正确运行完成。 随机数： random(min,max)指定区间、random()范围是[0,1)；点击坐标时常设置一个随机偏移，防止被检测到（每次都点同一个点还是太明显了） 分辨率适配问题，setScreenMetrics(1080, 1920);、表示脚本适合的屏幕宽高为1080x1920（编脚本时基于的设备），如果在别的分辨率手机上运行则会自动放缩光标。听上去很好的一个功能，一般游戏脚本必加这一行，但具体效果如何我没有测试过。 click(x,y)：点击坐标（无需root权限），返回是否成功，点击过程大约150ms，可能被其他事件中断。更长时间的点击如longClick(x,y)、持续600ms。 press(x,y,duartion)：按住坐标，一般超过500ms才被系统认为是长按。 swipe(x1,y1,x2,y2,duration)： 从(x1,y1)滑动到(x2,y2)，持续duration。 RootAutomator 上面的几个触摸操作都是免root的，而基于RootAutomator对象的触摸需要root权限，优点是执行没有延迟，明显比click要快。 12345678var ra=new RootAutomator(); //初始化一个对象ra.tap(x,y,id); //id代表不同“手指”，用于多点触摸，不需要时可省略该参数ra.swipe(x1,y1,x2,y2,duration,id)ra.press(x,y,duration,id)// 这些命令组合在一起就能完成复杂的操作了~ra.touchDown(x,y,id)ra.touchMove(x,y,id)ra.touchUp(id) 模拟按键；（返回bool值） 1234if(back()){}; //按下返回键home() //返回桌面还有一些需要root权限的，开头字母大写://Home()、Back()、Power()、Menu()、OK()、KeyCode()... colors颜色常用十六进制值或RGB值来表示，如蓝色可表示为#0000FF或(0,0,255)，一般都是#后面带6位十六进制数，分别表示R、G、B，但Autojs是8位，前面多了一个A(Alpha)、表示透明度，即ARGB。 Autojs通过一个16进制整数或一个字符串表示一个颜色，两者可以互相转换 12var myBlue=colors.toString(color.BLUE); //返回#ff0000ff,colors.BLUE代表蓝色，后面必须大写。var numBlue=colors.parseColor(\"#ff0000ff\"); //返回-16776961,至于为什么是这个数我也不清楚，平时还是用字符串表示比较好。 colors对象里还有一些判断两个颜色的相似度、返回A、R、G、B通道值的函数，平时也基本上用不上；颜色的用途主要体现在后面的多点找色上。 images游戏脚本的灵魂所在，images主要有图片处理、找图、找色几个部分；想让脚本识别游戏的某个区域、如果该区域的位置是固定的，通过构造多点比色比较快，而如果位置不固定则常用找图的方式，虽然占用资源比较多但准确性有保障。 images对象使用完后必须回收，防止内存泄漏。 12345var img=images.read(\"./name.png\"); //读取图片，错误时返回null//var img=images.load(url); //从网址获取图片//...图片操作后回收img.recycle();// 例外：captureScreen()返回的图片无需回收 mages对象能对图像进行复制、保存、Base64编码解码、剪切、调整大小、放缩、旋转、拼接、灰度化、阈值化、颜色控件转换、二值化、模糊与平滑处理、滤波…（强是很强大，就是基本上用不上） 获取截图权限：在找图找色之前往往要先获取当前屏幕的截图，这个截图一般是临时的、不会保存到文件（也可以设置保存）。 截图之前要向系统申请一次截图权限： 1234if(!requestScreenCapture()){ //可指定参数true（横屏截图） 或者 false（竖屏截图） toast(\"请求截图失败\"); exit();} 请求截图: captureScreen 12//在此之前记住要请求一次截图权限var img=captureScreen(); //可以指定保存路径path 颜色获取，很重要的一个函数，后面多点找色时可以先用它获取参数值。 12//获取某点的ARGB颜色值var color=images.pixel(img,100,200); //img是之前创建的images对象 区域找色（一种颜色）；findColor、findColorInRegion、findColorEquals 12345678910//首先说下region和threshold这两个参数，后面的找色函数options里都要用到：//region、找色区域，默认全图、指定[x,y]代表左上角点，从(x,y)到右下角；指定[x,y,width,height]则代表从(x,y)到(x+width,y+height)。//threshold、相似度临界值，0~255，默认为4；similarity=1-threshold/255，可以算出默认相似度达到了0.98，觉得太严了可以适当增大thresholdvar point = images.findColor(img, \"#ff0000\", { region: [100, 200], threshold: 10 });//如果找到则返回一个点，如：{463.0, 1242.0}；找不到返回null。//这里颜色值是6位，8位也行不过会忽略A通道（透明度）。// findColorInRegion，功能和findColor一样，只是优化了下参数表示。var point=images.findColorInRegion(img,\"#ff0000\",100,200,1080,1920,10);// findColorEquals，要求颜色完全相等，相当于findColor的threshold参数设为0var point=images.findColorEquals(img,\"#ff0000\",100,200,1080,1920); 多点找色：findMultiColors，先定位第一个点的颜色、根据(x,y)偏移获取并对比第二个点的颜色…以此类推，命令很麻烦，通常需要写一个函数来构造颜色列。 123456var point = images.findMultiColors(img, \"#ff949fc7\", //第一个点 [[60, 60, \"#ffe6efe6\"], //颜色Array， [60, -60, \"#ffeef3e6\"], [-60, 60, \"#ffe6efe6\"], [-60, -60, \"#ffeef3e6\"]], { region: [1548, 803, 140, 140] }) //指定区域 检测某坐标颜色：前几个命令都是根据颜色找坐标，这个是给坐标、比较颜色 12if(images.detectsColor(img,\"#fed9a8\",100,200,16,\"diff\")){}//最后两个参数可省略，代表threshold和匹配算法；x=100,y=200 找图：有时候找颜色会匹配到一些奇怪的地方去，还得用找图来实现，有images.findImage、images.findImageInRegion、images.matchTemplate。 123456var temp1=images.read(pathToImage);var point=images.findImage(img,temp1,{ region: [100, 200], threshold: 10 });//同样findImageInRegion只是优化了下参数排列//matchTemplate可以同时返回找到的多个位置，通过max控制最大的结果数量var result=images.matchTemplate(img,temp1,{ region: [100, 200], threshold: 10 ,max:5});//返回类型是一个MatchingResult对象，有point和similarity这两个数据成员。 脚本结构管理Module在一个文件里通过module.exports =...;把某个对象导出，从而可以在另一个文件通过var name=require('file.js');导入；相当于把整个文件当做一个函数，把exports的东西当做返回值。感觉用起来也不太方便，我选择不用这个功能。 Threads 启动一个子线程，threads.start： 12345678910//启动一个无限循环的线程var thread = threads.start(function(){ //用thread对象可以控制线程运行状态，如果不需要操作可以改为：//threads.start(function(){ while(true){ log(\"子线程运行中...\"); sleep(1000); }});sleep(5000);thread.interrupt(); threads.shutDownAll()： 停止所有通过threads.start()启动的子线程 等待线程开始执行（一般start后需要一段时间）：thread.waitFor();（这里thread是前面创建的thread变量） 等待线程执行完成：thread.join();，参数可以指定一个等待时间 中断线程运行：thread.interrupt(); 注意多线程中的变量问题，涉及到线程安全，文档里说的很详细 线程间的通信与传递变量，通过var connect = threads.disposable();实现；发送结果：connect.setAndNotify(s);，接收结果：connect.blockedGet(s); 交互界面Events、Dialogs、Console Events模块主要用来监听按键、触摸、通知等，但放在单线程里可能会因为程序其他部分而无法及时执行，造成非预期的结果，常常和多线程Threads模块一起使用，如音量键关闭脚本的例子： 1234567891011121314151617auto();threads.start(function(){ //在子线程中调用observeKey()从而使按键事件处理在子线程执行 events.observeKey(); //启用按键监听 events.on(\"key_down\", function(keyCode, events){ //常用事件有key、key_down、key_up、exit、toast、notification、touch(触摸某点) if(keyCode == keys.volume_up){ //音量上键关闭脚本 exit(); } });});events.on(\"exit\", function(){ //脚本停止运行时会触发exit事件 toast(\"脚本已结束\");});while(true){ log(\"脚本运行中...\"); sleep(2000);} Dialogs 这部分提供对话框支持，但由于是弹出一个全屏的消息提示框，实际体验是并不太能用上；如果脚本和用户的交互性比较强的话可以考虑一下。 Console 控制台的作用更像是用于调试，但一般Windows下用VSCode写脚本也不需要在控制台上显示吧，所以这部分给人的感觉也是很鸡肋…不过console的UI是固定的，也可以悬浮、最小化；有时不想设计UI的时候可以偷懒直接拿console过来凑合用用。 Floaty、UI界面设计这部分内容相当多，而且官方文档也有很多写得很简略（甚至一笔带过），要想真正从零开始设计出一个实用好看的UI出来还是有难度的；我是建议去网上多找几个模板文件运行运行，在别人的基础上修改起来就快多了，看不懂的地方再去翻翻文档解决。一般UI设计好后再和程序一对接（通过UI各组件的id），就可以打包做成apk了~ 写一个注册机实战加密解密 我们再测试下解密 看能不能解开 唯一 = device.getIMEI() 我们来回忆一下： 加密1 加密2——-固定加密 加密3 ————随机加密 解密2 解密3——解密使用 开始加密，可以用 加密2 加密3，随便用，都可以 但是你需要记住 加密的次数和加密顺序 ——-3次——-加密2——–加密2——–加密3 看结果 ?wv1%yv%4rv%0v%S0v%7vJ%5v%8Sw%3w%Uxw%9vW%vv%55v%yy%7j5 我们在我们自己的脚本中，开始写解密，相反的顺序 ———-解密3———解密2——–解密2——3次—- 得到 358811051254785 我们测试下 运行 这个函数 358811051254785 完美了，继续 运行到这里了 我们可以得到 一个 “加密结果3” 需要让对方把这个值 发给我们 这样操作 setClip(加密结果3); toast (“已经复制到右键了，请发给我”); 演示一下，运行一下，他发给我们的是这个 ?wvl%yv%4gv%0v%p0v%7vr%5v%8Hw%3w%dxw%9vk%vv%5hv%yy%7j5 说明，我们的方法是对的。继续 对方发给我们之后 我们运行解密 结果也出来了。 还是这个数字。358811051254785。那当然还是它了。 那么，我们就这样，什么也不干就发给他吗？？？不，，，，，，，，稍微有点常识的看一眼都知道，这可能就是手机的某个参数。 这时候，有小白就会问了，这不是没有意义吗？！错。大错特错。你看看对方发给我们的是什么，每次都不一样，他也迷糊，是吧。。。。。。。我们可以把提示代码抹去，虽然他每次都复制了，但是对方不知道呀，嘿嘿。你只需要第一次告诉对方，复制右键发给我们。嘿嘿。 为了彻底迷惑对方，我们再继续对“唯一”进行多次混合加密。这里必须用固定加密。。嘿嘿。 我们在我们自己的脚本中，也复制一模一样的，运行， 得到 “加密结果10”—-这个就是我们要发给对方的验证码了 最后，我们把代码完善下，能删除的log都删了 ok了 需要特别说明的 就是 你发给对方的脚本中 只能有加密函数别傻了胡痴地 把解密函数 也给对方发过去。嘿嘿。 这个只是在脚本上加密解密。还有网络加密解密。如果，有感兴趣的，以后可以出一个教程。非常简单的。因为网站都已经给我们现成的auto.js封装好的啊。只需要随便改一点点东西，就可以使用了。 代码发到下面了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102if(auto.service==null){auto.waitFor();};sleep(1000);唯一 = device.getIMEI()加密结果1 = 加密2(唯一)加密结果2 = 加密2(加密结果1)加密结果3 = 加密3(加密结果2)setClip(加密结果3);//toast (\"已经复制到右键了，请发给我\");sleep(90000)加密结果4 = 加密2(唯一)加密结果5 = 加密2(加密结果4)加密结果6 = 加密1(加密结果5)加密结果7 = 加密1(加密结果6)加密结果8 = 加密2(加密结果7)加密结果9 = 加密1(加密结果8)加密结果10 = 加密2(加密结果9)var 对方输入框里的 = rawInput(\"请输入验证码\");if (对方输入框里的 == 加密结果10) { log(\"验证码正确\") //开始干活喽} else { log(\"验证码错误\"); exit();}// 固定加密function 加密1(string) { return java.math.BigInteger(1, java.security.MessageDigest.getInstance(\"MD5\") .digest(java.lang.String(string).getBytes())).toString(16);}// 固定加密function 加密2(code) { var c = String.fromCharCode(code.charCodeAt(0) + code.length); for (var i = 1; i &lt; code.length; i++) { c += String.fromCharCode(code.charCodeAt(i) + code.charCodeAt(i - 1)); } return escape(c);}// 随机加密function 加密3(stringW) { var str = stringW + \"?\"; var ranWs = random(1, 6); var str1 = \"\"; for (var i = 0; i &lt; str.length; i++) { str1 = str1 + str[i]; if (i % ranWs == 0) { str1 = str1 + ranLetter(); } } log(str1) str1 = ranWs + str1; str1 = str1.split(\"\").reverse(); for (var x = 0; x &lt; str1.length; x++) { str1[x] = charDh(str1[x]); } return str1.join(\"\");}function ranLetter() { var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]; var ran = random(0, 3); if (ran == 0) { return random(0, 9); } else if (ran == 1) { return arr[random(0, arr.length - 1)]; } else { return arr[random(0, arr.length - 1)].toUpperCase(); }}function charDh(cha) { var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]; for (var jw = 0; jw &lt; arr.length; jw++) { if (cha == arr[jw]) { return arr[arr.length - 1 - jw]; } } return cha;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//解密var b = \"\"解密结果3 = 解密3(b)解密结果2 = 解密2(解密结果3)解密结果1 = 解密2(解密结果2)//log(解密结果1)//解密结果1 就是对方手机的IMEI 也就是“唯一”加密结果4 = 加密2(解密结果1)加密结果5 = 加密2(加密结果4)加密结果6 = 加密1(加密结果5)加密结果7 = 加密1(加密结果6)加密结果8 = 加密2(加密结果7)加密结果9 = 加密1(加密结果8)加密结果10 = 加密2(加密结果9)log(加密结果10)function 解密2(code) { code = unescape(code); var c = String.fromCharCode(code.charCodeAt(0) - code.length); for (var i = 1; i &lt; code.length; i++) { c += String.fromCharCode(code.charCodeAt(i) - c.charCodeAt(i - 1)); } return c;}function 解密3(stringJ) { var str2 = stringJ.split(\"\"); for (var x = 0; x &lt; str2.length; x++) { str2[x] = charDh(str2[x]); } str2 = str2.reverse().join(\"\"); log(str2) var tt = parseInt(str2[0]); str2 = str2.substring(1, str2.length - 1); var str3 = \"\"; for (var y = 0; y &lt; str2.length; y++) { if ((y - 1) % (tt + 1) != 0) { str3 = str3 + str2[y]; } } if (str3[str3.length - 1] == \"?\") { str3 = str3.substring(0, str3.length - 1); } return str3;}function charDh(cha) { var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]; for (var jw = 0; jw &lt; arr.length; jw++) { if (cha == arr[jw]) { return arr[arr.length - 1 - jw]; } } return cha;}function 加密1(string) { return java.math.BigInteger(1, java.security.MessageDigest.getInstance(\"MD5\") .digest(java.lang.String(string).getBytes())).toString(16);}function 加密2(code) { var c = String.fromCharCode(code.charCodeAt(0) + code.length); for (var i = 1; i &lt; code.length; i++) { c += String.fromCharCode(code.charCodeAt(i) + code.charCodeAt(i - 1)); } return escape(c);}function 加密3(stringW) { var str = stringW + \"?\"; var ranWs = random(1, 6); var str1 = \"\"; for (var i = 0; i &lt; str.length; i++) { str1 = str1 + str[i]; if (i % ranWs == 0) { str1 = str1 + ranLetter(); } } log(str1) str1 = ranWs + str1; str1 = str1.split(\"\").reverse(); for (var x = 0; x &lt; str1.length; x++) { str1[x] = charDh(str1[x]); } return str1.join(\"\");}function ranLetter() { var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]; var ran = random(0, 3); if (ran == 0) { return random(0, 9); } else if (ran == 1) { return arr[random(0, arr.length - 1)]; } else { return arr[random(0, arr.length - 1)].toUpperCase(); }} 常用功能封装调用云文件12345678910111213141516//导入模块function 导入常用函数模块() { var url = \"https://raw.githubusercontent.com/snailuncle/autojsCommonFunctions/master/autojsCommonFunctions.js\"; var r = http.get(url); log(\"code = \" + r.statusCode); var html = r.body.bytes(); files.writeBytes(\"./autojsCommonFunctions.js\", html); var common = require(\"./autojsCommonFunctions.js\"); return common;}var common = 导入常用函数模块();log(common);for (let i = 0; i &lt; 33; i++) { common.闪光弹(\"fire in the hole\");} 调起apk安装12var apkfile = files.path(APK包位置这里这么写是为了可以用相对路径);app.viewFile(apkfile) 蚂蚁森林暴力点击能量球123456789101112131415function CollectEnergy(){ console.log('开始收集能量') // 能量球半径为140 // 第一个为初始y坐标(screen_height*0.225=540),第二个为末尾y坐标screen_height*0.396=950 for (var row = 540; row &lt; 950; row += 140){ // 第一个为初始x(140)(screen_width*0.13),第二个为末尾x坐标(930)(screen_width*0.86) for (var col = 140; col &lt; 930; col += 140) { click(col, row); sleep(10); // log(col, row) } toastLog(\"能量收集完成\"); }} 读取json12345678910111213141516171819202122232425262728293031323334353637if (typeof files === 'undefined') { const fs = require('fs'); var files = { read: function(path){ return fs.readFileSync(path,{encoding:\"utf-8\"}).toString(); }, write: function(path,text){ return fs.writeFile(path,text,function(err){ if(err) throw err; }); } };}function readJSON(fileName){ if(typeof fileName==\"string\"){ var strList = fileName.split(\".\"); if(strList[strList.length-1].toLowerCase()==\"json\"){ var data = files.read(fileName); return JSON.parse(data); }else{ throw Error(\"not JSON File\") } }else{ throw Error(\"not file name\") }}function writeJSON(fileName,data){ if(typeof fileName == \"string\"){ try{ files.write(fileName,JSON.stringify(data)); }catch(e){ console.log(\"Hava Error!!\") } }}console.log(readJSON(\"project.json\")); 获取设备唯一标识1234567891011121314151617// var uuid = device.fingerprint;// toastLog(uuid)// 使用device.getAndroidId()代替device.getIMEI().这是因为安卓10以上限制了获取imei码var imei = device.getAndroidId()toast(imei)// md5加密函数function md5(string){ var res=java.math.BigInteger(1,java.security.MessageDigest.getInstance(\"MD5\").digest(java.lang.String(string).getBytes())).toString(16); while(res.length&lt;32)res=\"0\"+res; return res;} 强制结束app进程的功能123456789function forceCloseApp(appName) { var packageName = getPackageName(appName); app.openAppSetting(packageName);//打开app的详细信息 if (text(\"强行停止\").findOne().enabled()) {//判断强制停止按钮是否可点击，可点击（enabled值为true）则表示在运行，不可点击（enabled值为false）就代表未运行。 text(\"强行停止\").findOne().click(); text(\"确定\").findOne().click(); } back();} 提取文本中的数字的正则表达式123//代码举例：timesText = id(\"tv_remain_times\").findOne().text();times = timesText.replace(/[^0-9]/ig, \"\"); 安卓无障碍123456789auto.service.performGlobalAction(9);//1 返回//3 切换任务//4 下拉通知栏//5 展开通知栏//6 长按电源键//7 分屏模式//8 锁屏//9 截图 连续按两次返回键退出123456789101112131415161718192021\"ui\";ui.layout( &lt;vertical&gt; &lt;button&gt;aaa&lt;/button&gt; &lt;/vertical&gt;);var isCanFinish = false;ui.emitter.on(\"back_pressed\", (e) =&gt; { if (!isCanFinish) { toastLog(\"连续按两次返回键退出\"); isCanFinish = true; isCanFinishTimeout = setTimeout(() =&gt; { isCanFinish = false; }, 700); e.consumed = true; } else { clearTimeout(isCanFinishTimeout); e.consumed = false; }}); 信息提示1234log()toast()toastLog()alert() 截图相关用adb授予投影媒体权限● 重启后权限依然有效● 授予这个权限以后 requestCaptureScreen就不会弹窗询问了adb shell appops set org.autojs.autojspro PROJECT_MEDIA allow 123456789// 基于安卓无障碍截图保存auto.service.performGlobalAction(9);// 三指下滑截屏保存gestures( [0, 500, [230, 452], [230, 1000]], [0, 500, [500, 452], [500, 1000]], [0, 500, [755, 452], [755, 1000]]); 123456789101112131415161718192021222324// 自动获取截图权限function GetScreenCapture(){// 开启一个线程 let Thread = threads.start(function(){ if(auto.service != null){ //如果已经获得无障碍权限 //由于系统间同意授权的文本不同，采用正则表达式 let Allow = textMatches(/(允许|立即开始|统一)/).findOne(10*1000); if(Allow){ Allow.click(); } } }); if(!requestScreenCapture()){ log(\"请求截图权限失败\"); return false; }else{ Thread.interrupt() log(\"已获得截图权限\"); return true; }} 安卓高版本用无障碍截图 12345678910111213let img = null;if (device.sdkInt &gt;= 30) { img = $automator.takeScreenshot(); // 安卓11以上无障碍截图,需要回收} else { threads.start(function () { let r = text(\"立即开始\").findOne(3000); r &amp;&amp; r.click(); }); images.requestScreenCapture(); img = images.captureScreen();} 上下滑动翻页swipe()函数滑动在autojs4.1与pro不一致swipe(x1, y1, x2, y2, duration) duration {number} 滑动时长，单位毫秒模拟从坐标(x1, y1)滑动到坐标(x2, y2)，并返回是否成功。只有滑动操作执行完成时脚本才会继续执行。Auto.JS上下滑动可以是对整个屏幕的滑动或对某特定控件的滑动，对整个屏幕滑动 swipe(device.width / 2, device.height - 100, device.width / 2, 200, 5);swipe(device.width/2, device.height/2, device.width/2, device.height/6, 10) //划到底部 1234567891011121314151617//调用Slide(\"up\")function Slide(upordown){ var h=device.height; //屏幕高 var w=device.width; //屏幕宽 var x=device.width/2; //横坐标2分之1处 var h1=(device.height/6)*3.5; //纵坐标6分之3.5处， var h2=(h/6); //纵坐标6分之1处 if(upordown==\"up\"){ swipe(x, h1, x, h2, 400); //完美上滑向下翻页(从纵坐标6分之5处拖到纵坐标6分之1处) }else{ swipe(x, h2, x, h1, 400); //完美下滑向上翻页(从纵坐标6分之1处拖到纵坐标6分之5处) } } 重复执行几次123456var i=0;while (!descEndsWith(\"扫一扫\").exists() &amp;&amp; i&lt;=5){ i++;}if(i&gt;=5){} 123456789while(n!=0){ if(){ }else{ } n--;} 黑屏跑脚本(省电)原理很简单,就是去创建一个黑色的悬浮窗,在oled屏幕上,就不会发光,降低功耗.兼容任何脚本 12345678910111213141516function 息屏() { var h = confirm(\"是否要进入息屏挂机模式吗？可按下音量上键停止辅助。并不能锁定屏幕！！！通知栏会正常显示（oled屏可用)\"); if(h){ var w = floaty.rawWindow( &lt;frame gravity=\"center\" bg=\"#000000\"/&gt; ); w.setSize(-1, -1); w.setTouchable(true); //保持脚本运行 setInterval(()=&gt;{}, 1000); } }息屏() 一键启动无障碍12345678910111213141516171819202122232425262728importClass(android.content.Context);importClass(android.provider.Settings);console.show()try { var enabledServices = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES); //把要用的辅助服务打开，获取到已开启的服务，写到Services变量(每个服务间要用英文冒号连接) log('当前已启用的辅助服务\\n', enabledServices); /* 由于Android的一些bug，有时候实际没有开启的服务仍会出现在已启用的里面，所有没办法通过判断得知服务是否开启 像当前这样子会导致已开启服务里面有很多重复项目，建议直接写死不再每次重新获取 */ // hamibot,autojs,autojspro,绿去广告的无障碍 var Services = enabledServices + \":com.hamibot.hamibot/com.stardust.autojs.core.accessibility.AccessibilityService\"+ \":org.autojs.autojs/com.stardust.autojs.core.accessibility.AccessibilityService\"+ \":com.auto.greenskipad/com.auto.skip.service.NewTiaoGuoService\"+ \":org.autojs.autojspro/com.stardust.autojs.core.accessibility.AccessibilityService\"; Settings.Secure.putString(context.getContentResolver(), Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, Services); Settings.Secure.putString(context.getContentResolver(), Settings.Secure.ACCESSIBILITY_ENABLED, '1'); toastLog(\"成功开启无障碍服务\");} catch (error) { setClip(\"adb shell pm grant org.autojs.autojspro android.permission.WRITE_SECURE_SETTINGS\"); // setClip(\"adb shell pm grant :com.auto.greenskipad android.permission.WRITE_SECURE_SETTINGS\"); toastLog(\"\\n请确保已给予 WRITE_SECURE_SETTINGS 权限\\n\\n授权代码已复制到剪贴板，请使用adb工具连接手机执行(重启不失效)\\n\\n\", error); } Bmob 后端云提供可靠的 Serverless 云服务 轻松拥有开发中需要的各种后端能力Bmob官网文档 点击的方法：控件点击首先推荐的必然是控件点击，它的逻辑是只要能被侦测，就能被点击，无论它是躲在某个悬浮窗后面，还是躲在看不见的下滑栏的底部,即使是app在弹广告，依然可以无视掉。前提是找到控件的特殊属性 寻找控件建议不要用findOne()、waitFor()、exists()等一些会阻塞的方法，不然稍微出现一点其他事件就会阻塞，导致脚本莫名其妙的卡死，使用findOne(timeout)、findonce()时可以加个判断在不为null的时候再点击或其他操作，因为没找到返回null，直接click就会报错，脚本停止运行，要是是找的父或者子控件也写到判断里 bounds(813,883,1039,993).findOne().click(); 123456789101112131415161718192021222324252627282930313233343536373839/** * 包括控件点击和坐标点击 * clickControl(element) * 参数填属性 */a=className(\"android.widget.TextView\").text(\"芭芭农场\");clickControl(a) function clickControl(element,timeOut) { if (!timeOut) { timeOut = 1000 } let clickResult = false; if (element == null) { return false; } try { if (element.exists()) { toastLog(\"准备click：\" + element); let clickable = element.clickable();//是否可以点击 if (clickable) { toastLog(\"该控件可点击，尝试直接点击\") // element.findOnce(timeOut).click(); clickResult = element.findOnce(timeOut).click(); sleep(random(500, 1000)); } else { toastLog(\"尝试坐标点击\") let b = element.findOnce(timeOut).bounds(); click(b.centerX(), b.centerY()); clickResult =click(b.centerX(), b.centerY()); sleep(random(500, 1000)); } } return clickResult; } catch (error) { toast(\"clickControl方法出现错误：\" + error) return false; } } 层级结构其次仍然是控件点击的延申，层级点击，分为两种点击，通常用于app内的网页展示，表现可以具体参照jd，它的结构极其杂乱 写10多个child，找到它的那个拥有独一无二参数的上家，此时需要pc端控件查看，才能理清思路另外一种 就是使用indexInParent().depth()去查找，如果怕重复，就可以换为find()，然后再一个个检查 下面是一个我在饿了么里面用到的一段代码：sleep(3000); depth(‘15’).indexInParent(‘3’).waitFor(); log(‘页面加载完成\\n等待5s’); sleep(5000); let exb = depth(‘16’).indexInParent(‘0’).find(); for(i = 0; i &lt; exb.length; i++){ if(exb[i].bounds().centerX() &gt; dev_width/2) continue; if(exb[i].bounds().centerY() &gt; dev_hight/2) break; } exb[i].click();sleep(2000); 123456789101112//7.不断查找某控件父元素，并点击(解决模拟器和手机不查找元素不一致问题)function up_click(x) { if (x &amp;&amp; x.clickable()) return x.click(); for (let ii = 0; ii &lt; 6; ii++) { if (!x) break x = x.parent(); if (x &amp;&amp; x.clickable()) return x.click(); let list_x = x.children(); for (let i = 0; i &lt; list_x.length; i++) {if (list_x[i] &amp;&amp; list_x[i].clickable()) return list_x[i].click()};} return false} 识图点击即便层级结构复杂，我也是不推荐识图点击，有个例外，就是1对1定制，只在有限的几个设备上用，那识图确实是个省力的活，但是如果面向很多用户，并不推荐， 理由1 不同人的手机屏幕分辨率和尺寸不同，结果就是ppi不同，缩放不同，识图基本上是像素点对比的，所谓的容错也只是颜色的范围，这种问题同样出现在Windows中的pywinauto上 理由2 除了ppi不同导致图案大小不同，还会导致颜色色彩不同，是的，色彩，rgb值不一样。 修正方案：hamibot作者给的建议，只截取屏幕的一长条区域，进行颜色判定。 ③找图找色特别消耗内存，所以在能用控件就用控件，找图找色在找到后要用recycle()来对创建的图像对象回收，提高脚本稳定，让脚本能持续运行更长时间，截图也需要一定的时间 ④如果脚本有悬浮窗，使用找图要注意不要将要找的图遮挡不要在循环里面读图，还有就是不要频繁操作大字符串image对象创建后尽量在不使用时进行回收，同时避免循环创建大量图片。因为图片是一种占用内存比较大的资源 核心函数images.matchTemplate(img, template, options) 作用：[v4.1.0新增]在大图片中搜索小图片，并返回搜索结果MatchingResult。该函数可以用于找图时找出多个位置，可以通过max参数控制最大的结果数量。也可以对匹配结果进行排序、求最值等操作。返回 {MatchingResult} 参数： img {Image} 大图片 template {Image} 小图片（模板） options {Object} 找图选项： 1.threshold {number} 图片相似度。取值范围为0~1的浮点数。默认值为0.9。 2.region {Array} 找图区域。参见findColor函数关于region的说明。 3.max {number} 找图结果最大数量，默认为5 4.transparentMask {boolean} 是否使用透明模板找图。此选项开启后，传入的template参数可以是一个透明背景的图片对象用于匹配。此选项为 [Pro 8.0新增] 。 5.level {number} 一般而言不必修改此参数。不加此参数时该参数会根据图片大小自动调整。找图算法是采用图像金字塔进行的, level参数表示金字塔的层次, level越大可能带来越高的找图效率，但也可能造成找图失败（图片因过度缩小而无法分辨）或返回错误位置。因此，除非您清楚该参数的意义并需要进行性能调优，否则不需要用到该参数。 返回的MatchingResult对象matches 数组的元素是一个Match对象： point {Point} 匹配位置 similarity {number} 相似度pointsfirst()last()leftmost()topmost()rightmost()bottommost()best()worst()sortBy(cmp) base64编码转换图片可以转为 base64 编码 直接写在脚本中 当做变量使用。。加快图片传输速度 base64图片转换工具 Base641.images.fromBase64(图片的Base64数据)解码Base64数据并返回解码后的图片Image对象。如果base64无法解码则返回null。 2.images.toBase64(Image对象[, 图片格式, 图片质量])返回 {string},把图片编码为base64数据并返回。 bytesimages.fromBytes(bytes)bytes {byte[]} 字节数组解码字节数组bytes并返回解码后的图片Image对象。如果bytes无法解码则返回null。 images.toBytes(Image对象[, 图片格式, 图片质量]) 返回 {byte[]}把图片编码为字节数组并返回。 例子1// 循环找图：区域0.0.1080.760搜索到第一次小图位置在50.300，点击后，然后在从100.300.1080.760开始第二次搜索到位置在55.600，点击后，然后在从105.600.1080.760开始下一个搜索。每个搜索点击后判断一下当前Y位置是否到了图标出现的最大位置，超出就退出循环找图(就是全屏找，找到第一个就从第一个位置加点距离开始找第二个。) 123456789101112131415161718//多张图判断var findImgPoint = findImage(personHomeCapture, goldcoinTempl, { region: findImgRegion, threshold: 0.9 }) || findImage(personHomeCapture, goldballTempl, { region: findImgRegion }) || findImage(personHomeCapture, yellowgirlTempl, { region: findImgRegion, threshold: 0.9 }) || findImage(personHomeCapture, chivesTempl, { region: findImgRegion }) || findImage(personHomeCapture, pillowTempl, { region: findImgRegion }); 12345678//找图点击 function png_click(num, pngbase64){ while(num--){ let img = captureScreen(); let temp1 = images.fromBase64(pngbase64); let pos = findImage(img, temp1); if(pos){return click(pos.x, pos.y);} else sleep(1000);} return false;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 require (\"./权限/获取截图权限\")console.show ()function find_img_click(imgpath, regions,thresholds ) { let img1 = images.read( imgpath ); let 缩放x = device.width / 1080 let 缩放y = device.height / 2400 //缩放后的图 let img2 = images.scale(img1, 缩放x, 缩放y) // captureScreen()函数截全屏 let result = images.matchTemplate( captureScreen(), img2, { max: 5, region: regions, //区域 threshold: thresholds, }); let img_w = img2.getWidth() let img_h = img2.getHeight() //回收图片 img2.recycle(); if (result != null) { for (let i = 0; i &lt; result.matches.length; i++) { let pp = result.matches[i].point log('所找图坐标是：'+pp) log('所找图宽高为'+img_w,img_h) console.warn(\"找到\" + imgpath, pp.x, pp.y) //随机点击坐标 // let a = pp.x+Math.floor(Math.random()*5) // let b = pp.y+Math.floor(Math.random()*5) let a = random(pp.x,pp.x+img_w) let b = random(pp.y,pp.y+img_h) click( a, b) log('随机点击范围内的坐标是:'+ a+','+ b) console.error(\"点击--\" + imgpath) sleep(200) break; } } else { console.log(\"===未找到\" + imgpath) }}//调用识图函数imgpath='/sdcard/脚本/2.jpg' //图片路径regions=[0, 0, device.width, device.height] //识图范围thresholds=0.4 // 识别率要低一点find_img_click(imgpath,regions, 0.75) 区域找色点击images.findColor(image, color, options) 在图片中寻找颜色color。找到时返回找到的点Point，找不到时返回null。 image {Image} 图片 color {number | string} 要寻找的颜色的RGB值。如果是一个整数，则以0xRRGGBB的形式代表RGB值（A通道会被忽略）；如果是字符串，则以\"#RRGGBB\"代表其RGB值。 options {Object} 选项 选项包括： region {Array} 找色区域。是一个两个或四个元素的数组。(region[0], region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高。{如果只有region只有两个元素，则找色区域为(region[0], region[1])到图片右下角。}{如果不指定region选项，则找色区域为整张图片。} threshold {number} 找色时颜色相似度的临界值，范围为0 ~ 255（越小越相似，0为颜色相等，255为任何颜色都能匹配）。默认为4。threshold和浮点数相似度(0.0~1.0)的换算为 similarity = (255 - threshold) / 255. 该函数也可以作为全局函数使用。 12345678910function cs_click(rgb, xr, yr, wr, hr) { let img = captureScreen() let point = findColor(img, rgb, { region: [img.getWidth() * xr, img.getHeight() * yr, img.getWidth() * wr, img.getHeight() * hr], threshold: 8 }) if (point) { point.x = img.getWidth() - point.x; point.y = img.getHeight() - point.y return click(point.x, point.y); }} 123456789101112131415161718// 设置好友数，避免特殊情况一直循环friend_num=6;for (i=0;i&lt;friend_num;i++){ let point = findColor(img, '#1fa071', { region: [960,400,screen_width-960,1450], threshold: 20 }) if (point) { // click(point.x, point.y); log('进入好友'+point.x, point.y) CollectEnergy(); back() sleep(500) }else{ log('好友能量收集完毕'); break; }} 多点找色点击images.findMultiColors(img, firstColor, colors[, options]) img:要找色的图片 firstColor {number | string} 第一个点的颜色 colors {Array} 表示剩下的点相对于第一个点的位置和颜色的数组，数组的每个元素为[x, y, color] options {Object} 选项，包括： region {Array} 找色区域。是一个两个或四个元素的数组。 (region[0], region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高。如果只有region只有两个元素，则找色区域为(region[0], region[1])到图片右下角。如果不指定region选项，则找色区域为整张图片。 threshold {number} 找色时颜色相似度的临界值，范围为0 -255（越小越相似，0为颜色相等，255为任何颜色都能匹配）。默认为4。threshold和浮点数相似度(0.0~1.0)的换算为 similarity = (255 - threshold) / 255. 多点找色,其过程如下：在图片img中找到颜色firstColor的位置(x0, y0)对于数组colors的每个元素[x, y, color]，检查图片img在位置(x + x0, y + y0)上的像素是否是颜色color，是的话返回(x0, y0)，否则继续寻找firstColor的位置，重新执行第1步整张图片都找不到时返回null 12345var point = images.findMultiColors(img, \"#123456\", [[10, 20, \"#ffffff\"], [30, 40, \"#000000\"]], {region: [0, 960, device.width, device.height ]});toastLog(\"x = \" + point.x + \", y = \" + point.y);click (point.x, point.y) ocr点击牙叔识别数字ocr基于PaddleOCR开发Auto.js Pro文字识别插件 百度ocr借用外部的ocr识别，拿到字的坐标百度ocr 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//百度OCR 三连发//ocr1 返回识图结果function Baidu_ocr(imgFile){ log(\"识图...\"); var imag64 = images.toBase64(imgFile, \"png\", 100); var API_Key=\"自己的AK\"; var Secret_Key=\"自己的SK\"; var getTokenUrl=\"https://aip.baidubce.com/oauth/2.0/token\";//选择网络图片识别 var token_Res = http.post(getTokenUrl, { grant_type: \"client_credentials\", client_id: API_Key, client_secret: Secret_Key, }); var access_token=token_Res.body.json().access_token; var ocrUrl = \"https://aip.baidubce.com/rest/2.0/ocr/v1/webimage_loc\"; var ocr_Res = http.post(ocrUrl, { headers: { \"Content - Type\": \"application/x-www-form-urlencoded\" }, access_token: access_token, image: imag64, language_type:\"CHN_ENG\"//可添加额外参数 }); sleep(1000); var json = ocr_Res.body.json(); return json.words_result;}//OCR2 处理返回结果 并点击function ocr_click(target_words) { var imgScreen = captureScreen(); var logOcr= Baidu_ocr(imgScreen); var target_nums = 0; for (i = 0; i &lt; logOcr.length; i++){ if(target_words == logOcr[i].words) {console.log('找到：'+target_words);target_nums = i;break;} } if(!target_nums) {log('未找到指定文字');return false;} let postion = new Array(); postion[1] = logOcr[target_nums].location.top; postion[0] = logOcr[target_nums].location.left; sleep(500); click(postion[0], postion[1]); return postion;}//ocr3.记录所有相同字的位置，目的是为了尽可能的少发送截图请求function list_ocr(target_words) { sleep(2000); let img = captureScreen(); let imgScreen = images.clip(img, 0, dev_hight/2, dev_width, dev_hight/2); var logOcr= Baidu_ocr(imgScreen); let nums_list = new Array(); let times = 0; for (i = 0; i &lt; logOcr.length; i++){ if(target_words == logOcr[i].words) nums_list[times++] = i; } if(!times) {log('未找到指定文字');return false;} else log('找到'+times+'个'); var postion = new Array(); for(k = 0; k &lt; times; k++){ postion[k]=new Array(); } for(i = 0; i &lt; times; i++){ postion[i][0] = logOcr[nums_list[i]].location.left; postion[i][1] = logOcr[nums_list[i]].location.top; } return postion; } 浩然ocrocrResult.frame{List} 识别结果的位置识别结果为一个任意四边形，返回的是长度为8的整形列表。 分别为四个顶点的横纵坐标，即[x1,y1,x2,y2,x3,y3,x4,y4]。[左上，右上，右下，左下] 12345678910111213141516171819202122232425262728293031323334353637HaoranOcrClick('订阅号')function HaoranOcrClick(target) { let ocr = $plugins.load(\"com.hraps.ocr\"); GetScreenCapture() sleep(500) //识别图片 results = ocr.detect(captureScreen().getBitmap(), 1) //缩放比率 console.show() console.info(\"过滤前结果数：\" + results.size()) //识别结果过滤 results = ocr.filterScore(results, 0.5, 0.5, 0.5) //输出最终结果 for (var i = 0; i &lt; results.size(); i++) { var re = results.get(i) let t = re.text //识别出的文字 let p = re.frame //位置 for (j=0 ;j&lt;target.length;j++){ //判断每个字符都在识别结果内 var pan = re.text .includes(target[j]) if(!pan){ log('目标字符不在识别结果内'); break; }else{ var a=j+1 continue } } if(a==target.length){ let x = p[0] + (p[2] - p[0]) / 2; let y = p[1] + (p[5] - p[1]) / 2; console.log('全部找到文字准备点击：' + t + \"\\n其中心坐标是\" + x, y); click(x, y); break; } } } 坐标点击12345678910111213/** * @description: 纯粹设置坐标点击 * @param {*} x * @param {*} y * @return {*} */function CoordClick(x,y){ click(x+random(-20,20),y+random(-20,20)) console.log('成功点击'+x,y )} 轮廓识别图色的高级版 直接点击字符123// 直接点击字符click(\"str\",index); //点击第index个字符\"str\"(因为有时str会出现多次，另外注意下标从0开始) 意图Activity管理器下载地址 SchemeAndroid中的Scheme是一种页面跳转协议，和网站通过URL的形式访问一样，APP同样可以通过这种方式进行跳转scheme地址，可以直接打开app的某个页面 intent跳转Autojs的intent使用intent拦截者 simpleHook 两个软件抓意图安卓APP通用的intent跳转协议，scheme地址寻找方法与auto.js调用intent跳转只需要找到相关的参数，就可以直接打开指定的页面。前提如果APP里的页面，是不能分享的，那么基本可以认为这个页面是没有scheme地址的。 使用intent打开新浪微博的用户任务中心scheme首先在手机上手动进入新浪微博的任务中心。点击页面右上角的“…”，弹出分享卡片。点击“复制链接”。在电脑的浏览器里，打开这个链接.点击“我要领取”，进入新的页面。 查看页面的html代码，页面的body有这样一段： 1&lt;a href=\"https://c.weibo.cn?scheme=sinaweibo%3A%2F%2Fbrowser%3Furl%3Dhttps%253A%252F%252Fm.weibo.cn%252Fc%252Fcheckin%253Ffeaturecode%253Dfrom_sharingpage_to_mtask%2526luicode%253D20000061%2526lfid%253D180%26featurecode%3Dfrom_sharingpage_to_mtask%26luicode%3D20000061%26lfid%3D180&amp;directdownload=0\" class=\"m-btn m-btn-block m-btn-orange download-btn-r\" ontouchstart=\"\"&gt;去下载微博&lt;/a&gt; 这个url里，存在scheme这个关键字。我们把scheme后面的地址提取出来。sinaweibo%3A%2F%2Fbrowser%3Furl%3Dhttps%253A%252F%252Fm.weibo.cn%252Fc%252Fcheckin%253Ffeaturecode%253Dfrom_sharingpage_to_mtask%2526luicode%253D20000061%2526lfid%253D180%26featurecode%3Dfrom_sharingpage_to_mtask%26luicode%3D20000061%26lfid%3D180&amp;directdownload=0[]URL编码/解码工具(https://tool.chinaz.com/tools/urlencode.aspx) 选择“URL编码/解码”，将scheme地址，进行一次“UrlDecode解码”。可以看到开头部分的“%3A%2F%2F”已经被转换成了“://” 接下来使用auto.js的Intent（意图），来测试这个scheme地址。auto.js提供了构建Intent的函数app.intent(), 启动Activity的函数app.startActivity(), 发送广播的函数app.sendBroadcast()。使用这些方法可以用来方便的调用其他应用。 123app.startActivity({ data:\"sinaweibo://browser?url=https%3A%2F%2Fm.weibo.cn%2Fc%2Fcheckin%3Ffeaturecode%3Dfrom_sharingpage_to_mtask%26luicode%3D20000061%26lfid%3D180&amp;featurecode=from_sharingpage_to_mtask&amp;luicode=20000061&amp;lfid=180&amp;directdownload=0\"}); app.intent()构建Intent的函数 启动服务(Service)：Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。 传递广播：app.sendBroadcast()广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。 直达应用内的某个页面——启动ActivityActivity (应用程序活动)分割了应用中不同的界面和功能（例如微信的主界面、朋友圈、聊天窗口都是不同的Activity），通过Activity可以直接进入应用的特定界面，而不仅仅是启动应用 在Auto.js中，启动Activity有两种方法： 用app.startActivityapp.startActivity()启动活动(Activity)： Activity 表示应用中的一个”屏幕”。 例如应用主入口都是一个Activity，应用的功能通常也以Activity的形式独立，例如微信的主界面、朋友圈、聊天窗口都是不同的Activity。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并携带了任何必要的数据。 但无论用哪种方法，启动Activity都离不开Intent这个工具 Intent(意图)，Intent是一个消息传递对象，Android中提供了Intent来协助应用间的交互与通讯。 其用途一般有三种： 启动活动(Activity)：通过活动可以直达应用内的某个页面 通过startActivity(Intent)，可以隐式启动新的 Activity 实例，其中Intent 描述了要启动的 Activity 启动服务(Service)：不使用用户界面，而在后台执行操作的组件 通过 startService(Intent)可以启动Service，其中Intent 描述了要启动的服务Service 传递广播(Broadcast)： 广播是任何应用均可接收的消息，通过 sendBroadcast(Intent )可以将广播传递给其他应用 app.startActivity(options) 启动Activity 在Auto.js中，提供了与Intent(意图) 相关的进阶函数startActivity和sendBroadcast，它们可完成app模块没有内置的应用交互功能 app.startActivity(options)根据options选项构造一个Intent对象，并启动相应的Activity 其中，options选项有： action {string} 要完成的动作，如”android.intent.action.SEND” ps. 当action以”android.intent.action”开头时，可以省略前缀，直接用”SEND” category {Array} 意图的类别，比较少用 packageName {string} 目标包名 className {string} 目标Activity或Service等组件的名称 type {string} 表示和该意图直接相关的数据的类型，如”text/plain”为纯文本类型 data {string}如要打开一个文件, action为”android.intent.action.VIEW”, data为”file:///sdcard/1.txt”。 extras {Object} 额外信息,如发送邮件时的邮件标题、邮件正文 flags {Array} intent的标识，字符串数组，例如[“activity_new_task”, “grant_read_uri_permission”] root {Boolean} 是否以root权限启动、发送该intent options(即intent的参数)如何获取？ className（即Activity）、packageName通过Auto.js自带的布局分析获取category、action等可以通过例如”intent记录”，”隐式启动”等应用拦截内部intent或者查询暴露的intent。下载https://www.coolapk.com/apk/xyz.hanks.launchactivity其中拦截内部intent需要XPosed框架，或者可以通过反编译等手段获取参数。总之，没有简单直接的方法。举个例子： 例如，在某界面用Auto.js查询到应用包名com.netease.buff，当前活动 12345678com.netease.buff.userCenter.pushSetting.PushSettingsActivity又使用“隐式启动”应用查询到Intent为Intent {act=android.intent.action.MAINcat=[android.intent.category.NOTIFICATION_PREFERENCES]flg=0x14000040cmp=com.netease.buff/.userCenter.pushSetting.PushSettingsActivity} 12345678910function gotoOptions() {//打开设置页面 app.startActivity({ action: \"android.intent.action.MAIN\", packageName: \"com.netease.buff\", className: \"com.netease.buff.userCenter.pushSetting.PushSettingsActivity\", category: [android.intent.category.NOTIFICATION_PREFERENCES] }); return;}gotoOptions(); 注意，此方法有一个限制和缺点，使用此方法，填入的action必须满足android.intent.action.XXX 的格式 例如有时，在“隐式启动”应用中，得到的intent信息如下： 12345Intent {act=DELIVERYflg=0x14000040cmp=com.netease.buff/.entry.SplashActivity} 若继续将这里的DELIVERY 填入action，则会出错（因为上面介绍过，如果写action: “DELIVERY”，将会被startActivity自动补全为action: “android.intent.action.DELIVERY”，然而很明显没有这个action） 用Shell命令（似乎后一种更简洁方便）我们另寻出路：因为给出了cmp（即component）参数，可尝试用用Shell命令启动Activity打开应用或Activity的另一种方法是：通过AndroidStudio的Shell命令 1shell('am start -p com.tencent.mm'); 启动微信，这里使用了Shell命令中的am命令，shell即Unix Shell，是在类Unix系统提供的一系列命令。在Auto.js大致等同于用adb执行命令”adb shell”，有两种执行shell命令的方式： shell函数：一次性执行单条命令。 一般格式shell(cmd[, root])，[root]{Boolean} 表示是否以root权限运行，默认为false Shell对象：一般用于需要执行多条命令的情况，这时Shell对象效率更高。（因为每次运行shell函数都会打开一个单独的shell进程，而Shell对象自始至终使用同一个shell进程） 一般格式new Shell(root)、Shell.exec(cmd)、Shell.exit()等，详见官方文档 Shell之am命令：Activity Manager am命令即Activity Manager命令，用于管理应用程序活动、服务等。 以下命令均以”am “开头，例如shell(‘am start -p com.tencent.mm’); start [options] intent：启动 intent 指定的 Activity option常用参数（可以不填）：参见官方文档； intent常用参数： a action n component，指定组件名称，如“com.example.app/.ExampleActivity”，注意，这里的component参数是上面的startActivity所没有的，这个参数的获取来自于“隐式启动”应用中”cmp”的值 c category f flags t Mime_type d data_uri 举个例子： 在“隐式启动”应用中，得到的intent信息如下： 12345Intent {act=DELIVERYflg=0x14000040cmp=com.netease.buff/.entry.SplashActivity} 故对应的Shell命令如下 1shell('am start -a DELIVERY -f 0x14000040 -n com.netease.buff/.entry.SplashActivity'); 法一转换为法二另外，可以用法一中的option来构造一个Intent，并转换为对应的shell的intent命令的参数——app.intentToShell(options)，示例 1234shell(\"am start \" + app.intentToShell({packageName: “org.autojs.autojs”,className: “org.autojs.autojs.ui.settings.SettingsActivity_”}), true); 微信意图123456789//跳转扫一扫context.startActivity(app.intent({ action: \"VIEW\", className:\"com.tencent.mm.ui.LauncherUI\", packageName:\"com.tencent.mm\", extras: { \"LauncherUI.From.Scaner.Shortcut\": true }}).setFlags(335544320)); 支付宝意图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//跳转支付宝页面app.startActivity({ packageName: 'com.eg.android.AlipayGphone', action: \"VIEW\", data:\"alipays://platformapi/startapp?saId=20000167\",});/** * 小程序 * 修改上面的saId即可 * 60000002 蚂蚁森林 * 20000008 跳转支付宝登录界面 * 20000141 跳转修改名字 * 20000031 跳转修改头像 * 20000116 跳转支付宝付款 * 60000006 附近优惠 * 60000012 中小学 * 60000023 蚂蚁保险 * 60000024 彩票游戏,不对所有用户开放 * 60000029 口碑排行榜 * 60000032 添加第一张证件 各类证件齐管理 * 60000033 in贴纸商城 * 60000039 超值抢购 * 60000040 未来酒店 * 60000044 权益区 无法加载 * 60000047 校园头条 无法加载,可能缺少参数 * 60000052 手机通讯录备份 未对所有用户开放 * 60000057 阿里宝卡 * 60000071 天天有料 * 60000076 VIP预约服务 无法加载,可能我不是VIP的原因 * 60000077 优酷会员首页 * 60000081 商家服务 * 60000091 花呗 * 60000103 支付周奖励金列表页 * 60000105 我的银行卡 管理页 * 60000120 福员外 不知道干嘛的 * 60000125 租房 * 60000126 余额宝 * 60000130 淘票票 * 60000134 外币兑换 服务正在升级 * 60000135 飞猪汽车票 * 60000145 阿里巴巴认证中心 * 60000146 寄快递 * 60000148 财富号 * 60000150 我的口碑 * 60000153 注销账号 注销支付宝账号用的 * 60000154 AA收款 * 60000155 共享单车 * 60000156 支付宝红包~这个应该也是缺少参数 * 60000160 稳健收益 应该是理财类的东西 * 60000161 蚂蚁会员周周乐 * 60000162 彩虹星愿 应该是教育孩子的 * */ Rhino引擎官方文档 史上最全的autojs代码仓库 autojs代码：牙叔教程autojs非常见函数autojs-修改java代码-为我所用Appium 和 Airtest 编写的自动化脚本都依赖于 PC 端运行，没有办法直接运行在移动端；无障碍服务需要单独创建一个 Android 项目，没有完整的使用文档，使用起来有一定的门槛 AutoJS 它通过编写 JavaScript 脚本，结合系统的「 无障碍服务 」对 App 进行自动化操作脚本文件体积小，可以打包成 APK 直接安装拥有丰富的 UI 组件用于构建 GUI 界面非 Root 设备也能完成自动化操作，可以摆脱 PC 直接运行提供多种元素定位方式，可以适配各种机型官方文档非常详细，学习成本低 Auto.JS作为一款基于JavaScript语言的一款脚本，基本语法和结构可通过学习JavaScript来了解。要知道，安卓的app界面就是由一堆控件组成的，这些父子控件相互嵌套，组成了我们熟悉的app界面，因此，你要执行自动化操作，那么最常用的就是先精确的找到这个控件(唯一性)，再来说下一步对其进行操作，而我个人认为Auto.JS之所以方便好用，最大的一点就是查找你想要操作的控件(包括但不限于点击、设置文本等)时特别方便明了，一眼就能看懂并能迅速定位。因为Auto.JS是基于JavaScript的语言，因此基本的语法结构、很多两者通用的函数等都是可以在JavaScript里面找到，如常见的“.replace()”“.indexof()”“.test()”等这些都在JavaScript网站上有相关的用法说明 环境准备vscode插件Auto.js-VSCodeExt Auto.js-VSCodeExt-Fixed对插件 Auto.js-VSCodeExt 进行了部分优化 Autojs Clipboard同步手机剪贴板到电脑剪贴板 然后，使用 VS Code 快捷键「 Ctrl/Command + Shift + P 」，选择「 Auto.js:Start Server 」开启 AutoJS 服务 在同一wifi下无法连接，手机开热点给电脑，即可连接 Auto.js-Pro-Ext 1.4开启代码提示 进入以下文件夹：C:\\Users\\用户名.vscode\\extensions\\hyb1996.auto-js-pro-ext-1.3.2\\assets\\project-templates\\v8-default拷贝这两个文件到你的项目目录：node_modules,tsconfig.json scrcpy投屏Github地址 手机数据线连接电脑后，开启usb调试，自动连接 鼠标右键是返回 要想卸载scrcpy,先在目录下进入cmd,输入adb kill-server,再删除整个scrcpy文件即可 adb功能异常，重启adb（1）把adb服务杀死：adb kill-server（2）重启adb服务：adb reconnect 结合webditorautojs本身就有布局分析，但不一定所有手机都能用，使用weditor进行布局分析 weditor 地址 先把weditor安装好并运行起来。然后： .设备通过USB线连接电脑。在cmd命令行中输入adb tcpip 5555拔掉数据线在cmd命令行中输入adb connect 192.168.1.5(设备在局域网中的ip)在weditor 网页中输入手机的ip并且点击Connect连接 连接成功后，点击“Dump Hierarchy” 获取最新的界面。这里以微信为例，然后我们会看到布局分析，点击我们需要操作的控件，可以获取到resourceId、className、text等信息，然后我们运用autojs进行操作。 shell命令123456789101112131415161718192021222324252627282930313233点击 input tap X Y长按250ms input swipe X1 Y1 X1 Y1 250划屏250ms input swipe X1 Y1 X2 Y2 250输入文本 input text 文本②安装apk pm install &lt;apk位置&gt;卸载apk pm uninstall &lt;包名&gt;隐藏应用pm hide &lt;包名&gt;显示应用pm unhide &lt;包名&gt;停止应用 am force-stop 包名③am start -n 包名/包名＋类名（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等）(这个是可玩性最强的，可以设置在打开应用时运行该命令来达到跳广告，其他还有很多，我也正在研究中)跳广告例子：打开优酷时触发(当然也可以用活动触发，但是得找到这个活动)am start -n com.youku.phone/com.youku.phone.com.youku.HomePageEntry就可以跳广告注：应用包名可以用 【酷安】 的应用管理找或者用其他的都可以活动名称可以用 【开发者助手】 来找④打开网址(默认浏览器) am start -a android.intent.action.VIEW -d 网址微信打开网址am start -n com.tencent.mm/com.tencent.mm.plugin.webview.ui.tools.WebViewUI -d 网址⑤打开桌面图标(比如桌面的快捷方式、小程序等)am start \"intent:@\" (@是/data/data/com.miui.home/databases/launcher5x6.db里的图标对应的intent值⑥关机 shutdown重启 reboot opencv-autojs常用命令https://www.yuque.com/yashujs/bfug6u/yur8h8 小技巧autojs提取软件自带例子通过mt管理器点击autojspro的安装包，然后点击查看，依次打开assets/sample/中文，这就是例子文件。然后长按文件夹解压到任意目录 如果没有mt管理器，可以直接将autojspro.apk的后缀改成.zip,当成压缩包来提取文件。 快捷打开无障碍，长按两个音量键三秒 如何打开控制台依次点击 帮助—–切换开发者工具——console 问题查找控件存不存在使用exists ()。一般情况下Autojs生成的代码是：if (text(“刷视频赚”).exists()) {}，不建议这样写，有很多时候找不到或者是有多个文字一样的内容故：let earnVideo= className(“android.widget.TextView”).text(“刷视频赚”).findOnce();这样写准确率更高。 为什么有时候launchApp(‘应用名’);会失效第一,这是因为你手机存在同名软件.找不到你想要的app，要使用launch(‘应用包名’)。第二,是因为你没有给软件(后台弹出界面)权限 如果有界面，那么监听通知需要放在线程里。webview 注入js的js文件需要改后缀，如果还是js,会被加密导致无法使用webview 内页面引用静态文件可以使用相对路径如果多次调用 even.on，event.emit 会触发多次。可以用 even.removeAllListeners进行清除。console.show 调用时范围只是当前线程。不要在UI线程内死循环，要重新开启一个线程，不然会卡死无障碍服务权限申请可以使用auto,直接跳转到设置页。通知使用服务第一次调用后会提示一次之后，如果没有给予权限。大概率不再弹窗，并且不会报错。如果一直没有给权限，而且无法弹窗需要引导用户手动开启，并重启脚本。 支付宝/微信/其他软件在使用autojs时，遇到支付宝和微信以及一些安全意识较强的平台，很难获取到其页面的控件，无论你是使用autojs自带的控件分析或是Android studio的uiautomatorviewer.bat来分析它们的页面控件，都会分析到。但是你在获取的时侯就会发现根本获取不到， 原因支付宝和微信都把它们的控件藏起来了，可能是封装成某个类型，那个类型的输出就是空行。 我的方法是获取其控件后在其末尾加了个string，使得整个内容强转成string。 12var meId2 = id(\"XXX\").find()+\"\";//找到id为XXX的控件，然后加上空字符串//整个类型现在变成string，现在就可以用字符串截取的方式来获取控件的信息了。 //pro9基本无法使用，低版本可以while(!click(“智慧广工商”)); click(“智慧广工商”) http put1234567891011121314http .request(url, { method: \"PUT\", body: JSON.stringify({ access_token: access_token, content: android.util.Base64.encodeToString(files.readBytes(path), 2), sha: fileinfo.sha, message: \"更新文件\", }), headers: { \"Content-Type\": \"application/json;charset=UTF-8\", }, }) .body.json(); 事件与监听 - Events控制台 - Console1234567891011121314151617181920212223242526272829303132// 新线程中启动控制台threads.start(function () { if (isShowConsole) { console.show(); }});//显示控制台console.show();console.verbose(\"这是灰色\");console.log(\"这是黑色\");console.info(\"这是红色\");console.warn(\"这是蓝色\");console.error(\"这是绿色=_=\");console.trace(\"打印日志行数\");console.setSize(1000, 1000);//调整大小console.setPosition(0, 500); //调整位置console.hide(); //隐藏// 保存日志console.setGlobalLogConfig({ file: \"/sdcard/脚本/log.txt\"});console.time(\"保存截图的时间\");images.save(img, \"/sdcard/3.png\");console.timeEnd(\"保存截图的时间\"); 本地储存 - Storages12345678910111213141516// 保存数组和对象var storage = storages.create(\"Auto.js例子:复杂数据\");var arr = [1, 4, 2, 5];var obj = { name: \"Auto.js\", url: \"www.autojs.org\"};//保存storage.put(\"arr\", arr);storage.put(\"obj\", obj);console.show();//取出log(\"arr = \", storage.get(\"arr\"));log(\"obj = \", storage.get(\"obj\")); 图片与颜色autojs之内存泄露图色助手下载RGB颜色值与十六进制颜色码转换工具 12// 彩图转灰度图images.cvtColor(img, \"RGBA2GRAY\"); 2. 及时回收图片 123456789events.on(\"exit\", function () { if (bigImg &amp;&amp; !bigImg.isRecycled()) { bigImg.recycle(); } if (smallImg &amp;&amp; !smallImg.isRecycled()) { smallImg.recycle(); }}); dex123456// 加载目标dex文件，加载成功后将可以使用该dex文件的类。runtime.loadDex(filePath);// package com.keke; // public class YaShu {}importClass(com.keke.YaShu); //导入类 多线程 - Threadsthreads.start(action) 启动一个新线程并执行action。返回 {Thread} action {Function} 要在新线程执行的函数 悬浮窗 - FloatyFloatyWindow对象floaty.window(layout) layout {xml} | {View} 悬浮窗界面的XML或者View 指定悬浮窗的布局，创建并显示一个悬浮窗，返回一个FloatyWindow对象。 方法 window.setAdjustEnabled(enabled) 是否启用悬浮窗调整(大小、位置) window.setPosition(x, y) 设置悬浮窗位置。 window.getX() 返回悬浮窗位置的X坐标。 window.getY() window.setSize(width, height) 设置悬浮窗宽高。 window.getWidth() 返回悬浮窗宽度。 window.getHeight() window.close() 关闭悬浮窗。如果悬浮窗已经是关闭状态，则此函数将不执行任何操作。被关闭后的悬浮窗不能再显示。 window.exitOnClose() 使悬浮窗被关闭时自动结束脚本运行。 FloatyRawWindow对象floaty.rawWindow(layout) layout {xml} | {View} 悬浮窗界面的XML或者View 指定悬浮窗的布局，创建并显示一个原始悬浮窗，返回一个FloatyRawWindow对象。 与floaty.window()函数不同的是，该悬浮窗不会增加任何额外设施（例如调整大小、位置按钮），您可以根据自己需要编写任何布局。 方法 window.setTouchable(touchable) window.setPosition(x, y) window.getX() window.getY() window.setSize(width, height) window.getWidth() window.getHeight() window.close() window.exitOnClose() 对话框 - Dialogsdialogs.alert(title[, content, callback]) dialogs.confirm(title[, content, callback])dialogs.rawInput(title[, prefill, callback])dialogs.input(title[, prefill, callback])dialogs.prompt(title[, prefill, callback]) dialogs.select(title, items, callback) 显示一个带有选项列表的对话框 title {string} 对话框的标题。 items {Array} 对话框的选项列表，是一个字符串数组。 callback {Function} 回调函数，可选。当用户点击确定时被调用,一般用于ui模式。 dialogs.singleChoice(title, items[, index, callback])dialogs.multiChoice(title, items[, indices, callback])dialog.setDefaultDialogType(type)dialogs.build(properties) ui视图: View视图属性w View的宽度，是属性width的缩写形式。可以设置的值为*, auto和具体数值。h View的高度，是属性height的缩写形式。可以设置的值为*, auto和具体数值。id 在代码中可以通过一个View的id来获取到这个View，并对他进行操作(设置点击动作、设置属性、获取属性等)gravity View的”重力”。用于决定View的内容相对于View的位置，可以设置的值为: left 靠左 right 靠右 top 靠顶部 bottom 靠底部 center 居中 center_vertical 垂直居中 center_horizontal 水平居中layout_gravity View在布局中的”重力”，用于决定View本身在他的父布局的位置，可以设置的值和gravity属性相同。 bg View的背景。其值可以是一个链接或路径指向的图片，或者RGB格式的颜色，或者其他背景。alpha View的透明度，其值是一个0~1之间的小数，0表示完全透明，1表示完全不透明。foreground View的前景。前景即在一个View的内容上显示的内容，可能会覆盖掉View本身的内容。其值和属性bg的值类似。minHeight View的最小高度。minWidthvisibility View的可见性，style 设置View的样式。rotation View的旋转角度。通过该属性可以让这个View顺时针旋转一定的角度。transformPivotXtransformPivotYmarginmarginLeftmarginRightmarginTopmarginBottompaddingpaddingLeftpaddingRightpaddingToppaddingBottom 对视图的操作1234// 获取视图对象，通过视图view的idui.[id]ui.findView('id')$ui.findView('id') ui.[id].getText() //获取到这个按钮控件的文本内容.setText().setDataSource(数组) //获取数组元素 123456// 对控件设置监听ui.fab.setOnClickListener( function(view){ toastLog('你点击了fab') }) 控件文本控件: text text textColor textSize textStyle lines maxLines typeface ellipsize ems autoLink按钮控件: button输入框控件: input hint textColorHint textSizeHint inputType password numeric phoneNumber digit singleLine图片控件: img src tint scaleType radius radiusTopLeft radiusTopRight radiusBottomLeft radiusBottomRight borderWidth borderColor circle垂直布局: verticallayout_weight水平布局: horizontallayout_weight线性布局: linear帧布局: frame相对布局: relative勾选框控件: checkbox选择框控件: radio选择框布局: radiogroup开关控件: Switchcheckedtext进度条控件: progressbar拖动条控件: seekbar下来菜单控件: spinner时间选择控件: timepicker日期选择控件: datepicker浮动按钮控件: fab标题栏控件: toolbar卡片: card 在ui使用webview一个ui界面再调用另一个ui，把另一个ui封装成函数再调用，不需要另开一个线程 在ui使用webview 1234567891011\"ui\";ui.layout( &lt;vertical&gt; &lt;button id=\"btn\"&gt;点击打开网页&lt;/button&gt; &lt;webview id=\"web\"&gt;&lt;/webview&gt; &lt;/vertical&gt;);ui.btn.click(function () { ui.web.loadUrl(\"https://www.baidu.com\");}); 数据库https://www.yuque.com/yashujs/bfug6u/mv8e02 123456789101112131415161718192021222324252627 // 字段映射 let fieldMapping = { \"id\": \"int\", \"desc\": \"String\", } // 表名 let table = \"record\"; // 建表 let SQL = \"CREATE TABLE IF NOT EXISTS \" + table+\" (\" + \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" + \"desc VARCHAR(255)\" + \")\"; // 数据库名 let db = \"xianyu\"; let dbUtils = new DbUtils(db, SQL, fieldMapping); // 创建数据库和表 dbUtils.updateDatabase();// 清表dbUtils.deleteRows(table, null, null)// 数据查询 let existStatus = dbUtils.isExistRow(\"SELECT * FROM \" + table + \" WHERE desc = ?\", [text]);// 增加数据dbUtils.addRow(table, { desc: text }); 用MCV框架实现界面切换● M即model模型是指模型表示业务规则● V即View视图是指用户看到并与之交互的界面● C即controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求 main.js12\"ui\";require(\"./controller\").init(); model.js数据模型和业务逻辑; 验证登录 1234567891011121314151617181920let UserModel = function (username, password) { this.username = username; this.password = password; this.vip = false; this.login = function () { if (this.username === \"admin\" &amp;&amp; this.password === \"123\") { this.vip = true; return true; } else if (this.username === \"user\" &amp;&amp; this.password === \"123\") { this.vip = false; return true; } else { return false; } };};module.exports = { UserModel: UserModel,}; controller.js用来调度View层和Model层, 用来将不同的View和不同的Model组织在一起，顺便替双方传递消息; 把登录的数据交给model处理, 显示对应的界面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let view = require(\"./view\");let model = require(\"./model\");module.exports = { init,};function init() { loadLoginPage();}function loadLoginPage() { ui.layout(view.LoginPage); loginPageAction();}function loadHomePage(user) { ui.layout(view.HomePage); user.vip &amp;&amp; ui.vipComponentParent.addView(ui.inflate(view.VipComponent)); homePageAction(user);}function loginPageAction() { ui.login.click(function () { let username = ui.username.text(); let password = ui.password.text(); if (!username) { toastLog(\"username is empty\"); ui.username.setError(\"username is empty\"); return; } if (!password) { toastLog(\"password is empty\"); ui.password.setError(\"password is empty\"); return; } let user = new model.UserModel(username, password); let loginResult = user.login(); if (loginResult) { loadHomePage(user); } else { toastLog(\"login failed\"); } });}function homePageAction(user) { ui.username.text(user.username); ui.logout.click(function () { loadLoginPage(); });} view.js未登录页面和登录页面的xml文件 12345678910111213141516171819202122232425262728293031323334let LoginPage = ( &lt;vertical padding=\"30\"&gt; &lt;horizontal&gt; &lt;text text=\"username\" textSize=\"30sp\" /&gt; &lt;input id=\"username\" w=\"*\" /&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;text text=\"password\" textSize=\"30sp\" /&gt; &lt;input id=\"password\" type=\"password\" w=\"*\" /&gt; &lt;/horizontal&gt; &lt;button id=\"login\"&gt;login&lt;/button&gt;; &lt;/vertical&gt;);let HomePage = ( &lt;vertical padding=\"30\"&gt; &lt;text text=\"homepage\" w=\"*\" gravity=\"center\" textStyle=\"bold\" textSize=\"40sp\" /&gt; &lt;horizontal&gt; &lt;text text=\"username: \" textSize=\"30sp\" /&gt; &lt;text id=\"username\" textSize=\"30sp\" /&gt; &lt;linear id=\"vipComponentParent\"&gt;&lt;/linear&gt; &lt;/horizontal&gt; &lt;button id=\"logout\"&gt;logout&lt;/button&gt;; &lt;/vertical&gt;);let VipComponent = ( &lt;vertical&gt; &lt;text text=\" vip\" textColor=\"#ff5722\" w=\"*\" textStyle=\"bold\" textSize=\"30sp\" /&gt; &lt;/vertical&gt;);module.exports = { LoginPage: LoginPage, HomePage: HomePage, VipComponent: VipComponent,}; 进程与线程多线程属于同一个进程，同一个进程，申请一次截图权限就可以脚本引擎 - Engines模块，启动的脚本属于不同的进程 2个线程找图做任务，captureScreen 截图给不同的变量，为啥会有一个提示图片被回收？给变量了，只是内存地址被引用。可以用clone方法处理 画布所有的学习笔记，开源项目，还有博客均已经在GitHub开源，链接地址：https://github.com/yangchong211/YCBlogs关于案例已经开源，开源地址：https://github.com/yangchong211 1.Paint画笔介绍Paint即画笔，在绘图过程中起到了极其重要的作用，画笔主要保存了颜色， 样式等绘制信息，指定了如何绘制文本和图形，画笔对象有很多设置方法，大体上可以分为两类，一类与图形绘制相关，一类与文本绘制相关。 1.1 图形绘制常用的方法有这些 setARGB(int a,int r,int g,int b);设置绘制的颜色，a代表透明度，r，g，b代表颜色值。 setAlpha(int a);设置绘制图形的透明度。 setColor(int color);设置绘制的颜色，使用颜色值来表示，该颜色值包括透明度和RGB颜色。 setAntiAlias(boolean aa);设置是否使用抗锯齿功能，会消耗较大资源，绘制图形速度会变慢。 setDither(boolean dither);设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰 setFilterBitmap(boolean filter);如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作，加快显示速度，本设置项依赖于dither和xfermode的设置 setMaskFilter(MaskFilter maskfilter);设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等 setColorFilter(ColorFilter colorfilter);设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 setPathEffect(PathEffect effect);设置绘制路径的效果，如点画线等 setShader(Shader shader);设置图像效果，使用Shader可以绘制出各种渐变效果 setShadowLayer(float radius ,float dx,float dy,int color);在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 setStyle(Paint.Style style);设置画笔的样式，为FILL，FILL_AND_STROKE，或STROKE setStrokeCap(Paint.Cap cap);当画笔样式为STROKE或FILL_AND_STROKE时，设置笔刷的图形样式，如圆形样式 Cap.ROUND,或方形样式Cap.SQUARE setSrokeJoin(Paint.Join join);设置绘制时各图形的结合方式，如平滑效果等 setStrokeWidth(float width);当画笔样式为STROKE或FILL_AND_STROKE时，设置笔刷的粗细度 setXfermode(Xfermode xfermode);设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果 1.2 文本绘制 常用的方法有这些 setFakeBoldText(boolean fakeBoldText);模拟实现粗体文字，设置在小字体上效果会非常差 setSubpixelText(boolean subpixelText);设置该项为true，将有助于文本在LCD屏幕上的显示效果 setTextAlign(Paint.Align align);设置绘制文字的对齐方向 setTextScaleX(float scaleX);设置绘制文字x轴的缩放比例，可以实现文字的拉伸的效果 setTextSize(float textSize);设置绘制文字的字号大小 setTextSkewX(float skewX);设置斜体文字，skewX为倾斜弧度 setTypeface(Typeface typeface);设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等 setUnderlineText(boolean underlineText);设置带有下划线的文字效果 setStrikeThruText(boolean strikeThruText);设置带有删除线的效果 2.Canvas画布介绍 当我们调整好画笔之后，现在需要绘制到画布上，这就得用Canvas类了。在android中既然把Canvas当做画布，那么就可以在画布上绘制我们想要的任何东西。除了在画布上绘制之外，还需要设置一些关于画布的属性，比如，画布的颜色、尺寸等。 2.1 设置属性一般属性有： Canvas(Bitmap bitmap): 以bitmap对象创建一个画布，则将内容都绘制在bitmap上，因此bitmap不得为null。 Canvas(GL gl): 在绘制3D效果时使用，与OpenGL相关。 isOpaque(boolean isOpaque)：检测是否支持透明。 setViewport(int left, int top, int right, int bottom, int clipflag): 设置画布中显示窗口。 drawColor(int color): 设置Canvas的背景颜色。 setBitmap(Bitmap mBitmap): 设置具体画布，画的内容，保存为一个Bitmap。 clipRect(float left, float top, float right, float bottom): 设置显示区域，即设置裁剪区。 translate(float x, float y): 平移画布。 rotate(float degree, float px, float py): 旋转画布 。 skew(float sx, float sy): 设置偏移量。 save(): 将Canvas当前状态保存在堆栈，save之后可以调用Canvas的平移、旋转、错切、剪裁等操作。 restore(): 恢复为之前堆栈保存的Canvas状态，防止save后对Canvas执行的操作对后续的绘制有影响。restore和save要配对使用，restore可以比save少，但不能比save多，否则会引发error。save和restore之间，往往夹杂的是对Canvas的特殊操作。 save(int num)：将Canvas当前状态保存在堆栈，并予以编号int restoreToCount(int num)：恢复为之前堆栈保存的编号为int的Canvas状态 concat(Matrix matrix)：画布关联矩阵，画出来的内容按矩阵改变，而不是画布改变。 Drawable.draw(Canvas canvas)：将Drawable画到Canvas中注：这种方式画Drawable怎么设置透明度呢？((BitmapDrawable)Drawable).getPaint().setAlpha(mBgAlpha);2.2 画图【重点】 画图部分 canvas.drawPaint(Paint paint)将画笔设置的颜色和透明度铺满画布 drawRect(RectF rect, Paint paint)绘制矩形，参数一为RectF一个区域 drawRect(float left, float top, float right, float bottom, Paint paint)绘制矩形，left:矩形left的x坐标，top:矩形top的y坐标，right:矩形right的x坐标，bottom:矩形bottom的y坐标 drawRoundRect(RectF rect, float rx, float ry, Paint paint)绘制圆角矩形， rx:x方向的圆角半径，ry:y方向的圆角半径 drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint) drawPath(Path path, Paint paint)绘制一个路径，参数一为Path路径对象 drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint)贴图，参数一就是我们常规的Bitmap对象，参数二是源区域(这里是bitmap)，参数三是目标区域(应该在canvas的位置和大小)，参数四是Paint画刷对象，因为用到了缩放和拉伸的可能，当原始Rect不等于目标Rect时性能将会有大幅损失。 drawBitmap (Bitmap bitmap, float left, float top, Paint paint) drawLine(float startX, float startY, float stopX, float stopY, Paintpaint)画线，参数一起始点的x轴位置，参数二起始点的y轴位置，参数三终点的x轴水平位置，参数四y轴垂直位置，最后一个参数为Paint 画刷对象。 drawPoint(float x, float y, Paint paint)画点，参数一水平x轴，参数二垂直y轴，第三个参数为Paint对象。 drawText(String text, float x, floaty, Paint paint)渲染文本，Canvas类除了上面的还可以描绘文字，参数一是String类型的文本，参数二文字左侧到x轴距离，参数三文字BaseLine到y轴距离，参数四是Paint对象。 drawOval(RectF oval, Paint paint)绘制椭圆，参数一是扫描区域，参数二为paint对象 drawOval(float left, float top, float right, float bottom, Paint paint） drawCircle(float cx, float cy, float radius,Paint paint)绘制圆，参数一是中心点的x轴，参数二是中心点的y轴，参数三是半径，参数四是paint对象； drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)画弧，参数一是RectF对象，指定圆弧的外轮廓矩形区域，参数二是起始角(度)在电弧的开始，参数三扫描角(度)开始顺时针测量的，参数四是如果这是真的话,包括椭圆中心的电弧,并关闭它,如果它是假这将是一个弧线,参数五是Paint对象；2.3 Canvas对象的获取方式 2.3.1 Canvas对象的获取方式有两种：第一种通过重写View.onDraw方法，View中的Canvas对象会被当做参数传递过来，操作这个Canvas，效果会直接反应在View中。第二种通过new创建一个Canvas对象代码如下所示@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas);} Canvas canvas = new Canvas(); 2.4 Canvas的作用Canvas可以绘制的对象有：弧线(arcs)、填充颜色(argb和color)、Bitmap、圆(circle和oval)、点(point)、线(line)、矩形(Rect)、图片(Picture)、圆角矩形(RoundRect)、文本(text)、顶点(Vertices)、路径(path)。 2.5 Canvas绘制圆和椭圆绘制圆private Paint paint = new Paint(); @Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); paint.setAntiAlias(true); paint.setColor(Color.BLUE); paint.setStyle(Paint.Style.FILL); canvas.drawCircle(200,200,100 , paint);} 2.6 Canvas绘制矩形、圆角矩形如下所示imageprivate Paint paint = new Paint(); @Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); paint.setAntiAlias(true); paint.setColor(Color.RED); paint.setStyle(Paint.Style.FILL); canvas.drawRect(100, 100, 200, 200, paint); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { canvas.drawRoundRect(400, 100, 600, 300, 30, 30, paint); } paint.setStyle(Paint.Style.STROKE); paint.setStrokeWidth(20); canvas.drawRect(100, 400, 300, 600, paint);} 2.7 Canvas绘制文字Canvas绘制文字imageprivate Paint paint = new Paint(); @SuppressLint(“DrawAllocation”)@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); paint.setAntiAlias(true); paint.setColor(Color.RED); paint.setTextSize(100); canvas.drawText(“潇湘剑雨”, 100, 100, paint);} 2.8 Canvas绘制弧形、封闭弧形绘制弧形、封闭弧形imageprivate Paint paint = new Paint(); @SuppressLint(“DrawAllocation”)@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); paint.setAntiAlias(true); paint.setColor(Color.RED); RectF rel = new RectF(50, 50, 150, 150); //实心圆弧 canvas.drawArc(rel, 0, 135, false, paint); //实心圆弧 将圆心包含在内 RectF rel2 = new RectF(50, 200, 150, 300); canvas.drawArc(rel2, 0, 135, true, paint); //设置空心Style paint.setStyle(Paint.Style.STROKE); paint.setStrokeWidth(20); RectF rel3 = new RectF(50, 350, 150, 450); canvas.drawArc(rel3, 0, 270, false, paint); RectF rel4 = new RectF(50, 250, 150, 600); canvas.drawArc(rel4, 0, 270, true, paint);} 2.9 Canvas绘制Path路径Canvas绘制Path路径imageprivate Paint paint = new Paint();@SuppressLint(“DrawAllocation”)@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); Path angle = new Path(); angle.moveTo(250, 0); angle.lineTo(0, 500); angle.lineTo(100, 300); angle.lineTo(200, 350); angle.lineTo(500, 500); angle.close(); canvas.drawPath(angle, paint);} 3.Matrix变换矩阵介绍【Canvas位置转换】思考：如果要画一个仪表盘(数字围绕显示在一个圆圈中)，或者类似钟表指针样的控件，如何实现？Android还提供了一些对Canvas位置转换的方法：rorate、scale、translate、skew(扭曲)等，而且它允许你通过获得它的转换矩阵对象(getMatrix方法)直接操作它。这些操作就像是虽然你的笔还是原来的地方画，但是画纸旋转或者移动了，所以你画的东西的方位就产生变化。为了方便一些转换操作，Canvas还提供了保存和回滚属性的方法(save和restore)，比如你可以先保存目前画纸的位置(save)，然后旋转90度，向下移动100像素后画一些图形，画完后调用restore方法返回到刚才保存的位置。3.1 translate平移 3.2 rorate旋转 rorate旋转imageprivate Paint mPaint = new Paint(); @SuppressLint(“DrawAllocation”)@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawColor(Color.BLUE); mPaint.setColor(Color.RED); canvas.drawRect(new Rect(0, 0, 800, 800), mPaint); canvas.save(); mPaint.setColor(Color.GREEN); canvas.rotate(45,400,400); canvas.drawRect(new Rect(0, 0, 800, 800), mPaint); canvas.restore();}源代码有两个可以使用的方法：/** Preconcat the current matrix with the specified rotation. @param degrees The amount to rotate, in degrees /public native void rotate(float degrees);/** Preconcat the current matrix with the specified rotation. @param degrees The amount to rotate, in degrees @param px The x-coord for the pivot point (unchanged by the rotation) @param py The y-coord for the pivot point (unchanged by the rotation) /public final void rotate(float degrees, float px, float py) { translate(px, py); rotate(degrees); translate(-px, -py);} 3.3 scale缩放 scale缩放imageprivate Paint mPaint = new Paint(); @SuppressLint(“DrawAllocation”)@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawColor(Color.YELLOW); mPaint.setColor(Color.RED); canvas.drawRect(new Rect(0, 0, 800, 800), mPaint); // 保存画布状态 canvas.save(); canvas.scale(0.5f, 0.5f); mPaint.setColor(Color.GREEN); canvas.drawRect(new Rect(0, 0, 800, 800), mPaint); // 画布状态回滚 canvas.restore(); canvas.scale(0.5f, 0.5f, 400, 400); mPaint.setColor(Color.BLUE); canvas.drawRect(new Rect(0, 0, 800, 800), mPaint);}源码如下所示/** Preconcat the current matrix with the specified scale. @param sx The amount to scale in X @param sy The amount to scale in Y /public native void scale(float sx, float sy); /** Preconcat the current matrix with the specified scale. @param sx The amount to scale in X @param sy The amount to scale in Y @param px The x-coord for the pivot point (unchanged by the scale) @param py The y-coord for the pivot point (unchanged by the scale) /public final void scale(float sx, float sy, float px, float py) { translate(px, py); scale(sx, sy); translate(-px, -py);} 3.4 skew扭曲 4.RectF介绍 4.1 Rect简单属性 这是一个我们常用的一个“绘画相关的工具类”，常用语描述长方形/正方形，他只有4个属性public int left;public int top;public int right;public int bottom;其中常用的构造方法如下所示public Rect(int left, int top, int right, int bottom) { this.left = left; this.top = top; this.right = right; this.bottom = bottom;} public Rect(Rect r) { if (r == null) { left = top = right = bottom = 0; } else { left = r.left; top = r.top; right = r.right; bottom = r.bottom; }}这4个属性描述着这一个“方块”，但是这有一个知识点需要理清楚，先看这张图image4.2 Rect父类的实现 实现了Parcelable 所以需要实现一堆Object的方法，诸如equals，toString等等，来简单看一看对于equals方法，首先先对传来的对象进行判空，类型判断，再强转成Rect对象，最后还是一个个去比对那4个属性。@Overridepublic boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Rect r = (Rect) o; return left == r.left &amp;&amp; top == r.top &amp;&amp; right == r.right &amp;&amp; bottom == r.bottom; } @Overridepublic int hashCode() { int result = left; result = 31 * result + top; result = 31 * result + right; result = 31 * result + bottom; return result;} @Overridepublic String toString() { StringBuilder sb = new StringBuilder(32); sb.append(“Rect(“); sb.append(left); sb.append(“, “); sb.append(top); sb.append(“ - “); sb.append(right); sb.append(“, “); sb.append(bottom); sb.append(“)”); return sb.toString();}4.3 Rect常用的一些方法 获取“宽”//文章开头说的公式在这里得到了应验public final int width() { return right - left;}获取“高”public final int height() { return bottom - top;}有效性的判断//因为left是最左侧，right比left还小不就不成形了么？宽高同是如此public final boolean isEmpty() { return left &gt;= right || top &gt;= bottom;}全部置0操作public void setEmpty() { left = right = top = bottom = 0;}设置参数方法，和构造函数的区别仅在于不会创建新对象public void set(int left, int top, int right, int bottom) { this.left = left; this.top = top; this.right = right; this.bottom = bottom;}5.关于使用到这几个属性的自定义View 上面比较详细介绍了Canvas，Paint，Matrix，RectF等等的属性，作用，常用方法，接下来就需要结合具体业务需求练手写一下小案例自定义控件呢5.1 自定义轮播图圆点 5.1.1 需求介绍绘制圆环，一个实心中心圆，还有一个外圆环此控件可以设置宽度和高度，可以设置颜色5.1.2 思路介绍3.2.1 既然是绘制圆形，可以写一个继承View的自定义view3.2.2 重写onDraw方法，获取控件宽高，然后比较宽高值，取小值的一半作为圆的半径3.2.3 然后分别绘制选中状态和未选中状态的圆3.2.4 创建画笔Paint，并且设置相关属性，比如画笔颜色，类型等3.2.5 利用canvas绘制圆，然后再又用相同方法绘制外边缘3.2.6 自定义一个是否选中状态的方法，传入布尔值是否选中，然后调用view中invalidate方法5.1.3 代码介绍具体代码如下所示：/** @author yangchong blog : https://github.com/yangchong211 time : 2016/5/18 desc : 红点自定义控件 revise: 建议设置红点宽高一样，否则是椭圆 /public class DotView extends View { private boolean isInit = false; private boolean isSelected = false; private float mViewHeight; private float mViewWidth; private float mRadius; private Paint mPaintBg = new Paint(); private int mBgUnselectedColor = Color.parseColor(“#1A000000”); private int mBgSelectedColor = Color.parseColor(“#FDE26E”); private static final float mArcWidth = 2.0f; public DotView(Context context) { super(context); } public DotView(Context context, AttributeSet attrs) { super(context, attrs); } public DotView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); if (!isInit) { isInit = true; mViewHeight = getHeight(); mViewWidth = getWidth(); if (mViewHeight &gt;= mViewWidth) { mRadius = mViewWidth / 2.f; } else { mRadius = mViewHeight / 2.f; } } //是否选中 if (isSelected){ drawSelectedDot(canvas); } else{ drawUnSelectedDot(canvas); } } /** 绘制选中指示器红点 @param canvas canvas /private void drawSelectedDot(Canvas canvas) { //设置paint相关属性 mPaintBg.setAntiAlias(true); mPaintBg.setColor(mBgSelectedColor); mPaintBg.setStyle(Style.FILL); //绘制圆 canvas.drawCircle(mViewWidth / 2.f, mViewHeight / 2.f, mRadius - 8.f, mPaintBg); mPaintBg.setStyle(Style.STROKE); float offset = 1.f + mArcWidth; RectF oval = new RectF(mViewWidth / 2.f - mRadius + offset, mViewHeight / 2.f - mRadius + offset, mViewWidth / 2.f + mRadius - offset, mViewHeight / 2.f + mRadius - offset); //绘制指定的弧线，该弧线将被缩放以适应指定的椭圆形。 canvas.drawArc(oval, 0.f, 360.f, false, mPaintBg);} /** 绘制未选中指示器红点 @param canvas canvas /private void drawUnSelectedDot(Canvas canvas) { mPaintBg.setAntiAlias(true); mPaintBg.setColor(mBgUnselectedColor); mPaintBg.setStyle(Style.FILL); canvas.drawCircle(mViewWidth / 2.f, mViewHeight / 2.f, mRadius - 8.f, mPaintBg);} /** 设置是否选中 @param isSelected isSelected /public void setIsSelected(boolean isSelected) { this.isSelected = isSelected; //使整个视图无效。如果视图是可见的，则{@link#onDraw(android.Graphics.Canvas)}将在将来的某个时候被调用。 //调用该方法，会进行重新绘制，也就是调用onDraw方法 this.invalidate();}} 5.2 自定义圆环百分比进度条 5.2.1 需求分析1.业务需求：可以设置圆角，可以设置圆形，如果是圆角则必须设置半径，默认圆角半径为10dp2.如果设置了圆形，则即使设置圆角也无效；如果设置非圆形，则圆角生效，同时需要判断圆角半径是否大于控件宽高，处理边界逻辑3.当设置圆形的时候，即使设置宽高不一样，那么取宽高中的最小值的一半为圆形半径5.2.2 代码介绍代码如下所示public class ARoundImageView extends AppCompatImageView { /* * Paint：画笔 * Canvas：画布 * Matrix：变换矩阵 * * 业务需求：可以设置圆角，可以设置圆形，如果是圆角则必须设置半径，默认圆角半径为10dp */ /** * 圆形模式 */ private static final int MODE_CIRCLE = 1; /** * 普通模式 */ private static final int MODE_NONE = 0; /** * 圆角模式 */ private static final int MODE_ROUND = 2; /** * 圆角半径 */ private int currRound = dp2px(10); /** * 画笔 */ private Paint mPaint; /** * 默认是普通模式 */ private int currMode = 0; public ARoundImageView(Context context) { this(context,null); } public ARoundImageView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public ARoundImageView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); obtainStyledAttrs(context, attrs, defStyleAttr); initViews(); } private void obtainStyledAttrs(Context context, AttributeSet attrs, int defStyleAttr) { TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ARoundImageView, defStyleAttr, 0); currMode = a.hasValue(R.styleable.ARoundImageView_type) ? a.getInt(R.styleable.ARoundImageView_type, MODE_NONE) : MODE_NONE; currRound = a.hasValue(R.styleable.ARoundImageView_radius) ? a.getDimensionPixelSize(R.styleable.ARoundImageView_radius, currRound) : currRound; a.recycle(); } private void initViews() { //ANTI_ALIAS_FLAG 用于绘制时抗锯齿 mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG); } /** * 当模式为圆形模式的时候，我们强制让宽高一致 */ @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { if (currMode == MODE_CIRCLE) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); int result = Math.min(getMeasuredHeight(), getMeasuredWidth()); // 此方法必须由{@link#onMeasure(int，int)}调用，以存储已测量的宽度和测量的高度。 // 如果不这样做，将在测量时触发异常。 setMeasuredDimension(result, result); } else { super.onMeasure(widthMeasureSpec, heightMeasureSpec); } } @SuppressLint(\"DrawAllocation\") @Override protected void onDraw(Canvas canvas) { //获取ImageView图片资源 Drawable mDrawable = getDrawable(); //获取Matrix对象 Matrix mDrawMatrix = getImageMatrix(); if (mDrawable == null) { return; } if (mDrawable.getIntrinsicWidth() == 0 || mDrawable.getIntrinsicHeight() == 0) { return; } if (mDrawMatrix == null &amp;&amp; getPaddingTop() == 0 &amp;&amp; getPaddingLeft() == 0) { mDrawable.draw(canvas); } else { final int saveCount = canvas.getSaveCount(); canvas.save(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) { if (getCropToPadding()) { final int scrollX = getScrollX(); final int scrollY = getScrollY(); canvas.clipRect(scrollX + getPaddingLeft(), scrollY + getPaddingTop(), scrollX + getRight() - getLeft() - getPaddingRight(), scrollY + getBottom() - getTop() - getPaddingBottom()); } } canvas.translate(getPaddingLeft(), getPaddingTop()); switch (currMode){ case MODE_CIRCLE: Bitmap bitmap1 = drawable2Bitmap(mDrawable); mPaint.setShader(new BitmapShader(bitmap1, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)); canvas.drawCircle(getWidth() / 2, getHeight() / 2, getWidth() / 2, mPaint); break; case MODE_ROUND: Bitmap bitmap2 = drawable2Bitmap(mDrawable); mPaint.setShader(new BitmapShader(bitmap2, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)); canvas.drawRoundRect(new RectF(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom()), currRound, currRound, mPaint); break; case MODE_NONE: default: if (mDrawMatrix != null) { canvas.concat(mDrawMatrix); } mDrawable.draw(canvas); break; } canvas.restoreToCount(saveCount); } } /** * drawable转换成bitmap */ private Bitmap drawable2Bitmap(Drawable drawable) { if (drawable == null) { return null; } Bitmap bitmap = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); //根据传递的scaleType获取matrix对象，设置给bitmap Matrix matrix = getImageMatrix(); if (matrix != null) { canvas.concat(matrix); } drawable.draw(canvas); return bitmap; } private int dp2px(float value) { return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, value, getResources().getDisplayMetrics()); } }","categories":[{"name":"自动化","slug":"自动化","permalink":"https://wenkex.gitee.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"autojs","slug":"autojs","permalink":"https://wenkex.gitee.io/tags/autojs/"}]},{"title":"鸿蒙开发","slug":"鸿蒙开发","date":"2022-01-08T07:37:55.000Z","updated":"2022-01-08T07:37:55.000Z","comments":true,"path":"2022/010839456.html","link":"","permalink":"https://wenkex.gitee.io/2022/010839456.html","excerpt":"","text":"HarmonyOS概述HarmonyOS是一款面向万物互联时代的、全新的分布式操作系统。在传统的单设备系统能力基础上，HarmonyOS提出了基于同一套系统能力、适配多种终端形态的分布式理念，能够支持手机、平板、智能穿戴、智慧屏、车机等多种终端设备，提供全场景（移动办公、运动健康、社交通信、媒体娱乐等）业务能力。 HarmonyOS有三大特征：硬件互助，资源共享分布式软总线分布式软总线是手机、平板、智能穿戴、智慧屏、车机等分布式设备的通信基座，为设备之间的互联互通提供了统一的分布式通信能力， 典型应用场景举例： 智能家居场景：在烹饪时，手机可以通过碰一碰和烤箱连接，并将自动按照菜谱设置烹调参数，控制烤箱来制作菜肴。与此类似，料理机、油烟机、空气净化器、空调、灯、窗帘等都可以在手机端显示并通过手机控制。设备之间即连即用，无需繁琐的配置。多屏联动课堂：老师通过智慧屏授课，与学生开展互动，营造课堂氛围；学生通过平板完成课程学习和随堂问答。统一、全连接的逻辑网络确保了传输通道的高带宽、低时延、高可靠。 分布式设备虚拟化分布式设备虚拟化平台可以实现不同设备的资源融合、设备管理、数据处理，多种设备共同形成一个超级虚拟终端。针对不同类型的任务，为用户匹配并选择能力合适的执行硬件，让业务连续地在不同设备间流转，充分发挥不同设备的能力优势 典型应用场景举例： 视频通话场景：在做家务时接听视频电话，可以将手机与智慧屏连接，并将智慧屏的屏幕、摄像头与音箱虚拟化为本地资源，替代手机自身的屏幕、摄像头、听筒与扬声器，实现一边做家务、一边通过智慧屏和音箱来视频通话。游戏场景：在智慧屏上玩游戏时，可以将手机虚拟化为遥控器，借助手机的重力传感器、加速度传感器、触控能力，为玩家提供更便捷、更流畅的游戏体验。 分布式数据管理分布式数据管理基于分布式软总线的能力，实现应用程序数据和用户数据的分布式管理。用户数据不再与单一物理设备绑定，业务逻辑与数据存储分离，跨设备的数据处理如同本地数据处理一样方便快捷，让开发者能够轻松实现全场景、多设备下的数据存储、共享和访问，为打造一致、流畅的用户体验创造了基础条件。分布式数据管理示意图见图3。 典型应用场景举例： 协同办公场景：将手机上的文档投屏到智慧屏，在智慧屏上对文档执行翻页、缩放、涂鸦等操作，文档的最新状态可以在手机上同步显示。照片分享场景：出游时，使用手机拍摄的照片，可以在登录了同帐号的其他设备，比如平板上更方便地浏览、收藏、保存或编辑，也可以通过家中的智慧屏上同家人一起分享记录下的快乐瞬间。 分布式任务调度分布式任务调度基于分布式软总线、分布式数据管理、分布式Profile等技术特性，构建统一的分布式服务管理（发现、同步、注册、调用）机制，支持对跨设备的应用进行远程启动、远程调用、远程连接以及迁移等操作，能够根据不同设备的能力、位置、业务运行状态、资源使用情况，以及用户的习惯和意图，选择合适的设备运行分布式任务。 图4以应用迁移为例，简要地展示了分布式任务调度能力。 典型应用场景举例： 导航场景：如果用户驾车出行，上车前，在手机上规划好导航路线；上车后，导航自动迁移到车机和车载音箱；下车后，导航自动迁移回手机。如果用户骑车出行，在手机上规划好导航路线，骑行时手表可以接续导航。外卖场景：在手机上点外卖后，可以将订单信息迁移到手表上，随时查看外卖的配送状态。 一次开发，多端部署HarmonyOS通过组件化和小型化等设计方法，支持多种终端设备按需弹性部署，能够适配不同类别的硬件资源和功能需求。支撑通过编译链关系去自动生成组件化的依赖关系，形成组件树依赖图，支撑产品系统的便捷开发，降低硬件设备的开发门槛。 支持各组件的选择（组件可有可无）：根据硬件的形态和需求，可以选择所需的组件。支持组件内功能集的配置（组件可大可小）：根据硬件的资源情况和功能需求，可以选择配置组件中的功能集。例如，选择配置图形框架组件中的部分控件。支持组件间依赖的关联（平台可大可小）：根据编译链关系，可以自动生成组件化的依赖关系。例如，选择图形框架组件，将会自动选择依赖的图形引擎组件等。 统一OS，弹性部署对设备开发者而言，HarmonyOS采用了组件化的设计方案，可根据设备的资源能力和业务特征灵活裁剪，满足不同形态终端设备对操作系统的要求。 技术架构HarmonyOS整体遵从分层设计，从下向上依次为：内核层、系统服务层、框架层和应用层。系统功能按照“系统 &gt; 子系统 &gt; 功能/模块”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的子系统或功能/模块。 内核层内核子系统：HarmonyOS采用多内核设计，支持针对不同资源受限设备选用适合的OS内核。内核抽象层（KAL，Kernel Abstract Layer）通过屏蔽多内核差异，对上层提供基础的内核能力，包括进程/线程管理、内存管理、文件系统、网络管理和外设管理等。驱动子系统：硬件驱动框架（HDF）是HarmonyOS硬件生态开放的基础，提供统一外设访问能力和驱动开发、管理框架。 系统服务层系统服务层是HarmonyOS的核心能力集合，通过框架层对应用程序提供服务。该层包含以下几个部分： 系统基本能力子系统集：为分布式应用在HarmonyOS多设备上的运行、调度、迁移等操作提供了基础能力，由分布式软总线、分布式数据管理、分布式任务调度、方舟多语言运行时、公共基础库、多模输入、图形、安全、AI等子系统组成。其中，方舟运行时提供了C/C++/JS多语言运行时和基础的系统类库，也为使用方舟编译器静态化的Java程序（即应用程序或框架层中使用Java语言开发的部分）提供运行时。基础软件服务子系统集：为HarmonyOS提供公共的、通用的软件服务，由事件通知、电话、多媒体、DFX（Design For X） 、MSDP&amp;DV等子系统组成。增强软件服务子系统集：为HarmonyOS提供针对不同设备的、差异化的能力增强型软件服务，由智慧屏专有业务、穿戴专有业务、IoT专有业务等子系统组成。硬件服务子系统集：为HarmonyOS提供硬件服务，由位置服务、生物特征识别、穿戴专有硬件服务、IoT专有硬件服务等子系统组成。根据不同设备形态的部署环境，基础软件服务子系统集、增强软件服务子系统集、硬件服务子系统集内部可以按子系统粒度裁剪，每个子系统内部又可以按功能粒度裁剪。 框架层框架层为HarmonyOS应用开发提供了Java/C/C++/JS/TS等多语言的用户程序框架和Ability框架，两种UI框架（包括适用于Java语言的Java UI框架、适用于JS/TS语言的方舟开发框架），以及各种软硬件服务对外开放的多语言框架API。根据系统的组件化裁剪程度，HarmonyOS设备支持的API也会有所不同。 应用层应用层包括系统应用和第三方非系统应用。HarmonyOS的应用由一个或多个FA（Feature Ability）或PA（Particle Ability）组成。其中，FA有UI界面，提供与用户交互的能力；而PA无UI界面，提供后台运行任务的能力以及统一的数据访问抽象。FA在进行用户交互时所需的后台数据访问也需要由对应的PA提供支撑。基于FA/PA开发的应用，能够实现特定的业务功能，支持跨设备调度与分发，为用户提供一致、高效的应用体验。 用户应用程序包结构HarmonyOS的用户应用程序包以APP Pack（Application Package）形式发布，它是由一个或多个HAP（HarmonyOS Ability Package）以及描述每个HAP属性的pack.info组成。HAP是Ability的部署包，HarmonyOS应用代码围绕Ability组件展开。 一个HAP是由代码、资源、第三方库及应用配置文件组成的模块包，可分为entry和feature两种模块类型，如图1所示。 entry：应用的主模块。一个APP中，对于同一设备类型，可以有一个或多个entry类型的HAP，来支持该设备类型中不同规格（如API版本、屏幕规格等）的具体设备。如果同一设备类型存在多个entry模块，则必须配置distroFilter分发规则，使得应用市场在做应用的云端分发时，对该设备类型下不同规格的设备进行精确分发。feature：应用的动态特性模块。一个APP可以包含一个或多个feature类型的HAP，也可以不含。只有包含Ability的HAP才能够独立运行。 AbilityAbility是应用所具备的能力的抽象，一个应用可以包含一个或多个Ability。Ability分为两种类型：FA（Feature Ability）和PA（Particle Ability）。FA/PA是应用的基本组成单元，能够实现特定的业务功能。FA有UI界面，而PA无UI界面。 库文件库文件是应用依赖的第三方代码（例如so、jar、bin、har等二进制文件），存放在libs目录。 资源文件应用的资源文件（字符串、图片、音频等）存放于resources目录下，便于开发者使用和维护，详见资源文件的分类。 配置文件配置文件 (config.json) 是应用的Ability信息，用于声明应用的Ability，以及应用所需权限等信息，详见应用配置文件。 pack.info描述应用软件包中每个HAP的属性，由IDE编译生成，应用市场根据该文件进行拆包和HAP的分类存储。HAP的具体属性包括：delivery-with-install: 表示该HAP是否支持随应用安装。“true”表示支持随应用安装；“false”表示不支持随应用安装。name：HAP文件名。module-type：模块类型，entry或feature。device-type：表示支持该HAP运行的设备类型。 HARHAR（HarmonyOS Ability Resources）可以提供构建应用所需的所有内容，包括源代码、资源文件和config.json文件。HAR不同于HAP，HAR不能独立安装运行在设备上，只能作为应用模块的依赖项被引用。","categories":[{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkex.gitee.io/categories/%E9%B8%BF%E8%92%99/"}],"tags":[{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkex.gitee.io/tags/%E9%B8%BF%E8%92%99/"}]},{"title":"Docker学习","slug":"Docker入门","date":"2022-01-05T01:02:52.000Z","updated":"2022-01-05T01:02:52.000Z","comments":true,"path":"2022/010511205.html","link":"","permalink":"https://wenkex.gitee.io/2022/010511205.html","excerpt":"","text":"DockerDocker 是一个开源的应用容器引擎，基于 GO 语言开发，开发者可以打包应用及依赖包到一个可移植的容器中，然后发布到任何操作系统的机器上，也可以实现虚拟化。 简单理解:Docker就是一个虚拟机，可以让你在一个虚拟的，类似于沙盒的环境下进行环境搭建、软件安装、软件使用、程序编码等操作，并且这个环境是Linux系统。实际上：是在Linux系统下的一种容器，容器技术把一个系统需要的资源划分给一个独立的组(Linux系统下每个组的权限不同，互不干扰)，可以将此看作是一个新的Linux系统，因为它包含了Linux系统所需要的环境。与虚拟机不同的是，虚拟机下的系统是有虚拟硬件的，而Docker内的系统实际上是一个环境。 安装window下安装安装想要使用Docker-desktop首先安装WSL2内核 通过wsl命令将这两个子系统进行迁移docker-desktop：保存的是程序docker-desktop-data: 保存的镜像wsl --help:查看wsl命令提醒 12345678910111213141516#1.查看所有WSL。wsl -l --all -v#2、导出WSL。wsl --export docker-desktop D:\\data\\WSL2\\docker-desktop.tarwsl --export docker-desktop-data D:\\data\\WSL2\\docker-desktop-data.tar#3、注销待迁移WSL。wsl --unregister docker-desktopwsl --unregister docker-desktop-data#4、在新位置导入WSL。wsl --import docker-desktop D:\\data\\WSL2\\docker-desktop D:\\data\\WSL2\\docker-desktop.tar --version 2wsl --import docker-desktop-data D:\\data\\WSL2\\docker-desktop-data D:\\data\\WSL2\\docker-desktop-data.tar --version 2 配置国内源设置-&gt;Docker Engine 1234\"registry-mirrors\": [ \"https://docker.mirrors.ustc.edu.cn/\", \"https://hub-mirror.c.163.com/\"] centos下安装123456789101112131415161718192021222324# 卸载可能存在的旧版本yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine# 安装必要的系统工具yum install -y yum-utils device-mapper-persistent-data lvm2# 配置阿里云Docker Yum源yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# ​ 更新yum缓存yum makecache fast# 安装docker-CE(docker社区版)yum -y install docker-ce# 启动dockersystemctl start docker #查看dockers状态systemctl status docker#设置docker开机自启systemctl enable docker Docker Client：客户端，命令行Docker Daemon：服务端守护进程，接受并处理来自客户端的消息镜像与容器的关系镜像是一个linux虚拟机，容器是启动虚拟机，每次启动的时候，是一个副本，是先把镜像复制一份后直接启动，启动不干扰镜像，一个镜像可以启动无数个容器。 镜像：可以理解为没有运行的程序及其运行所依赖的操作系统文件和依赖库。而容器可以理解为运行中的镜像。其实一个就是程序，一个就是进程。相比普通的程序，多了运行所支持的操作系统文件和依赖库，所以镜像可以随便部署都能以一样状态运行。 镜像(Image)相当于面向对象编程 类 的概念 一个只读层被称为镜像，一个镜像是永久不会变的。因为 Docker 使用统一文件系统，Docker 进程认为整个文件系统是以读写方式挂载的，由于所有的变更都发生在顶层的可写层，所以下层的原始的只读镜像文件并未发生变化。 12345# 查找镜像docker search mysql#查看已有镜像docker images 拉取镜像123456789101112# 官方镜像docker pull 镜像名称# 个人镜像docker pull 仓库名称/镜像名称docker pull xunmi/django# 第三方仓库拉取docker pull 第三方仓库地址/仓库名称/镜像名称docker pull hub.c.163.com/library/mysql:latest(默认仓库名为library,所有从官方获取镜像相当于`sudo docker image pull library/镜像名称`) 删除镜像1234# 要删除镜像，要先删除其下的容器docker image rm 镜像名或镜像ID 或 docker rmi 镜像名或镜像ID 构建镜像通常在镜像仓库下载images 镜像无法满足当前业务软件运行要求，需要安装一些软件包并重新生成images镜像后进行大批量部署。使用docker commit和docker build 2种方式构建镜像。 commit构建镜像（1）运行容器 docker run -d -it --name webserver -p 8080:80 nginx（2）修改容器 （容器内修改）echo \"hello\" &gt; /usr/share/nginx/html/hello.html（3）构建新镜像 docker commit webserver nginx-202206 1234567#命令格式docker commit -a=\"作者\" -m=\"说明\" -p 容器id/容器名称 镜像新名称:镜像版本# 参数说明 -a :提交的镜像作者； -c :使用Dockerfile指令来创建镜像； -m :提交时的说明文字； -p :在commit时，将容器暂停。 （4）查看镜像 docker images nginx-202206（5）docker run运行 docker run -d -it --name nginx02 -p 8091:80 nginx-202206（6）访问测试 [root@localhost /]# curl 192.168.100.95:8091/hello.htmlhello（7）文件挂载docker run -d --name nginx01 -p 8090:80 -v /nginx/public:/usr/share/nginx/html -v /nginx/config:/etc/nginx/conf.d nginx-202206 dockerFile构建镜像(1)创建 dockerFile_nginx文件 vim dockerFile_nginx FROM nginx-202206COPY ./hello.html /usr/share/nginx/html(2)docker build 构建镜像 123456docker build -f dockerfile_nginx -t webnginx:v1.1 .# 参数说明-f 需要构建的脚本文件-t tag的缩写，构建后的镜像名称:版本号 (3)查看镜像 [root@localhost mnt]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEwebnginx v1.1 11917097ffd6 5 minutes ago 141MBnginx-202206 latest 756b1c638161 About an hour ago 141MBnginx latest 605c77e624dd 5 months ago 141MB(4)运行镜像 docker run -d -it –name nginxA -p 8095:80 webnginx:v1.1(5)测试 [root@localhost mnt]# curl 192.168.100.95:8095/hello.htmldockerFile 镜像保存、加载12345678（1）镜像保存#命令格式docker save 镜像id/镜像名称 -o /本地目录/文件名称docker save webnginx:v1.1 -o /opt/webnginx.tar（2）load加载镜像docker load -i /opt/webnginx.tar 容器(Container)相当于面向对象编程 对象 的概念 镜像运行后的进程。因为 Docker 的容器实在太轻量级了，很多时候用户都是随用随建，用完即删。启动一个容器首先要拉取一个镜像参考 容器状态(STATUS)exited:此时使用start命令可以将容器b1从die状态重新启动为running状态，并进行交互 查看容器123456docker ps # 查看正在运行的容器docker ps -a # 查看当前所有的容器docker inspect id #查看容器的信息 启动和关闭容器参数： -i 表示已交互模式运行容器 -t 为容器重新分配一个伪输入终端 -d 后台运行容器，想要进入容器需要使用指令 docker exec -v参数挂载宿主机文件或目录到容器 123456789101112131415161718docker run -d --restart=always -v D:\\data\\docker\\alist:/opt/alist/data -p 5244:5244 --name=\"alist01\" xhofe/alist:latestdocker run -it 镜像名 #启动一个容器docker rm 容器名或容器id #删除容器docker rename 容器原来名 要改为的名字 # 更改容器名# 重新启动已存在的容器docker start 容器名或容器iddocker stop 容器名或容器id # 停止容器docker restart &lt;容器 ID&gt; #停止的容器可以通过 docker restart 重启# 强制关闭容器docker kill 容器名或容器id 容器数据管理数据卷特点： 数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会被拷贝到初始化的数据卷中。 数据卷可以在容器之间共享和重用。 可以对数据卷里的内容直接进行修改。 数据卷的变化不会影响镜像的更新。 数据卷会一直存在，即使挂载数据卷的容器已经被删除。 12# 数据卷使用，为容器添加数据卷.-v 宿主机目录:容器内目录docker run -v /app/data:/data -it centos /bin/bash 操作后台容器1234#进入后台容器docker exec -it 容器ID bash 导出和导入容器1234docker export 1e560fca3906 &gt; ubuntu.tar # 导出容器docker /ubuntu.tar | docker import - test/ubuntu:v1 #导入容器，再将容器导入到一个镜像中docker import http://example.com/exampleimage.tgz example/imagerepo #通过指定 URL 或者某个目录来导入 容器制作成镜像1234567# 将容器制作成镜像docker commit 容器名 镜像名# 镜像打包备份(打包备份的文件会自动存放在当前命令行的路径下,如果想让保存的文件可以打开,可以加.tar后缀)docker save -o 保存的文件名 镜像名# 镜像解压docker load -i 文件路径/备份文件 2 docker容器数据管理2.1 docker容器的数据卷数据卷特点： 数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会被拷贝到初始化的数据卷中。 数据卷可以在容器之间共享和重用。 可以对数据卷里的内容直接进行修改。 数据卷的变化不会影响镜像的更新。 数据卷会一直存在，即使挂载数据卷的容器已经被删除。 12# 数据卷使用，为容器添加数据卷.-v 宿主机目录:容器内目录docker run -v /app/data:/data -it centos /bin/bash 2.2 docker的数据卷容器一个容器挂载了数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器叫做数据卷容器。 docker run --volumes-from [container name] 2.3 数据卷备份和还原123456789101112# 数据备份# -v ：指定保存数据的路径# tar cvf ：是容器运行时执行的命令，执行的是一个压缩文件tar 命令，# 将要备份容器中的目录压缩到指定的目录下。# 这个容器的名字叫做datavolume，挂载在data-volume2 上，# 宿主机目录是/root/backup，容器中的目录是/backup，运行centos系统，# 压缩之后的路径是/backup/data-volume2.tar.gz，# container data volume 是需要压缩备份的目录docker run --volumes-from [container name] -v /app/backup:/backup centos tar czvf /backup/backup.tar.gz [container data volume]# 数据还原docker run --volumes-from [container name] -v /app/backup:/backup centos tar xzvf /backup/backup.tar.gz [container data volume] vscode使用dockerhttps://docs.microsoft.com/zh-cn/visualstudio/docker/tutorials/docker-tutorialVS Code 提供可让你使用本地 Docker 桌面服务的扩展。 可以创建容器化应用，将应用部署到容器，并调试容器上运行的应用。 前提下载安装Docker Desktop 安装 VS Code Remote-WSL 扩展：使你能够在 VS Code 中打开在 WSL 上运行的 Linux 项目（无需担心路径问题、二进制兼容性或其他跨 OS 的难题）。 安装 VS code Remote-Containers 扩展：使你能够打开容器内的项目文件夹或存储库，并利用 Visual Studio Code 的完整功能集在容器中执行开发工作。 安装 VS Code Docker 扩展。 添加了从 VS Code 内生成、管理和部署容器化应用程序的功能。 （需要 Remote-Container 扩展才能实际使用容器作为开发环境。） 更换国内镜像源Docker中国区官方 “https://registry.docker-cn.com\"网易 “http://hub-mirror.c.163.com\" （这个还挺快的）ustc “https://docker.mirrors.ustc.edu.cn\"阿里云 “https://kfwkfulq.mirror.aliyuncs.com\" linux下修改 /etc/docker/daemon.json 文件，执行命令：vi /etc/docker/daemon.json 1234567891011{ \"registry-mirrors\": [\"https://registry.docker-cn.com\", \"http://hub-mirror.c.163.com\" , \"https://kfwkfulq.mirror.aliyuncs.com\" ]} 1service docker restart #重启Docker 创建容器1.在 VS Code 中，选择 终端 &gt; 新终端。 2.在终端窗口或 Bash 窗口中运行以下命令。docker run -dp 80:80 docker/getting-started参数 -d 在后台以分离模式运行容器。 -p 80:80 将主机的端口80映射到容器中的端口80。 docker/getting-started 指定要使用的映像。 3.在 VS Code 中，选择左侧的 docker 图标以查看 docker 扩展。 制作镜像制作docker镜像（image），最主要的是编写Dockerfile文件(一种基于文本的说明脚本) 需要在项目根目录创建Dockerfile文件 12345678FROM golang:alpine RUN mkdir /filesCOPY firstDockerImage.go /filesWORKDIR /filesRUN go build -o /files/firstImage firstDockerImage.goENTRYPOINT [\"/files/firstImage\"] 第1行：FROM 说明将要使用的基础镜像来自：golang:alpine （go语言alpine标签的镜像，alpine是阿尔卑斯，一种Linux系统，非常小） 第3行：在Docker镜像中创建一个新目录.【run 开始的命令是在镜像中操作】 第4行：将当前用户目录中的文件 firstDockerImage.go复制到镜像中的 /files目录下 【COPY是从用户复制到镜像】 第5行：修改Docker镜像的当前目录 第6行：run命令，依然是在镜像中执行go build命令，生成firstImage可执行程序。 第7行：指定运行镜像时，将要执行的【镜像中】程序的路径。 在文件资源管理器的 VS Code 中，右键单击 Dockerfile ，然后选择 “生成映像”。 上传到仓库1、使用docker login命令登录docker hub账户 输入自己的用户名和密码。 2、使用docker tag命令给镜像打标签 docker tag image:tag “user/repo:tag” 3、使用docker push命令上传镜像到docker hub docker push “user/repo:tag” docker安装实例安装mysql1234567891011121314151617docker pull mysql:latest #拉取 MySQL官方的最新版本的镜像 docker images #查看本地镜像#启动容器docker run --name mysql01 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest\\ --restart=unless-stopped\\ --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_unicode_ci #–-name mysql 容器名#-p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。#MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。#-d 后台运行#--restart=unless-stopped： docker启动的时候随之启动docker ps -a #查看是否启动成功 进入mysql容器内部1234567891011#进入mysql容器内部docker exec -it mysql01 bashmysql -u root -p #登录mysqlALTER USER 'root'@'localhost' IDENTIFIED BY '123456';#添加远程登录用户CREATE USER 'liaozesong'@'%' IDENTIFIED WITH mysql_native_password BY '123456';GRANT ALL PRIVILEGES ON *.* TO 'liaozesong'@'%';exit #退出mysql Docker 安装 UbuntuDocker 安装 CentosDocker 安装 NginxDocker 安装 Node.jsDocker 安装 PHPDocker 安装 TomcatDocker 安装 PythonDocker 安装 RedisDocker 安装 MongoDBDocker 安装 Apache安装RabbitMQ的Docker环境1234docker pull rabbitmq:3.7-managementdocker run -d --name e3-mall-rabbitmq -p 5672:5672 -p 15672:15672 --hostname e3-mall-rabbitmq -e RABBITMQ_DEFAULT_VHOST=mq_vhost -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -e TZ=Asia/Shanghai rabbitmq:3.7-management","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"容器","slug":"容器","permalink":"https://wenkex.gitee.io/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"各平台软件分享","slug":"各平台软件分享","date":"2022-01-04T10:10:17.000Z","updated":"2022-01-04T10:10:17.000Z","comments":true,"path":"2022/010422249.html","link":"","permalink":"https://wenkex.gitee.io/2022/010422249.html","excerpt":"","text":"多平台软件spacedesk将安卓，ios屏幕变为window拓展屏 海阔视界安卓下载最新版软件地址如下https://haikuo.lanzoux.com/u/GoldRiver 备用地址： https://haikuo.lanzoui.com/u/GoldRiver 如果上面的地址都不可用，可以在公众号(新方圆小棉袄)对话框回复“最新版”这几个字获取新版下载地址。 桌面版airhttps://www.123pan.com/s/fajA-meLQh 规则合集 1海阔视界，空气支持规则合集￥home_rule_url￥https://cdn.jsdelivr.net/gh/Lingyan000/share@main/air-rule-share clashgithub下载地址汉化 telegramhttps://telegram.org/ 汉化Telegram的具体方法是在浏览器的网址输入框里输入这个网址：”t.me/zh_CN“，打开页面后，点击”VIEW CHANNEL 隐藏自己的电话号码Telegram注册要使用电话号码，如果设置不当，你电报账号的电话号码可能被别人看到，如果你用国内手机注册，那么如果有关部门能查到你的电话号码，你也就完全暴露了。为防止这种情况，你可以在“隐私和安全”（Privacy and Security）的设置里把你的电话号码设置成完全不可见（或仅联系人可见），并把“谁能通过电话号码找到我”设成我的联系人，而不是所有人。 如果有海外的电话号码（包括虚拟号码如Google Voice等），尽量使用海外号码注册Telegram TG中文包TG语言包，点击即可使用。╍简体中文版本一（@Zh_CN 版）https://t.me/setlanguage/classic-zh-cn 版本二（聪聪版）https://t.me/setlanguage/zhcncc 版本三 （官方 beta 版）https://t.me/setlanguage/zh-hans-beta 繁体中文 (台湾)版本一：https://t.me/setlanguage/zh-hant-beta版本二：https://t.me/setlanguage/taiwan 繁体中文 (香港)版本一：https://t.me/setlanguage/hongkong 频道推荐电报群集合@hao1234bot 【超级索引】：Telegram上的Hao123，频道大全，也有个频道，是发送关键词，然后BOT提供关键词相关群组的机器人。可以拉到群组使用。 @zh_secretary_bot 【TGX-频道秘书】：TGX-索引公告板 @zh_secretary 的群组频道登记机器人，优点：和【TGCN-群组索引计划】差不多，又有可以看群组频道推荐的地方了，缺点：不能通过关键词查找 自定义代理作用：这样就不用打开clash的系统代理也能使用电报设置-高级-网络代理-自定义代理 服务器地址：127.0.0.1 代表本机ip端口：7890 clash默认端口 window软件Alist自建网盘管理https://alist-doc.nn.ci/docs/intro 微软文本转语音助手https://xiaomianao.lanzoum.com/iWOrz05eml1e支持云希在内的17种人声语音风格，保存格式就是mp3文件，非常方便点击鼠标右键还有翻译、敏感词替换、排版优化，OCR文字提取等功能 蓝叠安卓模拟器bluestacks5国际版，与hyper-v共存开启”root”安装目录下BlueStacks_nxt\\bluestacks.conf文件中找到bst.feature.rooting=”0”，改为1。然后重启模拟器，在设置中的设备开启root RSS订阅器下载github RSS订阅[好工具周刊订阅]：https://discuss-cn.bestxtools.com/t/weekly 聚客盒子订阅源：https://jukebox.pipecraft.net/atom/discussions 重复文件查找duplicate file finder 4 pc是一款完全免费的重复文件查找清理工具，这种重复文件查找并不是简单的通过文件名查找，还会根据文件内容本身进行比对，算法非常牛。 https://www.seeksunslowly.com/tss-files-mirror/duplicate-file-finder-free.exe power automate直接在微软商店安装 任意门它可以把电脑上的文件夹或者文件直接映射到公网访问，下载软件双击exe文件就能运行这里映射文件下载速度就取决于你的电脑上传最大速度，文件大小也完全没有限制下载地址https://pan.quark.cn/s/c7e3ca13b73e 备用地址：https://xiaomianao.lanzoum.com/i2HKw022tumb 伪pandownload伪pandownload官网：http://pandownload.net/index.htmlpandownload 一个百度网盘的不限速下载方案：原理简析：百度网盘移动端对.doc(x).ppt(x).pdf等之类的文件会有个预览模式，在预览模式中加载文件到本地是满速的。方法：可运用该原理，将文件重命名并添加上述后缀，点击文件即可进入预览模式，待文件下载完成后再将添加的后缀名删除掉，即可享受原文件。（还没试过） everything本地快速搜索https://www.voidtools.com/zh-cn/ uTools是一个极简、插件化的现代桌面软件，通过自由选配丰富的插件，打造得心应手的工具集合。通过快捷键（默认 alt + space ）就可以快速呼出这个搜索框。你可以往输入框内粘贴文本、图片、截图、文件、文件夹等等，唤出超级面板即可使用插件 插件推荐图床图床管理工具 程序员手册内置了十多个实用离线的中文文档。文档包括Linux、php、Python、Js等，还可以根据需要添加自己的文档，启用需要的文档。 Ctool开发者常用功能 本地搜索 搭配everything食用 批量重命名 在线流程图 Diagram 快速跳转至drawio，用于流程图绘制。 知悉思维导图 一个免费的思维导图插件，用于快速启动知犀思维导图网页，账号和uTools同步。主要是启动方便，而且还免费，市场上还有许多共享的资源。 快捷命令 插件介绍：快速打开软件，网站，运行shell命令等。我个人认为最牛x的还是直接运行代码，几乎支持所有的开发语言，程序员必备，有时候想调试一下代码片段，这个功能最方便了。可以去分享中心安装别人分享的快捷命名，有种逛油猴市场的感觉。 自动化助手 和上文快捷命令相似，只不过这个插件提供了其它实用的功能：图片去背景（removebg），图片一键上传到图床（目前支持路过图床和ＳＭ图床） Excalidraw 在线绘图白板 在线绘图工具，漫画风格非常nice。非常适合用于绘制手稿和灵感！ tinypng压缩图片使用tinypng压缩图片，支持批量操作，鼠标选中，右键快捷操作。 图片聊天 将文字转换为图片 Caesium参考Caesium是一款开源免费的无损压缩工具，它能够在保证图像质量的前提下，最大化压缩图像大小，节省存储空间。 Caesium目前支持Windows和macOS系统，因此，无论你是Windows用户还是macOS用户，都可以体验到它的强大。 Caesium的使用非常简单，直接打开要压缩的图片，选择输出文件夹即可，它支持单幅图压缩，也支持批量压缩。 scrcpy投屏Github地址 使用手机数据线连接电脑后，开启usb调试，自动连接 鼠标右键是返回 要想卸载scrcpy,先在目录下进入cmd,输入adb kill-server,再删除整个scrcpy文件即可 adb功能异常，重启adb（1）把adb服务杀死：adb kill-server（2）重启adb服务：adb reconnect OOAPB通过这个应用程序可以卸载在Windows10/11上预装的应用程序，应用无需安装，个人使用完全免费https://www.oo-software.com/en/ooappbuster 大学出题2022优势：1.编辑题库，2.加入题库，3.生成试卷，4.自动生成答案，5.生成word，6.一键打印。解锁新增试题，修改试题功能，比如你可以新增1000个题目，然后出5个题，系统会自动抽选题目，带答案方便老师改卷。这是目前能找到的比较方便很好的题库软件了，而且是2022新版的。适合：企业内训、小学、初中、高中、大学、培训机构、职业院校等老师的出题工作，由于是独立提取的，无在线题库功能，你们单位找一个专门电脑，所有老师都在里面增加题库内容，然后可以共享题库。非常方便，这是目前能找到的最好的出题软件了！ 可以无上限增加新题 链接：https://pan.baidu.com/s/1MhMUVJCm_T9apOQj8YKDPw提取码：52pj WxDatViewer是一款非常好用的微信dat图片批量解密、查看、整理工具 https://pan.lanzoui.com/b0405repg dism++是一款非常好用的系统清理和维护工具，使用它可以更好的精简系统功能：空间清理系统启动项管理系统备份和还原、系统激活、引导修复、春哥附体系统优化里面可以很方便的开启和关闭系统的种种功能驱动管理，可以选择相应的驱动然后选择导出或者添加驱动。 数据恢复WinFR界面版支持在Win/1110、NTFS、FAT、exFAT、ReFS 下从 SSD/HDD/USB/存储卡中恢复丢失的文件。文件手滑意外删除、磁盘格式化、磁盘损坏、中病毒等导致的文件丢失都可以使用这款工具尝试恢复。https://maxiaobang.lanzoup.com/iTnW5yztejg ApowerRecoverhttps://mp.weixin.qq.com/s/W_DHyZFt9j13VuLns8X4ew 安装后，将Crack文件夹中的文件复制到软件安装目录中，即可免费使用了蓝奏云下载：https://idege.lanzouw.com/i6M2Nylj5qf window包管理器都不好用 Chocolatey官方文档 123456789101112131415161718#安装ChocolateyGUI图形化的界面choco install chocolateygui #安装之后输入 chocolateygui 打开图形界面安装你想安装的软件即可choco upgrade chocolateychoco -h # 查看帮助choco &lt;command&gt; -h #查看相应命令的帮助choco install &lt;package name&gt; #安装软件包choco search &lt;keyword&gt; #搜索软件包，会列出跟关键字相关的所有软件包choco upgrade &lt;package name&gt; #升级软件包choco uninstall &lt;package name&gt; #卸载软件包choco list --local-only #查看本地安装的软件包choco list -l &gt; D://chocolatey.txt #软件列表备份 ScoopScoop 默认安装位置C:\\User\\Your Username\\scoop，如果想要更改安装位置，比如D:\\Scoop，可以在安装之前，先运行：$env:SCOOP=’D:\\Scoop’[Environment]::SetEnvironmentVariable(‘SCOOP’, $env:SCOOP, ‘User’) scoop export &gt; scoop.txt #导出软件列表 wingetappadb -d shell pm grant com.fooview.android.fooview android.permission.READ_LOGS FV 悬浮球-fooView拖动悬浮球到合适位置，等待红十字光标变黄，就可以开启「智能 OCR 文字识别+智能翻译+智能搜索」等功能。FV 悬浮球在手机上也有快捷启动图标，可以直接打开，能够看到很多便捷访问入口。FV 悬浮球支持用户自己编写并向社区中上传代码脚本，比如“强力跳广告”、“自动跳过启动广告”等等。 集影工具箱集影工具箱目前多达 20 种功能，包括视频压缩、图片压缩、视频转码、音频提取、移除音频、视频倍速、音视频合并、视频转 GIF、视频倒放、图片转 GIF 或者 mp4、m3u8 视频录制、音视频合并等功能。 开源阅读看小说 项目：https://github.com/gedoor/legado教程：https://www.yuque.com/legado/wiki书源：http://alanskycn.gitee.io/vip/书源制作教程 Xposed 框架虚拟引擎 · BlackBox黑盒BlackBox，是一款虚拟引擎，可以在Android上克隆、运行虚拟应用，拥有免安装运行能力。免 root 自带 Xposed 模块https://github.com/FBlackBox/BlackBoxPs：类似太极框架，可以虚拟定位，微X模块等功能 太极太极框架：https://taichi.cool/zh/ 关注 虚拟框架微信公众号即可发现全部内容 太极是一个无需Root，无需解释Bootloader，也不需要刷机就能使用 Xposed 模块的一个APP。太极拥有无需刷机、无需解锁、使用简单的优点，支持目前大部分xposed模块，该应用搭配各种xpose模块使用时，可以让你的应用程序拥有强大的功能。 太极v9.0.1下载链接 模块下载最全模块下载模块更新 3000Xposed [wx密友]http://dl.dimensionalzone.com/f/19604958-571565583-1e467c [colorqq2]http://dl.dimensionalzone.com/f/19604958-571576448-2f650f [指纹支付]http://dl.dimensionalzone.com/f/19604958-571576615-0048ee [killergram]http://dl.dimensionalzone.com/f/19604958-571577088-64b8c1 [QAuxiliary]http://dl.dimensionalzone.com/f/19604958-571578027-201ba1 [TSBattery]http://dl.dimensionalzone.com/f/19604958-571596194-1f2f5c [xmitools]http://dl.dimensionalzone.com/f/19604958-571603494-0ed2e4 [验证码提取器]http://dl.dimensionalzone.com/f/19604958-571605865-de6041 [叼毛]http://dl.dimensionalzone.com/f/19604958-571606444-be6ef9 [哔哩漫游]http://dl.dimensionalzone.com/f/19604958-571621885-eb978f [大圣净化]http://dl.dimensionalzone.com/f/19604958-571622398-a0796a [wx群消息助手]http://dl.dimensionalzone.com/f/19604958-571622999-f93fa2 [微博猪手]http://dl.dimensionalzone.com/f/19604958-571625557-1c357b [自动记账]http://dl.dimensionalzone.com/f/19604958-571627029-83a724 [联壁模块]http://dl.dimensionalzone.com/f/19604958-571627034-4e7483 [知了]http://dl.dimensionalzone.com/f/19604958-571627042-307820 [抖音伴侣]http://dl.dimensionalzone.com/f/19604958-571627064-37efef mt管理器https://www.mianshigee.com/tutorial/mt-manual/practice.md AidLuxhttps://www.aidlux.com/ AidLux平台全面覆盖手机、边缘端、终端云等，并且打通手机、电脑、平板、电视、工业自动化控制、机器人成一个统一的平台，实现跨终端无缝协同体验，并且该平台能使用全部安卓应用、Arm环境下的Linux应用，对于智能硬件开发者，不用再面对硬件的复杂性，AI环境的多样性，通过AidLux的智能AI加速模块，实现CPU、GPU、NPU和DSP多种方式的AI加速。 软件特色 各种机器人套件：ROS，PCL点云，Eigen，Protobuf和G2o等多种工具 支持多种开发语言：C/C++，Python,Java,JavaScript，Ruby，PHP，Go，Shell等 丰富Linux软件，AidCode，Git，Mysql，Hadoop，Nigix，Apache，Vim，Ssh，Vscode，Jupyter，积木编程等 扩展性好：内置了极简的外设极速互连模块，通过USB和网络等方式控制Arduino、机械臂、机器人、高清摄像机等 集成主流AI框架(Caffe、Mxnet、Keras、Pytorch、Tensorflow、Ncnn、MindSpore、PaddlePaddle、TNN、Opencv)，无需配置，直接使用 内置丰富的AI案例：人脸识别、人脸关键点识别、肢体识别、手势识别、头发识别、物体分类、物体跟踪、3D检测-、身体交换、人体抠图等 主研发AI智能加速模块，支持CPU+GPU+NPU+DSP加速智能加速，自动适配主流深度学习模型格式，无需格式转换即可自动加速和Forward ……………………………………………… 下载方式: 1.手机各大应用商店搜索AidLux下载 2.百度网盘: https://pan.baidu.com/s/1QYDvCKSl_H-B6YVCqdf8Qg?pwd=1v5y 提取码:1v5y 虚拟机Vmos pro手机虚拟机使用用mt管理器查看虚拟机里的文件 两仪原文 一个免 ROOT 的 Android 系统级容器 【下载地址】 百度网盘: https://pan.baidu.com/s/1tRFnXwc2An4pLNn0gmNvew?pwd=anlu提取码:anlu 微云:https://share.weiyun.com/3vUDEtdN 天翼:https://cloud.189.cn/t/N77Vn2Eb2YZv 迅雷:https://pan.xunlei.com/s/VMtzo7gpJ2nEJFrH-MTa9HtNA1 提取码：z2za SD Maid支持卸载残留扫描、系统/应用缓存清理、文件管理、应用管理、提取安装包、重复文件扫描、查看存储信息等。 ZArchiver安卓上最强的压缩/解压缩应用，有这一个就够了。基本上我们能用到的所有格式压缩包都可以处理。支持带密码的压缩包、分卷解压、免解压预览、自定义界面、文件管理等。 图叨叨宫格切图、模板拼图、以图搜图、电影台词、图片水印、图片打码、压缩裁剪、网页截图、动图制作、图片边框、图文卡片、手持弹幕等。 而且无广告、无后台，相当好用。 便捷下载一款万能手机下载器，简单方便。只要把链接粘贴进去，就可以自动解析下载图片、视频、音频、文档。 还支持音频提取、视频压缩、一键转换网页为 PDF 等。 浏览器kiwi brower一款基于Chromium核心的手机浏览器，强大的可扩展性让你轻松安装chrome应用商店里的扩展，真正支持Chrome电脑版插件 Via浏览器[下载]https://viayoo.com/zh-cn/ 参考：https://mp.weixin.qq.com/s/aUBBfdWrzXReW8DRmQ24sA启动秒开，没有杂七杂八的附加功能会自主学习的搜索引擎：Magi：https://magi.com/search?q=via相关插件：http://via-app.cn广告过滤1：https://cats-team.coding.net/p/adguard/d/AdRules/git/raw/main/adguard.txt广告过滤2：https://cats-team.coding.net/p/adguard/d/AdRules/git/raw/main/AdKillRules.txt&nbsp;广告过滤3：https://cdn.jsdelivr.net/gh/DoingDog/xXKiller@main/w.txt&nbsp; 李跳跳v1.75原文 【软件链接】 https://wwn.lanzoul.com/iKcrtywtuhc 密码:3m3m AppMgr Pro III5.35原文【免root】需要开启无障碍隐藏应用: 允许您隐藏系统（内置）应用，让隐藏的应用从你的桌面程序列表中消失不见。 冻结应用: 允许您冻结应用，被冻结的应用将不会被启动、执行或使用任何 CPU 或存储，自然也不会消耗任何电力。 应用管理: 可以帮助您管理所安装的应用，例如批次卸载应用，批次移动应用或分享你安装的应用给朋友等等。【下载地址】https://rtkcxzh.lanzouw.com/i8YZSzu9psh Android开发工具箱安卓开发助手它能够用来反编译其他应用、查看其他应用布局和控件信息、快速查看 Activity 历史记录、查看其他应用 Manifest、查看最近使用和最近安装的应用详细信息、提取任何应用 Apk 和 So 文件、调试 【下载链接】：https://wwn.lanzoul.com/igSpq008kxwj【备用链接】：https://wwn.lanzoux.com/igSpq008kxwj 科学https://www.alpacadisk.com/shared/AKYTwnwK5k1fir3V 安卓玩机各种玩机地址/工具/命令汇总http://wanji.jamcz.com/Android SDK（ADB和Fastboot电脑端工具）https://developer.android.google.cn/sADB/Fastboot驱动https://cz-jam.lanzouj.com/iZICY02v2k8jTWRPhttps://twrp.me/Magiskhttps://github.com/topjohnwu/Magisk 小米解锁工具https://www.miui.com/unlock/index.html小米ROM下载https://xiaomirom.com/series/小米刷机工具https://cdn.alsgp0.fds.api.mi-img.com一加ROM下载https://www.oneplus.com/cn/support/so三星刷机工具https://odindownload.com/三星ROM下载https://www.sammobile.com/firmwares/魅族ROOT链接https://mroot.flyme.cn/OPPO解锁https://www.oppo.cn/thread-397164526-1OPPO ROMhttps://www.coloros.com/romRealme解锁https://www.realmebbs.com/post-detailRealme刷机工具https://www.realmebbs.com/post-detailRealme ROMhttps://www.realme.com/support/softwa索尼解锁https://developer.sony.com/develop/op索尼ROMhttps://xperifirm.com/MOTO解锁https://motorola-global-portal.custheMOTO ROMhttps://mirrors.lolinet.com/firmware/ payload-dumper解包工具https://mrzzoxo.lanzouw.com/iR65zpaueyd酷安（玩机社区）https://www.coolapk.com/XDA（海外玩机论坛）https://forum.xda-developers.com/ shizukuhttps://sspai.com/post/73294强制分屏vivo手机有些应用无法分屏。【开发者模式】并点击进入；下拉页面，将【强制将活动设为可调整大小】开关打开；重启手机，重启后应用就支持强制分屏了。设置完后。先进入不能分屏的界面，然后上拉进入任务界面，点击另一个想要分屏应用的分屏按钮 LADB使用adb命令，必须开启无线调试模式 adb命令adb shell pm grant 应用包名 android.permission.WRITE_SECURE_SETTINGS 应用无障碍自启权限 黑域iqooneo5无法使用 小黄鸟抓包【下载地址】 https://zhusunjia.lanzouq.com/iYetI031in8j 证书:https://zhusunjia.lanzouq.com/ieIDD03cdqje iosTuneProiOS 平台免费听歌 app，曲库很大，一般歌都能听，不支持下载音乐。https://apps.apple.com/cn/app/tunepro-music/id12482625083 苹果快捷指令分享网站https://routinehub.co/相关链接：https://www.rcuts.com/https://applefans.today/category/applefans-classroom/apple-shortcuts/ Userscripts for Safarihttps://www.appinn.com/userscripts-for-safari/Userscripts 就是可以让海量的油猴脚本在 Safari 上运行的脚本管理器，和 Tampermonkey 是一个功能，只不过，它可以在 iPhone 上使用，就很香了。 由于 Userscripts 属于标准的 Safari 扩展，所以在 App Store 安装（Mac/iPhone/iPad）之后，需要前往 Safari 设置中开启扩展，具体路径是： iPhone 系统设置 &gt; Safari 浏览器 &gt; 扩展 &gt; Userscripts： 注意除了打开 Userscripts 之外，在里面的设置中，还需要允许所有网站。注意这里青小蛙尝试过“询问”，但并不成功，所以设置为了允许，如果你有安全顾虑，请谨慎操作。 浏览器插件油猴脚本网页文章转PDF脚本名称：网页限制解除(改)作用：解除网页复制的限制 脚本名称：知乎增强作用：让电脑浏览知乎的时候界面更实用 1、Userscript+一款脚本推荐利器，能够自动帮我们寻找适用于当前网站的所有脚本。AC-baidu-重定向优化去广告、绕过搜索引擎的重定向、自定义网址拦截、添加站点图标、优化搜索结果排版、自动翻页……searchEngineJump 搜索引擎快捷跳转在搜索引擎的输入框下面添加一行快捷菜单。能够快捷地在多个搜索引擎和网站之间进行跳转。支持自定义编辑跳转网站。5、Search By Image以图搜图脚本，内置了 12 个图片搜索引擎， 国内可下载安装Chrome扩展的方法https://www.gugeapps.net/https://www.extfans.com/https://huajiakeji.com/https://www.cnplugins.com/https://www.crx4chrome.com/https://fnd.io/#/https://chrome.zzzmh.cn/#/indexhttps://www.chromefk.com/https://www.yuque.com/eureka007https://crxdl.com/http://blandlifedev.blogspot.com/https://marketplace.visualstudio.com/https://www.chajian5.com/https://173app.com/chrome-exthttps://crxdl.com/https://chrome.zzzmh.cn/#/indexhttps://www.extfans.com/https://www.chromefor.com/http://yurl.sinaapp.com/crx2.php Chrome扩展安装方法1.直接把crx文件拖进扩展管理中心如果顺利，你直接把这个直接拖进 Chrome 扩展程序页面就能安装了2.不过有些时候，你可能会遇到安装 crx 文件报错 这样的话，就用另外一个办法： 在你的文件夹找到这个 crx 文件，确保你打开了文件管理器中的查看「文件扩展名」功能是勾上的 然后对你刚刚下载到的 crx 文件进行重命名，把扩展名改为 zip 然后把这个压缩包解压到一个你不会删除的位置！ 打开 Chrome 扩展程序页面的「开发者模式」 然后「加载已解压的扩展程序」 二管家Chrome 扩展管理工具功能1.根据规则自动开关扩展2.管理扩展3.根据网站推荐扩展4.快速提取CRX 同步书签floccus[地址] https://chrome.google.com/webstore/detail/floccus/fnaicdffflnofjppbagibeoednhnbjhg?utm_source=chrome-ntp-icon[开源地址：] https://github.com/marcelklehr/floccus/[参考教程：] http://chromecj.com/accessibility/2019-07/2622.html 移动的设置和桌面端基本是一样的。但是要注意，教程中的目录设置，桌面端可以选择根，但是移动端不能选择根，要选择移动设备书签。否则无法同步。 WebDAV ：目前支持 「坚果云、nextcloud / owncloud，box」 等 WebDAV 服务器同步 BookmarkHub跨浏览器同步书签它使用 GitHub 的 Gist 记录来存储浏览器的书签，可以放心安全的使用。 获取Github Token登录Github选择“设置-开发者设置-生成新token”，这里记得勾选Gist，然后点击“生成token”即可。 获取Gist ID这里new gist 进入对应的网页之后，输入描述、文件名、内容，这里可以随便输入即可，然后点击创建私有Gist。这时，在地址栏可以看到，URL的尾部就是Gist ID。从4a开始 配置插件点击插件的设置添加信息 Unpaywal当你浏览一篇学术文章时，Unpaywall会从2000万个免费合法的文献库里索引一个PDF副本，如果找到对应的文章，会在侧边出现一个绿色按钮，点击按钮就可以阅读或者下载全文。 WeChatSync（微信公众号同步助手）原文：https://mp.weixin.qq.com/s/oTMc_t_f65ITyTgy4Wdg9g是一款将微信文章同步到知乎， B站，微博，豆瓣，百家号， 简书， 头条号，搜狐号， 大鱼号， 一点资讯， Cnblog， CSDN， 51CTO， 掘金， 慕课网-手记， 开源中国，Typecho，WordPress等许多平台。 automa 自动化处理重复工作原文：https://mp.weixin.qq.com/s/ARID9OYRGcLLWGKT4BSd8QAutoma v0.5.1https://www.123pan.com/s/HQeA-EN1Sh Global Speed: 视频速度控制 支持0.25~16倍速的视频加速播放。而且它能用到的场景很多，比如某奇艺等平台的开头广告，直接点击16倍数，几秒就跳过去了。 ViolentMonkey 让你的Chrome可以使用油猴脚本（相比 Tampermonkey、GreaseMonkey 更为简洁方便） Nimbus一个网页版的多功能截图工具，提供了类似区域截屏、可滚动截屏、延迟截屏等等，花式截屏的小功能，甚至还可以帮你录制视频。 网站分享https://www.yuque.com/yashujs/bfug6u/dz9uiw 镜像Google搜索镜像http://d.6wl.cc/https://so.niostack.com/https://g.vovososo.com/https://google.icloudnative.io/https://ge1.azurewebsites.net/ 谷歌学术镜像https://nl.libre.men/scholarhttps://so.hiqq.com.cn/https://www.cn-ki.net/https://sc.panda321.com/ 好用的网站可以在 Codelf 网站上直接搜索，或安装 Codelf 插件变量命名神器 https://hyperbeam.com/注册好账号登录后，需要你创建一个房间，然后把房间链接分享出去就能和远在异地的女朋友交流了，支持文字、GIF、视频、语音通话。 设计改图鸭网站提供图片压缩、图片编辑、图片转文字等功能https://www.gaituya.com/用卷积神经网络把小而糊的图片进行放大，支持降噪处理，http://waifu2x.udp.jp/可快速将 JPG、PNG 等格式的图片快速转换为 SVG 矢量图https://www.visioncortex.org/vtracer/ 世界各地的朋友在这里分享他们的桌面布置灵感https://www.makerstations.io/为大家介绍创意相关工作者的工作桌面摆设情况https://www.workspaces.xyz/ 东京大学发布的一款工具 ：paper-digest可利用 AI 为每篇论文生成摘要，将阅读时间缩短为 3 分钟目前该工具仍处于初级阶段，生成的论文摘要仅供参考，深入研究最好还是阅读论文原稿。https://www.paper-digest.com/ 清华大学计算机系课程攻略https://rekcarc-tsc-uht.readthedocs.io/en/latest/https://github.com/PKUanonym/REKCARC-TSC-UHT spider-flow一个无需写代码的爬虫平台https://www.spiderflow.org/https://github.com/ssssssss-team/spider-flow Kmonad，一个自由改变键盘布局的软件可以让你无限地定制和扩展几乎所有键盘功能，包括改建、配置组合键等功能https://www.appinn.com/kmonad/ 用 Fruition + Notion 搭建个人网站DEMO: https://fruitionsite.com/GitHub: https://github.com/stephenou/fruitionsite作者主页： https://stephenou.com/教程：https://the-block.club/Fruition-Notion-e05ddf4392744a8a819a30ac7952520b 2021年【思维导图】盒子，C/C++，Golang，Linux，云原生，数据库，DPDK，音视频开发，TCP/IP，数据结构，计算机原理等https://github.com/0voice/learning_mind_map extract.pics？ Extract.pics 是一个易于使用的工具，允许您从任何公共网站提取、查看和下载图像。只需将网站的 URL 粘贴到输入字段中，然后单击“提取”即可开始该过程。 fffuel：设设设计用的小工具集合 官网 https://fffuel.co/ fffuel 是一个「即将推出」Html 模板的集合网站。除了网页模板，还提供了一些在网页设计中会使用到的工具 ssshape https://fffuel.co/ssshape/ ：矢量形状生成器在画布上添加几个点，点击 ssshape，会自动闭合所有点并对其形状进行平滑处理，最终得到一个边缘平滑的 SVG 形状 llline https://fffuel.co/llline/ ：矢量线段生成器在画布上添加几个点，点击生成后便能得到一条光滑的曲线，然后你可以旋转角度、改变它的颜色以及线段的形态 bbburst https://fffuel.co/bbburst/ ：图形散落分布以往想要制作一个「图形散落」风格的背景图，大多是通过喷枪或逐个逐个放置而成，过程比较繁琐。bbburst 可以帮你在预设的几个图形中，自动生成一张「图形散落」风格的图片 nnnoise https://fffuel.co/nnnoise/ ：「杂色」纹理生成器利用 nnnoise，可以生成一些「杂色」纹理，搭配上你想要的风格，或许别有一番滋味 dddoodle https://fffuel.co/dddoodle/ ：「极其」手绘风格的插图dddoodle 是一套手绘的 doodle 插图，其中有线段、箭头、圆形、星星以及一些有趣的形状，均为 CC 协议 ✅ rrready https://fffuel.co/rrready/ ：CSS 特性兼容列表不同浏览器支持不同 CSS 特性，这个问题长期困扰着开发者，利用 rrready 可以查看要使用到的 CSS 特性在不同浏览器中是否能够达成一致的效果 cccolor https://fffuel.co/cccolor ：选色器除了能够利用色盘、哈希值选取到想要的颜色，cccolor 还会为你生成匹配该颜色的相似色调、适合作为其阴影的颜色，及与其匹配的冷暖色调 ffflux https://fffuel.co/ffflux/ ：流体渐变生成器流体渐变带来的冲击力会比普通渐变色更强，色彩也更加丰富，或许能让你的设计更加活跃 lllook https://fffuel.co/lllook/ ：你想要什么表情lllook 是一套面部的简笔画表情包，比 emoji 丰富得多，也更加有趣 除了这些小工具，fffuel 的作者 Seb https://sebseb.co/ 还有其它有趣的项目，不妨去看看，其中我比较喜欢的是 muted https://muted.io/ 和 rrrelax https://rrrelax.app/ ，这里还有他整理的一些 设计小工具 https://cccreate.co/ 程序员学习网站原文 中国大学MOOC中国大学MOOC原名ICOURSE（爱课程），是教育R部和网易共同合作发布的一个互联网教育平台，旨在推动高等教学资源共享，让大家能免费享受许多985及TOP名校课程。绝大部分领域均有免费国家精品课程，资深教授授课！蹭网课必备！ 网址：https://www.icourse163.org/ 中国国家图书馆中国国家图书馆，收录绝对够全！只有你想不到，没有你搜不到，想要的资料应有尽有，还可以在线阅读~ 无论专业书籍还是人文书籍，均可搜索得到，还配有其ISBN账号，配合某盘资源可以进行pdf搜索下载！ 网址：http://www.nlc.cn/ B站B站不再是一个看番刷鬼畜的地方，学习课程越来越多，你想学的东西基本都可以在这里找到~ 网址：https://www.bilibili.com/ W3CW3School，一个全球最大的中文 Web 技术教程。在 W3School，你可以找到你所需要的所有的网站建设教程。从基础的 HTML 到 CSS，乃至进阶的 XML、SQL、JS、PHP 和 ASP.NET。 网址：https://www.w3school.com.cn/ 菜鸟教程和W3C性质差不多，都是提供各种基础编程教程，可以让你在短时间内实现从0到1的质的飞跃！ 网址：https://www.runoob.com/ MDNMDN Web Docs 站点提供有关开放 Web 技术的信息，包括用于 Web 站点和渐进式 Web 应用程序的 HTML、CSS 和 API。面向Web开发者的文档，权威教程。 网址：https://developer.mozilla.org/zh-CN/docs/Web 掘金掘金是一个帮助开发者成长的社区,是给开发者用的 Hacker News,给设计师用的 Designer News,和给产品经理用的 Medium。有不少技术大牛和极客们在输出优质干货。 网址：https://juejin.cn/ GithubGitHub 是世界上最大的代码托管平台。如果说 P***Hub 对于宅男来说是神一般的存在，那么 GitHub 对于程序员来说是永远滴神！ 网址：https://github.com/ 慕课网慕课网（IMOOC）是IT技能学习平台。慕课网(IMOOC)课程涉及JAVA、前端、Python、大数据等60类主流技术语言，覆盖了面试就业、职业成长、自我提升等需求场景，帮助用户实现从技能提升到岗位提升的能力闭环。 网址：https://www.imooc.com/ 张鑫旭的博客博客语言以简单明了著称，擅长深入挖掘css技巧及内部实现机制。 https://www.zhangxinxu.com/wordpress/ The Odin ProjectOdin 项目使有抱负的 Web 开发人员能够免费一起学习 网址：https://www.theodinproject.com/paths/foundations/courses/foundations angularJS学习资源合集一个 angularJS 资源大全 网址：https://angularjs.zeef.com/gianluca.arbezzano 30 seconds of code当你打开这个网站时，你会发下自己捡到宝了，这个网站分享了1084个有用的简短代码片段,你可以在30秒或更少时间中理解,满足开发者绝大多数开发需求 网址：https://www.30secondsofcode.org/ JS Tips这是一个分享 JavaScript 小技巧的网站,让读者提升撰写代码的能力.每天花不到 2 分鐘，你可以阅读到关于效能、习惯、技术、面试问题以及所有 JavaScript 相关知识 网址：https://www.jstips.co/zh_CN/javascript/ 如何跟上前端开发的最新前沿这是一个帮助前端学子们了解最新推出的工具, 最新的潮流以及开发流程的网站 网址：https://uptodate.frontendrescue.org/zh/ JS RunJSRUN.NET 一个极具活力的代码在线运行平台。有专业的HTML/CSS/JS在线调试工具，适用前端工程师的开发和学习。同时还有C语言、Java、PHP、Python等代码在线编译运行工具 网址：https://jsrun.net/ CodepenCodepen是一个完全免费的前端 Web 开发的在线代码编辑器、学习环境和社区，汇集了大量的优秀前端作品，很多大佬的作品都会上传到这里。 网址：https://codepen.io/ ES6 入门教程《ECMAScript 6 入门教程》一本由阮一峰老师撰写开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。这本书主要引导你进入 React 和 Webpack 世界。 网址：https://es6.ruanyifeng.com/ Stack OverflowStack Overflow 作为全球最大的技术问答网站，几乎没有你找不到的问题 网址：https://stackoverflow.com/ SegmentFaultSegmentFault 思否是中国领先的开发者技术社区。国内风靡的程序员社区，以技术问答、技术专栏、技术课程、技术资讯为核心的产品形态,为开发者提供纯粹、高质的技术交流平台。 网址：https://segmentfault.com/ LeetCodeLeetCode 是一个非常棒的OJ（Online Judge）平台，收录了许多互联网公司的算法题目，被称为刷题神器 网址：https://leetcode-cn.com/ LintCode这个网站可算是个面试的“作弊神器”吧，因为上面有很多国内外大厂面试真题，里面大厂面试真题还挺多的，而且会定期更新，跳槽前可以看一看~ 网址：https://www.lintcode.com/ 程序员一站式导航这个导航站提供了最精华有趣的内容，根据分类可以找到你所需要的站点、工具，能够节省不少时间~ 网址：https://cxy521.com/ 提高web前端开发效率的网站Animista地址：https://animista.net/Animista 是一个简单的 CSS 动画库网站。您可以测试和使用现成的 CSS 动画，也可以下载它们的代码。Web 开发人员一定要上的网站，这个对您提升开发效率非常有帮助。 Ray.so地址：https://ray.so/此网站可以将让您制作的精美图像进行源代码的分享。它支持几乎所有的编程语言格式。您可以设置背景、颜色、字体等。一定要试试这个网站。 FontAwesome地址：https://fontawesome.com/ 如果您在为您的项目寻找一些很棒的图标，您可以访问 FontAwesome 下载任何项目的免费图标。 Jsfiddle地址：http://jsfiddle/ Jsfiddle 是代码编辑器，您可以在其中通过实时预览测试 JavaScript、CSS、Html 代码。该网站是 Web 开发人员的便捷工具。 Unscreen地址：https://www.unscreen.com/ Unscreen 是一个帮助您去除视频背景的网站。它用于制作无背景视频。必须尝试该网站。 Dev Samples地址：https://www.devsamples.com/此网站是您可以自由复制粘贴到项目中的代码集合网站。该网站的重点是 Web 开发人员的源代码。Dev Samples 对新手开发人员来说很方便。 Readme.so 地址：https://readme.so/ Readme.so 是一个在线自述文件制作，可帮助开发人员为其项目创建自述文件。大多数开发人员使用readme.so为其 Github 项目创建自述文件。 ScreenShot.rock地址：https://screenshot.rocks/ Screenshot Rock 是一个可以创建漂亮的移动和浏览器屏幕截图的地方。您只需要上传任何屏幕截图，它就会为浏览器提供移动框架触摸功能。 Undesign地址：https://undesign.learn.uno/ Undesign 是设计工具、插图、开发人员和设计师的源代码、制造商资源等的免费集合。一定要试试这个网站。 Coolors地址：http://coolors/ Coolors 是我推荐的颜色组合网站。每次按“空格键”时，它都会生成新的颜色组合。 参考 服务器和网站在线测速工具http://ping.pehttps://www.ping.cn/站长工具https://ping.aizhan.com阿里云网站运维检测平台 写论文可以用到的网站 国家哲学社会科学文献中心： www.ncpssd.org现有中文期刊、外文期刊、古籍等资源，收录哲学社会科学相关领域文献共计10,000,000余条，提供有线阅读、全文下载等服务。 文津搜索： find.nlc.cn国家图书馆资源检索，汇聚了60多个资源库、近2亿条文献信息，可以查询包括图书、古文献、论文、期刊报纸、多媒体等在内的多种资料。 术语在线： www.termonline.cn一个可以查询专业术语的在线网站，非常权威，内容更新也很及时。 科塔学术： site.sciping.com学术导航网站，整理了许多论文搜索网站、学术工具、科研软件、期刊出版等，每一个都有细致的分类，并归纳了对应的网站。 Academic Phrasebank： www.phrasebank.manchester.ac.uk论文写作助手，这个网站主要提供论文各部分的模版，如介绍怎么写，总结怎么写，如何描述方法，报告细节等，对非英语母语作者非常有帮助。 iData： www.cn-ki.net一个知网镜像站，可以免费下载论文，知网比较新的没有，每天有免费下载限额。 SCI-Hub： sci-hub.com这个网站就不多介绍了，一个超棒的免费下载论文的网站，输入文献doi号即可搜索下载。 OALib： www.oalib.com目前收录了570万篇学术论文，涵盖多个领域，所有文章均可免费下载，是一个较为高效的论文查找网站。 研享网： www.academicshare.cn检索下载英文文献的利器，页面超级干净，支持关键词、题目、论文doi搜索。 Medsci： www.medsci.cn/sci期刊智能查询系统，支持模糊查询，每一个期刊还有对应的论坛。 Connected Papers： www.connectedpapers.com文献调研必备神器，它可以在线进行分析文献的引文信息，轻松了解某篇文献的引用和被引用关联，分析出文献的前世今生，方便我们对一篇文献或者某个领域进行调研。 近邻词汇检索： tool.mingdawoo.com可免费查找近似短语和相关术语，词穷的时候可以看看。 秘塔写作猫： xiezuocat.com可以校对中文字词错误、标点错误、语序错误、语法问题、同意混淆等，并给出修改建议，支持全文分析和智能排版，免费版基本上能满足日常需求。 Grammarly： www.grammarly.com英文语法错误查询好助手，可以安装为word插件，在你写作的时候就可以纠正你的语法错误了。 知犀思维导图： www.zhixi.com免费好用的论文大纲整理工具，可以借助这个工具做论文大纲。这个网站还提供许多思维导图模板，包括工作方法、考研考证的资料、管理方法、科普知识等方面的模板。 词云统计： cloud.niucodata.com在线中文词汇统计和分析工具，可以帮助用户分析一段话中的词性分类、词频统计并生成词云图。 Linggle： www.linggle.com提供英文常用语、搭配、近义词等检索，可以根据词性来推测完整搭配，还能帮助学习者分析出更准确的英文写作建议。 Netspeak： netspeak.org这个网站也是词汇，不过是用来查找你记不太清楚的词汇，比如congratulations，你不记得全部拼写了，你就可以在这个网站上来查一下。 Linguee： cn.linguee.com一个全能的在线多语言互译平台，提供24种语言的对应查询服务，而且还收集了数亿条译文例句，无论是日常领域的术语，还是专业难度偏大的词汇，在这里都能找到专业的翻译方式。 DocTranslator： www.onlinedoctranslator.com可免费在线翻译文档，支持109种不同语言文档任意转换，并保持排版不变。操作简单，直接上传文档就可以。 免费查重网站包括：万方免费查重（应届生免费一次）：chsi.wanfangtech.netPaperDay（标准版永久免费，旗舰版每日限免）：www.paperday.cn论文狗（每日免费一次）： www.lunwengo.netPaperYY（每日免费一次，11点多免费两次）：www.paperyy.comFreeCheck（每日免费一次）：www.freecheck.cnWritePass（每日1000个免费名额）：www.writepass.cn超星大雅（免费看相似度）：dsa.dayainfo.com百度学术（免费使用PaperTime一次）：xueshu.baidu.com/usercenter/papercheck 高效查重工具秘塔写作猫：写作改错和词语替换（需要注册）https://xiezuocat.com/#/火龙果写作：www.mypitaya.com 免费论文下载网站：广西壮族自治区图书馆：www.gxlib.org.cn国家哲学社会科学文献中心：www.ncpssd.org全国图书馆参考联盟：www.ucdrs.superlib.netOALib：www.oalib.com#论文 #查重 学习用CSDN：https://www.csdn.net/ TED（最优质的演讲）： https://www.ted.com/ 谷粉学术： https://gfsoso.99lb.net/scholar.html 大学资源网：http://www.dxzy163.com/ 简答题：http://www.jiandati.com/ 网易公开课：https://open.163.com/ted/ 网易云课堂：https://study.163.com/ 中国大学MOOC：www.icourse163.org 哔哩哔哩弹幕网：www.bilibili.com 我要自学网：www.51zxw.net 知乎：www.zhihu.com 学堂在线：www.xuetangx.com 爱课程：www.icourses.cn 猫咪论文：https://lunwen.im/ iData（论文搜索）：www.cn-ki.net 文泉考试：https://www.wqkaoshi.com 编程题库网(大厂最热题库列表) https://94tiku.com 找书籍用搬书匠 书栈网（极力推荐）：https://www.bookstack.cn/ 码农之家（计算机电子书下载）： www.xz577.com 鸠摩搜书：www.jiumodiary.com 云海电子图书馆：www.pdfbook.cn 周读（书籍搜索）：ireadweek.com 知轩藏书：http://www.zxcs.me/ 脚本之家电子书下载： https://www.jb51.net/books/ 搜书VIP-电子书搜索： http://www.soshuvip.com/all.html 书格（在线古籍图书馆）： https://new.shuge.org/ caj云阅读： http://cajviewer.cnki.net/cajcloud/ 必看网（人生必看的书籍）： https://www.biikan.com/ 冷知识 / 黑科技上班摸鱼必备（假装电脑系统升级）：http://fakeupdate.net/ PIECES 拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）： http://www.species-in-pieces.com/ 图片立体像素画： https://pissang.github.io/voxelize-image/ 福利单词（一个不太正经的背单词网站）： http://dict.ftqq.com 查无此人（刷新网站，展现一张AI 生成的人脸照片）： https://thispersondoesnotexist.com/ 在线制作地图图例：https://mapchart.net/ 创意光线绘画：http://weavesilk.com/ 星系观察：https://stellarium-web.org/ 煎蛋：http://jandan.net/ 渣男-说话的艺术：https://lovelive.tools/ 全历史：https://www.allhistory.com/ iData：https://www.cn-ki.net/ 术语在线：http://www.termonline.cn/ 写代码用GitHub：https://github.com/ 码云：https://gitee.com/ 源码之家：https://www.mycodes.net/ JSON to Dart： https://javiercbk.github.io/json_to_dart/ Json在线解析验证： https://www.json.cn/ 在线接口测试（Getman）： https://getman.cn/ 资源搜索用DogeDoge搜索引擎：www.dogedoge.com 秘迹搜索：https://mijisou.com/ 小白盘：https://www.xiaobaipan.com/ 云盘精灵（资源搜索）： www.yunpanjingling.com 虫部落（资源搜索）： www.chongbuluo.com 如风搜（资源搜索）： http://www.rufengso.net/ 爱扒：https://www.zyboe.com/ 各种小工具奶牛快传（在线传输文件利器）：cowtransfer.com 文叔叔（大文件传输，不限速）： https://www.wenshushu.cn/ 云端超级应用空间（PS，PPT，Excel，Ai）：https://uzer.me/ 香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）： https://www.xiangdang.net/ 二维码生成：https://cli.im/ 搜狗翻译：fanyi.sogou.com 熵数（图表制作，数据可视化）： https://dydata.io/appv2/##/pages/index/home 拷贝兔：https://cp.anyknew.com/ 图片无限变放大：http://bigjpg.com/zh 幕布（在线大纲笔记工具）：mubu.com 在线转换器（在线转换器转换任何测量单位）：https://zh.justcnw.com/ 调查问卷制作： https://www.wenjuan.com/ 果核剥壳（软件下载）： https://www.ghpym.com/ 软件下载：https://www.unyoo.com/ MSDN我告诉你（windows10系统镜像下载）：https://msdn.itellyou.cn/ 网站工具箱https://www.67tool.com/ https://tools.miku.ac/功能：收款码合并 导航页（工具集）世界各国网址大全： http://www.world68.com/ 小森林导航：http://www.xsldh6.com/ 简捷工具：http://www.shulijp.com/ NiceTool.net 好工具网： http://www.nicetool.net/ 现实君工具箱（综合型在线工具集成网站）：http://tool.uixsj.cn/ 蓝调网站：http://lcoc.top/ 偷渡鱼：https://touduyu.com/ 牛导航：http://www.ziliao6.com/ 小呆导航： https://www.webjike.com/index.html 简法主页：http://www.jianfast.com/ KIM主页：https://kim.plopco.com/ 聚BT：https://jubt.net/cn/index.html 精准云工具合集： https://jingzhunyun.com/ 兔2工具合集：https://www.tool2.cn/ 爱资料工具（在线实用工具集合）： www.toolnb.com 工具导航：https://hao.logosc.cn/ 音乐将加密的音乐文件转为可播放的 mp3 文件。目前支持网易云音乐 (.ncm) 、QQ 音乐 (.qmc, .mflac, .mgg) 、酷狗音乐 (.kgm) 、虾米音乐 (.xm) 、酷我音乐 (.kwm) 等格式。项目提供了网页版 浏览器扩展 Docker 和命令行版 等多种使用方式，所有转换都在本地进行，无需担心隐私问题。网页版：https://demo.unlock-music.dev/项目地址：https://github.com/unlock-music/unlock-music代码仓库：https://git.unlock-music.dev/um/web 看视频用阿木影视：https://www.aosk.online/ 电影推荐（分类别致）： http://www.mvcat.com APP影院：https://app.movie 去看TV：https://www.qukantv.net/ 动漫视频网：http://www.zzzfun.com/ 94神马电影网：http://www.9rmb.com/ NO视频官网：http://www.novipnoad.com/ 蓝光画质电影：http://www.languang.co/ 在线看剧：http://dy.27234.cn/ 大数据导航：http://hao.199it.com/ https://qzy998-1.ysgq.xyz/ 片库：https://www.mypianku.net 奈飞中文电影站：https://yanetflix.com 剧嗨：https://www.juhi.cc 555电影网：https://www.o8tv.com Tubitv：https://tubitv.com 片源：http://pianyuan.org/影视导航网站：http://www.549.tv/片吧 https://www.pianba.net/低端影视 https://ddrk.me/片库 https://www.pianku.li/七七看片 https://www.77kpp.com/旋风视频 https://miao101.com/体育直播：https://feisuzhibo.comBD影视分享 https://www.bd2020.com/一刻电影 http://www.yikedy.co/影视教程 https://www.yuque.com/eureka007/ziyuan/rnezaq VIP视频解析网站365t在線免費解析觀看系統http://vip.365tol.top/BL智能解析https://vip.bljiex.com/BL解析-Vip视频在线解析https://vip.bljiex.cc/TVB云播全网VIP视频解析：http://vip.tvyb10.com/Playm3u8解析-PC和手机全无广告!https://www.playm3u8.cn/jiexi.php?url=诺讯全网视频在线解析无广告https://www.nxflv.com/?url=天翼解析https://jsap.attakids.com/?url=kingtail智能解析 https://jx.kingtail.xyz/?url= 在线动漫网站汇总ZzzFun动漫 http://www.zzzfun.com/樱花动漫 http://www.yinghuacd.com/AGE动漫 https://www.agefans.vip/動畫線上看 https://anime1.me/嘀哩嘀哩 https://www.dilidili55.com/哈哩哈哩 http://halihali4.com/ 学设计用码力全开（产品/设计师/独立开发者的资源库）：https://www.maliquankai.com/designnav/ 免费音频素材：https://icons8.cn/music 新CG儿（视频素材模板，无水印+免费下载）： https://www.newcger.com/ Iconfont（阿里巴巴矢量图标库）： https://www.iconfont.cn/ 小图标下载：https://www.easyicon.net/ Flight Icon：https://www.flighticon.co/ 第一字体转换器：http://www.diyiziti.com/ doyoudosh（平面设计）： www.doyoudo.com 企业宣传视频在线制作：https://duomu.tv/ MAKE海报设计官网：http://maka.im/ 一键海报神器： https://www.logosc.cn/photo/utm_source=hao.logosc.cn&amp;utm_medium=referral 字由（字体设计）： http://www.hellofont.cn/ 查字体网站：https://fonts.safe.360.cn/ 爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）：http://www.aigei.com/ 在线视频剪辑： https://bilibili.clipchamp.com/editor 搞文档用即书（在线制作PPT）： https://www.keysuper.com/ PDF处理：https://smallpdf.com/cn PDF处理：https://www.ilovepdf.com/zh-cn PDF处理：https://www.pdfpai.com/ PDF处理：https://www.hipdf.cn/ 图片压缩，PDF处理： https://docsmall.com/ 腾讯文档（在线协作编辑和管理文档）： docs.qq.com ProcessOn（在线协作制作结构图）： www.processon.com iLovePDF（在线转换PDF利器）： www.ilovepdf.com PPT在线制作：https://www.woodo.cn/ PDF24工具（pdf处理工具）： https://tools.pdf24.org/en IMGBOT（在线图片处理）： www.imgbot.ai 福昕云编辑（在线编辑PDF）： edit.foxitcloud.cn TinyPNG（在线压缩图片）：tinypng.com UZER.ME（在线使用各种大应用，在线使用CAD，MATLAB，Office三件套 ）：uzer.me 优品PPT（模板下载）： http://www.ypppt.com/ 第一PPT（模板下载）： http://www.1ppt.com/xiazai/ 三顿PPT导航：sandunppt.com Excel函数表： https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188 图片图像处理去水印https://www.magiceraser.io/ 图片高清化https://bigjpg.com/ 壁纸wallhavenhttps://wallhaven.cc/ 极简壁纸https://bz.zzzmh.cn/index 电脑壁纸：http://lcoc.top/bizhi/ https://unsplash.com/ https://pixabay.com/ https://www.pexels.com/ https://visualhunt.com/ https://www.ssyer.com/ 彼岸图网：http://pic.netbian.com/ 极像素（超高清大图）： https://www.sigoo.com/ 免费版权图片搜索： https://www.logosc.cn/so/ 多功能图片网站：https://www.logosc.cn/so/ 牛牛TV：http://www.ziliao6.com/tv/ VideoFk解析视频： http://www.videofk.com/ 蓝调网站：http://lcoc.top/vip2.3/ 永久资源采集网： http://www.yongjiuzy1.com/ 临时邮箱注册时不想泄露自己邮箱时可用https://mail.td/zhhttps://mail.tm/zh/https://spambox.xyz/https://maildrop.cc/https://www.mohmal.com/zhhttp://24mail.chacuo.net/https://www.nowmymail.com/https://www.crazymailing.com/loginhttps://10minutemail.com/http://www.mytrashmail.com/https://www.clipmails.com/https://tempmail.altmails.com/https://mailpoof.com/zhhttps://www.gmailnator.com/https://www.disposablemail.com/https://www.mohmal.com/zhhttps://www.emailondeck.com/http://www.tempinbox.com/https://www.guerrillamail.com/https://dropmail.me/zh/https://www.moakt.com/https://mailsac.com/https://www.nowmymail.com/https://www.guerrillamail.com/zh/https://www.linshi-email.com/https://www.snapmail.cc/#/https://mail.mjj.edu.ge/https://www.20minutemail.com/#tophttp://24mail.chacuo.net/enushttps://www.8164.cc/#/emailList/allhttp://mailnesia.com/https://ihotmails.com/https://temp-mail.io/zh#临时邮箱 系统相关微PE工具箱目前极客圈中最推荐的Windows PE系统。微PE工具箱V2.2官网下载内有多种安装方式 1.安装到本地硬盘，可直接添加到开机启动项中，开机时可以选择进入PE系统，当本机Windows系统无法启动时，可以快速进入PE中进行维护，方便至极。 2.安装制作U盘启动工具 3.直接生成ISO镜像，配合Ventoy软件制作系统启动盘 2.内置实用工具箱 安装维护：主要有WIndows安装器、虚拟光驱、密码修改和注册表编辑器备份还原：主要是Ghost备份还原和一代神器分Dism++分区工具：主要是DiskGenius，这软件人尽皆知。文件工具：经典的Everything、7-zip压缩以及简单的看图软件Imagine硬件检测：主要是CPU-Z、SuperPI、以及HDTune硬盘检测。 Ventoy系统启动盘官网ventoy是一个国产开源的多系统U盘启动盘制作工具，无需反复格式化U盘，只需将各种iso镜像文件复制到U盘，即可实现多系统引导启动，无差异支持Legacy BIOS和UEFI模式， 不影响U盘性能，可正常使用U盘支持插件扩展启动过程中支持U盘设置写保护版本升级时数据不会丢失无需跟随操作系统升级而升级Ventoy 操作步骤1.官网下载地址 2.先插U盘，再启动.exe文件，点击安装（install）。然后它会反复强调数据安全，启动软件之后选好U盘（一般会自动选好），完成之后U盘便分成了三份。打开文件管理器里能看到的、最大的、空的分区，这就是用来存放数据的地方，就当是普通U盘用就好了，系统iso镜像就放这里。3.当设置U盘为第一启动顺序后，即可加载出Ventoy的菜单，键盘方向键选择对应的系统镜像即可开始安装系统了。4.有什么想安装的系统直接把镜像丢进去就可以，有好的PE系统比如上面的微PE也可以丢进去~这样你就有了一个多合一的超级多系统启动盘。 Edgeless打造一个功能强大专属自己的全能PE工具箱,可用来制作WinPE以及可启动U盘，Edgeless是一款国产半开源的PE工具，它不仅提供了一个纯净的Windows PE，同时引入了插件模式，通过工具你可自定义配置，例如软件、壁纸、图标、主题、脚本、驱动、库文件等，均可实现自定义，是打造个性化PE系统的超级工具。 系统镜像下载NEXT, ITELLYOUhttps://next.itellyou.cn/专注于Win7，当然也有win10https://www.newxitong.com/Latest10 | 获取最新的系统镜像https://latest10.win/HelloWindowshttps://hellowindows.cn/宋永志博客 - 有态度的封装爱好者http://www.songyongzhi.com/极简系统-最纯净的系统下载平台https://www.sysmini.com/MSDN - 山己几子木https://msdn.sjjzm.com/TechBenchhttps://tb.rg-adguard.net/public.php win10版本(msdn中) Windows 10家庭版（Windows 10 Home） Windows 10专业版（Windows 10 Pro） 在window 10 Insider Preview那一列 Windows 10企业版（Windows 10 Enterprise） Windows 10教育版（Windows 10 Education） Windows 10移动版（Windows 10 Mobile） Windows 10企业移动版（Windows 10 Mobile Enterprise） Windows 10 IoT Core（主要针对物联网设备） Win10各版本区别 win10版本区别 Consumer editions消费者版本包括：家庭版、教育版、专业版Business editionsVOL 商业版本包括：企业版、教育版、专业版 Win10家庭版，主要是面向消费者和个人PC用户的电脑系统版本，适合个人或者家庭电脑用户推荐。Win10专业版也是面向个人电脑用户，相比家庭版要稍微好些（WWW.PC841.COM 电脑百事网），并且Win10专业版还面向大屏平板电脑，笔记本、PC平板二合一变形本等桌面设备。Win10移动版，则主要面向小尺寸的触摸设备，主要针对智能手机、小屏平板电脑等移动设备。Win10企业版，主要是在专业版基础上，增加了专门给大中型企业的需求开发的高级功能，适合企业用户推荐。Win10教育版，主要基于企业版进行开发，专门为了符合学校教职工、管理人员、老师和学生的需求。Win10移动企业版，则主要面向使用智能手机和小尺寸平板的企业用户，提供最佳的操作体验。Win10物联网核心版，该版本主要面向低成本的物联网设备。 激活操作系统Qwins一键激活 ，运行前加入系统白名单。防误杀https://pan.baidu.com/s/1H3qAl-9OtXtHG9mdkk5p6A?pwd=h1qk 提取码：h1qk KMS 激活 Windows 系统https://kms.cx/https://other.ikxin.com/kmshttps://www.moerats.com/kms/https://kms.cangshui.net/ 其他相关https://www.yuque.com/eureka007/ziyuan/zdp3ny Ps：不建议使用大白菜、老毛桃、U 大师、电脑店等一些 HEU KMS激活https://52sharing.lanzout.com/imB79053g0za https://pan.baidu.com/s/1ENu-yrJ6QgZxjsG-u5peqw?pwd=626h 提取码：626h HEU KMS Activator 25,解压密码：landian.news HEU KMS Activator是一款简洁高效的全能激活工具，软件支持智能激活、KMS激活、数字激活、OEM激活等，适用所有Windows, Office版本，无需联网即可一键激活功能 1.智能激活：自动读取和识别当前系统和软件版本实现智能激活，对非专业用户来说无需手动选择具体版本。 2.重置功能：软件内置许可证重置功能可以在用户需要的情况下清理所有激活信息，即恢复到未激活的状态。 3.数字激活：软件支持数字许可证激活实现永久授权，此功能仅支持Windows 10+ 零售版不支持批量授权。 4.版本转换：如果你有需要的话还可以使用内置的转换功能对版本进行转换，包括零售版转换为批量授权等。 5.备份还原：内置备份还原工具可以将系统激活信息保存的目录备份，如有需要下次可以使用备份恢复激活。 6.自动续期：KMS激活有效期为180天，软件可以安装自动续期服务实现循环激活，从而达到永久激活目的。 Win10家庭版升级成专业版首先用360c盘搬家软件，转移大文件，然后用Dism软件备份系统镜像 最后用HEU软件更改win10版本信息为专业版 ，再上这个网站进行kms服务器激活果核剥壳KMS激活服务器 - 果核剥壳 (ghxi.com) 成功经验在下面网址找密钥，输入了专业工作站版密钥，然后重启电脑，再输入专业版密钥 https://mp.weixin.qq.com/s/Cpi41y4vh4IvHOKKCLDWvw 查看密钥情况：cmd slmgr.vbs -dlv 工具文章同步插件一键同步文章到多个内容平台，支持今日头条、WordPress、知乎、简书、掘金、CSDN、typecho各大平台，一次发布，多平台同步发布。解放个人生产力。 在线简历排版工具这是一个支持 Markdown 和富文本的在线简历排版工具，如下图所示，你可以通过 Markdown 语法或者富文本编辑的方式编辑一个美观的简历。 云策文档云策文档是一款开源知识管理工具。在线文档通过独立的知识库空间，结构化地组织在线协作文档，实现知识的积累与沉淀，促进知识的复用与流通。该项目基于 next.js、nest.js、MySQL 等技术栈。 https://www.yuque.com/eureka007/2022/irgz9n资源分享各种资源 26T夸克网盘资源免费分享2022最新影视、10T经典影视、23考研资料、幼儿资料、学而思幼儿到高中全套资料、音乐合集、游戏合集、相声小品春晚、破解软件、系统工具、电子书等等，持续更新中 「Java基础进阶 Docker入门+实战」链接：https://www.aliyundrive.com/s/uEVaArQnJzA「[上海交大Java初级编程基础]」链接：https://www.aliyundrive.com/s/boxD8mRug4h「10万字总结java面试题和答案.pdf」链接：https://www.aliyundrive.com/s/bvEKzav1kXN「SpringCloud微服务2021实战教程」链接：https://www.aliyundrive.com/s/1xN7jTTgk9Z「Web协议详解与抓包实战【完结】」链接：https://www.aliyundrive.com/s/pJmi3XWN7ou「小程序开发从入门到精通视频课」链接：https://www.aliyundrive.com/s/enbntr58oUJ「HarmonyOS 2.0鸿蒙应用开发实战教程」链接：https://www.aliyundrive.com/s/9CqJsMsCwkb「腾讯课堂.小程序从入门到精通」链接：https://www.aliyundrive.com/s/DMN9o1Ewd9K「imooc-微信小程序入门与实战」链接：https://www.aliyundrive.com/s/iY3eLGfwS2G「【梦曦】微信小程序」链接：https://www.aliyundrive.com/s/q6XJs6WKkLM「慕课网.纯正商业级应用-微信小程序开发实战」链接：https://www.aliyundrive.com/s/TaHXBdXPTKS「微信小程序视频教程（全）」链接：https://www.aliyundrive.com/s/njgATHqUDWP「安卓逆向开发11期（47.5G）」链接：https://www.aliyundrive.com/s/rnksYru7CDm「安卓开发视频」链接：https://www.aliyundrive.com/s/vw9eUB8gJAz「Linux操作系统零基础入门学习」链接：https://www.aliyundrive.com/s/2hUBRf1PS85「从零学可视化数据分析师教程」链接：https://www.aliyundrive.com/s/X2F9MKfNYNg「AutoCAD2022企业版」链接：https://www.aliyundrive.com/s/JYksMbcuQ8f「论文降重方法.txt」链接：https://www.aliyundrive.com/s/chfKNuj5npy「免费使用中国知网方法.txt」链接：https://www.aliyundrive.com/s/kC8WRPUKwhN「各类网盘密码提取工具」链接：https://www.aliyundrive.com/s/UShaBvdNNYi “&nbsp;免责声明”大部分资源来源于网络，仅供学习和交流使用，严禁商用，如有侵权，请联系我删除。所有资源都有时效性，如果遇到失效的，请私信我。","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://wenkex.gitee.io/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"数据库-mysql","slug":"数据库-mysql","date":"2021-12-31T17:12:58.000Z","updated":"2021-12-31T17:12:58.000Z","comments":true,"path":"2022/010151482.html","link":"","permalink":"https://wenkex.gitee.io/2022/010151482.html","excerpt":"","text":"数据库数据模型的分类：层次模型、网状模型和关系模型 为什么使用数据库持久化：将内存中的数据存储在硬盘上固化，一般是存储在关系型数据库中，或者也可以存储在磁盘文件，XML数据文件中 数据库与数据库管理系统 数据库（DATA BASE）:即存储数据的仓库，其本质是一个文件系统，它保存了一系列有组织的数据 数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中的数据。例如MySQL数据库管理系统 SQL:(结构化查询语言)Structure Query Language：专门用来与数据库通信的语言 关系：数据库管理系统可以管理多个数据库，开发人员一般针对一个应用创建一个数据库， 数据库分类关系型数据库： 关系型数据库：将复杂的数据结构归结为简单的二元关系即二维表格。建立在关系模型的基础上 关系型数据库以行(row)和列(column)的形式存储数据，这一系列的行和列被称为表(table),一组表组成了一个库(database) SQL就是关系型数据库的查询语言 oracle DB2 SQLServer Mysql SQLite - 优点： 1.复杂查询：可使用SQL语句方便的在一个或多个表间进行非常复杂的数据查询。 2.事务支持：可以实现安全性能很高的数据访问要求 缺点： *每次操作都要进行sql语句的解析，消耗较大 *不能很好的满足并发需求，特别是海量数据爆发，关系型数据库读写能力会显得不足 *关系型数据库往往每一步都要进行加锁的操作，也造成了数据库的负担 *数据一致性高，有时也会使数据的存储不灵活 非关系型数据库（NoSql）非关系型数据库：可看成关系型数据库的阉割版本，基于键值对存储数据，减少不常用的功能，性能非常高。NoSQL泛指非关系型数据库。大部分非关系型数据库是免费的。 优点：*高并发，读写能力强 *弱化数据结构一致性，使用更加灵活 *有良好的可扩展性 缺点：*通用性差，没有sql语句那样通用的语句 *操作灵活导致容易出错和混乱 *没有外键关联等复杂的操作 Nosql的使用情况： 1、对数据存储灵活性要求高，一致性要求低 2、数据处理海量并发，要求瞬间效率速度比较高 3、数据比较容易建立Nosql模型 4、网站灵活时缓冲存储，爬虫应用 Nosql 的分类： 1、键值型数据库 Redis 2、文档型数据库 MongoDB 3、列存储数据库 HBase 4、图形数据库 MySQL SQL 语法 一、基础 二、创建表 三、修改表 安装docker下安装 Mysql1234567891011#创建容器并后台启动# --name 后面是这个镜像的名称# -p 3306:3306 表示在这个容器中使用(第二个)端口映射到本机的端口号(第一个)# -d 表示使用守护进程运行，即服务挂在后台# -v 表示挂载数据卷，格式是-v localPath:containerPath 本地目录:容器目录docker run -d mysql:latest -p 3306:3310 --name mysqlll -e MYSQL_ROOT_PASSWORD=1234docker run --name mysqll -p 3306:3310 -e MYSQL_ROOT_PASSWORD=Lzslov123! -d mysql:latest# 查看容器docker ps -a# 进入容器docker exec -it ID bash window下安装下载https://dev.mysql.com/downloads/mysql/ 下载完后，我们将 zip 包解压到相应的目录，这里我将解压后的文件夹放在D:\\ruanjian\\mysql-8.0.28-winx64 配置MySQL 的配置文件在安装目录下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息： 1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\\\web\\\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 环境变量新建系统变量MYSQL_HOME，变量值为你的安装目录D:\\ruanjian\\mysql-8.0.28-winx64在系统变量里，找到Path变量，点击“编辑”按钮，我们将;%MYSQL_HOME%\\bin添加到path变量（一般放在最后面） 用户相关操作1234567891011121314151617#以下命令均需先以root身份登录mysql：mysql -uroot -p'密码'#Mysql下创建新的用户create user 用户名 identified by '密码';#给用户分配权限grant 权限 on 数据库.数据表 to '用户' @ '主机名';#查看MySql当前所有的用户：SELECT DISTINCT User FROM mysql.user;select user,host from mysql.user;show grants; #查看当前用户权限#刷新权限，使权限生效，flush privileges; 基础MySQL命令终止符为分号 ; 在命令行行中，每个命令末尾都要带上； 在大多数系统中，SQL 语句都是不区分大小写的，但是出于严谨，而且便于区分保留字（保留字(reserved word)：指在高级语言中已经定义过的字，使用者不能再将这些字作为变量名或过程名使用。和变量名，我们把保留字大写，把变量和数据小写。 source xxx.sql ; #命令行执行sql文件 模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。 主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。 SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。 SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。 SQL 支持以下三种注释： 1234## 注释SELECT * FROM mytable; -- 注释/* 注释1 注释2 */ mysql语句的四大组成成分（DDL、DML、DQL、DCL) DML语言(Data Manipulation Language):数据操作语言用于操作数据库对象中所包含的数据： 关键字有：insert（插入），update（更改），delete（删除） DQL（Data Query Language）数据查询语言关键字SELECT语句1.基础查询2.条件查询3模查词(LIKE)4.字段控制查询( DISTINCT)5.排序( DRDER BY)6.分组查词 DDL(Data Definition Language):数据定义语言 关键字有：create(创建)，drop（删除） ，truncate（删除表结构，再创一张表），alter（修改） 数据库操作1234567CREATE DATABASE xxx; -- 创建数据库SHOW DATABASES; -- 查看当前数据库服务器中的所有数据库DROP DATABASE xxx; -- 删除指定数据库USE xxx; -- 使用数据库 数据表基本操作1234show tables; --查看当前库所有表 show 表名 --查看表信息 desc 表名; --查看表结构 二、创建表123456789101112CREATE TABLE 表名 ( 表字段名：定义每个表字段 # int 类型，不为空，自增 id INT NOT NULL AUTO_INCREMENT, # int 类型，不可为空，默认值为 1，不为空 col1 INT NOT NULL DEFAULT 1, # 变长字符串类型，最长为 45 个字符，可以为空 col2 VARCHAR(45) NULL, # 日期类型，可为空 col3 DATE NULL, # 设置主键为 id PRIMARY KEY (`id`)); 改表记录 UPDATE 表名 SET 修改字段=’’ WHERE 条件 复制表-修改字段的数据类型 alter table &lt;表名&gt; modify &lt;字段名&gt; &lt;新数据类型&gt;添加字段 alter table &lt;表名&gt; add&lt;字段名&gt; &lt;新数据类型&gt;[约束条件] [first|after 已存在字段名];删除字段 alter table &lt;表名&gt; drop&lt;字段名&gt;; 三、修改表添加列 12ALTER TABLE mytableADD col CHAR(20); 删除列 12ALTER TABLE mytableDROP COLUMN col; 删除表 1DROP TABLE mytable; 四、插入普通插入 12INSERT INTO mytable(col1, col2)VALUES(val1, val2); 插入检索出来的数据 123INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2; 将一个表的内容插入到一个新表 12CREATE TABLE newtable ASSELECT * FROM mytable; 五、更新123UPDATE mytableSET col = valWHERE id = 1; 六、删除123456DELETE FROM mytableWHERE id = 1;drop table if exists stu,student; --删除数据表 TRUNCATE TABLE mytable; --可以清空表，也就是删除所有行。 使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。 七、查询DISTINCT相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。 12SELECT DISTINCT col1, col2FROM mytable; LIMIT限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 返回前 5 行： 123SELECT *FROM mytableLIMIT 5; 123SELECT *FROM mytableLIMIT 0, 5; 返回第 3 ~ 5 行： 123SELECT *FROM mytableLIMIT 2, 3; 八、排序 ASC ：升序（默认） DESC ：降序 可以按多个列进行排序，并且为每个列指定不同的排序方式： 123SELECT *FROM mytableORDER BY col1 DESC, col2 ASC; 九、过滤不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。 123SELECT *FROM mytableWHERE col IS NULL; 下表显示了 WHERE 子句可用的操作符 操作符 说明 = 等于 &lt; 小于 &gt; 大于 &lt;&gt; != 不等于 &lt;= !&gt; 小于等于 &gt;= !&lt; 大于等于 BETWEEN 在两个值之间 IS NULL 为 NULL 值 应该注意到，NULL 与 0、空字符串都不同。 AND 和 OR 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。 IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。 NOT 操作符用于否定一个条件。 十、通配符通配符也是用在过滤语句中，但它只能用于文本字段。 % 匹配 &gt;=0 个任意字符； _ 匹配 ==1 个任意字符； [ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。 使用 Like 来进行通配符匹配。 123SELECT *FROM mytableWHERE col LIKE '[^AB]%'; -- 不以 A 和 B 开头的任意文本 不要滥用通配符，通配符位于开头处匹配会非常慢。 十一、计算字段在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。 12SELECT col1 * col2 AS aliasFROM mytable; CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。 12SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_colFROM mytable; 十二、函数各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。 汇总 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG() 会忽略 NULL 行。 使用 DISTINCT 可以汇总不同的值。 12SELECT AVG(DISTINCT col1) AS avg_colFROM mytable; 文本处理 函数 说明 LEFT() 左边的字符 RIGHT() 右边的字符 LOWER() 转换为小写字符 UPPER() 转换为大写字符 LTRIM() 去除左边的空格 RTRIM() 去除右边的空格 LENGTH() 长度 SOUNDEX() 转换为语音值 其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。 123SELECT *FROM mytableWHERE SOUNDEX(col1) = SOUNDEX('apple') 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:&lt;zero-width space&gt;MM:SS 函 数 说 明 ADDDATE() 增加一个日期（天、周等） ADDTIME() 增加一个时间（时、分等） CURDATE() 返回当前日期 CURTIME() 返回当前时间 DATE() 返回日期时间的日期部分 DATEDIFF() 计算两个日期之差 DATE_ADD() 高度灵活的日期运算函数 DATE_FORMAT() 返回一个格式化的日期或时间串 DAY() 返回一个日期的天数部分 DAYOFWEEK() 对于一个日期，返回对应的星期几 HOUR() 返回一个时间的小时部分 MINUTE() 返回一个时间的分钟部分 MONTH() 返回一个日期的月份部分 NOW() 返回当前日期和时间 SECOND() 返回一个时间的秒部分 TIME() 返回一个日期时间的时间部分 YEAR() 返回一个日期的年份部分 1mysql&gt; SELECT NOW(); 12018-4-14 20:25:11 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 十三、分组把具有相同的数据值的行放在同一组中。 可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。 指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。 123SELECT col, COUNT(*) AS numFROM mytableGROUP BY col; GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。 1234SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num; WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。 12345SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING num &gt;= 2; 分组规定： GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。 十四、子查询子查询中只能返回一个字段的数据。 可以将子查询的结果作为 WHRER 语句的过滤条件： 1234SELECT *FROM mytable1WHERE col1 IN (SELECT col2 FROM mytable2); 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次： 123456SELECT cust_name, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders_numFROM CustomersORDER BY cust_name; 十五、连接连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。 连接可以替换子查询，并且比子查询的效率一般会更快。 可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。 内连接内连接又称等值连接，使用 INNER JOIN 关键字。 123SELECT A.value, B.valueFROM tablea AS A INNER JOIN tableb AS BON A.key = B.key; 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。 123SELECT A.value, B.valueFROM tablea AS A, tableb AS BWHERE A.key = B.key; 自连接自连接可以看成内连接的一种，只是连接的表是自身而已。 一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。 子查询版本 123456SELECT nameFROM employeeWHERE department = ( SELECT department FROM employee WHERE name = \"Jim\"); 自连接版本 1234SELECT e1.nameFROM employee AS e1 INNER JOIN employee AS e2ON e1.department = e2.department AND e2.name = \"Jim\"; 自然连接自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。 内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。 12SELECT A.value, B.valueFROM tablea AS A NATURAL JOIN tableb AS B; 外连接外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。 检索所有顾客的订单信息，包括还没有订单信息的顾客。 123SELECT Customers.cust_id, Customer.cust_name, Orders.order_idFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_id; customers 表： cust_id cust_name 1 a 2 b 3 c orders 表： order_id cust_id 1 1 2 1 3 3 4 3 结果： cust_id cust_name order_id 1 a 1 1 a 2 3 c 3 3 c 4 2 b Null 十六、组合查询使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。 每个查询必须包含相同的列、表达式和聚集函数。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 1234567SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2; 十七、视图MySQL 视图（View）是由数据库中的一个表或多个表导出的虚拟表，同真实表一样，视图也由列和行构成，但视图并不实际存在于数据库中。行和列的数据来自于定义视图的查询中所使用的表，并且还是在使用视图时动态生成的。 数据库中只存放了视图的定义，并没有存放视图中的数据，这些数据都存放在定义视图查询所引用的真实表中。使用视图查询数据时，数据库会从真实表中取出对应的数据。因此，视图中的数据是依赖于真实表中的数据的。一旦真实表中的数据发生改变，显示在视图中的数据也会发生改变。 视图可以从原有的表上选取对用户有用的信息，那些对用户没用，或者用户没有权限了解的信息，都可以直接屏蔽掉，作用类似于筛选。这样做既使应用简单化，也保证了系统的安全。 也就不能对其进行索引操作。 对视图的操作和对普通表的操作一样。 视图具有如下好处： 简化复杂的 SQL 操作，比如复杂的连接； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 12345678-- 创建视图格式create view 视图名 as select [查询语句]CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_colFROM mytableWHERE col5 = val; 索引索引并非越多越好避免对经常更新的表建立过多的索引数据量小的表最好不要使用索引在不同值少的列上不要建立索引为经常需要排序、分组和联接操作的字段建立索引 （2）索引的关键字（PPT 索引视图触发器第21页） 十八、存储过程存储过程可以看成是对一系列 SQL 操作的批处理。 使用存储过程的好处： 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。 包含 in、out 和 inout 三种参数。 给变量赋值都需要用 select into 语句。 每次只能给一个变量赋值，不支持集合的操作。 123456789101112delimiter //create procedure myprocedure( out ret int ) begin declare y int; select sum(col1) from mytable into y; select y*y into ret; end //delimiter ; 12call myprocedure(@ret);select @ret; 十九、游标在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。 使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标； 1234567891011121314151617181920delimiter //create procedure myprocedure(out ret int) begin declare done boolean default 0; declare mycursor cursor for select col1 from mytable; # 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1 declare continue handler for sqlstate '02000' set done = 1; open mycursor; repeat fetch mycursor into ret; select ret; until done end repeat; close mycursor; end // delimiter ; 二十、触发器触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。 INSERT 触发器包含一个名为 NEW 的虚拟表。 1234CREATE TRIGGER mytrigger AFTER INSERT ON mytableFOR EACH ROW SELECT NEW.col into @result;SELECT @result; -- 获取结果 DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。 UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。 MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。 二十一、事务管理基本术语： 事务（transaction）指一组 SQL 语句； 回退（rollback）指撤销指定 SQL 语句的过程； 提交（commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。 MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。 设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。 如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。 1234567START TRANSACTION// ...SAVEPOINT delete1// ...ROLLBACK TO delete1// ...COMMIT 二十二、字符集基本术语： 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对字符指定如何比较，主要用于排序和分组。 除了给表指定字符集和校对外，也可以给列指定： 123CREATE TABLE mytable(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; 可以在排序、分组时指定校对： 123SELECT *FROM mytableORDER BY col COLLATE latin1_general_ci; 二十三、权限管理MySQL 的账户信息保存在 mysql 这个数据库中。 12USE mysql;SELECT user FROM user; 创建账户 新创建的账户没有任何权限。 1CREATE USER myuser IDENTIFIED BY 'mypassword'; 修改账户名 1RENAME USER myuser TO newuser; 删除账户 1DROP USER myuser; 查看权限 1SHOW GRANTS FOR myuser; 授予权限 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 1GRANT SELECT, INSERT ON mydatabase.* TO myuser; 删除权限 GRANT 和 REVOKE 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 1REVOKE SELECT, INSERT ON mydatabase.* FROM myuser; 更改密码 必须使用 Password() 函数进行加密。 1SET PASSWROD FOR myuser = Password('new_password'); 启动MySQL 数据库1.初始化数据库：mysqld --initialize --console 执行完成后，会输出 root 用户的初始默认密码 12018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: qwsctyr(2+Da qwsctyr(2+Da 就是初始密码，后续登录需要用到，你也可以在登陆后修改密码。2.安装mysqld install3.启动net start mysql linux下安装1.安装mysql命令 ：$ sudo apt-get install -y mysql-server2.查看mysql的版本命令（注意-V是大写，不然会出现如下错误）：$ mysql -V3.启动mysql命令(关闭，重启等只需将start换成stop,restart等即可)：$sudo service mysql start4.登录mysql命令为：$ mysql -u用户名 -p密码5.连接远程数据库：$ mysql -h -P -u -p 工具vscode链接MySQL安装插件MySQL ，MySQL syntax配置MySQL插件，点击+号，输入密码即可 sql语句快速生成器utools插件 可以将excel或word表格中的内容快速生成sql的插入语句或更新语句 子查询子查询就是嵌套查询，一个select语句中包含另一个完整的select语句。 1.子查询出现的位置： where后，作为条为被查询的一条件的一部分；from后，作表；2.当子查询出现在where后作为条件时，还可以使用如下关键字： anyall3.子查询结果集的形式： 单行单列（用于条件）单行多列（用于条件）多行单列（用于条件）多行多列（用于表） 1.带比较运算符的子查询2.带 EXISTS关键字的子查询3.带ANY关键字的子查询4.带AL关键字的子查询 多表连接查询内连接查询 select 表1查询的字段，表2查询的字段 from 表1 inner join 表2 on 两表都有的字段； 3外连接查询(只适用于两表) 左（外）连接查询 select 表1查询的字段，表2查询的字段 from 表1 left join 表2 on 条件； 左表的记录将会全部表示出来，而右表只会显示符合搜索条件的记录 右（外）连接查询 22.SQL语句的执行顺序。（PPT数据查询第79页） 存储过程基本格式及使用，怎么调用存储过程 (PPT存储过程与事务第17页）定义 ： 存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。存储过程的特点 1、能完成较复杂的判断和运算 2、可编程行强，灵活 3、SQL编程的代码可重复使用 4、执行的速度相对快一些 5、减少网络之间的数据传输，节省开销创建存储过程的简单语法 1234create procedure 名称()begin.........end 调用存储过程 call 名称();存储函数里的变量 1234567891011create procedure test2()begin -- 使用 declare语句声明一个变量 declare username varchar(32) default ''; -- 使用set语句给变量赋值 set username='xiaoxiao'; -- 将users表中id=1的名称赋值给username select name into username from users where id=1; -- 返回变量 select username;end; 事务mysql事务处理的四种基本特性（原子性、一致性、隔离性、持久性）（书本P102页） 4.事务的基本语法，比如开启事务（start transcation、begin) ,提交事务commit，回滚 rollback（书本P103页） 5.mysql设置了事务的4种隔离级别（读未提交、读提交、可重复读、可串行化）（书本没有） 触发器 触发器与函数、存储过程一样，触发器是一种对象，它能根据对表的操作时间，触发一些动作，这些动作可以是insert,update,delete等修改操作。 123456create trigger tr_users_insert after insert on users for each row begin insert into oplog(userid,username,action,optime) values(NEW.id,NEW.name,'insert',now()); end;，三个激活触发器的操作（插入insert、修改update和删除delete）（书本没有）（PPT 索引视图触发器第43页） 数据库规范化设计1.实体之间的映射关系：一对一1:1 、一对多1:n、多对一n:1 、多对多m:n 2.E-R图的绘制 3.E-R图转换成关系模型 4.数据库模型图的概念 命令速查https://blog.csdn.net/horses/article/details/104849500 面试题1、数据库索引索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。 索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。 优点：通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。可以大大加快数据的检索速度，这也是创建索引的最主要的原因。可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。缺点：创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。添加索引原则在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://wenkex.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wenkex.gitee.io/tags/MySQL/"}]},{"title":"计网学习","slug":"计算机网络","date":"2021-12-24T00:55:20.000Z","updated":"2021-12-24T00:55:20.000Z","comments":true,"path":"2021/122451189.html","link":"","permalink":"https://wenkex.gitee.io/2021/122451189.html","excerpt":"","text":"体系结构OSI模型物理层，数据链路层，网络层，传输层，会话层，表示层，应用层TCP/IP模型网络接口层(数字信号与模拟信号相互转换)，网洛层(ip协议)，传输层(tcp和udp协议)，应用层(http协议) 综合OSI和TCP/IP的优点采用五层协议的体系结构阐述计算机网络的原理 一. 物理层集线器，中继器 相关协议点对点协议PPP用在SONET/SDH链路时，采用零比特填充方法来实现透明传输。 通过传输介质发送和接收二进制比特流。 数据通信的基本知识 编码把数据转换成数字信号（01） 不归零制， 归零制（正脉冲代表1，负脉冲代表0）， 曼彻斯特编码（位周期中心的向上跳变代表0，向下代表1，反之亦可） 差分曼彻斯特编码（每一位的中心处始终有跳变。位开始边界有跳变为0，位开始边界无跳变为1）。 调制方法 转换为模拟信号 调幅：对基带信号的波幅进行调整，例如将上图的1信号波幅进行改变，在接收方读取时有载波输出为1 调相：对基带信号相位进行调制，例如将0信号的初相位调整为0度，1信号的初相位调整为180度。 调频：对基带信号频率进行调整，例如将0信号调制为频率f1，1信号调制为频率f2。 2.数据交换方式 ①分组交换 ②电路交换 信道复用技术 ①频分复用FDM 是有N路信号要在一个信道中传送。可以使用调制的方法，把各路信号分别搬迁到适当的频率位置，使彼此不产生干扰。各路信号在同样的时间占用不同的带宽资源。 ②时分复用TDM 是将时间划分为一段段等长的帧，每一路信号在每一个帧中占用固定信号的时隙。 ③波分复用 ④码分复用CDM 数字传输系统 宽带接入技术 重要内容 使用点对点信道的数据链路层 封装成帧 透明传输 差错检测 字节填充 使用广播通信的数据链路层 二. 数据链路层交换机，网桥 链路层服务组帧：封装高层数据报构成数据帧，加首部和尾部 控制字符SOH放在一帧的最前面，表示帧的首部开始 控制字符EOT放在一帧的最后，表示帧的结束 流量控制：协调相邻的发送结点，接收 差错检测：信号衰减和噪音会引起差错，接收端检测到差错，通知发送端重传或直接丢弃帧 差错纠正：接收端直接纠正比特差错 全双工和半双工通信控制 全双工：同时双向传输。半双工：交替双向传输 数据链路层协议的代表包括：PPP、帧中继等 适配器的作用CSMA/CD协议使用集线器的星形拓扑结构MAC层的硬件地址MAC帧的格式以太网的扩展 三. 网络层网络通信让不同的电脑上的软件能够进行数据传递，即进程间的通信 提供主机间的逻辑通信机制，在邻接节点间进行数据包可靠传输 负责对子网间的数据包进行路由选择，为分组交换网上的不同主机提供通信服务。 网络层协议的代表包括：IP、ICMP、IGMP等。网络层提供的两种服务 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol）IP地址通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。 当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个局域网（LAN）中的内部IP地址，通过网络地址转换（NAT）服务我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“路由器”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。 IP地址分类IP地址分类（A类 B类 C类 D类 E类）IP地址由四段组成，每个字段是一个字节，8位，最大值是255， IP地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。 IP地址的四大类型标识的是网络中的某台主机。IPv4的地址长度为32位，共4个字节，但实际中我们用点分十进制记法。 IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。 全0和全1的都保留不用。 A类：(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。 B类：(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。 C类：(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。 D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户[1] 。 E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。 在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：A类地址：10.0.0.0～10.255.255.255B类地址：172.16.0.0～172.31.255.255C类地址：192.168.0.0～192.168.255.255 回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。一般用于测试使用。例如：ping 127.0.0.1来测试本机TCP/IP是否正常。 IP 地址编址方式IP 地址的编址方式经历了三个历史阶段： 分类 子网划分 无分类 1. 分类 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 3. 无分类 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 ip目前已经不采用分类表示法，所以大家重点关注CIDR表示法（无分类编址）。例 128.14.35.7/20 = 10000000 00001110 0010|0011 00000111 即前20位是网络前缀，后12位是主机号，那么我们通过令主机号分别为全0和全1就可以得到一个CIDR地址块的最小地址和最大地址，即 最小地址是：128.14.32.0 = 10000000 00001110 0010|0000 00000000 最大地址是：128.14.47.255 = 10000000 00001110 0010|1111 11111111 子网掩码是：255.255.240.0 = 11111111 11111111 1111|0000 00000000 因此就可以看出来，这个CIDR地址块可以指派(47-32+1)*256=4096个地址，这里没有把全0和全1除外。 IP数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 地址解析协议 ARP网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 ARP 实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 网际控制报文协议 ICMPICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 1. Ping Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 Traceroute Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 VPN虚拟专用网由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 网络地址转换 NAT专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 路由器路由器的结构路由器从功能上可以划分为：路由选择和分组转发。 分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 路由器分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 路由选择协议路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。 互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。 可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF 自治系统间的路由选择：BGP 1. 内部网关协议 RIPRIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 2. 内部网关协议 OSPF开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 只有当链路状态发生变化时，路由器才会发送信息。 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 3. 外部网关协议 BGPBGP（Border Gateway Protocol，边界网关协议） AS 之间的路由选择很困难，主要是由于： 互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 TCP/IP模型实现网络通信的基础是网络通信协议，所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等， 网络协议的三要素是：语法、语义和时序。 构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层， TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情： 数据不传丢不传错（利用握手、校验和重传机制可以实现）。 流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。 拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。 网络应用模式 C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。 去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。 四. 传输层（transport layer）概述提供应用进程间的逻辑通信机制应用进程利用该服务传送应用层报文 复用功能多个应用层进程可同时使用下面运输层的服务 分用功能运输层把收到的信息分别交付到上面应用层中的相应进程运输层协议（端到端协议）发送方将应用递交的信息下传给网络层接收方将接收的信息上交给应用层 TCP传输控制协议数据传输单位是报文段可靠的，面向连接的运输服务，一般数据不会丢失， 有一个可靠的机制，丢失会重传 不提供广播或多播服务3.开销较多 面向字节流，全双工 有流量控制和拥塞控制 TCP可靠传输的实现三次握手 第一次：当客户端向服务端发起连接时，会先发送一段称为SYN包的连接请求数据，请求建立连接 第二次：服务端收到请求后，如果同意连接，则回复一个确认应答（ACK）和同步序列（SYN）的数据段 第三次:客户端收到之后，再发送一个确认应答(ACK包)，建立连接，开始传输实际数据 为什么要三次握手而不是两次握手？这是为了防止，因为已失效的请求报文，突然又传到服务器，引起错误 假设采用两次握手建立连接，客户端向服务端发送一个syn包请求建立连接，因为某些未知的原因，并没有到达服务器，在中间某个网络节点产生了滞留，为了建立连接，客户端会重发syn包，这次的数据包正常送达，服务端发送syn+ack之后就建立起了连接。 但是第一包数据阻塞的网络突然恢复，第一包syn包又送达到服务端，这时服务端会认为客户端又发起了一个新的连接，从而在两次握手之后进入等待数据状态，服务端认为是两个连接，而客户端认为是一个连接，造成了状态不一致，如果在三次握手的情况下，服务端收不到最后的ack包，自然不会认为连接建立成功。 所以三次握手本质上来说就是为了解决网络信道不可靠的问题，为了在不可靠的信道上建立起可靠的连接，经过三次握手之后，客户端和服务端都进入了数据传输状态。 四次挥手处于连接状态的客户端和服务端，都可以发起关闭连接请求，此时需要四次挥手来进行连接关闭。假设客户端主动发起连接关闭请求，他给服务端发起一包FIN包，标识要关闭连接，自己进入终止等待1装填，服务端收到FIN包，发送一包ACK包，标识自己进入了关闭等待状态，客户端进入终止等待2状态，这是第二次挥手，服务端此时还可以发送未发送的数据，而客户端还可以接受数据，待服务端发送完数据之后，发送一包FIN包，最后进入确认状态，这是第3次挥手，客户端收到之后恢复ACK包，进入超时等待状态，经过超时时间后关闭连接，而服务端收到ACK包后，立即关闭连接，这是第四次挥手。 为什么客户端要等待超时时间？这是为了保证对方已经收到ACK包，因为假设客户端发送完最后一包ACK包后释放了连接，一旦ACK包在网络中丢失，服务端将一直停留在 最后确认状态，如果等待一段时间，这时服务端会因为没有收到ack包重发FIN包，客户端会响应 这个FIN包进行重发ack包，并刷新超时时间，这个机制跟第三次握手一样。也是为了保证在不可靠的网络链路中进行可靠的连接断开确认 UDP用户数据报协议数据传输单位是用户数据报 1.传输数据前不需要先建立连接 2.收到UDP报后，不需要给出确定 3.不提供可靠交付，但是一种最有效的工作方式 是不安全的，就是你去邮局寄信，信能不能到达对方手里，对方是否知道你写信了，这些都是未知的。在传输过程中数据可能会丢失，也就是丢包 TCP和UDP的区别tcp和udp都是工作在传输层，用于程序之间传输数据的。数据一般包含：文件类型，视频类型，jpg图片等。 tcp是基于连接的，传输数据稳定可靠，适用于对网络通讯质量要求较高的场景，需要准确无误的传输给对方，比如，传输文件，发送邮件，浏览网页等等 udp是基于非连接的，优点是速度快，但是可能产生丢包，所以适用于对实时性要求较高但是对少量丢包并没有太大要求的场景。比如：域名查询，语音通话，视频直播等。udp还有一个非常重要的应用场景就是隧道网络，比如：VXLAN 端口socket套接字套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。 TCP套接字所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。 下面的代码实现了一个提供时间日期的服务器。 12345678910111213141516171819202122232425262728293031323334from socket import socket, SOCK_STREAM, AF_INETfrom datetime import datetimedef main(): # 1.创建套接字对象并指定使用哪种传输服务 # family=AF_INET - IPv4地址 # family=AF_INET6 - IPv6地址 # type=SOCK_STREAM - TCP套接字 # type=SOCK_DGRAM - UDP套接字 # type=SOCK_RAW - 原始套接字 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(端口用于区分不同的服务) # 同一时间在同一个端口上只能绑定一个服务否则报错 server.bind(('192.168.1.2', 6789)) # 3.开启监听 - 监听客户端连接到服务器 # 参数512可以理解为连接队列的大小 server.listen(512) print('服务器启动开始监听...') while True: # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行 # accept方法返回一个元组其中的第一个元素是客户端对象 # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成) client, addr = server.accept() print(str(addr) + '连接到了服务器.') # 5.发送数据 client.send(str(datetime.now()).encode('utf-8')) # 6.断开连接 client.close()if __name__ == '__main__': main() 运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。 1telnet 192.168.1.2 6789 当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。 123456789101112131415from socket import socketdef main(): # 1.创建套接字对象默认使用IPv4和TCP协议 client = socket() # 2.连接到服务器(需要指定IP地址和端口) client.connect(('192.168.1.2', 6789)) # 3.从服务器接收数据 print(client.recv(1024).decode('utf-8')) client.close()if __name__ == '__main__': main() 需要注意的是，上面的服务器并没有使用多线程或者异步I/O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。 服务器端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from socket import socket, SOCK_STREAM, AF_INETfrom base64 import b64encodefrom json import dumpsfrom threading import Threaddef main(): # 自定义线程类 class FileTransferHandler(Thread): def __init__(self, cclient): super().__init__() self.cclient = cclient def run(self): my_dict = {} my_dict['filename'] = 'guido.jpg' # JSON是纯文本不能携带二进制数据 # 所以图片的二进制数据要处理成base64编码 my_dict['filedata'] = data # 通过dumps函数将字典处理成JSON字符串 json_str = dumps(my_dict) # 发送JSON字符串 self.cclient.send(json_str.encode('utf-8')) self.cclient.close() # 1.创建套接字对象并指定使用哪种传输服务 server = socket() # 2.绑定IP地址和端口(区分不同的服务) server.bind(('192.168.1.2', 5566)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print('服务器启动开始监听...') with open('guido.jpg', 'rb') as f: # 将二进制数据处理成base64再解码成字符串 data = b64encode(f.read()).decode('utf-8') while True: client, addr = server.accept() # 启动一个线程来处理客户端的请求 FileTransferHandler(client).start()if __name__ == '__main__': main() 客户端代码： 1234567891011121314151617181920212223242526272829from socket import socketfrom json import loadsfrom base64 import b64decodedef main(): client = socket() client.connect(('192.168.1.2', 5566)) # 定义一个保存二进制数据的对象 in_data = bytes() # 由于不知道服务器发送的数据有多大每次接收1024字节 data = client.recv(1024) while data: # 将收到的数据拼接起来 in_data += data data = client.recv(1024) # 将收到的二进制数据解码成JSON字符串并转换成字典 # loads函数的作用就是将JSON字符串转成字典对象 my_dict = loads(in_data.decode('utf-8')) filename = my_dict['filename'] filedata = my_dict['filedata'].encode('utf-8') with open('/Users/Hao/' + filename, 'wb') as f: # 将base64格式的数据解码成二进制数据并写入文件 f.write(b64decode(filedata)) print('图片已保存.')if __name__ == '__main__': main() 在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从000000到111111的64种状态。维基百科上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。 说明： 上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。 UDP套接字传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。 应用层（application layer）概述任务是通过应用进程间的交互来完成特定网络应用进程指的是主机正在运行的程序应用层交互的数据单元称为报文 应用层协议定义的是应用进程间通信和交互的规则 域名系统DNS将域名转换为Ip地址 文件传送协议FTPHTTPHTTP协议的服务端口为80 基于HTTP协议的网络资源访问HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，ll通过HTTP或者HTTPS（超文本传输安全协议）请求的资源由URI（统一资源标识符）来标识。通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。 URLHTTP 使用 URL（ U niform Resource Locator，统一资源定位符）来定位资源，它是 URI（Uniform Resource Identifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。 URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。 wikipedia：统一资源标志符 wikipedia: URL rfc2616：3.2.2 http URL What is the difference between a URI, a URL and a URN? HTTP请求报文客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。 请求报文结构： 第一行是请求行（request line）包含了请求方法、URL、协议版本； 接下来的多行都是请求头部（headers，请求头由若干键值对构成，包含了浏览器、编码方式、首选语言、缓存策略等信息； 一个空行（blank line）用来分隔首部和内容主体 Body 最后是请求的内容主体，请求数据（request body） 12345678910111213GET http://www.example.com/ HTTP/1.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cache-Control: max-age=0Host: www.example.comIf-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMTIf-None-Match: \"3147526947+gzip\"Proxy-Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 xxxparam1=1&amp;param2=2 HTTP 方法客户端发送的 请求报文 第一行为请求行，包含了方法字段。 1.GET- 获取资源 当前网络请求中，绝大部分使用的是 GET 方法。 2.HEAD 获取报文首部 和 GET 方法类似，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 3.POST 传输实体主体 POST 主要用来传输数据，而 GET 主要用来获取资源。 更多 POST 与 GET 的比较请见第九章。 4.PUT 上传文件 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 123456PUT /new.html HTTP/1.1Host: example.comContent-type: text/htmlContent-length: 16&lt;p&gt;New File&lt;/p&gt; 5.PATCH 对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 1234567PATCH /file.txt HTTP/1.1Host: www.example.comContent-Type: application/exampleIf-Match: \"e0023aa4e\"Content-Length: 100[description of changes] 6.DELETE 删除文件 与 PUT 功能相反，并且同样不带验证机制。 1DELETE /file.html HTTP/1.1 7.OPTIONS 查询支持的方法 查询指定的 URL 能够支持的方法。 会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 8.CONNECT 要求在与代理服务器通信时建立隧道 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 1CONNECT www.example.com:443 HTTP/1.1 9.TRACE 追踪路径 服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。 通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 rfc2616：9 Method Definitions HTTP响应报文响应报文结构： 第一行是响应行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了 响应头，包含了一系列服务器的信息，以及服务器对请求的响应。 一个空行分隔首部和内容主体 最后是响应体，是服务器根据客户端的请求返回给客户端的具体数据。可能是 HTML 页面，也有可能是JSON或二进制数据等 12345678910111213141516171819202122232425HTTP/1.1 200 OKAge: 529651Cache-Control: max-age=604800Connection: keep-aliveContent-Encoding: gzipContent-Length: 648Content-Type: text/html; charset=UTF-8Date: Mon, 02 Nov 2020 17:53:39 GMTEtag: \"3147526947+ident+gzip\"Expires: Mon, 09 Nov 2020 17:53:39 GMTKeep-Alive: timeout=4Last-Modified: Thu, 17 Oct 2019 07:18:26 GMTProxy-Connection: keep-aliveServer: ECS (sjc/16DF)Vary: Accept-EncodingX-Cache: HIT&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Example Domain&lt;/title&gt; // 省略... &lt;/body&gt;&lt;/html&gt; HTTP 状态码服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 1234200 //请求成功404 //请求资源不存在，输入了错误的url Session和 Cookies我们在浏览网站的过程中，经常会遇到需要登录的情况，而有些网页只有登录之后才可以访问，而且登录之后可以连续访问很多次网站，但是有时候过一段时间就需要重新登录。 还有一些网站，在打开浏览器时就自动登录了，而且很长时间都不会失效，这种情况又是为什么？其实这里面涉及 Session和 Cookies 的相关知识， 静态网页和动态网页在开始介绍它们之前，我们需要先了解一下静态网页和动态网页的概念。这里还是前面的示例代码，内容如下： 这是最基本的 HTML代码，我们将其保存为一个 .html文件，然后把它放在某台具有固定公网 IP 的主机上，主机上装上 Apache 或 Nginx等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服 务器看到这个页面，这就搭建了一个最简单的网站。 这种网页的内容是 HTML代码编写的，文字、图片等内容均通过写好的 HTML代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据 URL灵活多变 地显示内容等。例如，我们想要给这个网页的 URL传入一个 name 参数，让其在网页中显示出来，是无法做到的。 因此，动态网页应运而生，它可以动态解析 URL中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。我们现在遇到的大多数网站都是动态网站，它们不再是一个简单的 HTML，而是可能由 JSP、PHP、Python等语言编写的，其功能比静态网页强大和丰富太多了。 此外，动态网站还可以实现用户登录和注册的功能。再回到开头来看提到的问题，很多页面是需要登录之后才可以查看的。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东 西，有了它，我们才能保持登录状态，才能访问登录之后才能看到的页面。 那么，这种神秘的凭证到底是什么呢？其实它就是 Session和 Cookies 共同产生的结果，下面我们来一探究竟。 无状态 HTTPHTTP 的无状态特点是指服务器无法判断客户端是什么状态。即服务器无法判断用户身份。 当我们向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。 这意味着如果后续需要处理前面的信息，则必须重传，这也导致需要额外传递一些前面的重复请求，才能获取后续响应，然而这种效果显然不是我们想要的。为了保持前后状态，我们肯定不能将前面的请求全 部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。 这时两个用于保持 HTTP 连接状态的技术就出现了，它们分别是 Session和 Cookies。 SessionSession在服务端，也就是网站的服务器，用来保存用户的 Session信息；Session，中文称之为会话，其本身的含义是指有始有终的一系列动作 / 消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 Session。 而在 Web 中，Session对象用来存储特定用户 Session所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session对象中的变量将不会丢失，而是在整个用户 Session中一直存在下 去。当用户请求来自应用程序的 Web 页时，如果该用户还没有 Session，则 Web 服务器将自动创建一个 Session对象。当 Session过期或被放弃后，服务器将终止该 Session。 CookiesCookies 在客户端，也可以理解为浏览器端，有了 Cookies，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别 Cookies 并鉴定出是哪个用户，然后再判断用户是否是登录状态，进而返回对应的响应。 我们可以理解为 Cookies 里面保存了登录的凭证，有了它，只需要在下次请求携带 Cookies 发送请求而不必重新输入用户名、密码等信息重新登录了。 因此在爬虫中，有时候处理需要登录才能访问的页面时，我们一般会直接将登录成功后获取的 Cookies 放在请求头里面直接请求，而不必重新模拟登录。 Cookies 指某些网站为了辨别用户身份、进行 Session跟踪而存储在用户本地终端上的数据。 什么是cookieCookie实际上是一小段的文本信息（key-value格式）。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。 打个比方，我们去银行办理储蓄业务，第一次给你办了张银行卡，里面存放了身份证、密码、手机等个人信息。当你下次再来这个银行时，银行机器能识别你的卡，从而能够直接办理业务。 会话Cookie 和持久Cookie从表面意思来说，会话 Cookie 就是把 Cookie 放在浏览器内存里，浏览器在关闭之后该 Cookie 即失效；持久 Cookie 则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。 其实严格来说，没有会话 Cookie 和持久 Cookie 之 分，只是由 Cookie 的 MaxAge 或 Expires 字段决定了过期的时间。 因此，一些持久化登录的网站其实就是把 Cookie 的有效时间和 Session有效期设置得比较长，下次我们再访问页面时仍然携带之前的 Cookie，就可以直接保持登录状态。 属性结构在浏览器开发者工具中打开 Application选项卡，然后在左侧会有一个 Storage 部分，最后一项即为 Cookies，将其点开 其中每个条目可以称为 Cookie。它有如下几个属性。Name，即该 Cookie 的名称。Cookie 一旦创建，名称便不可更改。Value，即该 Cookie 的值。如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据，则需要使用 BASE64 编码。 MaxAge，即该 Cookie 失效的时间，单位秒，也常和 Expires 一起使用，通过它可以计算出其有效时间。MaxAge 如果为正数，则该 Cookie 在 MaxAge 秒之后失效。如果为负数，则关闭浏览器时 Cookie 即 失效，浏览器也不会以任何形式保存该 Cookie。Path，即该 Cookie 的使用路径。如果设置为 /path/，则只有路径为 /path/ 的页面可以访问该 Cookie。如果设置为 /，则本域名下的所有页面都可以访问该 Cookie。Domain，即可以访问该 Cookie 的域名。例如如果设置为 .zhihu.com，则所有以 zhihu.com，结尾的域名都可以访问该 Cookie。Size 字段，即此 Cookie 的大小。 Http 字段，即 Cookie 的 httponly属性。若此属性为 true，则只有在 HTTP Headers 中会带有此 Cookie 的信息，而不能通过 document.cookie 来访问此 Cookie。 Secure，即该 Cookie 是否仅被使用安全协议传输。安全协议。安全协议有 HTTPS、SSL等，在网络上传输数据之前先将数据加密。默认为 false。 Session维持那么，我们怎样利用 Cookies 保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有 Set-Cookie 字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把 Cookies 保存起来。当浏 览器下一次再请求该网站时，浏览器会把此 Cookies 放到请求头一起提交给服务器，Cookies 携带了 Session ID 信息，服务器检查该 Cookies 即可找到对应的 Session是什么，然后再判断 Session来以此来辨认用户 状态。 在成功登录某个网站时，服务器会告诉客户端设置哪些 Cookies 信息，在后续访问页面时客户端会把 Cookies 发送给服务器，服务器再找到对应的 Session加以判断。如果 Session中的某些设置登录状态的变量是 有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。 反之，如果传给服务器的 Cookies 是无效的，或者 Session已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。 所以，Cookies 和 Session需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录 Session控制。 常见误区常在谈论 Session机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，Session就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对 Session 来说，也是一样，除非程序通知服务器删除一个 Session，否则服务器会一直保留。比如，程序一般都是在我们做注销操作时才去删除 Session。 但是当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话 Cookie 来保存 Session ID 信息，而关闭浏览器后 Cookies 就消失了，再次连接服务器时，也就无法找到原来的 Session了。如果服务器设置的 Cookies 保存到硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 Cookies 发送给服务器，则再次打开浏览器，仍然能够找到原来的 Session ID，依旧还是可以保持登录状态的。 而且恰恰是由于关闭浏览器不会导致 Session被删除，这就需要服务器为 Session设置一个失效时间，当距离客户端上一次使用 Session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才 会把 Session删除以节省存储空间。 HTTPSHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 加密1. 对称密钥加密对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。 优点：运算速度快； 缺点：无法安全地将密钥传输给通信方。 2.非对称密钥加密非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。 优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。 3. HTTPS 采用的加密方式上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案： 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性; 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key） ### 认证 通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。 完整性保护SSL 提供报文摘要功能来进行完整性保护。 HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。 HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。 HTTPS 的缺点 因为需要进行加密解密等过程，因此速度会更慢； 需要支付证书授权的高额费用。 SMTPSMP协议的服务端口为25SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于传输系统之间的邮件信息并提供与来信有关的通知。 远程终端协议TELNET动态主机配置协议应用进程跨网络的通信P2P对等方式1.没有固定的服务请求者和服务提供2.对等方相互之间直接通信3.每个对等方既是服务请求者又是服务提供者 复习题选择题 物理层中指明在接口电缆的各条线上出现的电压的范围（ B ）。A. 机械特性 B. 电气特性C. 功能特性 D. 过程特性 下列属于半双工通信方式的是（ C ）。A. 无线电广播 B. 有线闭路电视C. 无线对讲机 D. 手机通话 光纤通信使用（ C ）。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM 典型应用于传输速率1Gbit/s(距离100米)的绞合线类别是（ C ）。A. 3类线 B. 超5类线C. 6类线 D. 8类线 传输带宽最大的介质是（ C ）。A. 双绞线 B. 同轴电缆C. 光纤 D. 微波 （ A ）是有N路信号要在一个信道中传送。可以使用调制的方法，把各路信号分别搬迁到适当的频率位置，使彼此不产生干扰。各路信号在同样的时间占用不同的带宽资源。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM （ A ）技术是用数字技术对现有模拟电话的用户线进行改造，使它能承载宽带数字业务。A．ADSL B. 光纤同轴混合网（HFC网）C. 光纤接入 D. FTTx技术 控制字符（ A ）放在一帧的最前面，表示帧的首部开始。A. SOH B. EOTC. ESC D. MTU 局域网通常采用的网络拓扑结构不包括（ D ）。A. 星形网 B. 环形网C. 总线网 D. 三角形 10GBASE-ER采用的媒体介质是（ B ）。A. 多模光纤 B. 单模光纤C. 同轴电缆 D. 双绞线 无分类编址CIDR地址块中网络前缀长度为/18相当于包含（ D ）个C类网络数。A. 21 B. 23C. 80 D. 64 CIDR地址块206.0.64.0/18的子网掩码采用点分十进制法是记法是（ C ）。A. 255.255.255.0 B. 255.255.240.0C. 255.255.192.0 D. 255.255.254.0 以下可分配给主机或者路由器的IP地址是（ C ）。A. 131.107.255.80/28 B. 231.211.128.0/17C. 126.1.4.255/23 D. 198.121.204.128/25 Internet的前身是美国的（ A ）。A. ARPANET B. 信息高速公路C. RFC D. 分组交换网络15．下列不属于ISP的是（ D ）。A. 中国联通 B. 中国电信C. 德国电信 D. 优酷16．计算机通信网络的数据传送方式属于（C ）。A. 电路交换 B. 报文交换C. 分组交换 D. 虚电路交换 广州工商学院的校园网属于（ C ）。A. 广域网 B. 城域网C. 局域网 D. 个域网 主机或路由器发送数据帧所需要的时间是（ A ）。A. 发送时延 B. 传播时延C. 处理时延 D. 排队时延 网络协议三要素中的（ A ）表示数据与控制信息的结构或格式。A. 语法 B. 语义C. 同步 D. 协议 以下属于UDP支持的应用程序是（ C ）。A. 浏览器打开网页 B. 收发电子邮件C. 网络视频点播 D. 远程登陆方式连接 物理层中指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等是（ A ）。A. 机械特性 B. 电气特性C. 功能特性 D. 过程特性 下列属于全双工通信方式的是（ D ）。A. 无线电广播 B. 有线闭路电视C. 无线对讲机 D. 手机通话 3G移动通信技术使用（ D ）。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM 通常双绞线的最大传输距离是（ D ）。A. 10米 B. 18米C. 50米 D. 100米 早期有线电视网使用的介质主要是（ B ）。A. 双绞线 B. 同轴电缆C. 光纤 D. 微波 （ B ）是将时间划分为一段段等长的帧，每一路信号在每一个帧中占用固定信号的时隙。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM （ B ）是目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传达电视节目外，还能提供电话、数据和其他宽带交互型业务。A．ADSL B. 光纤同轴混合网（HFC网）C. 光纤接入 D. FTTx技术 控制字符（ B ）放在一帧的最后，表示帧的结束。A. SOH B. EOTC. ESC D. MTU 总线型以太网通常采用（ A ）访问控制协议。A. CSMA/CD B.CSMA/CAC. 频分复用 D.时分复用 （ B ）的光源要使用昂贵的半导体激光器，而不能使用较便宜的发光二极管。A. 多模光纤 B. 单模光纤C. 同轴电缆 D. 双绞线 无分类编址CIDR地址块中网络前缀长度为/16相当于包含（ A ）个B类网络数。A. 1 B. 2C. 64 D. 256 CIDR地址块206.0.64.0/17的子网掩码采用点分十进制法是记法是（ B ）。A. 255.255.0.0 B. 255.255.128.0C. 255.255.192.0 D. 255.255.254.0 判断题（√）1.*一般的适配器都包括了数据链路层和物理层这两层的功能。（√）2.封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。（√）3.所有的PPP帧的长度都是整数字节。（√）4.PPP协议用在SONET/SDH链路时，采用零比特填充方法来实现透明传输。（√）5.最初的以太网是将许多计算机都连接到一根总线上，也称为共享以太网。（√）1.*一般的适配器都包括了数据链路层和物理层这两层的功能。（√ ）2.封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。（√）3.所有的 PPP 帧的长度都是整数字节。（√）4.PPP 协议用在 SONET/SDH 链路时，采用零比特填充方法来实现透明传输。（√）5.最初的以太网是将许多计算机都连接到一根总线上，也称为共享以太网。（×）6.以太网使用面向连接的工作方式。（√）7.*以太网发送的数据都使用曼彻斯特编码，其特点是可以实现时钟自同步。（√）8.以太网的站点在发送帧时，如果经过2τ后还没有检测到冲突，则本次发送不会再出现冲突了。（ √ ）9.速率达到或超过 100 Mb/s 的以太网称为高速以太网。（ √ ）10.100BASE-T 以太网工作在全双工方式时，不使用CSMA/CD协议( √ )11. CSMA/CD协议采用半双工通信。( × )6. 集线器工作于数据链路层。 //工作于物理层(√ )7. 以太网交换机是一种即插即用设备，其内部的地址表是通过自学习算法自动逐渐建立起来的。 填空题1．OSI/RM的七层协议分别是物理层、数据链路层、____网络层__、运输层、会话层、表示层、应用层。2．双绞线分为无屏蔽双绞线（UTP）和____屏蔽双绞线(STP)__。3．为了解决透明传输问题，在发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个_____转义字符“ESC”_____。 ____物理地址_____是使用数据链路层的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。 在IP层下面每一种数据链路层协议都规定了一个数据帧中的数据字段的最大长度，这称为___最大传送单元MTU ______。 HTTPS应用程序采用熟知的端口号____TCP_____。 万维网使用____超文本标记语言HTML ________来显示各种万维网页面。11．TCP/IP的四层协议包括链路层、网际层IP、运输层、____应用层______。12．数字信号可以通过_____调制器_____转化为模拟信号。13．在带宽W（Hz）的低通信道中，若不考虑噪声影响，则码元传输的最高速率是2W（码元/秒）。传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的识别称为不可能，这就是著名的____奈氏准则___。 ___香农公式_____表明信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。 ___封装成帧____就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。 计算机与外界局域网的连接是通过___网络适配器完成的_________。 网络层提供的服务分为虚电路和____数据报______。 C类地址可容纳的主机数是____254________。 HTTP应用程序采用熟知的端口号______TCP______。 FTP的中文翻译是___文件传输协议_________。 __生存时间或者TTL ___占8位，表明数据报在网络中的寿命。 内部网关协议IGP使用最多的是RIP和_____最短路径优先或者OSPF _______。 外部网关协议EGP使用最多的是_____ BGP的版本4或者BGP-4__。 1．数字信号可以通过___抽样，量化，编码____转化为模拟信号。 简答题1．什么是DNS？什么是DHCP服务器？答：域名系统DNS是互联网使用的命名系统，用来便于人们使用的机器名字转换为IP地址。动态主机配置协议DHCP提供了一种机制，称为即插即用连网。这种机制允许一台计算机自动加入新的网络和获取IP地址而不用手工参与。 什么是虚拟专用网络VPN？（P186）什么是网络地址转换NAT？(P188)答：虚拟专用网络VPN是指这种网络是为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信。如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么多有通过互联网传送的数据都必须加密。网络地址转换NAT是指在专用网连接到互联网的路由器上安装NAT软件。装有NAT软件的路由器叫作NAT路由器，它至少一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和互联网连接。 1.三报文握手建立TCP连接过程 P247第一次握手:客户端将报文标志位SYN置为1,产生一个序号值seq=x,将该数据包发送给服务器端后客户端进入SYN_SENT状态第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=x+1，随机产生一个序号值seq=y，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。第三次握手：客户端收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给服务器端，服务器端检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了 2.TCP和UDP的主要区别TCP提供面向连接、按序可靠的字节流服务（面向字节流）、有流量控制和拥塞控制。UDP提供无连接、不可靠的数据报服务（面向报文）。3.什么是VPN P1864.什么叫网络地址转换为NAT P188 5.什么是DNS P261将域名转换为IP地址 6.什么是DHCP P304动态 主机 配置 协议不需要手动的去配置ip地址以及其他的网络参数 7.什么是超文本传输协议HTTP答：超文本传输协议HTTP是面向事务的应用层协议，它是万维网上能够可靠的交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。协议HTTP不仅传送完成超文本跳转所必需的信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像等。 8.顶级域名分为哪几类 p263（1）国家顶级域名（2）通用顶级域名（3）基础结构域名9.域名服务器有哪几类 P265（1）根域名服务器（2）顶级域名服务器（3）权限域名服务器（4）本地域名服务器 10.什么是超文本标记语言HTML P283超文本标记语言HTML是一种制作万维网页面的标准语言，它消除了不同计算机之间信息交流的障碍11.什么是远程终端协议TELNET P271用户通过TCP登陆远地主机，远程操控远地主机，又称终端仿真协议12.什么是万维网www P272万维网是大规模的，联机式的信息储藏所，简称web13什么是统一资源定位符URL P274从互联网上获取资源位置和访问这些资源的方法6.什么叫做公用网和专用网？公用网：公用网用来提供服务。Client通过此网络与服务器通信。专用网：是某个部门为本单位的特殊工作的需要而建立的网络.这种网络不向本单位以外的人提供服务.例如,军队,铁路,电力等系统均有本系统的专用网。7.时延是由那几部分组成的？发送时延与传输时延的有什么区别？P22 8.IGP和EGP这两类协议的主要区别是什么? 答：内部网关协议IGP，是在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。外部网关协议EGP，是在不同的自治系统边界传递路由信息的协议，不关心自治系统内部使用何种协议。1、什么叫做“三网融合”？“三网融合”又叫“三网合一”，意指电信网络、有线电视网络和计算机网络的相互渗透、互相兼容、并逐步整合成为全世界统一的信息通信网络，其中互联网是其核心部分。2、什么叫做客户-服务器方式(C/S方式)？客户（Client）和服务器（Server）都是指通信种所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服务和被服务的关系。3、 什么叫做P2P方式？是指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机都运行了对等连接软件（P2P软件），它们就可以进行平等的、对等连接通信。这时，双方都可以下载对方已经存储在硬盘中的共享文档。因此这种的方式称为P2P方式。4、什么叫做电路交换？是指在同一电信网用户群中任意两个或多个用户终端之间建立电路暂时连接的交换方式。暂时连接独占一条通信路径并保持到连接释放为止例如，用固定电话拨打电话的数据传送方式属于（电路交换）。5、什么叫做报文交换？报文交换不要求在两个通信节点之间建立专用通路。节点把要发送的信息组织成一个数据包一报文，该报文中含有目标节点的地址，完整的报文在网络中一站一站地向前传送。每一个节点接收整个报文，检查目标节点地址，然后根据网络中的交通情况在适当的时候转发到下一个节点。经过多次的存储一转发，最后到达目标，因而这样的网络叫存储一转发网络。6、什么叫分组交换？分组交换也称为包交换，它将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组。首部指明了该分组发送的地址，当交换机收到分组之后，将根据首部中的地址信息将分组转发到目的地，这个过程就是分组交换。7、什么虚电路交换？所谓交换虚电路(SVC)就是两个数据终端要通信时先用呼叫程序建立电路（即虚电路），然后发送数据，通信结束后用拆线程序拆除虚电路。通过蓝牙无线技术连接起来的网络属于（ ）。8、什么叫做广域网？广域网(Wide Area Network ,简称WAN)是一种跨地区的数据通讯网络,通常包含一个国家或地区。广域网通常由两个或多个局域网组成。9、什么叫做城域网？城域网(Metropolitan Area Network)是在一个城市范围内所建立的计算机通信网，简称MAN。属宽带局域网。10、什么叫做局域网？局域网的覆盖范围一般是方圆几千米之内，其具备的安装便捷、成本节约、扩展方便等特点使其在各类办公室内运用广泛。11、什么叫做个域网？个人域网（PAN），是指能在便携式消费电器与通信设备之间进行短距离通信的网络，其覆盖范围一般在10米半径以内。 作图： P451、能根据比特流画出曼彻斯特编码、差分曼彻斯特编码、归零制和不归零制编码的图。2、能根据基带信号画出最基本调制方法中的调幅和调频图。调幅：对基带信号的波幅进行调整，例如将上图的1信号波幅进行改变，在接收方读取时有载波输出为1.调频：对基带信号频率进行调整，例如将0信号调制为频率f1，1信号调制为频率f2。调相：对基带信号相位进行调制，例如将0信号的初相位调整为0度，1信号的初相位调整为180度。 计算CIDR地址快的使用（即路由聚合方法），如课本129页的图4-13。 有如下的5个/24地址块，试进行最大可能的聚合。 156.152.0/24 156.153.0/24 156.154.0/24 156.155.0/24 156.156.0/24解：这几块地址前面两个字节一样，只需比较第三个字节： 156.152.0/24 第三个字节 1001 1000 156.153.0/24第三个字节 1001 1001 156.154.0/24第三个字节 1001 1010 156.155.0/24第三个字节 1001 1011 156.156.0/24第三个字节 1001 1100那么这五个地址块的共同前缀有21位：212.156. 1001 1最大可能聚合地址块是：212.156.1001 1000.00000000/21=212.156.152.0/21 2、 某单位分配到一个地址块136.23.12.32 /27。现在需要进一步划分为4 个一样大的子网。试问：（1）每个子网的网络前缀有多长？（2）每一个子网中有多少个地址？（3）每一个子网的地址块是什么？（4）每一个子网可分配给主机使用的最小地址和最大地址是什么？答：将136.23.12.32 /27转换为二进制：10001000 00010111 00001100 00100000/27（1）根据题意，建立4个子网，要借2位为子网号，22=4，所以网络前缀为27+2=29位，剩下32-29=3位作主机位。 所以每个子网前缀有29位。 （2）每个子网的地址中有3位留给主机用，因此共有23=8个地址。 （3）（4）四 个子网的地址块以及每个子网分配给主机的最小地址和最大地址是：第一个地址块136.23.12.32 /29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00100 000/29最小地址：136.23.12.33（00100 001）最大地址: 136.23.12.38（00100 110）第二个地址块136.23.12.40/29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00101 000/29最小地址：136.23.12.41（00101 001）最大地址：136.23.12.46（00101 110）第三个地址块136.23.12.48 /29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00110 000/29最小地址：136.23.12.49（00110 001）最大地址：136.23.12.54（00110 110）第四个地址块：136.23.12.56/29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00111 000/29最小地址：136.23.12.57（00111 001）最大地址：136.23.12.62（00111 110） 3、 某单位分配到地址块136.230/16。该单位有2000 台机器，平均分布在 8个不同的地点。试给每一个地点分配一个地址块，并计算出每个地址块中IP地址的最小值和最大值（说明：必须有完整的解题步骤，否则不得分。）答：2000/8=250，每个点平均250台电脑。如选255.255.255.0为掩码，每个子网有28-2=254&gt;250，共有子网数=28-2=254&gt;8，能满足实际需求。每个地点的网络前缀和主机IP地址的最小值和最大值为：地点 子网号 子网络地址 主机的最小值和值1 00000001 136.230.1.0/24 : 136.230.1.1–136.230.1.2542 00000002 136.230.2.0/24 : 136.230.2.1–136.230.2.2543 00000003 136.230.3.0/24 : 136.230.3.1–136.230.3.254………………………………..7 00000007 136.230.7.0/24 : 136.230.7.1–136.230.7.2548 00000001 136.230.8.0/24 : 136.230.8.1–136.230.8.254 4、某组织分配到一个地址块，其中第一个地址是14.24.74.0/24。这个组织需要划分为11个子网。具体要求是：具有64个地址的子网两个；具有32个地址的子网两个；具有16个地址的子网三个；具有4个地址的子网四个（这里的地址包括网络地址和广播地址）。试设计这些子网。分配结束后还剩下多少地址？（说明：必须有完整的解题步骤，否则不得分。）解答：将14.24.74.0/24转换为二进制：00001110 00011000 01001010 00000000/24 具有64个地址的子网2个：根据要求可知，要借2位为子网号，因为每个子网为64个地址，所以主机号最少要保留6位才能满足每个子网64个地址，主机号共有8位，剩下8-2=6位可借给网络号。00001110 00011000 01001010 00 000000 转为十进制：14.24.74.0/2600001110 00011000 01001010 01 000000 转为十进制：14.24.74.64/262）具有32个地址的子网2个因为每个子网为32个地址，所以主机号最少要保留5位才能满足每个子网32个地址，主机号共有8位，剩下8-5=3位可借给网络号。00001110 00011000 01001010 100 00000 转为十进制：14.24.74.128/2700001110 00011000 01001010 101 00000 转为十进制：14.24.74.160/273）具有16个地址的子网3个因为每个子网为16个地址，所以主机号最少要保留4位才能满足每个子网16个地址，主机号共有8位，剩下8-4=4位可借给网络号。00001110 00011000 01001010 1100 0000 转为十进制：14.24.74.192/2800001110 00011000 01001010 1101 0000 转为十进制：14.24.74.208/2800001110 00011000 01001010 1110 0000 转为十进制：14.24.74.224/284）具有4个地址的子网4个因为每个子网为4个地址，所以主机号最少要保留2位才能满足每个子网4个地址，主机号共有8位，剩下8-2=6位可借给网络号。00001110 00011000 01001010 111100 00 转为十进制：14.24.74.240/3000001110 00011000 01001010 111101 00 转为十进制：14.24.74.244/3000001110 00011000 01001010 111110 00 转为十进制：14.24.74.248/3000001110 00011000 01001010 111111 00 转为十进制：14.24.74.252/30全部256个地址已经分配完毕，没有剩下的地址。 网络通信网络中进程如何通信我们要理解网络中进程如何通信，得解决两个问题： 1、我们要如何标识一台主机，即怎样确定我们将要通信的进程是在那一台主机上运行。 ａ、TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机 2、我们要如何标识唯一进程，本地通过pid标识，网络中应该怎样标识？解决办法： ｂ、传输层的“协议+端口”可以唯一标识主机中的应用程序（进程），因此，我们利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互 发送电子邮件在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。 就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。 下面的代码演示了如何在Python发送邮件。 12345678910111213141516171819202122from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextdef main(): # 请自行修改下面的邮件发送者和接收者 sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com', 'uvwxyz@126.com'] message = MIMEText('用Python发送邮件的示例代码.', 'plain', 'utf-8') message['From'] = Header('王大锤', 'utf-8') message['To'] = Header('骆昊', 'utf-8') message['Subject'] = Header('示例代码实验邮件', 'utf-8') smtper = SMTP('smtp.126.com') # 请自行修改下面的登录口令 smtper.login(sender, 'secretpass') smtper.sendmail(sender, receivers, message.as_string()) print('邮件发送完成!')if __name__ == '__main__': main() 如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartimport urllibdef main(): # 创建一个带附件的邮件消息对象 message = MIMEMultipart() # 创建文本内容 text_content = MIMEText('附件中有本月数据请查收', 'plain', 'utf-8') message['Subject'] = Header('本月数据', 'utf-8') # 将文本内容添加到邮件消息对象中 message.attach(text_content) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/hello.txt', 'rb') as f: txt = MIMEText(f.read(), 'base64', 'utf-8') txt['Content-Type'] = 'text/plain' txt['Content-Disposition'] = 'attachment; filename=hello.txt' message.attach(txt) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/汇总数据.xlsx', 'rb') as f: xls = MIMEText(f.read(), 'base64', 'utf-8') xls['Content-Type'] = 'application/vnd.ms-excel' xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx' message.attach(xls) # 创建SMTP对象 smtper = SMTP('smtp.126.com') # 开启安全连接 # smtper.starttls() sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com'] # 登录到SMTP服务器 # 请注意此处不是使用密码而是邮件客户端授权码进行登录 # 对此有疑问的读者可以联系自己使用的邮件服务器客服 smtper.login(sender, 'secretpass') # 发送邮件 smtper.sendmail(sender, receivers, message.as_string()) # 与邮件服务器断开连接 smtper.quit() print('发送完成!')if __name__ == '__main__': main() 发送短信发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了互亿无线短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。 1234567891011121314151617181920212223import urllib.parseimport http.clientimport jsondef main(): host = \"106.ihuyi.com\" sms_send_uri = \"/webservice/sms.php?method=Submit\" # 下面的参数需要填入自己注册的账号和对应的密码 params = urllib.parse.urlencode({'account': '你自己的账号', 'password' : '你自己的密码', 'content': '您的验证码是：147258。请不要把验证码泄露给其他人。', 'mobile': '接收者的手机号', 'format':'json' }) print(params) headers = {'Content-type': 'application/x-www-form-urlencoded', 'Accept': 'text/plain'} conn = http.client.HTTPConnection(host, port=80, timeout=30) conn.request('POST', sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read() jsonstr = response_str.decode('utf-8') print(json.loads(jsonstr)) conn.close()if __name__ == '__main__': main() URL(统一资源定位符)URL 是 Uniform Resource Locator 的简写，，用于表示服务端的各种资源 URL 主要由以下几部分组成scheme://host:port/path?key=value scheme：代表的是访问的协议，一般为 http 或者 https。例如，https://www.baidu.com 的协议是 https； host：主机的Ip地址或者域名，例如，https://www.baidu.com 的 host 为 www.baidu.com； port：端口号，http 协议默认使用 80 端口，https 协议默认使用 443 端口。通常情况下，使用默认值，不需要显式的写明端口号，例如，https://www.baidu.com 的端口是 443。某些情况下，可以显式的写明端口号，例如，http://localhost:5000 的端口号是 5000； path：页面路径，例如：http://www.imooc.com/wiki/html5 的 path 是 wiki/html5； key=value：查询字符串，例如：https://www.baidu.com/s?wd=python，查询字符串是 wd=python，查询字符串包括两部分：参数名和参数值，这个例子中，参数名是 wd，参数值是 python。 域名域名解析就是将域名转换为IP地址去访问 A记录将域名指向ip地址，主机记录填你自己设置的，值填ip地址 CNAME也叫别名记录，用来把域名解析到别的域名上。一般情况下都建议使用CNAME记录。CNAME记录可用于CDN加速，通过CDN加速别名解析网站域名，这样既可以起到加速网站的作用，又能隐藏网站的真实IP，减少被攻击的几率。 内网穿透内网穿透是指将内网中的软件服务通过网络代理方式暴露给广域网用户。可以实现内网穿透的方式很多，比如通过防火墙硬件、网络穿透软件来进行实现。先简单解释一下，大多数情况下，我们的个人电脑都处于内网，即没有可公开访问的独立 IP 地址（上网要通过其他网关），因此其他内网用户找不到你，就没办法和你建立连接。 而内网穿透的作用，就是将内网的电脑暴露到公共网络。可以理解为一个中间人，由于他知道你的电脑地址，所以能帮助其他用户访问到你的计算机。「无公网IP实现外网访问内网群晖.docx」链接：https://www.aliyundrive.com/s/ftxwXuv2SAi「开源内网穿透工具 frp 简单使用教程.docx」链接：https://www.aliyundrive.com/s/3K6okzrMght「常见内网穿透工具使用总结.docx」链接：https://www.aliyundrive.com/s/DDhaPQfR6SS「使用内网穿透访问内网ssh图文教程.docx」链接：https://www.aliyundrive.com/s/9U1Migig8yB「内网渗透之内网穿透.docx」链接：https://www.aliyundrive.com/s/Uh88x4GSjz4「内网穿透神器NPS的使用.docx」链接：https://www.aliyundrive.com/s/7XQUhDhPGBm 参考 nps-npc原文 nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。 一台有公网IP的服务器（VPS）运行服务端（NPS） 一个或多个运行在内网的服务器或者PC运行客户端（NPC） 特点Go语言编写 支持跨平台 支持多种协议的代理 web管理端 使用方法其官方网站为：https://ehang-io.github.io/nps 其官网文档对软件的安装、使用描述的非常完整，基本根据官方文档就可以进行顺利安装与使用。其官方网站为：https://ehang-io.github.io/nps 其官网文档对软件的安装、使用描述的非常完整，基本根据官方文档就可以进行顺利安装与使用。 NATAPP原文 未整理原文：https://zhuanlan.zhihu.com/p/303175108首先解释一下“内网”与“外网”的概念：内网：即所说的局域网，比如学校的局域网，局域网内每台计算机的IP地址在本局域网内具有互异性，是不可重复的。但两个局域网内的内网IP可以有相同的。外网：即互联网，局域网通过一台服务器或是一个路由器对外连接的网络，这个IP地址是唯一的。也就是说内网里所有的计算机都是连接到这一个外网IP上，通过这一个外网IP对外进行交换数据的。也就是说，一个局域网里所有电脑的内网IP是互不相同的,但共用一个外网IP。（用ipconfig/all查到的IP是你本机的内网IP；在http://www.ip138.com上看到的是你连接互联网所使用的IP，即外网）。 然后解释一下公有 IP 和私有 IP 的区别：公有地址(Public address)：由 Inter NIC(Internet Network Information Center 因特网信息中心)负责。这些 IP 地址分配给注册并向Inter NIC提出申请的组织机构，公有 IP 全球唯一，通过它直接访问因特网(直接能上网)。私有地址(Private address)：属于非注册地址，专门为组织机构内部使用，说白了，私有 IP 不能直接上网。而我们平时通过运营商(电信、移动、联通宽带等)上网，家里面通过路由器分出来的 IP 都是私有 IP(局域网 IP)，大家可能会疑问，我们可以上网啊，怎么会是私有 IP 呢?租用(申请)公有 IP 是需要钱的。 运营商买了一些公有 IP，然后通过这些公有 IP 分出来，再分给一个一个的用户使用。这个过程有点类似于，我们去安装了宽度，通过路由器分出几个 IP，让好几个人都能上网，当然运营商通过公有 IP 分出来的过程肯定比这个复杂多了。所以，我们平时上网用的 IP 是私有 IP，真正拥有公有 IP 的是运营商(当然，我们可以租用一个公有 IP )。所以，A 家庭的局域网 IP 和 B 家庭的局域网 IP 相同很正常，但是，最终 A 和 B 能上网(数据走出去)还是通过运营商的公有 IP，毕竟，公有 IP 的资源有限，这一片区域的用户使用的很有可能(实际上就是这样的)是同一个公有 IP最后需要解释一下端口映射：端口映射是 NAT 的一种，它将外网主机的 IP 地址的一个端口映射到内网中一台机器，提供相应的服务。当用户访问该 IP 的这个端口时，服务器自动将请求映射到对应局域网内部的机器上。之前提到的内网，是不能被外网直接的访问的，只能通过一些中转技术，让内网“假装”成外网。这就平常所说的内网穿透。内网穿透原理 内网穿透的概念 内网穿透，即NAT穿透，网络连接时术语，计算机是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透。就是说映射端口，能让外网的电脑找到处于内网的电脑，提高下载速度。不管是内网穿透还是其他类型的网络穿透，都是网络穿透的统一方法来研究和解决。 内网穿透原理对于内网来说，其不是不能主动访问公网端口，而是不能反过来有效的被公网访问。内网穿透的主要思路就是利用这一点，让在内网的节点主动访问一个拥有公网IP地址的服务器，并由中间服务器搭桥，打通经过该服务器从其他主机到NAT之后节点的隧道。 有哪些应用场景提供内网穿透服务连接内网服务器，在外网演示内网web站点无需服务器部署，快速调试本地程序，微信公众号开发利器支持http、https协议站点，省去证书中间件复杂配置，http协议站点直接升级为https站点支持TCP，UDP协议端口转发。支持数据库、SSH、远程桌面、网络摄像头等等开放到外网 建立隧道的工具 钉钉穿透 工具基于ngrok封装，简单、见效快，新手、个人开发者最佳选择 Ngrok项目主页：https://ngrok.com/项目介绍： 一个通过任何NAT或防火墙为您的本地主机服务器提供即时访问、安全的URL的命令。类似花生壳，分为服务端和客户端，也可以自己搭建服务端。开源，老牌穿透工具，源码很久没有更新了 Ssh&nbsp;配合autossh工具使用，因为autossh会容错项目主页：http://www.harding.motd.ca/autossh/项目介绍：自动重新启动SSH会话和隧道。autossh是一个程序，用于启动ssh的副本并进行监控，在死亡或停止传输流量时根据需要重新启动它。 这个想法来自rstunnel（Reliable SSH Tunnel），但是在C中实现。作者的观点是，它不像匆匆忙忙的工作那么容易。使用端口转发环路或远程回显服务进行连接监视。在遇到连接拒绝等快速故障时，关闭连接尝试的速度。在OpenBSD，Linux，Solaris，Mac OS X，Cygwin和AIX上编译和测试; 应该在其他BSD上工作。免费软件。Natapp项目主页：https://natapp.cn/项目介绍：基于ngrok的国内收费内网穿透工具，4包卫龙辣条的费用可以享有不限流量，自定义域名等好处类似花生壳，有免费版本，比花生壳好。免费版本：提供http,https,tcp全隧道穿透，随机域名/TCP端口，不定时强制更换域名/端口，自定义本地端口 Spike项目主页：https://github.com/slince/spike项目介绍：Spike是一个可以用来将你的内网服务暴露在公网的快速的反向代理，基于ReactPHP，采用IO多路复用模型。采用Php实现。 个人不推荐花生壳项目主页：https://hsk.oray.com/项目介绍：商业化比较成功的内网穿透。个人开发很不推荐，收费贵，企业可以考虑使用。需要建立账号实名认证，支付2包卫龙辣条费用，可自选一个壳域名，注册过程比较麻烦，流量限制Lanproxy项目主页：https://github.com/ffay/lanproxy项目介绍：lanproxy是一个将局域网个人电脑、服务器代理到公网的内网穿透工具，目前仅支持tcp流量转发，可支持任何tcp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面…）。目前市面上提供类似服务的有花生壳、TeamView、GoToMyCloud等等，但要使用第三方的公网服务器就必须为第三方付费，并且这些服务都有各种各样的限制，此外，由于数据包会流经第三方，因此对数据安全也是一大隐患。Frp项目主页：https://github.com/fatedier/frp项目介绍：frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。开源，强大牛逼，适合企业中开发使用，可穿透任意常规合法端口（包含22），需要提供云服务器，自己的域名，宽带上限由你的服务器所决定。 工具选择https://juejin.cn/post/6860694239412649991?share_token=26950be9-39b6-432c-b29a-a26df3e8cae4内网穿透工具比较(ngrok,frp,lanproxy,goproxy,nps)https://blog.csdn.net/a1035434631/article/details/108010819 ngork基本原理是通过客户端与公网服务端建立通道及映射关系，然后服务端提供可访问的公网地址。当外网访问此公网地址时，ngrok服务端根据映射关系找到客户端，然后转发给客户端的服务https://juejin.cn/post/6844903993911558157?share_token=1b8c42ab-1174-48a2-9122-00e008829d45 XML• XML是指可扩展标记语言(Xtensible Markup Language),它是一种标记语言，html是用于显示数据，xml主要功能是为了存储数据，xml也可以显示数据（不是主要功能)• XML标签没有被预定义，需要用户自行定义标签。 XML的应用1.不同的系统之间传输数据 2.用来表示生活中有关系的数据 3.经常用在配置文件 例如现在连接数据库知道数据库的用户名和密码，数据名称，修改数据库的信息，不需要修改源代码，只要修改配置文件就可以了 JSON语言在开发中凡是涉及到『跨平台数据传输』，JSON格式一定是首选 JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和XML一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。 XML的例子： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;message&gt; &lt;from&gt;Alice&lt;/from&gt; &lt;to&gt;Bob&lt;/to&gt; &lt;content&gt;Will you marry me?&lt;/content&gt;&lt;/message&gt; JSON的例子： 12345{ \"from\": \"Alice\", \"to\": \"Bob\", \"content\": \"Will you marry me?\"} JSON格式{}定义JSON对象[]定义JSON数组 12345// JSON对象的格式是：{key:value,key:value,...,key:value}// JOSN数组的格式是：[value,value,...,value] key的类型固定是字符串value的类型可以是：基本数据类型引用类型：JSON对象或JSON数组","categories":[{"name":"前端","slug":"前端","permalink":"https://wenkex.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://wenkex.gitee.io/tags/web/"},{"name":"计网","slug":"计网","permalink":"https://wenkex.gitee.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"java学习","slug":"java基础","date":"2021-12-24T00:53:47.000Z","updated":"2021-12-24T00:53:47.000Z","comments":true,"path":"2021/122465132.html","link":"","permalink":"https://wenkex.gitee.io/2021/122465132.html","excerpt":"","text":"Java基础知识高级语言的编译运行方式编程：写好代码编译: 机器只认识0011的机器语言，将代码转化成机器认识的过程运行：让机器执行编译后的指令 Java的进制二进制：以0b开头十进制：默认不加前缀八进制：以0开头十六进制：以0x开头 用记事本编写Java代码在cmd中调用JDK中的Javac编译.java文件javac demo.java最后会生成字节码.class文件 运行编译后的文件java demo 此时不需要带后缀 跨平台原理Java的跨平台时通过虚拟机实现的，它不是直接运行在操作系统中，而是运行在虚拟机中，针对不同的操作系统，安装不同的虚拟机就可以了 JRE和jdkJDK : Java Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境jre（Java Runtime Envirnment），Java工具（javac/java/jdb等）和Java基础的类库 jre:java运行环境 在JDK的安装目录下有一个jre目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib合起来就称为jre。 bin:Java工具 javac：编译工具 java：运行工具 jdb：调试工具 jhat:内存分析工具 lib：类库 include:java和JVM交互用的头文件 java的内存模型栈内存：方法在执行时进栈，执行完毕后出栈堆内存：new出来的对象都在这里方法区：字节码文件临时存储 串池： 标识符命名规则可以包含数字，但不能以数字开头除了下划线_,和$符之外，不能有其它特殊字符，如空格区分字母大小写不能使用Java关键字换行符\\n要加双引号System.out.println(“名字”+“\\n”); 注释单行注释：//多行注释：从“/”开始到“/”结束，文档注释：从“/*”开始到“/”结束文档注释可以用javadoc命令提取出来，生成类似于jdk文档的网页文件，以便于他人了解一个类的功能。 变量变量定义格式：数据类型 变量名 =值;前面不可以有访问符变量只能存一个值，在使用前一定要赋值变量名不允许重复定义一条语句可以定义多个变量 Java 修饰符访问控制修饰符访问符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类和接口私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。 public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 非访问修饰符为了实现一些其他的功能，Java 也提供了许多非访问修饰符。 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 static 修饰符：用来修饰类方法和类变量。静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 Java 运算符算术运算符前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算。 后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算 关系运算符1234567!= 检查如果两个操作数的值是否相等，如果值不相等则条件为真。 (A != B) 为真。&gt; 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。 （A&gt; B）为假。&lt; 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。（A &lt;B）为真。&gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 （A&gt; = B）为假。&lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 （A &lt;= B）为真。== 在基本数据类型中比较数据值，在引用数据类型中比的是地址值 位运算符1234567＆ 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100| 如果相对应位都是 0，则结果为 0，否则为 1 （A | B）得到61，即 0011 1101^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011&lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000&gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111&gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A&gt;&gt;&gt;2得到15即0000 1111 逻辑运算符123&amp;&amp; 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 （A &amp;&amp; B）为假。|| 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 （A | | B）为真。！ 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 ！（A &amp;&amp; B）为真。 赋值运算符 条件运算符(三元运算符)条件判断语句 ? value if true : value if false 其他运算符基本数据类型 数据类型 名称 内存大小(B) 注：1B = 8b byte 字节型 1 short 字符型 2 int 短整型 4 long 整型 8 | float | 单精度浮点型 | 4 || double | 双精度浮点型 | 8 || char | 字符型 | 2 ||boolean | 布尔 |不同情况下不同 | 整数型 short型（短整型）数据在内存中占用2个字节 long型（长整型）数据在内存中占用8个字节。需要加l后缀long num = 123L int型（整型）数据在内存中占用4个字节。 byte型（字节型）数据在内存中占用1个字节，表示的存储数据范围为：-128~127。浮点型 float型（单精度浮点型）数据在内存中占用4个字节。 float t = 3.1f f转为double型 double型（双精度浮点型）数据在内存中占用8个字节。 一般小数默认是double型 布尔型(boolean)boolean：数据值只有true或false，适用于逻辑计算。 字符型(char)char每个字符占2个字节，定义时用单引号’ ‘char类型的变量在参与计算时，类型自动提升为Int,查询ascii码表例如控制字符’0’的是48 包装类Character 类Character 类用于对单个字符进行操作。 Character 类在对象中包装一个基本类型 char 的值 在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。 1Character ch = new Character('a'); //创建一个Character类对象 Character类的方法 1.isLetter()是否是一个字母 2.isDigit()是否是一个数字字符 3.isWhitespace()是否是一个空白字符 4.isUpperCase()是否是大写字母 5.isLowerCase()是否是小写字母 6.toUpperCase()指定字母的大写形式 7.toLowerCase()指定字母的小写形式 8.toString()返回字符的字符串形式，字符串的长度仅为1 在某些情况下，Java编译器会自动创建一个Character对象。 例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。 引用数据类型引用数据类型有：类、接口类型、数组类型、String类型，枚举类型、注解类型。 区别 2、基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上。 而引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。 3、在数据做为参数传递的时候，基本数据类型是值传递，而引用数据类型是引用传递（地址传递）。 String 类String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了创建字符串 123456789101112131415161718String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：String str = \"Runoob\"; //首先在堆内存上的串池中查找是否存在该字符串，没有则创建，并将地址赋给在栈内存中的对应变量；有则复用String str2=new String (\"Runoob\"); //每次new都在堆内存中重新开辟新空间// 传递一个字符数组，根据字符数组的内容再创建一个新的字符串对象,需要修改字符串时使用char [] chs={'a','b','c'};String s4= new String (chs);//传递一个字节数组byte[] bytes = {97,98,99,100}String s5=new String (bytes)//s5输出是abcdString str2=\"abcd\";int len = str2.substring(1,3).replace(\"a\",\"b\").length(); //链式编程System.out.println(len); 123456789String str1 = \"hello world\";String str2 = new String(\"hello world\");//比较字符串boolean b =str1.equals(str2); //完全相同boolean b2=str1.equalsIgnoreCase(str2); //忽略大小写System.out.println(b);char result = str.charAt(0); //charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。 replace()替换substring()截取查找切割检索加密打乱内容大小转换 统计字符统计—-计数器思想 12int big =0,small=0,number=0; big++ 格式化字符串我们知道输出格式化数字可以使用 printf() 和 format() 方法。 如下所示： 12345System.out.printf(\"浮点型变量的值为 \" + \"%f, 整型变量的值为 \" + \" %d, 字符串变量的值为 \" + \"is %s\", floatVar, intVar, stringVar); 字符串存入字符数组123for(Character c : s.toCharArray()){} StringBuilderStringBuilder可以看作一个容器，创建之后里面的内容是可变的作用：拼接字符串，反转字符串 1234567// 构造方法StringBuilder sb= new StringBuilder(\"abc\");System.out.println(\"sb\");sb.append(); //添加数据sb.reverse(); //反转容器的内容sb.length(); //返回长度(字符出现的个数)sb.toString(); //把StringBuilder对象转为String对象 StringJoiner是一个可变容器，方便拼接字符串 12345678910111213141516171819StringJoiner sj = new StringJoiner(间隔符号) //指定拼接时的符号StringJoiner sj = new StringJoiner(间隔符号，开始符号，结束符号)sj.add(\"\") //添加元素sj.length()sj.toString() //转换为字符串```### 键盘录入扫描类```java// 导包import java.util.Scanner;// 创建对象Scanner sc= new Scanner(System.in);// 接受数据int i = sc.nextInt();// next和nextInt以空格或回车换行作为结束// nextLine以回车换行作为结束 循环结构while循环如果您想要同样的操作执行多次,，就需要使用循环结构。 123while( 布尔表达式 ) { //循环内容} do while循环对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。可以用到do…while循环 123do { //代码语句}while(布尔表达式); for循环关于for循环有以下几点说明： 1.最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。2.然后，检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。3.执行一次循环后，更新循环控制变量。4.再次检测布尔表达式。循环执行上面的过程。 1234for(初始化; 布尔表达式; 更新) { //代码语句} foreach 循环在遍历数组、集合方面使用foreach 循环语句的语法格式如下： 1234for(类型 变量名:集合) { 语句块;} “类型”为集合元素的类型，“变量名”表示集合中的每一个元素，“集合”是被遍历的集合对象或数组。每执行一次循环语句，循环变量就读取集合中的一个元素， break关键字break主要用在循环语句或者switch语句中，用来跳出整个语句块。 break跳出最里层的循环，并且继续执行该循环下面的语句。 continue关键字continue适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。 在for循环中，continue语句使程序立即跳转到更新语句。提前结束本次循环，直接执行下次循环 在while或者do…while循环中，程序立即跳转到布尔表达式的判断语句。 分支结构if…else if…else 语句if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。 使用if，else if，else语句的时候，需要注意下面几点： if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。If 语句可以有若干个 else if 语句，它们必须在 else 语句之前。一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。 switch多重选择switch 语句switch 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 switch 语法格式如下： 1234567891011switch(expression){ case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句} switch 语句有如下规则： switch 语句中的变量类型只能为 byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。 switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到break语句出现才会跳出 switch 语句。 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。 switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。 异常Error严重的错误 OutOfMemoryError：内存耗尽 NoClassDefFoundError：无法加载某个Class StackOverflowError：栈溢出 Exceptio是运行时的错误，它可以被捕获并处理。 RuntimeException以及它的子类； 非RuntimeException （包括IOException、ReflectiveOperationException等等） 异常类分为两种 1.错误。一般指与虚拟机相关的问题，这些错误无法恢复和捕获 2.异常（Exception），因编码错误或外在因素导致的问题 两种异常处理机制 1.使用try catch捕获异常 存在多个catch的时候，catch的顺序非常重要：子类必须写在前面 2.trrows抛出异常 Java方法定义格式 123456修饰符 返回值类型 方法名(参数类型 参数名){ ... 方法体 ... return 返回值;} 修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型 ：方法可能会返回值。returnValueType 是方法返回值的数据类型。若方法中没有returun返回值，则该方法的返回类型为void类型。 方法名：是方法的实际名称。方法名和参数表共同构成方法签名。 参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。 方法体：方法体包含具体的语句，定义该方法的功能。 若方法中没有returun返回值，则该方法的返回类型为void类型 类类可以看成是创建 Java 对象的模板。，描述一类对象的属性(状态)和方法(行为)定义类的注意事项：1.类名首字母建议大写，见名知意，驼峰模式2.一个Java文件可以定义多个class类，建议一个文件定义一个类；但只能有一个类被public修饰，而且public修饰的类必须是代码文件名， 12345public class 类名{ 成员变量 成员方法} 类型变量一个类可以包含以下类型变量： 1.成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。直接把field用public暴露给外部可能会破坏封装性，所以用private，外部代码可以调用get()方法和set()方法来间接获取和修改指定的私有成员变量的值成员变量可以被类中方法、构造方法和特定类的语句块访问。修饰符 数据类型 变量名 2.局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。 就近原则谁离我近，我就用谁 12345678public class Friend{ private int age; public void method(){ int age =10; System.out.println(age); //10 }} this关键字：this代表当前对象的内存地址，在实例方法或者构造方法中，为了区分局部变量和实例变量，this不能省略代表当前类将来产生的对象，即将来用该类new出来的对象，用于获取当前类的对象的引用this.name = name //this.name值成员变量 supper关键字通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 123456789101112131415161718class Animal { private int age; void eat() { System.out.println(\"animal : eat\"); }} class Dog extends Animal { void eat() { System.out.println(\"dog : eat\"); } void eatTest() { this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 System.out.println(supper.age) }} 参数方法的参数传递机制形参：声明方法时定义的参数，形参前必须有数据类型 格式：方法名（数据类型 形参）实参：调用方法时给方法传递的实际数据，使用格式：对象名.方法名（实参） 可变参数：定义格式方法名（参数列表，数据类型 … 变量）注意：可变参数只能处于参数列表的最后一个方法最多只能包含一个可变参数可变参数本质是一个数组，因此在调用时，既可以传入多个参数，也可传入一个数组 构造方法(构造器)作用：在创建对象时初始化成员变量 两种构造器无论是否使用，建议两个都写上，右键直接生成 空参构造方法：可以省略，如果我们没有写任何构造方法，虚拟机会给我们加一个空参构造。初始化对象时，成员变量采用默认值 带参构造方法:初始化对象时，同时为对象赋值 12Person p1 = new Person(\"Xiao Ming\", 15); // 调用带参数的构造方法Person p2 = new Person(); // 调用无参数构造方法 特点：1.构造方法的名称与类名一致。2.构造方法没有返回类型（也没有void），没有返回值(不能有return)3.构造方法在创建对象时由虚拟机调用，不能手动调用构造方法，每次创建对象，都会调用一次调用构造方法，必须用new操作符。不能被static、final、synchronized、abstract和native修饰。构造方法不能被子类继承，所以用final和abstract修饰没有意义。 定义构造方法用于初始化一个新建的对象，所以用static修饰没有意义 1234访问修饰符 类名(参数){} 子类调用构造器只能够被调用（隐式或显式），而不能被继承如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。 如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 1234567891011121314151617181920212223242526//父类class SuperClass { private int n; //无参构造器 SuperClass(){} //带参构造器 SuperClass(int n) { this.n = n; }}// SubClass2 类继承class SubClass2 extends SuperClass{ private int n; SubClass2(){ super(300); // 调用父类中带有参数的构造器 System.out.println(\"SubClass2\"); } public SubClass2(int n){ // 自动调用父类的无参数构造器 System.out.println(\"SubClass2(int n):\"+n); this.n = n; }} set方法和get方法用private修饰的成员只能在本类才能访问， 当类中有private修饰的私有变量时，其他类只能通过set和get方法间接地操作这些私有域变量 因此要对每个私有变量都要提供get(获取),set(赋值)方法，右键直接生成就好 1234567891011private int age;// 1.返回类型必须是void // 2.方法名是set+成员变量名字的首字母大写 public void setAge(int age){ this.name= name}public int getAge(int age){ return age} 方法的调用1.调用非静态方法 对象名.方法名（）2.调用静态方法 类名.方法名() 方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。目的：功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。 方法重写子类重写了父类的方法注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法 内部类java允许在一个类的类体里再定义一个类，该情况下外面的类叫外部类，里面的叫内部类内部类可以访问其所在内部类的所有属性 成员内部类在外部类的内部定义一个类 静态内部类非静态内部类局部内部类匿名内部类抽象类抽象类是类和类之间的共同特征，将这些共同特征进一步形成抽象类， 抽象类的意义抽取共性时，无法确定方法体，就把方法定义为抽象抽象类作为子类的模版，强制子类按照格式书写，避免子类设计的随意性 定义抽象类和抽象方法抽象方法只需在抽象类中，提供声明，不需要实现即没有方法体 有抽象方法的类只能被定义为抽象类，但抽象类中可以没有抽象方法 final和abstract不能同时同时使用，这两个关键字是对立的。抽象方法不能被 final 修饰，因为抽象方法就是被子类实现的 抽象类的子类可以是抽象类。也可以是非抽象类 一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖/重写/实现，因此不能用private修饰抽象方法 由于类本身不存在，所以抽象类无法实例化创建对象。只可以通过抽象类派生出新的子类，再由其子类来创建对象 语法格式： 12345678910//抽象类定义public abstract class 类名{ //抽象方法，没有{}括起来的方法体 public abstract 返回值类型 方法名（参数列表）; public void call(){}. //空方法} 抽象类的子类写一个子类继承抽象类，重写抽象方法虽然不能直接new一个抽象类，但可以先声明一个抽象类变量，再用这个变量指向其子类对象 1抽象类名 a = new 子类名(); //抽象类变量指向子类对象 接口接口规定一批类必须提供某些方法，但不提供实现方法不能用final关键字修饰接口当多个对象不能够抽象出共同的父类，但有共同的行为，这种情况下就需要将这种行为封装成接口。 接口与类的区别接口不能用于实例化对象接口没有构造方法接口中所有方法必须是抽象方法接口中不能包含成员变量，除了static和final变量接口不是被类继承了，而是被类实现了接口支持多重继承 接口成员特点接口是隐性抽象的，接口中的每个方法也是隐形抽象的，声明时不必使用abstract关键字接口访问符可以是public或默认，默认是采用包权限访问控制，即在相同包内才可以访问该接口 接口的成员变量被隐含地声明为public static final，只能是静态常量 接口没有构造方法 接口的成员方法被隐形指定为public absrtactjdk7接口只能定义抽象方法，jdk9后接口可以定义有方法体的方法(默认，静态)和私有方法默认方法，静态方法，私有方法 定义接口用关键字interface定义 12345678910111213访问符 interface 接口名 {//接口定义的只能是静态常量int a = 5;//接口定义的普通方法只能是public的抽象方法void display();//接口中定义默认方法，用default修饰default void print(int b){}//接口中定义类方法，用static修饰static void del(){}} 实现接口接口不能实例化接口和类是实现关系，用implements实现接口，可以单实现，也可以多实现，必须实现接口中定义的所有抽象方法，语法格式： 12345678910111213访问符 class 实现类名 implements 接口1，接口2{}public static void main (String[]args){//先声明一个接口类型的变量，new一个该接口实现类的实例对象，并将其引用赋值给变量接口名 变量名 = new 接口实现类（）;//调用接口的默认方法，必须通过实例对象来调用变量名.默认方法（）;//调用接口的类方法接口名.类方法（）;//声明接口实现类的变量，并实例化该类型对象接口实现类名 变量名 = new 接口实现类名（）;} 接口的继承接口可以继承多个接口，不能继承类使用interface可以声明一个接口： 1234interface Person { void run(); String getName();} 属性只能是常量 一个类可以实现多个interface，例如： 123class Student implements Person, Hello { // 实现了两个interface ...} 面对对象对象是类的一个实例，有状态和行为 对比面向过程，是两种不同的处理问题的角度，面向过程注重于每个过程的步骤及顺序 面向对象更注重于事情有哪些参与者即对象，以及各自需要做什么。 面向过程比较直接高效，而面向对象更易于复用，扩展和维护。 面向对象有三大特性：封装，继承，多态 创建对象创建类的对象分为两步1.定义该类的一个变量，此时在栈上会分配空间储存对象在堆中的地址（即对象的引用）2.创建该对象的实际物理空间，即在堆中为该对象分配空间，并把此空间的地址（即引用）赋给对象名，此步骤通过new关键字来实例化该类的一个对象 1234类名 对象名=new 类名(); //创建实例对象 对象名.属性名; //访问对象的属性 对象名.方法名(); //调用对象的方法 面向对象三大特征封装封装：告诉我们如何正确的设计对象的属性和方法 原则：对象代表什么，就得封装对应的数据，并提供数据对应的行为。比如人画圆，就得设计一个人类和一个圆类，画圆这个方法要在圆类定义，因为要根据半径画圆 封装的好处：让编程变得简单，有什么事，找对象，调用方法即可 封装的意义：在于明确标识出与允许外部使用的所有成员变量和成员方法 实际上就是信息隐藏，将类中的成员属性和成员方法修饰为私有化，数据被保护在对象的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系，即get/set方法。 其他对象只能通过该对象提供的get/set方法，与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外提供的接口来访问该对象。 访问控制修饰符 如果有很多代码都使用了Dog这个类；当某一天这个类的age属性需要换成String类型，那么，外部使用它的任何地方都需要需改xxx.age=”xxx”，这将是非常繁琐的一个过程，那该怎么办呢？很简单，使用private修饰符将属性封装，开放访问接口的方法，我们只需要修改一下set方法就能完美解决。 1234567891011121314151617public static void main(String[] args) { Dog d1 = new Dog(); //调用时发生变化 d1.setName(\"旺财\"); d1.setAge(3); }}class Dog{ private String age;//修改为String类型 private String name; //将属性私有化，提供set方法，将int类型的值转成String public void setAge(int age) { this.age = String.valueOf(age); } public void setName(String name) { this.name = name; } 这样外部使用它的地方都不用修改，我们只用简单的修改对象内部就可以了，更加方便快捷。到了这里我们应该可以看出，封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。 这里还可以体现出一些封装属性的优势，案例如下： 12345678910111213141516171819202122public static void main(String[] args) { Dog d1 = new Dog(); d1.setName(\"旺财\"); d1.setAge(300);//狗的年龄赋值很明显不合理，这里就需要在set方法中给出提示 }}class Dog{ private String age; private String name; public void setAge(int age) { if(age&gt;100||age&lt;0) { System.out.println(\"你见过超过100岁的狗狗吗？\"); }else { this.age = String.valueOf(age); } } public void setName(String name) { this.name = name; } } 继承作用：子类通过extends关键字继承父类，通过继承，子类可以使用父类中的非私有属性和非私有方法，从而提高代码的重用性，提高开发效率。 子类自动获得了父类的所有字段，严禁定义与父类重名的字段！为了让子类可以访问父类的字段，把private改为protected。用protected修饰的字段可以被子类访问除了父类中私有的属性和方法，子类必须全部继承。3、子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。4、子类可以用自己的方式实现父类的方法（即方法的重写/覆盖）。 5、构造器而言，它只能够被调用，而不能被继承，子类可以使用super()调用父类构造器。6、对于继承而已，子类会默认调用父类的无参构造，但是如果父类没有无参构造，子类必须要在其构造方法中的第一行代码调用指定父类的构造器，传递对应参数。7、Java 的继承是单继承，即每个子类只能拥有一个直接父类，但是该父类可以有多个子类 语法格式访问符 修饰符 class 子类 extends 父类{ } 多态多态的定义：是同一个行为具有多种表现形式或形态的能力。简单来说就是不同类型的对象（父类或子类）调用同一个方法，根据发出调用的对象不同，执行的方法也就不同。 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 多态的作用：消除类型之间的耦合关系。 这里举一个简单的小例子：父类是个农民，技能是使用锄头耕地。子类继承了父类，重写了父类的锄头耕地技能，更新换代为使用拖拉机耕地。如果是父类对象调用这个技能，就是使用锄头手动耕地，如果是子类对象调用这个技能，就是使用拖拉机耕地。 java实现多态有三个必要条件：继承、重写、父类引用指向子类对象。 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 父类引用指向子类对象（向上转型）：在多态中需要将子类的引用赋给父类对象，只有这样引用才能够调用父类的方法和子类的方法。父类类型 变量名 = new 子类对象 注意：由于父类引用指向子类对象属于向上转型，它只能访问父类中拥有的方法和属性，无法调用子类特有的方法(子类中存在而父类中不存在的方法)，比如说方法的重载，尽管方法名称相同，但是父类只能调用到子类重写的方法，调用不到重载方法。 123456789101112131415161718192021222324252627282930public class People {//人类 作为所有职业的父类 public int age; public String name; void work() {//父类的方法 System.out.println(\"劳动\"); } public static void main(String[] args) { //父类引用指向子类对象就是多态性的体现 People p1 = new Doctor();// p1的类型是人类类型，但是指向的实例对象是医生 p1.work();//父类引用发出的调用，调用到的是医生类中重写父类的方法 People p2 = new Teacher(); p2.work();//父类引用发出的调用，调用到的是教师类中重写父类的方法 } } class Doctor extends People{ @Override void work() {//医生类继承人类，重写工作方法 System.out.println(\"救死扶伤\"); } }class Teacher extends People{ @Override void work() {//教师类继承人类，重写工作方法 System.out.println(\"教书育人\"); }} 12345678910 class Teacher extends People{ @Override void work() {//教师类继承人类，重写work方法 System.out.println(\"教书育人\"); } void work(String name) {//重载了work方法，但是此方法父类引用无法调用 System.out.println(\"负责教导的课程是\"+name); }} 多态的好处： 1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如：医生、律师、程序员都是人类的子类，根据使用场景不同随时可以替换为符合的职业。2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在拥有了医生、律师的继承上，还可以继续添加新的职业，比如主播，运动员等，都是添加为人类的多态性。3.接口性（interface-ability）。多态是超类通过抽象方法，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。每个子类都可以根据自身的特性去重写父类的抽象方法。4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 类之间的关系继承依赖关系在一个类的方法中操作另一个类的对象，则称其依赖于第二个类例如方法的参数时某个类的对象 关联关系体现为一个类中使用另一个类的对象作为该类的成员变量 聚合关系聚合关系是关联关系的一种特例，体现是整体与部分的关系，表现为一个类（整体）由多个其他类的对象（部分）作为该类的成员变量 组成关系java数组数组是一种容器，它用一组连续的内存空间，存储固定大小的同类型(考虑隐形转换)元素，是一种线性表数据结构 数组存储的弊端1). 一旦初始化以后，其长度就不可修改。2). 数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。3). 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用4). 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。 定义数组 1.静态初始化：手动指定数组元素，而数组的长度由系统（JVM）来决定；如果明确了要操作的具体数据，直接静态初始化即可1234// 语法格式：数组类型[] 数组名= new 数组类型[]{元素1,元素2,…,元素n,};数组类型[] 数组名 = {元素1,元素2,…,元素n,}; //简化定义 2.动态初始化：手动指定数组长度，每个数组元素的初始值由系统来决定。【与静态初始化特点相反】；只明确元素具体个数1数组类型[] 数组名= new 数组类型[ length ]; 动态初始化数组默认初始化值规律整数类型默认为0浮点数型：0.0字符型：’/u0000’ 即空格布尔类型：false引用数据类型：null 集合概念：对象的容器，定义了对多个对象进行操作的常用方法，可以实现数组的功能都是Object类型 集合的优点解决数组存储数据方面的弊端。 与数组的区别： 数组长度固定，集合长度不固定。 数组可以存储基本类型和引用数据类型，集合只能储存引用类型 3.集合也不能直接存储java对象，集合当中存储的都是java对象的内存地址。（或者说集合中存储的是引用。）位置：java.util.*; Collection接口Collection接口被List和Set接口继承 常用方法boolean add(Object e) 向集合中添加一个元素对象boolean addAll(Collection c) 将一个集合的所有对象添加到此集合中int size() 获取集合中元素的个数 boolean remove(Object o) 删除集合中的某个元素。void clear() 清空集合 boolean contains(Object o) 判断当前集合中是否包含元素o，boolean aquals(object o) //比较此集合与指定对象是否相等。 boolean isEmpty() 判断该集合中元素的个数是否为0Object[] toArray() 调用这个方法可以把集合转换成数组。【作为了解，使用不多。】 123Collection c = new ArrayList();c.add(1200); // 自动装箱(java5的新特性。),实际上是放进去了一个对象的内存地址。 List(列表)接口与实现类List接口：有序，有下标，元素可重复 ArrayList类（常用）ArrayList：作为List接口的主要实现类；线程不安全的(非线程安全。)，效率高；底层使用Object[] elementData存储.集合底层采用了数组这种数据结构，ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。 123456// jdk 8中ArrayList的变化:ArrayList list = new ArrayList(); //底层Object[] elementData初始化为{}.并没创建长度为10的数组list.add(123); //第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0] … 如果此次的添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。// 结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)// 使用带参构造器事先确定数组长度，避免底层的默认自动扩容，提高了效率 LinkedListLinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储. Java LinkedList 类是List和Deque接口的双向链表实现。它实现了所有可选的列表操作，并允许所有元素（包括空值）。 Java LinkedList特性 双向链表实现，实现了 List 和 Deque 接口。因此，它也可以用作队列、双端队列或者堆栈。 允许所有元素，包括重复项和 NULL。 LinkedList 维护元素的插入顺序。 它不是同步的。如果多个线程并发访问一个链表，并且至少有一个线程在结构上修改了链表，则必须进行外部同步。 使用 Collections.synchronizedList(new LinkedList()) 获取同步链表。 此类返回的迭代器是快速失败的，可能会抛出 ConcurrentModificationException。 它没有实现 RandomAccess 接口。 LinkedList的方法 123456789101112131415boolean add(Object o) ：将指定的元素添加到列表的末尾。void add(int index, Object element) ：在列表中的指定位置索引处插入指定元素。void addFirst(Object o) ：在列表的开头插入给定的元素。void addLast(Object o) ：将给定元素添加到列表的末尾。int size() : 返回列表中元素的数量boolean contains(Object o) : 如果列表包含指定元素，则返回 true，否则返回 false。boolean remove(Object o) ：删除列表中第一次出现的指定元素。Object getFirst() ：返回列表中的第一个元素。Object getLast() ：返回列表中的最后一个元素。int indexOf(Object o) ：返回指定元素第一次出现在列表中的索引，如果列表不包含指定元素，则返回 -1.lastIndexOf(Object o) ：返回指定元素最后一次出现在列表中的索引，如果列表不包含指定元素，则返回 -1.Iterator iterator() ：以适当的顺序返回此列表中元素的迭代器。Object[] toArray() ：以适当的顺序返回一个包含此列表中所有元素的数组。List subList(int fromIndex, int toIndex) ：返回此列表中指定 fromIndex（包含）和 toIndex（不包含）之间的部分的视图。 Vector集合底层采用了数组这种数据结构，线程安全的，所有的方法都有synchronized关键字修饰，比较安全但效率低，所以使用率低 Set(集)接口与实现类Set接口：无序，无下标，元素不能重复 HashSet(Hash 表)TreeSet(二叉树)泛型和工具类Map(映射)接口与实现类Map用于保存具有映射关系的数据，Map里保存着两组数据：key和value，它们都可以使任何引用类型的数据，但key不能重复。所以通过指定的key就可以取出对应的value。 map中的containsKey（key）方法是判断该key在map中是否有key存在。如果存在则返回true。如果不存在则返回false。 HashMap1234Map&lt;Integer,String&gt;map =new HashMap&lt;&gt;();map.put(1,\"a\");map.put(2,\"b\");System.out.println(map.get(1)); //获取键为1的值 HashTableTreeMapLinkedHashMapJava泛型Java 泛型（generics）是 JDK 5 中引入的一个新特性泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。检查并限制传入参数的类型，消除了类型的强制转换。 java 中泛型标记符即类型形参： E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ？ - 表示不确定的 java 类型 泛型类泛型类的定义语法 123class 类名&lt;泛型标识，泛型标识，....&gt;{ private 泛型标识 变量名;} 使用语法 1类名&lt;具体的数据类型&gt; 对象名 = new 类名&lt;&gt;(); 12345678910111213141516171819public class Generic&lt;T&gt; {} //定义一个泛型类//泛型类型在逻辑上可以看成多个不同的类型，但实际上都是相同类型，即Generic类Generic&lt;String&gt; generic = new Generic&lt;&gt;(\"Hello\"); //初始化类对象Generic&lt;Integer&gt; generic1 = new Generic&lt;&gt;(1223); Generic&lt;int&gt; generic1 = new Generic&lt;&gt;(1223); //报错，泛型的类型参数只能是类类型，不能是基本数据类型//如果没有指定具体的数据类型，此时泛型类的操作类型是ObjectGeneric&lt;&gt; generic = new Generic&lt;&gt;(\"Hello\"); 泛型接口泛型方法你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。 下面是定义泛型方法的规则： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像 int、double、char 等）。 定义语法规则 12345//&lt;T,E,..&gt;声明是泛型方法修饰符 &lt;T,E,..&gt; 返回值类型 方法名 (形参列表){ 方法体；} 12345678910111213/** * @description: * @parmesan&lt;E&gt; 泛型标识，具体类型由调用方法的时候来指定 * @return {*} */public &lt;E&gt; E getProduct (ArrayList&lt;E&gt; list){ return list.get(random.nextInt(list.size()));}//调用泛型方法ArraryList&lt;String&gt; strList = new ArraryList&lt;&gt; ();getProduct(strList); //传入strList集合对象 习题简答题1、java源程序在控制台环境下编译和运行的命令是什么？编译之后生成了什么文件？编译Javac name.java 生成.class文件运行Java name 2．Java的数据类型分为哪几种？请列举出8个Java的基本数据类型。 byte short int long double float char boolean 继承的主要作用是什么？如何使用一个子类继承一个父类？通过继承，子类可以使用父类的非私有属性和非私有方法，从而提高代码重用性，提高开发效率 4、continue的功能是什么？break的功能是什么？两者的区别？continue跳出本次循环，直接执行下一次循环break直接跳出本层循环 toString 方法的功能是什么？如何使用toString 来实现方法重写？toString()将对象的内容转换为字符串当需要将一个对象输出到显示器时,通常要调用他的toString()方法,将对象的内容转换为字符串.java中的所有类默认都有一个toString()方法 默认情况下 System.out.println(对象名)或者System.out.println(对象名.toString())输出的是此对象的类名和此对象对应内存的首地址 如果想自定义输出信息必须重写toString()方法 12345678/*注意事项1.必须被声明为public2.返回类型为String3.方法的名称必须为toString,且无参数4.方法体中不要使用输出方法System.out.println()语法格式为*/public String toString(){ } 6、构造方法的作用是什么？在创建对象时，初始化对象的属性 什么是抽象方法？什么是抽象类？抽象类就是不能使用new方法进行实例化的类，即没有具体实例对象的类抽象方法：抽象方法就是以abstract修饰的方法，这种方法只声明返回的数据类型，方法名称和所需要的参数，没有方法体，这个方法必须被子类的方法所重写 8 什么是类间的依赖关系？什么是类的关联关系？什么是类的聚合关系？什么是类的组成关系？ 依赖关系在一个类的方法中操作另一个类的对象，则称其依赖于第二个类例如方法的参数时某个类的对象 关联关系体现为一个类中使用另一个类的对象作为该类的成员变量 聚合关系是关联关系的一种特例，表现为一个类（整体）由多个其他类的对象（部分）作为该类的成员变量 super关键字的主要作用是什么？对于有继承关系的类，子类可以通过这个关键字调用父类中的方法写法，即 super（构造方法名），而且必须是这个构造方法的第一句。在子类的构造方法中调用父类的构造方法在子类方法访问父类的属性和方法 this代表什么？this大部分情况下是可以省略的，请说明什么时候不能省略this。this是一个变量，保存了当前对象的内存地址，指向这个对象自身。this代表的就是 “当前对象”在实例方法或者构造方法当中，为了区分同名的局部变量和实例变量，this不能省略 Java中包含哪几种内部类？什么是成员内部类？什么是局部内部类？什么是最终类？包含：成员内部类、局部内部类、静态内部类、匿名内部类成员内部类：在“外部类”的内部定义一个类，作为一个成员存在，与外部类的属性、方法并列局部内部类：在方法中定义的内部类称为局部内部类，不仅可以访问包含它的外部类成员，还可以访问局部变量最终类：最终类有final关键字修饰，最终类不可被继承 什么是类？类里面包含什么？什么是对象？两者之间的区别是什么？类：类是具有相同属性和方法的一组对象的集合类包含字段和方法对象：对象是一具体事物区别：对象是类的一个实例，拥有类定义的属性和方法 java中有哪几种注释？分别用什么符号表示？单行注释：//多行注释：从“/”开始到“/”结束，文档注释：从“/*”开始到“/”结束文档注释可以用javadoc命令提取出来，生成类似于jdk文档的网页文件，以便于他人了解一个类的功能。 什么是缺省构造器？它的作用是什么？缺省构造器什么时候无法产生作用？如果一个类没有定义构造方法，编译器会自动创建一个缺省构造器作用在创建对象时初始化对象的属性如果你已经定义了一个无参构造方法， public、private、protected三个访问控制符代表了不同的访问级别，请分别进行说明。public公共访问权限，可被同一包或不同包的所有类访问protected子类访问权限，可以被同一包的其它类访问，也可以被其他包的子类访问friendly包访问权限，如果没设置访问符则默认friendly包访问权限，可被同一包中所有类访问private 当前类访问权限，只能被当前类的其它成员访问 什么是多态？多态在代码中的表现形式是什么？多态的作用？同一个对象在不同阶段，多种状态表现形式：继承、重写、父类引用指向子类对象作用：可以将子类对象直接赋值给一个父类引用变量，无须任何类型转换 一个”.java”源文件中是否可以包括多个类(不是内部类)?有什么限制?可以，但只能有一个public类，并且public的类名必须和文件名一致 final关键字的主要作用是什么？被final关键字修饰的类不能被继承，被final关键字修饰的类属性和类方法不能被覆盖（重写）； 什么是接口？接口如何定义？接口中能够包含哪些方法？接口和类在继承方面的区别。接口可以定义抽象方法，默认方法，类方法接口可以多继承，即一个接口可以继承多个接口类只能单继承，一个子类只能有一个直接父类 什么是方法重载？什么是方法重写？两者的区别？方法重载是指在同一个类中定义多个同名的方法，但要求每个方法具有不同的参数类型或者参数个数方法重写是指在子类创建一个与父类中除了方法体的实现不同外，其它都相同的方法，以便实现不同于父类的功能 判断一个变量的数据是奇数还是偶数12345678910111213141516171819public class Test { public static void main(String[] args) { judgeNum(2); judgeNum(3);}/*** 判断是奇数还是偶数的方法* @param num*/public static void judgeNum(int num) { if(num % 2 == 0) { System.out.println(num + \"是偶数\");} else { System.out.println(num + \"是奇数\");}}} 计算 1000 以内不能被 7 整除的整数之和。1234567891011public class Test02 { public static void main(String[] args) { int s=0; for(int i=1;i&lt;=1000;i++){ if((i%7)!=0){ s=s+i; } } System.out.println(s); }} 计算 1+2-3+4-5+…+100 的结果。12345678910111213141516171819public class Method03 { public static void main(String[] args) { int res = getSum(); System.out.println(res); } /* 返回值类型: int 方法名称： getSum 参数列表： */ public static int getSum(){ int sum = 0; for (int i = 1; i &lt;= 100; i++) { sum += i; } return sum; } 定义一个方法，计算某个整数的阶乘。1234567891011121314public class Method04 { public static void main(String[] args) { int res = jieCheng(5); System.out.println(res); } public static int jieCheng(int num) { int result = 1; for (int i = num; i &gt; 1; i--) { result *= i; } return result; }} 定义一个方法，判断某个整数是否为质数。（质数是指大于 1 的自然数中，除了 1 和它本身之外不再有其它因数的自然数。） 12345678910111213141516171819202122232425public class Test02 { public static void main(String[] args) { System.out.println(prime(3)); } //定义方法 public static boolean prime(int n) { //先判断小于0的 if (n &lt; 0) { return false; } if (n == 1 || n == 2) { return true; } else { int a = (int) Math.sqrt(n); //如9%3=0 他除了1合本身还有别的数 for (int i = 2; i &lt;= a; i++) { if (n % i == 0) { return false; } } return true; } }} 小红的妈妈每天都会给她 2.5 元钱，她都会存起来。但是，如果这一天是存钱的第 5 天或者是 5 的倍数的话，她都会花去 6 元。请问：经过多少天，小红才可以存到 100 元钱。 123456789101112131415public class XiTi5 { public static void main(String[] args){ double sum = 0; for(int i=1;;i++){ sum = 2.5 + sum; if(i%5==0){ sum = sum-6; } if(sum&gt;=100){ System.out.println(\"经过\"+i+\"天可以存到100元钱\"+\",\"+\"钱的总数是\"+sum+\"元\"); break; } } }} 水仙花数一个数如果是一个三位数，并且它的十位、个位、百位的数字立方和等于它本身，这个数就叫做水仙花数。例如：371 = 3 的立方+7 的立方+1 的立方。 请求出所有水仙花数。 123456789101112131415public class XiTi6 { public static void main(String[] args) { int a,b,c,s; for(int i=100;i&lt;1000;i++) { c=i%10; b=(i/10)%10; a=i/100; if(Math.pow(a,3)+Math.pow(b,3)+Math.pow(c,3)==i) { System.out.print(\" \"+i); } } }} 求出数组中的最大值[5, 15, 30, 20, 1000] 12345678910111213141516public class Array03 { public static void main(String[] args) { int[] array = {5, 15, 30, 20, 1000}; int max; max = array[0]; for (int i = 1; i &lt; array.length; i++) { if(array[i] &gt; max) { max = array[i]; } } System.out.println(\"max:\" + max); }} 数组元素反转本来：[10, 30, 20, 40, 50]结果：[50，40, 20, 30, 10]要求不能使用新数组，就用原来的唯一一个数组。 12345678910111213141516171819202122232425262728293031323334public class Array04 { public static void main(String[] args) { int[] array = {10, 20, 30, 40, 50}; //遍历打印数组本来的样子 for (int i = 0; i &lt; array.length; i++) { System.out.println(array[i]); } System.out.println(\"==================\"); /* 初始化语句： int min = 0, max = array.length - 1; 条件判断： min &lt; max 步进表达式： min++, max-- 循环体：交换 */ for(int min = 0, max = array.length - 1; min &lt; max; min++, max--) { //交换 int temp = array[min]; array[min] = array[max]; array[max] = temp; } for (int i = 0; i &lt; array.length; i++) { System.out.println(array[i]); } }} 对象数组定义一个数组，用来存储 3 个 Person 类的对象break &amp; continue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class Person { //属性 == 实例变量 private String name; private int age; //构造方法 public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } //setter getter public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}public class PersonTe { public static void main(String[] args) { //首先创建一个长度为3的数组，用来存放Person类型的对象 Person[] array = new Person[3]; System.out.println(array[0]); //创建3个对象 Person p1 = new Person(\"ZhangSan\", 18); Person p2 = new Person(\"ZhangSa\", 19); Person p3 = new Person(\"Zhang\", 20); //赋值 array[0] = p1; array[1] = p2; array[2] = p3; System.out.println(array[1].getName()); }}public class PersonTest { public static void main(String[] args) { Person01 p1 = new Person01(); p1.name = \"ZhangSan\"; p1.sayHello(\"Lisi\"); System.out.println(p1); }}class Person01{ //实例变量 String name; //实例方法 public void sayHello(String name) { System.out.println(name + \" , hello, I am \" + this.name); System.out.println(this); }} 实现一个 student 类包含属性：name age address zipCode要求：全部属性都私有化，并提供相应的 get/set 方法以及无参构造方法和有参构造方法。并为该类添加一个方法，返回 student 对象的地址和邮编。最后编写测试类，返回自己的地址邮编。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Student { //实例变量 private String name; private int age; private String address; private String zipcode; //静态变量：类级别 static String job = \"study\"; //无参构造 public Student(){ } //有参构造 public Student(String name, int age, String address, String zipcode) { this.name = name; this.address = address; this.age = age; this.zipcode = zipcode; } //返回地址和邮编 public String getPostAddress() { return \"地址：\" + this.address + \" , 邮编：\" + this.zipcode; //return \"地址：\" + this.g + \" , 邮编：\" + this.zipcode; } public void study() { System.out.println(this.getName() + \"is studying.\"); } //静态方法 public static void testStatic() { System.out.println(\"static\"); } //getter and setter public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}public class StudentTest { public static void main(String[] args) { Student s1 = new Student(); s1.setName(\"XiaoMei\"); s1.setAge(20); System.out.println(s1.getName() + \",\" + s1.getAge()); Student s2 = new Student(\"XiaoMing\", 18, \"佛山\", \"374893748\"); System.out.println(s2.getPostAddress()); }} 实现一个日期类，表示年月日信息。要求：全部属性都私有化，并提供相应的 get/set 方法以及无参构造方法和有参构造方法。如果调用无参构造方法，默认创建的日期为 1970 年 1 月 1 号。并为该类添加一个可以打印日期的方法。最后编写测试类输出 2022 年 1 月 1 日。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Date { //实例变量 private int year; private int month; private int day; //无参构造 public Date() { this.year = 1999; this.month = 1; this.day = 1; } //有参构造 public Date(int year, int month, int day){ this.year = year; this.month = month; this.day = day; } //setter and getter public void setYear(int year) { //设立关卡 this.year = year; } public int getYear() { return year; } //打印的日期方法 public void printDate() { //System.out.println(this.year + \"年\" + this.month + \"月\" + this.day + \"日\"); //System.out.println(year + \"年\" + month + \"月\" + day + \"日\"); System.out.println(this.getYear() + \"年\" + this.month + \"月\" + this.day + \"日\"); }}public class DateTest { public static void main(String[] args) { Date d1 = new Date(); d1.printDate(); Date d2 = new Date(2021, 11, 16); //System.out.println(d2.printDate()); }} 继承和方法覆盖： 1、编写程序模拟 主人 喂养 宠物 的场景。主人养了一只狗作为宠物，主人会喂狗，只要主人喂狗，狗就吃最后输出：主人喂了食物，狗吃的很香过了一段时间，主人又养了一个新的宠物：猫咪最后输出：主人喂了食物，猫吃的很香 12345678910111213141516171819202122232425262728293031323334353637383940414243class Testfeed{ public static void main(String[] args) { //创建一个宠物对象 Pet pet = new Pet(); //创建一个狗对象 Dog dog = new Dog(); //创建一个主人对象 Master master = new Master(); //调用主人投喂方法 master.feed(dog); }}class Pet{//创建宠物类让其它类都继承他 public void eat(){//创建宠物吃方法 System.out.println(\"动物在吃\"); }}class Dog extends Pet//创建狗类{ public void eat(){//覆盖父类吃方法对吃方法重写 System.out.println(\"狗在吃\"); }}class Cat extends Pet{ public void eat(){ System.out.println(\"猫在吃\"); }}class YingWu extends Pet{ public void eat(){ System.out.println(\"鹦鹉在吃\"); }}class Master{ public void feed(Pet p){//此处实际上是 Pet p = new Dog();此处涉及到父类引用指向子类对象，即多态 p.eat();//调用父类吃方法，此处为编译器识别通过，具体调用哪个子类的吃方法还要看动态绑定的那个子类是啥 }} 2、编写程序实现乐手弹奏乐器，可以弹奏不同的乐器从而发出不同的声音。乐器包括：二胡、钢琴和琵琶实现乐器类 Instrument, 包括方法 makeSound()通过测试类，让乐手弹奏不同的乐器参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void play(Instrument instrument){ instrument.makeSound() }//测试类public class TestMusic { public static void main(String[] args) { Musician m = new Musician(); Violin v = new Violin(); m.play(v); }}//乐器类class Instrument{ public void makeSound(){ System.out.println(\"乐器发声\"); }}//二胡class Erhu extends Instrument{ public void makeSound(){ System.out.println(\"二胡在拉\"); }}//钢琴class Piano extends Instrument{ public void makeSound(){ System.out.println(\"弹钢琴\"); } }//小提琴class Violin extends Instrument{ public void makeSound(){ System.out.println(\"拉小题琴\"); } }class Musician{ public void play(Instrument i){ i.makeSound(); }} 接口：（要求用多态实现） 面试什么是面向对象对比面向过程，是两种不同的处理问题的角度，面向过程注重于每个过程的步骤及顺序 面向对象更注重于事情有哪些参与者即对象，以及各自需要做什么。 面向过程比较直接高效，而面向对象更易于复用，扩展和维护。 面向对象有三大特性：封装，继承，多态","categories":[{"name":"java","slug":"java","permalink":"https://wenkex.gitee.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wenkex.gitee.io/tags/java/"}]},{"title":"git和github","slug":"git与github","date":"2021-11-20T13:42:04.000Z","updated":"2022-08-29T03:56:33.413Z","comments":true,"path":"2021/11205629.html","link":"","permalink":"https://wenkex.gitee.io/2021/11205629.html","excerpt":"","text":"git使用安装gitGit是一个分布式代码管理工具，可以在本地提交，不需要依赖网络，并且会将每次提交自动备份到本地。每个开发者都可以把远程仓库clone一份到本地，并会把提交历史一并拿过来。 官网下载 按照安装向导来安装Git，相关参数勾选为默认即可 安装完成后，右键菜单栏会出现Git GUI和Git Bash git bash使用 复制 ctrl + insert 粘贴 shift + insert git设置http全局代理由于国内访问github困难，在克隆Github仓库时，git无法连接GitHub。因此需要git设置http全局代理 将下方命令的端口填入clash的端口7890,并在命令行中输入，git即可顺利连接GitHub 1234567#git设置全局http代理和https代理git config --global http.proxy 127.0.0.1:端口git config --global https.proxy 127.0.0.1:端口#取消这两个全局代理git config --global --unset http.proxygit config --global --unset https.proxy 在vscode使用gitgit-commit-plugin：自动生成规范 git 提交信息的插件。 使用组合键 ctrl + Shift + P 呼出 指令行，并键入指令 show git commit template 或者点击 git 插件栏上的小图标唤醒插件界面。 GitLens 增强了VS Code 中的 Git，并解锁了每个存储库中未开发的知识。它可以帮助您通过 Git 责备注释和 CodeLens直观地可视化代码作者身份，无缝导航和探索Git 存储库，通过丰富的可视化和强大的比较命令获得有价值的见解等等。 联系多个仓库要想与多个远程仓库的分支建立联系，可以使用 git remote add 指令添加其他的远程仓库，取个与origin不一样的别名就可以啦 git工作区域Git有四个工作区域 工作区（Working Directory)：就是你平时存放项目代码的地方 暂存区(Stage/Index)：用于临时存放你的改动，事实上是一个保存即将提交到文件列表信息的文件git add . 本地仓库(Repository或Git Directory)：就是安全存放数据的位置，这里面有你提交到所有版本的数据，其中HEAD指向最新放入仓库的版本 远程仓库(Remote Directory)：托管代码的服务器 关联本地项目与远程仓库并推送 https 123#在本地文件夹中进入终端，克隆仓库#git clone [url]git clone https://github.com/wenkexia/AI.git 选择ssh方式关联仓库Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 1234567git init #创建一个本地仓库touch READ.md # 一定要创建# git remote add origin [SSH key]git remote add origin git@github.com:PanXF-HUST/test.git #关联远程仓库git remote -v #命令查看关联状况 git命令git管理的文件有三种状态：已修改（modified）、已暂存（staged）、已提交（committed） 123git add .git commit -m 'first'git push -u origin main 使用git bash操作 1234567891011121314151617181920git config -l #查看系统配置git status #查看所有文件状态git status [filename] #查看指定文件状态git log #查看提交的详细信息git add . #暂存当前分支所有本地修改的文件git commit -m 'logs' #提交暂存区到本地git仓库中 logs：本次修改的描述git show id #在推送(push)操作之前，如想要检查文件代码变化，指定提交ID来查看具体的变化。#如果对上面的提交修改没有疑义，则我们就可以将文件代码推送到远程存储库中git push -u origin \"分支\" #将本地修改内容提交至远程，-u设置默认分支#git fetch + git merge 更安全，等价于git push origin \"分支\" git fetch origin master #先抓取远程仓库的更新到本地,如果有冲突就要解决冲突后再合并git merge origin FETCH_HEAD #然后与你的本地仓库合并 git push命令详解12345678910111213141516git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;#将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。git pull origin master:brantest#如果远程分支是与当前分支合并，则冒号后面的部分可以省略。git pull origin master# 把本地库的内容推送到远程，第一次使用加上了-u参数，是推送内容并关联分支。git push -u origin maingit push -f origin main #强制更新git push -f 或者 git push --force 分支名 #利用强覆盖方式用你本地的代码替代git仓库内的内容 分支相关分支允许您创建原始主要工作项目的新的、独立的版本。您可以创建一个分支来编辑它以进行更改、添加新功能或在尝试修复错误时编写测试。一个新的分支可以让你在不以任何方式影响主代码的情况下做到这一点。 总而言之 - 分支让您可以在不影响核心代码的情况下更改代码库，直到您完全准备好实施这些更改。 123456789101112git branch #查看本地分支 git branch -a #查看全部分支(包含本地和远程git checkout branch_name #切换分支git branch -d local_branch_name #删除本地分支，如果分支包含未合并的更改和未推送的提交，则不允许删除git branch -D local_branch_name #强制删除本地分支git push origin --delete \"分支名称\" #删除远程分支git branch [branchname] #创建分支 git重新关联远程分支取消与当前远程仓库的关联 12345678// 查看远程仓库git remote show origin// 查看当前分支关联的远程分支git branch -vv// 取消与远程仓库关联git remote remove origin (2) 重新添加需要关联的远程仓库 git remote add origin git@xxxxx:xxx/xxx.git(3) 提交到远程分支 123456// 首先pull一下git pull origin develop// 然后提交至远程分支git push --set-upstream origin develop 忽略文件有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立”.gitignore”文件，此文件有如下规则： 1.忽略文件中的空行或以井号(#)开始的行将会被忽略。2.可以使用Liux通配符。例如：星号(*)代表任意多个字符，问号(？)代表一个字符，方括号([abc])代表可选字符范围，大括号({string1,string2})代表可选的字符串等。3.如果名称的最前面有一个感叹号(！)，表示例外规则，将不被忽略。4.如果名称的最前面是一个路径分隔符(/)，表示要忽略的文件在此目录下，而子目录中的文件不忽略。5.如果名称的最后面是一个路径分隔符(/)，表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 出现的问题问题一https://blog.csdn.net/u010483897/article/details/87799685在提交更改时出现commit or discard the untracked or modified content in submodules原因是有个别文件夹内还有.git文件，删除就可以了 github使用github文档GitHub 中文教程 键盘快捷键shift + ？:查看快捷键. ： 打开网络编辑器 GitHub鏡像站https://www.library.ac.cn/https://hub.fastgit.xyz/https://raw.hellogithub.com/https://hub.gitfast.tkhttps://hub.gitslow.tkhttps://hub.verge.tkhttps://raw.gitfast.tkhttps://raw.gitslow.tkhttps://raw.verge.tk GitHub加速下载https://hub.fastgit.org/https://ghproxy.com/ 加速访问GitHub参考文章参考https://zhuanlan.zhihu.com/p/364453651 修改本地hosts DNS能帮你在访问域名的时候查到实际的IP地址Github 在全球各地都有服务器，而在国内，DNS解析服务基本上都是把域名解析到了美国的服务器，所以访问起来会比较慢但我们可以通过修改本地 hosts 文件来绕过公共DNS解析，直接访问 Github 在韩国、日本等的服务器，从而达到加速访问的目的 hosts 文件就相当于本地通讯录，你的通讯录里面记了公司的电话。 1.打开本地host文件C:\\Windows\\System32\\drivers\\etc在这个项目https://github.com/521xueweihan/GitHub520复制添加内容到本地host2.更新DNS缓存 SwitchHosts1.这个工具来实现自动更新 hosts 中的IP地址2.我们先到 SwitchHosts 官网下载这款管理工具：https://swh.app/zh/3.下载安装好SwitchHosts之后标题随意取，URL地址填这个：https://raw.hellogithub.com/hosts4.自动刷新最好建议选1小时5.点击确认后，还要手动启用一下，接着稍等片刻本地 hosts 即会更新 UsbEAm Hosts Editor羽翼城博客下载 反向代理steamcommunity 302（WIN）羽翼城大佬后来又开发的 steamcommunity 302 就是通过反代来加速访问 Github 等网站 软件可以到这里下载：https://www.dogfight360.com/blog/686/比较棘手的是可能会出现80／443端口被占用的情况，这个需要关闭对应监听端口的进程／服务来解决，具体教程可见羽翼城大佬在下载页面做出的说明 FastGithub（WIN／Mac／Linux）FastGithub 则是另一款同样基于反代来加速 Gtihub 访问的工具，支持WIN／Mac／Linux三端，还能在docker上一键部署： FastGithub 除了可以加速访问 Gtihub ，最大的优势是它顺便还能助你直连V2EX 提供域名的纯净IP解析； 提供IP测速并选择最快的IP； 提供域名的tls连接自定义配置； Google的CDN资源替换，解决大量国外网站无法加载js和css的问题； https://github.com/dotnetcore/FastGithub清华网盘：https://cloud.tsinghua.edu.cn/d/df482a15afb64dfeaff8/ Windows端的话，下载后双击即可运行 dev-sidecar（WIN／Mac／Ubuntu／Linux）dev-sidecar 这个项目命名取自service-mesh的service-sidecar，意为为开发者打辅助的边车工具，主要就是用于解决 Github 访问的问题：https://gitee.com/docmirror/dev-sidecar 下载后首次运行前会需要让你安装过一个证书，跟着教程安装即可 加速软件Steam++（WIN／Mac／Linux／Android）比较稳定的长期可用加速软件Steam++：https://steampp.net/ 这个原本主要是用于加速访问Steam相关网站、社区的 但软件开发到后面，现在已经支持加速诸多平台了目前支持以下平台的加速： Steam Discord Twitch Origin Uplay 国外验证码平台：Google Recaptcha、hCaptcha、Arkoselabs Github Microsoft Store 网盘服务：OneDrive、MEGA、Dropbox 其他网站：Nyaa、Pinteres、P站、V2EX等 Github ActionsGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具 GitHub Actions 的工作原理：当我们提前设置好需要自动化执行的任务脚本（.github/workflows 下的 .yml 文件）后，GitHub Actions 监控当前仓库的某一个操作（如：push），一旦有此操作，就会分配一个虚拟主机来自动化执行这些任务。 我们设置的任务即为 Action ，它存放在项目根目录的 .github/workflows 文件下，后缀为 .yml。一个 Action 相当于是一个工作流 workflow，一个工作流则可以有多个任务 job，而每个任务又能分成几个步骤 step。任务、步骤会依次执行。 项目推荐项目GitHub 开源项目star列表：https://github.com/jimbrig/jimsghstars 资源和使用技巧分享的GitHub列表：https://github.com/jayboxyz/websites-and-tools 1Awsome_Windows Windows应用推荐列表2.ChromeAppHeroes 为优秀的Chrome插件写一本中文说明书，扩展收集列表3.papirus-icon-theme Papirus icon theme for Linux4.HelloGitHub 分享 GitHub 上有趣、入门级的开源项目5.Best-websites-a-programmer-should-visit-zh 程序员应该访问的最佳网站中文版6.awesome 从GitHub上精选的开源项目，一份很棒的列表7.free-programming-books-zh_CN 免费的计算机编程类中文书籍8.Online_Tools 一些在线的工具,情报资源9.awesome-productivity-cn 绝妙的个人生产力（Awesome Productivity 中文版）10.Awesome-Linux-Software-zh_CN 一个 Linux 上超赞的应用，软件，工具以及其它资源的集中地。11.awesome-for-beginners A list of awesome beginners-friendly projects.12.awesome-mac 一份很棒的MacOS应用列表13.open-source-ios-apps Collaborative List of Open-Source iOS Apps14.Simply beautiful open source icons 简约美观的开源图标库15.awesome-MacOS A curated list of awesome applications, softwares, tools and shiny things for macOS16.interview 笔试面试知识整理17.free-api 收集免费的接口服务,做一个api的搬运工 Awesome GitHub Repo Awesome GitHub Repo 是逛逛 GitHub 创建的开源项目，会收集整理 GitHub 上高质量、有趣的开源项目，并将他们进行归类。地址：https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo 新一代爬虫平台 平台以流程图的方式定义爬虫，是一个高度灵活可配置的爬虫平台。新一代爬虫平台，以图形化方式定义爬虫流程，不写代码即可完成爬虫。开源地址：https://github.com/ssssssss-team/spider-flow 开发者技术路线 它为前端、后端、DevOps等开发着准备可详细的技术路线图。 开源地址：https://github.com/kamranahmedse/developer-roadmap 自学编程之路 Python 开源项目之「自学编程之路」，保姆级教程：AI实验室、宝藏视频、数据结构、学习指南、机器学习实战、深度学习实战、网络爬虫、大厂面经、程序人生、资源分享。 开源地址：https://github.com/Jack-Cherish/PythonPark git与github账号绑定1234567# 配置git用户和邮箱git config --global user.name \"xxxx\" git config --global user.email \"xxxxx@qq.com\" git config --global --list #查看配置的结果 # 本机生成SSH公钥，实现免密登录 ssh-keygen -t rsa 将公钥添加到Github管理平台我的目录是：C:\\Users\\wenke.ssh\\ id_rsa.pub将ssh文件夹中的公钥添加到GitHub管理平台中，进入github设置setting-》ssh and GPG keys-》new ssh key 12ssh -T git@github.com #验证是否绑定成功 Github学生开发包1、申请地址网址：https://education.github.com/ 受到 GitHub 支持的证明材料有： 你的学校的录取通知书（大一新生用，比如我） 你的学生证（手写也行，但是得有照片和钢印） 你的学校教务系统的课表（学习通的也行） 你的成绩单（电子版也可） 或者其他任何可以证明你是在读学生的材料（已经毕业的材料提交无效） 申请理由I am a junior student from China, and I used Github to share my code with my classmates and friends since I entered university. 4、Github学生开发者包可用工具具体可以看这里：https://education.github.com/pack （云服务商和域名篇）https://zhuanlan.zhihu.com/p/422851915#:~:","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"知识","slug":"知识","permalink":"https://wenkex.gitee.io/tags/%E7%9F%A5%E8%AF%86/"}],"author":"wenke"},{"title":"hexo博客搭建","slug":"hexo博客搭建","date":"2021-11-19T02:32:49.000Z","updated":"2022-08-29T13:18:14.234Z","comments":true,"path":"2021/111958091.html","link":"","permalink":"https://wenkex.gitee.io/2021/111958091.html","excerpt":"","text":"Hexo 简介Hexo 是一个快速，简单且功能强大的博客框架。如果你用 Markdown 写博客，Hexo 可以在几秒内生成带有精美主题的静态文件。 准备环境Node.js 安装。Git 并安装配置环境变量，两个都要配置 安装Hexo，创建一个文件夹例如blog，右键打开Git Bash运行： npm install -g hexo-cli查看版本 hexo -v 初始化Hexohexo init blogcd blog #进入blog目录npm install 新建完成后，指定文件夹目录下有：node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件 Hexo版本升级12345678910111213141516171819# 使用淘宝源的 cnpm 替换 npmnpm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g cnpm # 升级 npmcnpm cache clean -f # 清除 npm 缓存===更新 hexo: 进入 blog 目录，执行如下命令=== # 更新 package.json 中的 hexo 及个插件版本cnpm install -g npm-check npm-check # 检查之前安装的插件，都有哪些是可以升级的 cnpm install -g npm-upgrade npm-upgrade # 升级系统中的插件# 更新 hexo 及所有插件cnpm update# 确认 hexo 已经更新hexo -v 创建GitHub仓库或者码云仓库1.创建仓库，仓库名必须和用户名一致，其他按照默认，直接创建2.打开cmd，添加Git本地用户git config –global user.name “ 用户名 “git config –global user.email “绑定的邮箱” 3.申请Sky秘钥ssh-keygen -t rsa -C “Git绑定的邮箱”sky在这 C:\\Users\\啊科.ssh 4.复制Sky秘钥添加到GitHub或者码云查看是否成功 ssh -T git@github.com 将本地仓库与远程仓库连接1.安装git部署插件：才能用hexo d 上传npm install hexo-deployer-git –save 2.复制生成的仓库连接修改博客目录下的_config.yml文件 1234deploy: type: git repository: https://gitee.com/wenkex/wenkex.git branch: master 本地创建文章，上传到远程仓库hexo clean清理缓存 hexo g 刷新博客文章 hexo s 开启本地映射 #为了在本地检查文章，该步骤可以跳过，该命令按Ctrl+C结束 hexo d 将本地博客上传到远程仓库，第一次上传会让你输入GitHub或码云的账号密码等待上传完成，打开Gitee pages，更新Https内容（每次上传文件后都要执行这一步） 在你创建的博客文件夹下打开git bash，输入命令 hexo new 文章标题 用yarn cgd或npm run cgd运行如下命令hexo cl &amp;&amp; hexo g &amp;&amp; hexo d一键上传到远程仓库hexo cl &amp;&amp; hexo g &amp;&amp; hexo s一键开启本地映射 1.目录结构说明参考参考 在执行过Hexo deploy命令之后，目录结构新增了.deploy_git，public，.gitignore，如下 123456789101112131415161718 $ tree -L 2.├── .deploy_git├── node_modules├── public├── scaffolds│&nbsp;&nbsp; ├── draft.md│&nbsp;&nbsp; ├── page.md│&nbsp;&nbsp; └── post.md├── source│&nbsp;&nbsp; ├── _posts│&nbsp;&nbsp; ├── _drafts├── themes├── _config.yml├── db.json├── package.json└── package-lock.json _config.yml用来配置博客相关的参数，初始化时自动创建 node_modules用来存储已安装的各类依赖包 package.json用来查看 Hexo 的版本以及相关依赖包的版本。 scaffold模板文件夹，初始化时自动创建。包含page，post，draft三种模板，分别对应 页面、要发布的文章、草稿。在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：$ hexo new photo \"My Gallery\"在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章， themes主题文件夹，初始化时自动创建。每一个主题，都有一个单独的文件夹。 source：资源文件夹。用来存放图片、Markdown 文档（文章、草稿）、各种页面（分类、关于页面等）。 public：将 source 文件夹里的 Markdown 文档，转换成 index.html。再结合主题进行渲染，就是我们最终看到的博客。 .deploy_git：将 public 文件夹的内容提交到 Github 后生成，内容与 public 文件夹基本一致。 这三者的关系大致是：source -&gt; public -&gt; .deploy_git执行hexo generate，根据 source，更新 public。执行hexo deploy，根据 public，更新 .deploy_git。 2.常用命令1.hexo server #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。简写：hexo s 2.hexo clean#清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹 3.hexo g#生成静态网页 (执行后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下) 等价于hexo generate 4.hexo d#自动生成网站静态文件，并将本地数据部署到设定的仓库(如github)等价于hexo deploy 4.新建文章自动打开编辑器执行 hexo new “名字”，这样就会在_posts 下生成一篇新文章，但需要手动打开，1.只需要在站点根目录下新建 scripts 目录，2.然后在scripts目录下新建 auto_open.js，在文件填入一下内容： 12345var spawn = require('child_process').exec;// Hexo 3 用户复制这段hexo.on('new', function(data){ spawn('start \"D:\\Program Files\\Typora\\Typora.exe\" ' + data.path);}); 其中 “D:\\Program Files\\Typora\\Typora.exe” 是我本地编辑器的路径，只需要改为你本地编辑器的路径即可，然后在执行 hexo cl &amp;&amp; hexo g -d，部署到 GitHub 即可，以后在发布文章就会自动打开编辑器。 5.一键部署通过 hexo-deployer-git 插件可以实现一键将博客同时部署到多个git仓库中。如同时发布到github及gitee提供的pages服务。安装：npm install hexo-deployer-git --save修改 Hexo 根目录下的_config.yml 文件中的如下内容: 12345678910#一键部署，修改成自己的repo和branchdeploy: - type: git repo: https://github.com/lxl80/blog.git branch: gh-pages ignore_hidden:false - type:git repo:https://gitee.com/lxl80/lxl80.git branch:master ignore_hidden:false 简化部署在package.json中添加\"cgd\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo d\"以后就可以用npm run cgd直接部署上线 12345678\"scripts\": { \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"deploy\": \"hexo deploy\", \"server\": \"hexo server\", \"cgs\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\", \"cgd\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo d\"}, 使用文章资源文件夹(弃用，现在用图床)在config.yaml文件中更改一下配置：post_asset_folder: true当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。此时应该使用这样的方式来引入图片：{% asset_img image.jpg 这是一张图片 %} 图片插件 插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true github添加域名参考 1.注册一个域名2.添加域名解析（注：使用自定义域名，需要将记录类型修改为 CNAME 将域名指向另一个域名，记录值修改为 GitHub对应仓库名，如：wenkexia.github.io）3.在GitHub 中设置新的注册的域名（具体位置：Settings –&gt; Pages –&gt; Custom domain），之后保存验证就可以了4.进入 hexo 根目录的 source 文件夹；创建 CNAME 文件，文件添加域名 –&gt; zhangyh.fun。注意：文件名全部大写，没有后缀；文件内容只有域名；5.重新生成静态文件，并提交。hexo d SEO优化参考 搜索引擎优化，又称为SEO，即Search Engine Optimization，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。Google自动收录效果还不错，百度就差得远了（GitHub不允许百度的Spider爬取GitHub上的内容）。所以在第三步验证网站的时候，建议选择CNAME验证的方式。 生成 sitemap 文件1.安装插件查看是否有安装插件npm [name] -v 百度 npm install hexo-generator-baidu-sitemap --save谷歌 npm install hexo-generator-sitemap --save 2.添加站点配置_config.yml 12345sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 再重启 hexo，在本地访问 localhost:4000/sitemap.xml和 localhost:4000/baidusitemap.xml 就能正确的展示出两个sitemap 文件了。 推送到 谷歌 和 百度百度百度站点管理添加文件方式不可行，hexo会处理html文件 所以选择，在 head.ejs 里添加 html 标签 1.1 手动提交baidusitemap.xml(里面也有自动提交的代码) 1.2 可以用”抓取诊断”，手动-百度抓取 1.3 Robots → 检测并更新 谷歌谷歌站点管理 在根目录下 新建 robots.txtrobots配置 1234567891011121314User-agent: *Allow: /Allow: /home/Allow: /archives/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://yoursite/sitemap.xmlSitemap: http://yoursite/baidusitemap.xml Hexo自定义原理Hexo 系列的博客中的文章都是经Hexo的主题渲染的静态网页。所以Hexo博客大部分都呈现出一种高度的统一化与规范化。不过 Hexo 提供了跳过渲染功能，使得我们可以直接在博客中放入自定义网页。 比如在博客中放入图片、自定义404.html、自定义About页面、简历等创建自定义网页网页可以是自己编写的，也可以是别人现成的源码（下载喜欢的页面）。 添加文件网页编写完成后，在Hexo\\source目录下创建一个文件夹（文件夹名称任意，比如我创建的是about这个文件夹，部署完成后，访问http://mrlsm.github.io/about即可看到效果，依此类推） 将 html 文件放置于此文件夹，并重命名为 index.html 。 跳过渲染有下述两种方法： 1.指定文件跳过渲染实现原理 给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。 实现方法在不需要渲染的文章或HTML文件头部添加以下标记 123---layout: false--- 添加该指令后，执行 hexo g命令时便会跳过该 index.html文件，使得index.html不受当前 hexo 主题影响，完全是一个独立的网页，如果网页引用了 css 或 js，css 和 js 需使用外链或者将css js 文件放入index.html同目录下引用。 引用图片亦是如此 2.对相关文件跳过渲染实现原理只有source目录下的文件才会发布到public（能够在网络上访问到），因此Hexo只渲染source目录下的文件。skip_render参数设置的路径是相对于source目录的路径。Hexo的配置文件中提供了配置项skip_render ，是用来对不需要的目录或者文件进行渲染排除。 实现方法在_config.yml文件中设置skip_render使用编辑器打开 Hexo 目录下的_config.yml文件，找到skip_render skip_render一般有以下四种常用参数： 跳过source目录下的 test.html:skip_render: test.html 跳过source目录下 test 文件夹内所有文件：skip_render: test/* 跳过source目录下 test 文件夹内所有文件包括子文件夹以及子文件夹内的文件：skip_render: test/** 跳过多个路径：1234skip_render: - test.html - test/* 不渲染 md 文件skip_render: test/*.md 单个文件夹下指定类型文件 安装一个本地后台管理(Hexo Admin)1.在博客根目录下运行下列指令npm install --save hexo-admin2.运行hexo s3.接下来在浏览器地址栏粘贴这个地址，http://localhost:4000/admin/4.增加密码进入Settings &gt; Setup authentification设置账户，密码得到一串配置填加到站点配置文件下 12345admin: username: myfavoritename password_hash: be121740bf988b2225a313fa1f107ca1 secret: a secret something 增加上传功能在博客根目录下运行下列指令 123456echo \"hexo clean &amp;&amp; hexo g -d\"&gt;hexo-deploy.bat #生成一个内容为\"hexo clean &amp;&amp; hexo g -d\"，名为\"hexo-deploy\"的bat文件。#配置_config.yml文件，echo admin:&gt;&gt;\"_config.yml\"echo \" deployCommand: 'hexo-deploy.bat'\"&gt;&gt;\"_config.yml\"#开启hexo服务hexo server -d 这个教程是对于github的部署的。如果想用来管理gitee的博客，建议修改成echo “hexo clean &amp;&amp; hexo g -d &amp;&amp; start https://gitee.com/用户名/用户名/pages\"&gt;hexo-deploy.bat，这样方便在网页端同步更新gitee page。在网页中编辑完，直接左上角Deploy，直接点deploy按钮，就可以完成博客的部署。 可能遇到的问题(每次都要输入密码)：查看一下你的_config.yml，将文档最后的deploy的repo从http改为git@github类型。 图床建议使用utool里的图床插件，picGo还要下载，而utool里还有其他有趣的插件 使用 PicGo+GitHub图床参考 新建GitHub仓库创建是记住分支名，默认是main 生成一个Token在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页 配置PicGo前往下载PicGo，安装好后开始配置图床设定仓库名：按照【用户名/图床仓库名】的格式填写 设定分支名：【main】 设定Token：粘贴之前生成的【Token】 设定自定义域名：它的作用是，在图片上传后，PicGo 会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接，并放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【https://cdn.jsdelivr.net/gh/用户名/图床仓库名 】 用GitHub Actions自动部署HexoGitHub 仓库我们需要准备一个部署博客的仓库，一般命名为 .github.io 这种形式，同时在本仓库上再创建一个分支用于保存 Hexo 开发源码。我这里使用建好的 hexo-blog-backup 分支进行 Hexo 开发源码备份，使用 master 分支进行博客源码部署。 提醒，这里也可以建两个仓库分别进行博客源码和 Hexo 开发源码的保存，跟建两个分支一样。 生成部署密钥在 Git Bash Here 中执行ssh-keygen -f github-deploy-key会在当前目录中生成两个文件，私钥文件 github-deploy-key 和公钥文件 github-deploy-key.pub 配置部署密钥私钥复制 github-deploy-key 文件内容，在 myblog 仓库 Settings -&gt; Secrets -&gt; New repository secret 页面上添加。在 Name 输入框填写 HEXO_DEPLOY_PRI在 Value 输入框填写 github-deploy-key 文件内容 另外建一个用于同步到 gitee 的私钥，用于存储 gitee 的密码在 Name 输入框填写 GITEE_PASSWORD在 Value 输入框填写 gitee 的密码 公钥复制 github-deploy-key.pub 文件内容，在 wbsu2003.github.io 仓库 Settings -&gt; Deploy keys -&gt; Add deploy key 页面上添加。 在 Title 输入框填写 HEXO_DEPLOY_PUB在 Key 输入框填写 github-deploy-key.pub 文件内容勾选 Allow write access 选项 同步代码在备份仓库上butterfly主题配置官方文档 安装插件如果你没有 pug 以及 stylus 的渲染器，请下载安装：npm install hexo-renderer-pug hexo-renderer-stylus --save butterfly主题升级1.在 hexo 的根目录创建一个文件 _config.butterfly.yml，并把主题目录的 _config.yml 内容复製到 _config.butterfly.yml 去。( 注意: 复製的是主题的 _config.yml ,而不是 hexo 的 _config.yml)2.不要把主题目录的 _config.yml 删掉3.以后只需要在 _config.butterfly.yml进行配置就行。4.Hexo会自动合併主题中的_config.yml和 _config.butterfly.yml里的配置，如果存在同名配置，会使用_config.butterfly.yml的配置，其优先度较高。 如果你只使用到主题配置文件，那么升级只需对比新版本主题的配置文件，把旧版本主题配置文件改动到新版本主题配置文件中。重新 git clone 新版 Butterfly 主题到 root/themes/ git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly Inject参考打开主题配置文件（butterfly.yml）定位搜索 inject其中head是用来引入css的。bottom是用来引入js的。 以相对路径引入1.将写好的css文件移动到\\Butterfly\\source\\css\\目录下。2.然后修改配置文件的引入方式 123456inject: head: - &lt;link rel=\"stylesheet\" href=\"/css/name.css\"&gt; bottom: - &lt;script src=\"xxxx\"&gt;&lt;/script&gt; 标签外挂（Tag Plugins）(推荐)参考参考标籤外挂是Hexo独有的功能，并不是标準的Markdown格式。 以下的写法，只适用于Butterfly主题，用在其它主题上不会有效果，甚至可能会报错。使用前请留意 Tabs页面内置小标签使用 123456789101112131415161718192021222324{% tabs Unique name, [index] %}&lt;!-- tab [Tab caption] [@icon] --&gt;Any content (support inline tags too).&lt;!-- endtab --&gt;{% endtabs %}Unique name : Unique name of tabs block tag without comma. Will be used in #id's as prefix for each tab with their index numbers. If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes. Only for current url of post/page must be unique![index] : Index number of active tab. If not specified, first tab (1) will be selected. If index is -1, no tab will be selected. It's will be something like spoiler. Optional parameter.[Tab caption] : Caption of current tab. If not caption specified, unique name with tab index suffix will be used as caption of tab. If not caption specified, but specified icon, caption will empty. Optional parameter.[@icon] : FontAwesome icon name (full-name, look like 'fas fa-font') Can be specified with or without space; e.g. 'Tab caption @icon' similar to 'Tab caption@icon'. Optional parameter. 1234567891011121314{% tabs test4 %}&lt;!-- tab 第一个Tab --&gt;**tab名字为第一个Tab**&lt;!-- endtab --&gt;&lt;!-- tab @fab fa-apple-pay --&gt;**只有图标 没有Tab名字**&lt;!-- endtab --&gt;&lt;!-- tab 炸弹@fas fa-bomb --&gt;**名字+icon**&lt;!-- endtab --&gt;{% endtabs %} 第一个Tab炸弹tab名字为第一个Tab只有图标 没有Tab名字名字+icon Button12345678910111213141516171819{% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %}[url] : 链接[text] : 按钮文字[icon] : [可选] 图标[color] : [可选] 按钮背景顔色(默认style时） 按钮字体和边框顔色(outline时) default/blue/pink/red/purple/orange/green[style] : [可选] 按钮样式 默认实心 outline/留空[layout] : [可选] 按钮佈局 默认为line block/留空[position] : [可选] 按钮位置 前提是设置了layout为block 默认为左边 center/right/留空[size] : [可选] 按钮大小 larger/留空 This is my website, click the button Butterfly gallery 相册图库参考参考 编辑主题导航栏加入相册按钮在站点主题_config.yml文件下menu菜单下新增gallery页面。 12menu: 相册: /gallery/ || fas fa-heart 新建相册页面在站点的source文件夹下面新建一个gallery相册页面。hexo new page gallery打开新建的gallery文件夹，里面会有一个index.md文件，设置index.md文件内容。然后使用标签外挂 galleryGroup，具体用法请查看对应的内容。 123456789101112--- title: gallery date: 2020-10-05 12:00:00 type: \"gallery\"layout: \"gallery\" &lt;div class=\"gallery-group-main\"&gt;{% galleryGroup '壁纸' '收藏的一些壁纸' '/Gallery/wallpaper' https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png %}{% galleryGroup '漫威' '关于漫威的图片' '/Gallery/marvel' https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %}{% galleryGroup 'OH MY GIRL' '关于OH MY GIRL的图片' '/Gallery/ohmygirl' https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg %}&lt;/div&gt;--- name：图库名字description：图库描述link：连接到对应相册的地址img-url：图库封面的地址 新建相册图片展示页面在gallery文件夹（也就是刚才创建的那个文件），可以在里面新建一些文件夹，也就是相册文件夹然后在新建的相册文件夹里，分别在每个文件夹里新建文件index.md ,然后使用标签外挂 gallery，具体用法请查看对应的内容。 1234567891011121314--- {% gallery %}![](https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg)![](https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg)![](https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg)![](https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg)![](https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg)![](https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg)![](https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg)![](https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg){% endgallery %}--- 友情链接创建友情链接页面在博客的根目录输入 hexo new page link修改source/link/index.md这个文件 12345 ---title: 友情链接date: 2018-06-07 22:17:49type: \"link\"--- 友情链接添加在Hexo博客目录中的source/_data（如果没有 _data 文件夹，请自行创建），创建一个文件link.yml 123456789101112131415161718192021222324- class_name: 友情链接 class_desc: 那些人，那些事 link_list: - name: Hexo link: https://hexo.io/zh-tw/ avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg descr: 快速、简单且强大的网誌框架- class_name: 网站 class_desc: 值得推荐的网站 link_list: - name: Youtube link: https://www.youtube.com/ avatar: https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png descr: 视频网站 - name: Weibo link: https://www.weibo.com/ avatar: https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png descr: 中国最大社交分享平台 - name: Twitter link: https://twitter.com/ avatar: https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png descr: 社交分享平台 class_name和class_desc支持html格式书写，如不需要，也可以留空。 评论开启评论需要在comments-use中填写你需要的评论。 支持双评论显示，只需要配置两个评论（第一个为默认显示） 参数 解释 use 使用的评论（填写的评论首字母需要大写。最多支持两个）注意：由于共用 ID,双评论不能是 Disqus 和 Disqusjs text 是否显示评论服务商的名字 lazyload 是否为评论开启lazyload，开启后，只有滚动到评论位置时才会加载评论所需要的资源（开启lazyload后，评论数将不显示） count 是否在文章顶部显示评论数livere 和 utterances 不支持评论数显示 card_post_count 是否在首页文章卡片显示评论数gitalk、livere 和 utterances不支持评论数显示 Pjax当用户点击链接，通过ajax更新页面需要变化的部分，然后使用HTML5的pushState修改浏览器的URL地址。 这样可以不用重复加载相同的资源（css/js）， 从而提升网页的加载速度。 12345pjax: enable: true exclude: - /music/ - /no-pjax/ 对于一些第三方插件，有些并不支持 pjax 。你可以把网页加入到 exclude 里，这个网页会被 pjax 排除在外。点击该网页会重新加载网站 使用pjax后，一些自己DIY的js可能会无效，跳转页面时需要重新调用，请参考Pjax文档使用pjax后，一些个别页面加载的js/css，将会改为所有页面都加载 Butterfly的Pjax目前仍有一些问题，请留意 引用文章参考以_post为根目录定位文件（md文件会被渲染成html）因为使用了abbrlink生成文章永久链接，所以在GitHub仓库中由md渲染成的HTML文件名是日期加abbrlink数字 新建一个页面打开文章&lt;a href=\"/2021/12184010.html\" target=\"_blank\"&gt;显示的文字&lt;/a&gt; 在此页面打开新文章[显示的文字](/2021/12184010.html){% post_link 文章文件名 显示文本 %} 添加 RSS 订阅支持本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下：npm install hexo-generator-feed --save 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明已经安装成功了。 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456789# RSS订阅plugin: - hexo-generator-feed# Feed Atomfeed: type: atom path: atom.xml limit: 20 在主题的配置文件_config.butterfly.yml中的social属性下添加rss的icon配置： 12social: fa fa-rss: /atom.xml 添加emoji表情支持Matery 主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：😄）转变成会跳跃的emoji表情，安装命令如下：npm install hexo-filter-github-emojis --save在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 1234567githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 添加动态诗词参考 采用的是今日诗词，每次返回一句诗词，根据时间、地点、天气、事件智能推荐。官网有API文档，可以去看一下，有多种安装方式，最简单的方式就是从官网获取代码，1.在/themes/matery/layout/_partial/head.ejs添加下面的一行代码： 12&lt;script src=\"https://sdk.jinrishici.com/v2/browser/jinrishici.js\" charset=\"utf-8\"&gt;&lt;/script&gt; 2.然后再将/themes/matery/layout/_partial/bg-cover-content.ejs中的&lt;%= config.description %&gt;修改为&lt;%- '&lt;span id=\"jinrishici-sentence\"&gt;正在加载今日诗词....&lt;/span&gt;' %&gt;3.使用前提是将主题配置文件的subtitle的值改为false。 添加萌萌的动漫人物1.安装插件npm install --save hexo-helper-live2d2.输入以下命令，安装下载动画人物库，将 haruto 更换成你想要的模型名称即可 如：npm install live2d-widget-model-haruto更多模型选择请点击 3.根目录_config.yml配置里面添加： 12345678910111213141516171819live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-haruto #模型选择 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: true #是否在手机端显示 react: opacity: 0.7 动漫人物最好不要和不蒜子一起使用，不然不蒜子会显示不出来。 添加全局吸底Aplayer音乐(不采用)安装hexo-tag-aplayer插件关闭 asset_inject由于需要全局都插入aplayer和meting资源，为了防止插入重复的资源，需要把asset_inject设为false在Hexo的配置文件中 123aplayer: meting: true asset_inject: false 开启主题的aplayerInject在主题的配置文件中，enable设为true和per_page设为true 1234# Inject the css and script (aplayer/meting)aplayerInject: enable: true per_page: true 插入Aplayer html把aplayer代码插入到主题配置文件的inject.bottom去 1234inject: head: bottom: - &lt;div class=\"aplayer no-destroy\" data-id=\"000PeZCQ1i4XVs\" data-server=\"tencent\" data-type=\"artist\" data-fixed=\"true\" data-mini=\"true\" data-listFolded=\"false\" data-order=\"random\" data-preload=\"none\" data-autoplay=\"true\" muted&gt;&lt;/div&gt; id是自己分享的歌曲后由链接得到的idserver可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐）。type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） 如果你想切换页面时，音乐不会中断。请把主题配置文件的pjax设为true，在class里需添加no-destroy，这样防止切换页面时Aplayer被销毁 UI 调整按照上面的步骤设置完成后，浏览器左下角会出现Aplayer。打开文章页面时，你会发现打开Toc目录的按钮被遮挡了。我们需要修改CSS来改变按钮的位置。向上调整 123#toggle-sidebar { bottom: 80px} 在主题配置文件中，添加到inject去 123inject: head: - '&lt;style type=\"text/css\"&gt;#toggle-sidebar {bottom: 80px}&lt;/style&gt;' 参考文章https://butterfly.js.org/https://yangchaoyi.vip/ matery主题配置（不采用）下载主题hexo-theme-matery 是一个采用 Material Design 和响应式设计的 Hexo 博客主题去github下载解压缩后，将 hexo-theme-matery 的文件夹复制到 Hexo 的 themes 文件夹中即可。 切换主题修改 Hexo 根目录下的_config.yml 的 theme 的值：theme: hexo-theme-matery 主题目录结构说明1.matery/layout下的.ejs文件是编写关于主页右上角分类，归档的2.目录样式在：themes\\Matery\\layout_partial\\post-detail-toc.ejs3.如果有多语言支持需求，可以更改 themes/next/languages 下对应语言的翻译。 medias个性化参考 1.我先把banner 和 featureimages里的图片来了个大换血。不过这里我发现一个问题，壁纸尺寸必须和电脑显示屏的分辨率一样才能完美显示。比如我的电脑分辨率是1080*1920，那么我下载的壁纸也得是这个尺寸，不然浏览器渲染显示的时候会不好看。 2.接着我又把网站logo，avatars，favicon 也给换成了自己喜欢的图片免费logo生成网站 代码高亮参考 Hexo的matery主题中的代码块出现代码大小不一，代码键复制，无法高亮等BUG 评论主题中内置了valine, miniValine, livere, gitment, gitalk, changyan评论通过主题文件夹下的_config.yml文件中的相应属性进行设置推荐使用valine和livere这里重点说一下valine评论配置 1234567891011valine: on: true # 是否启用 appid: # 你的appid --&gt; https://valine.js.org/quickstart.html，请阅读这个获取appid和appkey appkey: # 你的key avatar: '' # 匿名者头像选项 https://valine.js.org/avatar.html 访客的头像,最好启用下面的`requiredFields`中的邮箱必填，填写qq邮箱，头像会变成qq头像 placeholder: '客官，说点什么吧' # 评论内容输入框的 placeholder master: 'xxxxxx' # 博主标签识别，博主邮箱md5 可以去md5加密网站，例如 https://md5jiami.51240.com/ ，将自己的邮箱输入， 得到 32位小写 的字符串填入这里 friends: ['xxxxxxx', 'xxxxxx'] # 小伙伴的 邮箱md5， 是个数组 requiredFields: ['nick', 'mail'] # 设置必填项 ['nick', 'mail'] nick为昵称必填， mail为邮箱必填, 空数组，则不校验 backgroundImg: '/medias/comment-bg.gif' # 右下角背景图片, or http://xxx.gif backgroundColor: 'rgba(255,255,255,0.9)' # 背景颜色, 0.9标是透明度 打开腾讯兔小巢后台反馈在主题配置文件更改，加入自己注册后得到的产品Id就可以 1234# 腾讯兔小巢，见https://txc.qq.com/tuxiaochao: enable: true productId: 371566 添加 Tidio 在线聊天功能前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 百度优化登录百度搜索资源平台， 登录成功之后在 用户中心 –&gt; 站点管理 页面中点击添加网站，按提示操作。因为我是部署在gitee上的，刚开始我选择的是文件验证方式，但一直提示验证文件内容不符，因此选择了HTML标签验证复制的标签增加在\\themes\\Chic\\layout\\_partial的head.ejs的&lt;head&gt;与&nbsp;&lt;/head&gt;标签之间经过以上步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。hexo-theme-matery主题已经内置了自动推送的方式， 检查themes/hexo-theme-matery/_config.yml文件中如下配置:# 百度搜索资源平台提交链接baiduPush: true自动推送的JS代码部署在站点的每一个页面源代码中，当页面在每次被浏览时，链接就会被自动推送给百度。 添加百度统计参考 1.注册百度统计账号2.添加博客域名3.获取Baidu Analytics ID然后进入代码管理-&gt;代码获取可以看到如下一段javascript代码，这段代码本来是要手动嵌入到网页中的，但是Hexo已经帮我们嵌入了，所以我们自诩配置Baidu Analytics ID即可，这个ID就是下面代码的hm.js?后面那一串，先复制一下 123456789&lt;script&gt;var _hmt = _hmt || [];(function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?5b6ae75148041557ddd693925322myid\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s);})();&lt;/script&gt; 4.配置Baidu Analytics ID打开主题的配置文件，然后搜索Baidu Analytics ID，找到如下配置项： 12# Baidu Analytics IDbaidu_analytics: 5b6ae75148041557ddd69392532288de 去掉baidu_analytics前面的#号开启百度统计，值设置成刚在百度统计后台复制的Baidu Analytics ID 添加导航页参考 1.首先新建页面，执行下面的命令 1hexo new page navigate 2.修改 navigate 目录下的 index.md 的格式 123456---title: 导航date: 2020-05-09 11:19:14type: \"navigate\"layout: \"navigate\"--- 3.在主题配置文件中添加导航 12345678910111213141516171819202122232425262728293031323334# main menu navigation url and icon# 配置菜单导航的名称、路径和图标icon.menu: Index: url: / icon: fas fa-home 统计: url: / icon: fas fa-sitemap children: - name: 分类 url: /categories icon: fas fa-bookmark - name: 标签 url: /tags icon: fas fa-tags - name: 归档 url: /archives icon: fas fa-archive About: url: /about icon: fas fa-address-card Contact: url: /contact icon: fas fa-comments 友人帐: url: /friends icon: fas fa-share-alt 赞助墙: url: /sponsor icon: fa fa-credit-card 导航: url: /navigate icon: fas fa-location-arrow 4.在 matery/layout 下新建 navigate.ejs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414&lt;div class=\"navi-height bg-cover pd-header \"&gt; &lt;div class=\" link-box container\"&gt; &lt;!-- 搜索框 --&gt; &lt;div class=\"baidu baidu-2 large-screen\"&gt; &lt;form name=\"f\" action=\"https://www.baidu.com/\" target=\"_blank\"&gt; &lt;div id=\"Select-2\"&gt; &lt;div class=\"Select-box-2\" id=\"baidu\"&gt; &lt;ul style=\"height: 46px;\"&gt; &lt;li class=\"this_s\"&gt;百 · 度&lt;/li&gt; &lt;li class=\"bing_s\"&gt;必 · 应&lt;/li&gt; &lt;li class=\"google_s\"&gt;谷 · 歌&lt;/li&gt; &lt;li class=\"baidu_s\"&gt;百 · 度&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input name=\"wd\" id=\"kw-2\" maxlength=\"100\" autocomplete=\"off\" type=\"text\"&gt; &lt;/div&gt; &lt;div class=\"qingkong\" id=\"qingkong\" title=\"清 · 空\" style=\"display: none;\"&gt;x&lt;/div&gt; &lt;input value=\"搜 · 索\" id=\"su-2\" type=\"submit\"&gt; &lt;ul class=\"keylist\"&gt;&lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- 链接 --&gt; &lt;div class=\"row tags-posts \"&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;娱乐 · 影视&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.jd.com/\" class=\"link-3\" target=\"_blank\"&gt;京东&lt;/a&gt; &lt;li&gt;&lt;a href=\"https://www.taobao.com/\" class=\"link-3\" target=\"_blank\"&gt;淘宝&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.tmall.com/\" class=\"link-3\" target=\"_blank\"&gt;天猫&lt;/a&gt;&lt;/li&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"https://v.qq.com/\" class=\"link-3\" target=\"_blank\"&gt;腾讯视频&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.iqiyi.com/\" class=\"link-3\" target=\"_blank\"&gt;爱奇艺&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.bilibili.com/\" class=\"link-3\" target=\"_blank\"&gt;哔哩哔哩&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"https://music.163.com/\" class=\"link-3\" target=\"_blank\"&gt;网易云音乐&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://y.qq.com/\" class=\"link-3\" target=\"_blank\"&gt;QQ音乐&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.kugou.com/\" class=\"link-3\" target=\"_blank\"&gt;酷狗音乐&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;社区 · Code&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.mobaijun.com/contact/\" class=\"link-3\" target=\"_blank\"&gt;留言&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://github.com/\" class=\"link-3\" target=\"_blank\"&gt;GitHub&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://coding.net/\" class=\"link-3\" target=\"_blank\"&gt;Coding&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://juejin.im/\" class=\"link-3\" target=\"_blank\"&gt;掘金&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://gitee.com/\" class=\"link-3\" target=\"_blank\"&gt;码云&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.csdn.net/\" class=\"link-3\" target=\"_blank\"&gt;CSDN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.jianshu.com/\" class=\"link-3\" target=\"_blank\"&gt;简书&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://segmentfault.com/\" class=\"link-3\" target=\"_blank\"&gt;思否&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://cloud.tencent.com/developer/\" class=\"link-3\" target=\"_blank\"&gt;云+社区&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;实用 · 工具&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://mdnice.com/\" class=\"link-3\" target=\"_blank\"&gt;Nice编辑器&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://translate.google.cn/\" class=\"link-3\" target=\"_blank\"&gt;谷歌翻译&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.uupoop.com/\" class=\"link-3\" target=\"_blank\"&gt;在线PS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.processon.com/\" class=\"link-3\" target=\"_blank\"&gt;思维导图&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://wallhaven.cc/\" class=\"link-3\" target=\"_blank\"&gt;超清壁纸&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://cli.im/\" class=\"link-3\" target=\"_blank\"&gt;二维码&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.yinfans.me/\" class=\"link-3\" target=\"_blank\"&gt;音范思&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.52pojie.cn/\" class=\"link-3\" target=\"_blank\"&gt;吾爱破解&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://my.openwrite.cn/\" class=\"link-3\" target=\"_blank\"&gt;OW分发&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;编程 · 学习&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.oschina.net/\" class=\"link-3\" target=\"_blank\"&gt;开源中国&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://htmldog.com/\" class=\"link-3\" target=\"_blank\"&gt;HTML狗&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.icourse163.org/\" class=\"link-3\" target=\"_blank\"&gt;中国大学慕课&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.imooc.com/\" class=\"link-3\" target=\"_blank\"&gt;慕课网&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.wxapp-union.com/\" class=\"link-3\" target=\"_blank\"&gt;小程序&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.runoob.com/\" class=\"link-3\" target=\"_blank\"&gt;菜鸟教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://blog.51cto.com/\" class=\"link-3\" target=\"_blank\"&gt;51CTO&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.shiyanlou.com/library/\" class=\"link-3\" target=\"_blank\"&gt;实验楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://spring.io/\" class=\"link-3\" target=\"_blank\"&gt;Spring&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;资讯 · 趋势&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.huxiu.com/\" class=\"link-3\" target=\"_blank\"&gt;虎嗅&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://insights.stackoverflow.com/\" class=\"link-3\" target=\"_blank\"&gt;技术调查&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.asciiworld.com/\" class=\"link-3\" target=\"_blank\"&gt;摸鱼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://sspai.com/\" class=\"link-3\" target=\"_blank\"&gt;少数派&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://zh.wikihow.com/\" class=\"link-3\" target=\"_blank\"&gt;WikeHom&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.awesomes.cn/rank?sort=hot\" class=\"link-3\" target=\"_blank\"&gt;前端趋势&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://github-trending.com/\" class=\"link-3\" target=\"_blank\"&gt;GitHub趋势&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.tiobe.com/\" class=\"link-3\" target=\"_blank\"&gt;编程趋势&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://trends.google.com/\" class=\"link-3\" target=\"_blank\"&gt;Google趋势&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;搜索 · 其他&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://ac.scmor.com/\" class=\"link-3\" target=\"_blank\"&gt;谷歌镜像&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.pansoso.com/\" class=\"link-3\" target=\"_blank\"&gt;网盘搜索&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://tool.mkblog.cn/music/\" class=\"link-3\" target=\"_blank\"&gt;音乐搜索&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.dytt8.net/\" class=\"link-3\" target=\"_blank\"&gt;电影天堂&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://carbon.now.sh/\" class=\"link-3\" target=\"_blank\"&gt;代码图片&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.zhipin.com/\" class=\"link-3\" target=\"_blank\"&gt;Boos&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://fontawesome.com/\" class=\"link-3\" target=\"_blank\"&gt;图标库&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.qvdv.com/tools/qvdv-guid.html\" class=\"link-3\" target=\"_blank\"&gt;在线工具&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"http://zhongguose.com/\" class=\"link-3\" target=\"_blank\"&gt;中国色&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; /*选择搜索引擎*/ $('.Select-box ul').hover(function () { $(this).css('height', 'auto') }, function () { $(this).css('height', '40px') }); $('.Select-box-2 ul').hover(function () { $(this).css('height', 'auto') }, function () { $(this).css('height', '46px') }); $('.Select-box li').click(function () { var _tihs = $(this).attr('class'); var _html = $(this).html(); if (_tihs == 'baidu_s') { _tihs = 'https://www.baidu.com/s'; _name = 'wd'; } if (_tihs == 'google_s') { _tihs = 'https://www.google.com/search'; _name = 'q'; } if (_tihs == 'bing_s') { _tihs = 'https://www.bing.com/search'; _name = 'q'; } $('.baidu form').attr('action', _tihs); $('.this_s').html(_html); $('#kw').attr('name', _name); $('.Select-box ul').css('height', '40px') }); $('.Select-box-2 li').click(function () { var _tihs = $(this).attr('class'); var _html = $(this).html(); if (_tihs == 'baidu_s') { _tihs = 'https://www.baidu.com/s'; _name = 'wd'; } if (_tihs == 'google_s') { _tihs = 'https://www.google.com/search'; _name = 'q'; } if (_tihs == 'bing_s') { _tihs = 'https://www.bing.com/search'; _name = 'q'; } $('.baidu form').attr('action', _tihs); $('.this_s').html(_html); $('#kw-2').attr('name', _name); $('.Select-box-2 ul').css('height', '48px') }); //清空输入框内容 $('.qingkong').click(function () { cls(); $(this).css('display', 'none') }); function cls() { var sum = 0; var t = document.getElementsByTagName(\"INPUT\"); for (var i = 0; i &lt; t.length; i++) { if (t[i].type == 'text') { ++sum; t[i].value = \"\";//清空 } } } //清空输入框按钮的显示和隐藏 function if_btn() { var btn_obj = document.getElementById(\"kw\") || document.getElementById(\"kw-2\"); var cls_btn = document.getElementById(\"qingkong\"); var btn_obj_val; var times; //当元素获得焦点时 if (btn_obj == '' || btn_obj == null) { return false; //如果没有找到这个元素，则将函数返回，不继续执行 } btn_obj.onfocus = function () { times = setInterval(function () { btn_obj_val = btn_obj.value; if (btn_obj_val != 0) { cls_btn.style.display = \"block\"; } else { cls_btn.style.display = \"none\"; } }, 200); } //元素失去焦点时 btn_obj.onblur = function () { clearInterval(times); } } &lt;/script&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; * { margin: 0; padding: 0; font-family: \"微软雅黑\" } ul,li,h1,h2,h3,h4,h5,h6,p,form,dl,dt,dd { margin: 0px; padding: 0px; font-size: 14px; font-weight: normal; } img { border-style: none; } li { list-style: none; float: left } a { text-decoration: none } .card { background-color: rgba(25, 240, 229, 0); width: 96%; margin-left: 2% } .baidu { float: left; margin-left: 100px; } .baidu form { position: relative } .Select-box ul { height: 40px; position: absolute; left: -1px; top: 0px; z-index: 9999; background: #FFF; border: 1px solid #ccc; border-top: none; overflow: hidden } .Select-box li { width: 60px; line-height: 40px; font-size: 14px; color: #484848; border: 0; cursor: pointer; } .Select-box li:hover { background: #3385ff; color: #FFF; } .Select-box .this_s { color: #317ef3; } .Select-box .this_s:hover { background: #FFF; color: #317ef3; } .qingkong { position: absolute; right: 120px; top: 12px; width: 18px; height: 18px; background: rgba(0, 0, 0, 0.1); border-radius: 18px; line-height: 16px; color: #666666; cursor: pointer; text-align: center; font-size: 14px; display: none; } .qingkong:hover { background: rgba(0, 0, 0, 0.2); } .qingkong:active { background: rgba(0, 0, 0, 0.3); } .baidu-2 { width: 100%; height: 110px; margin: 0 auto; background: none; padding-top: 50px; } .baidu-2 form { width: 520px; margin: 0 auto; } .baidu-2 input { padding: 13px 8px; opacity: 0.9; font-size: 15px; } #Select-2 { float: left; } .Select-box-2 { text-align: center; float: left; position: relative; } .Select-box-2 ul { height: 46px; position: absolute; left: 0px; top: 1px; z-index: 9999; background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; border-top: none; overflow: hidden } .Select-box-2 li { width: 60px; line-height: 46px; font-size: 15px; color: #484848; border: 0; cursor: pointer; } .Select-box-2 li:hover { background: #3385ff; color: #FFF; } .Select-box-2 .this_s { color: #317ef3; } .Select-box-2 .this_s:hover { background: none; color: #317ef3; } #kw-2 { width: 335px; outline: 0; border: 1px solid #ccc; background: rgba(255, 255, 255, 0.2); color: #000000; padding-left: 70px; font-weight: bold; } /*修改搜索框样式*/ #su-2 { width: 90px; background: blue; border: none; border-top: #3385ff 1px solid; border-bottom: 1px solid #2d78f4; color: #FFF; cursor: pointer; /*去轮廓阴影*/ outline: none; } /*光标移动到搜索框颜色*/ #su-2:hover { background: blue; border-bottom: 1px solid blue; } #su-2:active { background: blue; box-shadow: inset 1px 1px 3px blue; -webkit-box-shadow: inset 1px 1px 3px blue; } .jj-list-tit { font-size: 16px; line-height: 25px; color: #ffffff; width: 100%; padding-left: 38.5%; } .jj-list-con { overflow: hidden; margin: 0 auto } /*控制网站列表间距*/ .jj-list-con li { width: 31.333%; margin: 1%; } .link-3 { display: block; background: rgba(0, 0, 0, .35); color: #FFF; font-size: 13px; text-align: center; line-height: 35px; padding: 4px 0; border-radius: 2px; transition: all 0.2s } .link-3:hover { background: rgba(0, 0, 0, .45); font-size: 15px; font-weight: bold } /*1栏 小于584*/ @media only screen and (max-width: 584px) { .navi-height { height: 1300px; } .link-box { margin-top: 5%; } .large-screen { display: none; } } /* 2栏 大于584 小于993px */ @media only screen and (min-width: 584px) and (max-width: 993px) { .navi-height { height: 800px; } .link-box { margin-top: 5%; } .large-screen { display: none; } } /*3栏 大于993px*/ @media only screen and (min-width: 993px) { .navi-height { position: absolute; width: 100%; height: 100%; } } /* 隐藏footer */ .page-footer { display: none; }&lt;/style&gt;&lt;% if (theme.banner.enable) { %&gt;&lt;script&gt; // 每天切换 banner 图. Switch banner image every day. var bannerUrl = \"&lt;%- theme.jsDelivr.url %&gt;&lt;%- url_for('/medias/banner/') %&gt;\" + new Date().getDay() + '.jpg'; $('.bg-cover').css('background-image', 'url(' + bannerUrl + ')');&lt;/script&gt;&lt;% } else { %&gt;&lt;script&gt; $('.bg-cover').css('background-image', 'url(&lt;%- theme.jsDelivr.url %&gt;&lt;%- url_for('/medias/banner/0.jpg') %&gt;)');&lt;/script&gt;&lt;% } %&gt; 修改导航栏颜色以及透明效果打开themes/matery/source/css/matery.css文件，大约在250行，有一个.bg-color属性，修改其属性值即可，代码如下： 1234.bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); //修改成自己喜欢的颜色值 opacity: 0.8; //透明效果 值范围 0~1，看情况自己修改} 新增加载动画参考 1.在 Matery 主题配置文件 _config.yml 中新增配置属性 preloader。 1234# 是否开启页面加载动画 true 开启，false 关闭preloader: enable: true 2.在 Matery 主题目录 /layout/_widget 下新增文件 loading.ejs，将以下内容写入 loading.ejs。 12345678910111213141516171819202122&lt;% if (theme.preloader.enable) { %&gt;&lt;div id=\"loading-box\"&gt; &lt;div class=\"loading-left-bg\"&gt;&lt;/div&gt; &lt;div class=\"loading-right-bg\"&gt;&lt;/div&gt; &lt;div class=\"spinner-box\"&gt; &lt;div class=\"configure-border-1\"&gt; &lt;div class=\"configure-core\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"configure-border-2\"&gt; &lt;div class=\"configure-core\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"loading-word\"&gt;加载中...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; window.addEventListener('load', function(){ document.body.style.overflow = 'auto'; document.getElementById('loading-box').classList.add(\"loaded\") }, false)&lt;/script&gt;&lt;% } %&gt; 3.接着在 Matery 主题目录 /css 下新增 loading.css ，并将以下内容写入 loading.css。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#loading-box .loading-left-bg,#loading-box .loading-right-bg { position: fixed; z-index: 1000; width: 50%; height: 100%; background-color: #37474f; transition: all 0.5s;}#loading-box .loading-right-bg { right: 0;}#loading-box &gt; .spinner-box { position: fixed; z-index: 1001; display: flex; justify-content: center; align-items: center; width: 100%; height: 100vh;}#loading-box .spinner-box .configure-border-1 { position: absolute; padding: 3px; width: 115px; height: 115px; background: #ffab91; animation: configure-clockwise 3s ease-in-out 0s infinite alternate;}#loading-box .spinner-box .configure-border-2 { left: -115px; padding: 3px; width: 115px; height: 115px; background: rgb(63, 249, 220); transform: rotate(45deg); animation: configure-xclockwise 3s ease-in-out 0s infinite alternate;}#loading-box .spinner-box .loading-word { position: absolute; color: #ffffff; font-size: 0.8rem;}#loading-box .spinner-box .configure-core { width: 100%; height: 100%; background-color: #37474f;}div.loaded div.loading-left-bg { transform: translate(-100%, 0);}div.loaded div.loading-right-bg { transform: translate(100%, 0);}div.loaded div.spinner-box { display: none !important; }@keyframes configure-clockwise { 0% { transform: rotate(0); } 25% { transform: rotate(90deg); } 50% { transform: rotate(180deg); } 75% { transform: rotate(270deg); } 100% { transform: rotate(360deg); }}@keyframes configure-xclockwise { 0% { transform: rotate(45deg); } 25% { transform: rotate(-45deg); } 50% { transform: rotate(-135deg); } 75% { transform: rotate(-225deg); } 100% { transform: rotate(-315deg); }} 4.然后找到 Matery 主题目录 /layout/_partial 下找到 head.ejs，并在 &lt;head&gt; 标签中添加以下内容引入 loading.css 文件。&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"&lt;%- theme.jsDelivr.url %&gt;&lt;%- url_for('/css/loading.css') %&gt;\"&gt; 5.再找到 Matery 主题目录 /layout 下找到 layout.ejs，然后在&lt;body&gt; 标签下引入 loading.ejs。&lt;%- partial('_widget/loading') %&gt; 安装插件搜索1.使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下：npm install hexo-generator-search --save2.在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123search: path: search.xml field: post 3.在主题配置文件中开启本地搜索 文章字数统计插件如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。安装命令如下：npm i --save hexo-wordcount然后只需在主题下的 _config.yml 文件中，激活以下配置项即可： 12345wordCount: enable: false # 将这个值设置为 true 即可. postWordCount: true min2read: true totalCount: true 图片懒加载 图片预加载：顾名思义，图片预加载就是在网页全部加载之前，提前加载图片。当用户需要查看时可直接从本地缓存中渲染，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，这样浏览者可能以为图片预览慢而没兴趣浏览，把网页关掉，这时，就需要图片预加载。当然这种做法实际上牺牲了服务器的性能换取了更好的用户体验。 图片懒加载（缓载）：延迟加载图片或符合某些条件时才加载某些图片。这样做的好处是减少不必要的访问数据库或延迟访问数据库的次数，因为每次访问数据库都是比较耗时的即只有真正使用该对象的数据时才会创建。懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 懒加载对服务器前端有一定的缓解压力作用，预载则会增加服务器前端压力。使用图片懒加载需要安装插件：hexo-lazyload-image在站点根目录执行下面的命令： 1npm install hexo-lazyload-image --save 之后在站点配置文件下添加下面的代码： 1234lazyload: enable: true # 是否开启图片懒加载 onlypost: false # 是否只对文章的图片做懒加载 loadingImg: # eg ./images/loading.gif 代码压缩因为 hexo 生成的 html、css、js 等都有很多的空格或者换行，而空格和换行也是占用字节的，所以需要将空格换行去掉也就是我要进行的 “压缩”。我们采用 gulp 代码压缩方式。使用方法： 进入站点根目录下依次执行下面的命令： 123456# 全局安装gulp模块npm install gulp -g# 安装各种小功能模块 执行这步的时候，可能会提示权限的问题，最好以管理员模式执行npm install gulp gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save# 额外的功能模块npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save 在 Hexo 根目录新建文件 gulpfile.js，并复制以下内容到文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168var gulp = require(\"gulp\");var debug = require(\"gulp-debug\");var cleancss = require(\"gulp-clean-css\"); //css压缩组件var uglify = require(\"gulp-uglify\"); //js压缩组件var htmlmin = require(\"gulp-htmlmin\"); //html压缩组件var htmlclean = require(\"gulp-htmlclean\"); //html清理组件var imagemin = require(\"gulp-imagemin\"); //图片压缩组件var changed = require(\"gulp-changed\"); //文件更改校验组件var gulpif = require(\"gulp-if\"); //任务 帮助调用组件var plumber = require(\"gulp-plumber\"); //容错组件（发生错误不跳出任务，并报出错误内容）var isScriptAll = true; //是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件)var isDebug = true; //是否调试显示 编译通过的文件var gulpBabel = require(\"gulp-babel\");var es2015Preset = require(\"babel-preset-es2015\");var del = require(\"del\");var Hexo = require(\"hexo\");var hexo = new Hexo(process.cwd(), {}); // 初始化一个hexo对象// 清除public文件夹gulp.task(\"clean\", function () { return del([\"public/**/*\"]);});// 下面几个跟hexo有关的操作，主要通过hexo.call()去执行，注意return// 创建静态页面 （等同 hexo generate）gulp.task(\"generate\", function () { return hexo.init().then(function () { return hexo .call(\"generate\", { watch: false }) .then(function () { return hexo.exit(); }) .catch(function (err) { return hexo.exit(err); }); });});// 启动Hexo服务器gulp.task(\"server\", function () { return hexo .init() .then(function () { return hexo.call(\"server\", {}); }) .catch(function (err) { console.log(err); });});// 部署到服务器gulp.task(\"deploy\", function () { return hexo.init().then(function () { return hexo .call(\"deploy\", { watch: false }) .then(function () { return hexo.exit(); }) .catch(function (err) { return hexo.exit(err); }); });});// 压缩public目录下的js文件gulp.task(\"compressJs\", function () { return gulp .src([\"./public/**/*.js\", \"!./public/libs/**\"]) //排除的js .pipe(gulpif(!isScriptAll, changed(\"./public\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress JS:\" }))) .pipe(plumber()) .pipe( gulpBabel({ presets: [es2015Preset] // es5检查机制 }) ) .pipe(uglify()) //调用压缩组件方法uglify(),对合并的文件进行压缩 .pipe(gulp.dest(\"./public\")); //输出到目标目录});// 压缩public目录下的css文件gulp.task(\"compressCss\", function () { var option = { rebase: false, //advanced: true, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: \"ie7\" //保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式] //keepBreaks: true, //类型：Boolean 默认：false [是否保留换行] //keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 }; return gulp .src([\"./public/**/*.css\", \"!./public/**/*.min.css\"]) //排除的css .pipe(gulpif(!isScriptAll, changed(\"./public\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress CSS:\" }))) .pipe(plumber()) .pipe(cleancss(option)) .pipe(gulp.dest(\"./public\"));});// 压缩public目录下的html文件gulp.task(\"compressHtml\", function () { var cleanOptions = { protect: /&lt;\\!--%fooTemplate\\b.*?%--&gt;/g, //忽略处理 unprotect: /&lt;script [^&gt;]*\\btype=\"text\\/x-handlebars-template\"[\\s\\S]+?&lt;\\/script&gt;/gi //特殊处理 }; var minOption = { collapseWhitespace: true, //压缩HTML collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=\"true\"/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=\"\" /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=\"text/javascript\" removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=\"text/css\" removeComments: true, //清除HTML注释 minifyJS: true, //压缩页面JS minifyCSS: true, //压缩页面CSS minifyURLs: true //替换页面URL }; return gulp .src(\"./public/**/*.html\") .pipe(gulpif(isDebug, debug({ title: \"Compress HTML:\" }))) .pipe(plumber()) .pipe(htmlclean(cleanOptions)) .pipe(htmlmin(minOption)) .pipe(gulp.dest(\"./public\"));});// 压缩 public/medias 目录内图片gulp.task(\"compressImage\", function () { var option = { optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false //类型：Boolean 默认：false 多次优化svg直到完全优化 }; return gulp .src(\"./public/medias/**/*.*\") .pipe(gulpif(!isScriptAll, changed(\"./public/medias\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress Images:\" }))) .pipe(plumber()) .pipe(imagemin(option)) .pipe(gulp.dest(\"./public\"));});// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆 -&gt; 部署到服务器gulp.task( \"build\", gulp.series( \"clean\", \"generate\", \"compressHtml\", \"compressCss\", \"compressJs\", \"compressImage\", gulp.parallel(\"deploy\") ));// 默认任务gulp.task( \"default\", gulp.series( \"clean\", \"generate\", gulp.parallel(\"compressHtml\", \"compressCss\", \"compressJs\",\"compressImage\") ));//Gulp4最大的一个改变就是gulp.task函数现在只支持两个参数，分别是任务名和运行任务的函数 以后的执行方式有两种： 直接在 Hexo 根目录执行 gulp 或者 gulp default ，这个命令相当于 hexo cl&amp;&amp;hexo g 并且再把代码和图片压缩。 在 Hexo 根目录执行 gulp build ，等于说生成、压缩文件后又帮你自动部署了。 文章链接转静态短地址如果文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于SEO，且gitment评论对中文链接也不支持。我们可以用hexo-permalink-pinyin Hexo 插件生成文章时生成中文拼音的永久链接，或者用hexo-abbrlink 生成静态文章链接。以下结合hexo-abbrlink生成类似 /yyyy/mmdd+随机数.html 的文章链接地址。安装命令如下：npm install hexo-abbrlink --save在 Hexo 根目录下的 _config.yml 文件中，修改 permalink: ，并在文件末尾新增 abbrlink:配置项： 12345permalink: :year/:month:day:abbrlink.htmlabbrlink: alg: crc16 #算法选项：crc16丨crc32 rep: dec #输出进制：dec为十进制，hex为十六进制","categories":[{"name":"hexo","slug":"hexo","permalink":"https://wenkex.gitee.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wenkex.gitee.io/tags/hexo/"}]}],"categories":[{"name":"待分","slug":"待分","permalink":"https://wenkex.gitee.io/categories/%E5%BE%85%E5%88%86/"},{"name":"学习","slug":"学习","permalink":"https://wenkex.gitee.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"工具","slug":"工具","permalink":"https://wenkex.gitee.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"数据库","slug":"数据库","permalink":"https://wenkex.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"web","slug":"web","permalink":"https://wenkex.gitee.io/categories/web/"},{"name":"java","slug":"java","permalink":"https://wenkex.gitee.io/categories/java/"},{"name":"前端","slug":"前端","permalink":"https://wenkex.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/categories/python/"},{"name":"pytohn","slug":"pytohn","permalink":"https://wenkex.gitee.io/categories/pytohn/"},{"name":"知识","slug":"知识","permalink":"https://wenkex.gitee.io/categories/%E7%9F%A5%E8%AF%86/"},{"name":"自动化","slug":"自动化","permalink":"https://wenkex.gitee.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkex.gitee.io/categories/%E9%B8%BF%E8%92%99/"},{"name":"hexo","slug":"hexo","permalink":"https://wenkex.gitee.io/categories/hexo/"}],"tags":[{"name":"待分","slug":"待分","permalink":"https://wenkex.gitee.io/tags/%E5%BE%85%E5%88%86/"},{"name":"知识","slug":"知识","permalink":"https://wenkex.gitee.io/tags/%E7%9F%A5%E8%AF%86/"},{"name":"正则","slug":"正则","permalink":"https://wenkex.gitee.io/tags/%E6%AD%A3%E5%88%99/"},{"name":"SQLite","slug":"SQLite","permalink":"https://wenkex.gitee.io/tags/SQLite/"},{"name":"postman","slug":"postman","permalink":"https://wenkex.gitee.io/tags/postman/"},{"name":"redis","slug":"redis","permalink":"https://wenkex.gitee.io/tags/redis/"},{"name":"web","slug":"web","permalink":"https://wenkex.gitee.io/tags/web/"},{"name":"框架","slug":"框架","permalink":"https://wenkex.gitee.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"qq","slug":"qq","permalink":"https://wenkex.gitee.io/tags/qq/"},{"name":"python","slug":"python","permalink":"https://wenkex.gitee.io/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://wenkex.gitee.io/tags/pandas/"},{"name":"numpy","slug":"numpy","permalink":"https://wenkex.gitee.io/tags/numpy/"},{"name":"爬虫","slug":"爬虫","permalink":"https://wenkex.gitee.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"flask","slug":"flask","permalink":"https://wenkex.gitee.io/tags/flask/"},{"name":"matlab","slug":"matlab","permalink":"https://wenkex.gitee.io/tags/matlab/"},{"name":"深度学习","slug":"深度学习","permalink":"https://wenkex.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"linux","slug":"linux","permalink":"https://wenkex.gitee.io/tags/linux/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wenkex.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"小程序","slug":"小程序","permalink":"https://wenkex.gitee.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"window","slug":"window","permalink":"https://wenkex.gitee.io/tags/window/"},{"name":"自动化","slug":"自动化","permalink":"https://wenkex.gitee.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"markdown","slug":"markdown","permalink":"https://wenkex.gitee.io/tags/markdown/"},{"name":"vscode","slug":"vscode","permalink":"https://wenkex.gitee.io/tags/vscode/"},{"name":"autojs","slug":"autojs","permalink":"https://wenkex.gitee.io/tags/autojs/"},{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkex.gitee.io/tags/%E9%B8%BF%E8%92%99/"},{"name":"容器","slug":"容器","permalink":"https://wenkex.gitee.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"软件","slug":"软件","permalink":"https://wenkex.gitee.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"MySQL","slug":"MySQL","permalink":"https://wenkex.gitee.io/tags/MySQL/"},{"name":"计网","slug":"计网","permalink":"https://wenkex.gitee.io/tags/%E8%AE%A1%E7%BD%91/"},{"name":"java","slug":"java","permalink":"https://wenkex.gitee.io/tags/java/"},{"name":"hexo","slug":"hexo","permalink":"https://wenkex.gitee.io/tags/hexo/"}]}