{"meta":{"title":"wenke","subtitle":"个人博客","description":"专注于编程,分享生活,分享知识","author":"wenke","url":"https://wenkexia.github.io","root":"/"},"pages":[{"title":"404","date":"2021-11-01T11:37:13.000Z","updated":"2021-11-01T11:38:12.585Z","comments":true,"path":"404/index.html","permalink":"https://wenkexia.github.io/404/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-11-01T11:27:35.000Z","updated":"2021-12-21T11:53:24.702Z","comments":true,"path":"categories/index.html","permalink":"https://wenkexia.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-11-01T11:29:40.000Z","updated":"2022-01-08T12:59:04.203Z","comments":true,"path":"about/index.html","permalink":"https://wenkexia.github.io/about/index.html","excerpt":"","text":"“&nbsp;免责声明” 大部分资源来源于网络，仅供学习和交流使用，严禁商用，如有侵权，请联系我删除。 所有资源都有时效性，如果遇到失效的，请私信我。"},{"title":"contact","date":"2021-11-01T11:31:07.000Z","updated":"2021-11-01T11:34:49.609Z","comments":true,"path":"contact/index.html","permalink":"https://wenkexia.github.io/contact/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-12-21T11:51:03.000Z","updated":"2021-12-21T11:51:03.000Z","comments":true,"path":"link/index.html","permalink":"https://wenkexia.github.io/link/index.html","excerpt":"","text":"申请友链在评论区留言即可，但需先添加本站友链（申请格式如下文所述） ‘name: wenke’ ‘link: https://wenkex.top/'‘avatar: https://gitee.com/wenkex/blogimage/raw/master/favicon.png' ‘descr: wenke’"},{"title":"相册集","date":"2020-04-21T10:44:23.000Z","updated":"2022-01-06T10:15:44.567Z","comments":true,"path":"gallery/index.html","permalink":"https://wenkexia.github.io/gallery/index.html","excerpt":"","text":"虾虾 关于虾虾"},{"title":"标签","date":"2021-11-01T11:27:35.000Z","updated":"2021-12-21T11:53:03.522Z","comments":true,"path":"tags/index.html","permalink":"https://wenkexia.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-06T10:26:36.009Z","updated":"2022-01-06T10:26:36.009Z","comments":true,"path":"gallery/虾虾/index.html","permalink":"https://wenkexia.github.io/gallery/%E8%99%BE%E8%99%BE/index.html","excerpt":"","text":""}],"posts":[{"title":"postman接口自动化测试","slug":"postman接口自动化测试","date":"2022-04-20T01:36:28.000Z","updated":"2022-04-20T01:36:28.000Z","comments":true,"path":"2022/04205354.html","link":"","permalink":"https://wenkexia.github.io/2022/04205354.html","excerpt":"","text":"responseCode ：包含请求的返回的状态信息(如：code)responseBody：为接口请求放回的数据内容（类型为字符串）tests ：为键值对形式，用于表示我们的测试结果是成功与否，最终展示在 Test Results 中。key ：（如：code 200）我们可以用来当做结果的一个描述value：其值为布尔型，ture 表示测试通过， false 表示测试失败。所以上述代码应该不难理解了，而有了返回结果的数据以及表示结果成功与否 (预请求脚本)Pre-request Script","categories":[{"name":"web","slug":"web","permalink":"https://wenkexia.github.io/categories/web/"}],"tags":[{"name":"postman","slug":"postman","permalink":"https://wenkexia.github.io/tags/postman/"}]},{"title":"数据库-redis","slug":"数据库-redis","date":"2022-04-19T01:23:48.000Z","updated":"2022-04-19T01:23:48.000Z","comments":true,"path":"2022/041918402.html","link":"","permalink":"https://wenkexia.github.io/2022/041918402.html","excerpt":"","text":"redisRedis 是键值对(Key-Value)存储数据库，并提供多种语言的 API。 安装 Redis安装 Redis的docker环境123456789101112131415161718192021222324252627282930313233343536# 要确保docker环境已经安装成功docker --versiondocker search redis#拉取最新版本docker pull redis# -d：使用指定的镜像在后台运行容器，（使用守护进程运行）通过 docker ps查看不到的。因为在 docker 中，后台服务必须要有一个前台服务才能运行（前台服务即使用 -it 选项启动的服务）# -it 表示已交互模式运行容器,为容器重新分配一个伪输入终端# -p 6379:6379 将容器的6379端口映射到主机的6379端口# --name=\"myredis\" 表示自定义容器名# --requirepass \"root\"# -v /docker/redis/data:/data: 将主机中当前目录下的data挂载到容器的/data# redis-server : 在容器执行redis-server启动命令，# --appendonly yes 打开redis持久化配置docker run -d redis:latest -p 6379:6379 redis-server --appendonly yes --name=\"myredis\" --requirepass \"root\"docker start 容器名或容器id# 查看运行中的容器docker ps# 进入redis容器并启动一个redis交互式会话docker exec -it redis容器名 /bin/bash# 在redis交互式会话中连接 redis 服务redis-cli# 清理容器(停止 docker-redis 容器并删除)：docker stop redis容器名docker rm redis容器名 使用123456redis-cli #在redis交互式会话中连接 redis 服务config get requirepass #查看现有的redis密码config set requirepass pass_123456 #设置redis密码","categories":[{"name":"数据库","slug":"数据库","permalink":"https://wenkexia.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://wenkexia.github.io/tags/redis/"}]},{"title":"springboot学习","slug":"springboot学习","date":"2022-04-04T10:57:26.000Z","updated":"2022-04-04T10:57:26.000Z","comments":true,"path":"2022/040423525.html","link":"","permalink":"https://wenkexia.github.io/2022/040423525.html","excerpt":"","text":"学习框架首先要先了解它是干什么的，然后了解它的项目结构即每个文件有什么用 springbootspringboot是一个用来简化spring应用的初始搭建以及开发过程的框架简化依赖配置，简化常用工程相关配置，内置服务器 创建项目1.通过idea创建，可以更改成阿里云镜像服务：https://start.aliyun.comspring默认服务器：https://start.spring.io 2.若idea不能联网，通过spring boot官网创建 Druid连接池数据源与数据库连接池什么是数据源？JDBC2.0提供了javax.sql.DataSource接口，它负责建立与数据库的连接，当在应用程序中访问数据库时，不必编写连接数据库的代码，直接引用DataSource获取数据库的连接对象即可。用于获取操作数据的Connection对象。 什么是数据库连接池？数据库连接池的思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。可通过设定连接池的最大连接数来防止系统无尽的与数据库连接。更重要的是我们可以通过连接池的管理机制监视数据库的连接的数量、使用情况，为系统开发、测试以及性能调整提供依据。 数据源和数据库连接池的关系？数据源建立多个数据库连接，这些数据库连接将会保存在数据库连接池中，当需要访问数据库时，只需要从数据库连接池中获取空闲的数据库连接，当程序访问数据库结束时，数据库连接会放回数据库连接池中。 为什么要使用数据库连接池？传统的JDBC访问数据库技术，每次访问数据库都需要通过数据库驱动器Driver和数据库名称以及密码等等资源建立数据库连接。 如此就会存在两大问题： 频繁的建立与断开数据库连接，会降低执行效率，增加系统资源的开销。数据库的连接需要用户名和密码等资源，这些也需要一定的内存和CPU的开销。而数据库连接池很好地解决了这些问题。 加载依赖123456789101112&lt;!-- pom.xml --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; MyBatis-Plus数据库框架：Mybatis Plus &gt; Mybatis代码生成器：Mybatis Plus Generator &gt; Mybatis Generator Mybatis Plus 针对单表的基本CRUD操作，只需要创建好实体类，并创建一个继承自BaseMapper的接口即可，可谓非常简洁。并且，我们注意到，User类中的managerId，createTime属性，自动和数据库表中的manager_id，create_time对应了起来，这是因为mp自动做了数据库下划线命名，到Java类的驼峰命名之间的转化。 步骤1.导入依赖2.配置application.yml3.在数据库中创建表4.在entity层根据数据库表创建相应实体类5.在dao层创建对应mapper接口6.在SpringBoot启动类上配置mapper接口的扫描路径7.编写一个SpringBoot测试类 导入依赖123456&lt;!-- pom.xml --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; 配置数据库1234567891011# application.yml spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/数据库名?serverTimezone=Asia/Shanghai username: root password: root mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #开启SQL语句打印 mybatisplus分页工具类 IPagelombok最常用的用法就是在实体类中使用它的@Data注解，这样实体类就不用写set、get、toString等方法 @Data注解包含了 @ToString、@EqualsAndHashCode、@Getter / @Setter和@RequiredArgsConstructor的功能 引入依赖123456&lt;!-- pom.xml --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.14&lt;/version&gt;&lt;/dependency&gt; REST风格REST(Representational State Transfer),表现形式状态转换。它是一种针对网络应用的设计风格 优点1.隐藏资源的访问行为，无法通过地址得知对资源是何种操作2.书写简化 RESTful根据REST风格对资源进行访问称为RESTful @RestController类型：类注解位置：springMVC控制器类定义上方作用：设置当前控制器类为RESTful风格，等同于@Controller + @ResponseBody两个注解组合功能 请求动作映射名称：@GetMapping @PostMapping @PutMapping @DeleteMapping类型：方法注解位置：基于SpringMVC的RESTful开发控制器方法定义上方作用：设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求 @PathVariable类型：形参注解位置：springMVC控制器方法形参定义前面作用：绑定路径参数与处理器方法形参间的关系 常用注解区别@RequestParam用于接收url地址传参或表单传参@RequestBody用于接收json数据@PathVariable用于接收路径参数，使用{参数名称）描述路径参数 应用后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody,应用较广如果发送非json格式数据，选用@RequestParam接收请求参数采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值 案例1.设定http请求动作 12345@RequestMapping(value = \"/users\",method = RequestMethod.POST)@ResponseBodypublic String save(@ResponseBody User user){ System.out.println(\"user save\"); return \"{'module':'save'}\"; 2.设定请求参数(路径变量) 1234567// 路径上要有参数占位{id}@RequestMapping(value = \"/users/{id}\",method = RequestMethod.DELETE)@ResponseBody// 在形参上加@PathVariablepublic String delete(@PathVariable Integer id){ System.out.println(\"user save\"+id); return \"{'module':'delete'}\"; controller调用service,service调用dao 数据层DAO(Data Access Object) 是数据访问层，也被称为mapper层。即数据持久层，对数据做持久化操作。dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。 使用mybatis-plus后不用写mapper.xml文件 123456// dao/接口名.java// 定义数据层接口与映射配置，继承BaseMapper&lt;把实体类作为泛型传入&gt;@Mapper public interface 接口名 extends BaseMapper&lt;实体类&gt; { } entity层即数据库实体层，也被称为model层，pojo层，domain层存放的是实体类，属性值与数据库中的属性值保持一致。 实现set和get方法。 一般数据库一张表对应一个实体类，类属性同表字段一一对应 使用了 Lombok 简化代码 123456789101112131415161718// entity:@TableName(value = \"user\") //value指定表名@Date //使用Lombok插件，这样实体类就不用写set、get、toString等方法public class User implements Serializable { private static final long serialVersionUID = 1L; //value与数据库主键列名一致，若实体类属性名与表主键列名一致可省略value @TableId(value = \"id\", type = IdType.AUTO) //指定自增策略 private Integer id; //若没有开启驼峰命名，或者表中列名不符合驼峰规则，可通过该注解指定数据库表中的列名，exist标明数据表中有没有对应列 @TableField(value = \"last_name\",exist = true) private String lastName; private String name; private String password; private String username; } 业务层(service)业务层，service层的作用为完成功能设计。存放业务逻辑处理，不直接对数据库进行操作，有接口和接口实现类(定义一个接口，然后再一个或多个类去实现),提供controller层调用的方法。调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。（也就是说对于项目中的功能的需求就是在这里完成的） 快速开发方案使用MyBatisPlus提供有业务层通用接口(ISerivce)与业务层通用实现类(ServiceImpl&lt;M,T&gt;)在通用类基础上做功能重载或功能追加注意重载时不要覆盖原始操作，避免原始提供的功能丢失 创建接口在java内的项目包下 新建 service包（一般接口都放在其中） 然后再其中新建XXXService接口 12// 基于mybatisplus快速开发，ctrl+o查看mp帮你重写或覆盖的方法public interface IBookService extends IService &lt;实体类&gt;{ } 创建接口实现类service 包内 新建 impl 包（实现类全部在impl包内） 1234@Service// 继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类// extends ServiceImpl&lt;BookDao,Book&gt; //传入两个泛型(dao层,实体类)public class IBookServiceImpl extends ServiceImpl&lt;BookDao,Book&gt; implements IBookService {} 单元测试类1234567891011121314151617181920212223242526package com.ke.bookm.service;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;/** * @author wenke * @Classname BookServiceTestCasde * @Description TODO * @Date 2022/4/7 20:48 */@SpringBootTestpublic class BookServiceTestCase { // 接口有多个实现类时使用@Qualifier注解指定实现类： // @Qualifier(\"qualifierServiceImpl2\") @Autowired private BookService bookService; @Test void testGetById(){ bookService.getById(4); }} 控制器层(controller)表现层，控制器层，controller层的功能为请求和响应控制。controller层负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端。 @Controller和@ResponseBody注解在一个类上添加@Controller注解，表明了这个类是一个控制器类在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面,若返回json等内容到页面，则需要加@ResponseBody注解 @ResponseBody表示方法的返回值直接以指定的格式写入Http response body中，而不是解析为跳转路径。格式的转换是通过HttpMessageConverter中的方法实现的，因为它是一个接口，因此由其实现类完成转换。 @RestController如果需要返回的是数据（如：JSON、XML或自定义的metatype等数据类型）时，@RestController完全等同于@Controller+@Responsebody如果要求方法返回的是json格式数据，而不是跳转页面，可以直接在类上标注@RestController，而不用在每个方法中标注@ResponseBody，简化了开发过程。但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面 @RequestMapping@RequestMapping注解是用来映射请求的，即指明处理器可以处理哪些URL请求，该注解既可以用在类上，也可以用在方法上。 当使用@RequestMapping标记控制器类时，方法的请求地址是相对类的请求地址而言的；当没有使用@RequestMapping标记类时，方法的请求地址是绝对路径。 @RequestMapping的地址可以是url变量，并且通过@PathVariable注解获取作为方法的参数。也可以是通配符来筛选请求地址。 @Autowired@Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。 在使用@Autowired时，首先在容器中查询对应类型的bean如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据如果查询的结果不止一个，那么@Autowired会根据名称来查找。 @Override@Override 注解是用来指定方法重写的，只能修饰方法并且只能用于方法重写，不能修饰其它的元素。它可以强制一个子类必须重写父类方法或者实现接口的方法。 创建控制器类创建控制器类com.controller.UserController.java 1234567@RestController@RequestMapping(\"/users\")public class UserController { // 添加业务层对象 @Autowired private IUserService userService; } controller.utils表现层数据一致性处理 启动类123456789101112131415package com.example.mp; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication // 在SpringBoot启动类上配置mapper接口的扫描路径 @MapperScan(\"com.example.mp.mappers\") public class MybatisPlusApplication { public static void main(String[] args) { // 定义容器对象，并启动 SpringApplication.run(MybatisPlusApplication.class, args); } } SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean 测试类123456789101112@SpringBootTestclass Springboot04JunitApplicationTests { //注入你要测试的对象 @Autowired private BookDao bookDao; @Test void contextLoads() { //执行要测试的对象对应的方法 bookDao.save(); System.out.println(\"two...\"); }} application.yml在官方文档里找到application.properties文件，可查看可修改的配置官方文档 默认是application.properties，我们将application.properties改为application.yaml yaml后缀使用.yml或者.yaml都行 优点：易阅读易于脚本语言交互以数据为核心，重数据轻格式 语法规则大小写敏感属性层级关系使用多行描述，每行结尾使用冒号结束使用缩进表示层级关系，同层级左侧对齐，只允许使用空格(不允许使用Tab键)属性值前面添加空格(属性名与属性值之间使用冒号+空格作为分隔)#表示注释使用” “括住的内容可以使用转义字符 常用用$进行变量引用path: c:\\user\\bin temp: ${path}\\temp 数据结构对象：键值对的集合，又称为映射(mapping)/ 哈希(hashes) / 字典(dictionary) 数组：一组按次序排列的值，又称为序列(sequence) / 列表(list) 使用一个短横线加一个空格代表一个数组项：hobby: Javajdk pythonpy纯量(scalars)：单个的、不可再分的值","categories":[{"name":"java","slug":"java","permalink":"https://wenkexia.github.io/categories/java/"}],"tags":[{"name":"web","slug":"web","permalink":"https://wenkexia.github.io/tags/web/"}]},{"title":"前端学习","slug":"前端学习","date":"2022-04-03T14:07:51.000Z","updated":"2022-04-03T14:07:51.000Z","comments":true,"path":"2022/040312750.html","link":"","permalink":"https://wenkexia.github.io/2022/040312750.html","excerpt":"","text":"HTMLHTML:（HyperText Markup Language）【超文本标记语言】狭义的HTML指的是网页；广义的HTML指的是前端技术（html,css,js,以及各种框架）——网页，移动端网页，小程序，公众号，移动端的app，快应用等。 HTML是一门标记语言，标记语言由一套标记标签组成，学习HTML，就是学习标签。 基础HTML注释符号是以 &lt;– 开始以 –&gt; 结束的 vscode编辑htmlopen in brower按下快捷键ALT+B 即可在浏览器运行html HTMLHint错误提示 html snippets常用html代码片段模板 live server实时预览html文件 beautify格式化代码工具，美化javascript，JSON，CSS，Sass，和HTML HTML文件的规范html文件以开始，以结尾，其他任何标签，需要写在和之间；Html标签只包含两个子标签：head和body；和网页设置相关的内容都写在head标签里；需要显示的内容都写在body标签里； 标签由尖括号包裹单词构成，如：&lt;html&gt;，所以标签不可能以数字开头。标签不区分大小写，但推荐小写。标签也称为元素。 单标签1234单标签有两种写法： 写法一：只写开标签即可&lt;br&gt; 写法二：在开标签的结尾写一个/，如&lt;br/&gt; 双标签：12开始标签又称开放标签&lt;a&gt;标签体&lt;/a&gt;结束标签又称闭合标签或关标签自闭合标签/单标签，如：&lt;meta charset=\"UTF-8\"&gt;，&lt;br&gt;等 超链接指向 w3school 的超链接： 12&lt;a href=\"http://www.w3school.com.cn\" &gt;文字说明&lt;/a&gt;rel：规定当前文档与被链接文档之间的关系。 HTML 表单method 属性规定如何发送表单数据（表单数据发送到 action 属性所规定的页面）。 表单数据可以作为 URL 变量（method=”get”）或者 HTTP post （method=”post”）的方式来发送。 123456&lt;!-- 一个简单的 HTML 表单，包含两个文本输入框和一个提交按钮 --&gt;&lt;form action=\"form_action.asp\" method=\"get\"&gt; First name: &lt;input type=\"text\" name=\"fname\" /&gt; Last name: &lt;input type=\"text\" name=\"lname\" /&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; input标签input 标签用于搜集用户信息。根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等。&lt;input type=\"表单元素的类型\" name=\"名称\" value=\"默认值\" size=\"宽度\"&gt; type属性text 单行文本框 省略时默认就是textpassword 密码框 输入时以点号显示，安全redio 单选按钮 只能选择其中一个checkbox 复选框 可以同时选择多个submit 提交按钮 提交表单数据reset 重置按钮 重置表单元素的初始值image 图像按钮 可以使用图片作为按钮button 普通按钮 默认情况下无功能file 文件选择器 选择要上传的文件hidden 隐藏域 在页面上不显示，但是会提交，可以用来存储数据 placeholder属性placeholder属性提供可描述输入字段预期值的提示信息 CSS基础div标签中id、class属性的使用与区别div用于标示块级元素，而span标示行内元素。 1、语法区别id对应CSS是用样式选择符“#”（井号）；class对应CSS是用样式选择符“.”(英文半角输入句号)。 12&lt;div id=\"header\"&gt;&lt;/div&gt; &lt;div class=\"abc\"&gt;&lt;/div&gt; 对应CSS应该是： 123#header{...} .abc{...} id：在同一个页面，只可以被调用一次，在CSS里用“#”表示。class：是类标签，在同一个页面可以调用无数次（没限制的），在CSS里用“.”表示。 使用css三种使用 CSS 的方法 外部 CSS内部 CSS行内 CSS 外部 CSS外部样式表可以在任何文本编辑器中编写，并且必须以 .css 扩展名保存。外部样式在 HTML 页面 部分内的 元素中进行定义： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS 选择器CSS 选择器用于“查找”（或选取）要设置样式的 HTML 元素。 id选择器:#id id 名称不能以数字开头。 12345/* 这条CSS 规则将应用于 id=\"para1\" 的 HTML 元素 */#para1 { text-align: center; color: red;} 类选择器:如需选择拥有特定 class 的元素，请写一个句点（.）字符，后面跟类名。 12345/* 在此例中，所有带有 class=\"center\" 的 HTML 元素将为红色且居中对齐： */.center { text-align: center; color: red;} CSS 通用选择器通用选择器（*）选择页面上的所有的 HTML 元素。 123456/* 下面的 CSS 规则会影响页面上的每个 HTML 元素： */* { text-align: center; color: blue;} CSS 分组选择器分组选择器选取所有具有相同样式定义的 HTML 元素。 1234h1, h2, p { text-align: center; color: red;} 组合器选择器（根据它们之间的特定关系来选取元素）伪类选择器（根据特定状态选取元素）伪元素选择器（选取元素的一部分并设置其样式）属性选择器（根据属性或属性值来选取元素）css基础属性文字类colorfont-sizetext-decorationtext-align 尺寸类widthheight 背景：background-colorbackground-imagebackground-size:cover 工具谷歌浏览器CSS Overview在 Chrome 的管理面板中，开启CSS Overview面板之后，就可以查看当前网站的样式信息了，包括颜色信息、字体信息、媒体查询等 1.在任意页面打开 Chrome 浏览器的 DevTools；2.单击更多选项 -&gt; More tools -&gt; CSS Overview。 新的字体编辑器工具Chrome DevTools 提供了一个实验性的字体编辑器工具，可以用来改变字体设置。可以用它来改变字体、大小、粗细、行高、字符间距，并实时看到变化 1.在任意页面打开 Chrome 浏览器的 DevTools；2.点击右上角设置图标 -&gt; 选中左侧 Experiments -&gt; 勾选 Enable New Font Editor Tools within Styles Pane；3.重启浏览器的 DevTools；4.选择HTML元素，其中包括想改变的字体，点击字体图标即可。 JavaScriptJavaScript是一种轻量级的脚本语言。 JavaScript 插入 HTML 页面后，由浏览器执行。JavaScript 控制了网页的行为 推荐w3school或者runoob JavaScript的组成：ECMAScript(语言基础，如：语法、数据类型结构以及一些内置对象) DOM（一些操作页面元素的方法） BOM（一些操作浏览器的方法） HTML 定义了网页的内容CSS 描述了网页的布局 数据结构1234var length = 7; // 数字var lastName = \"Gates\"; // 字符串var cars = [\"Porsche\", \"Volvo\", \"BMW\"]; // 数组var x = {firstName:\"Bill\", lastName:\"Gates\"}; // 对象 数字12345678910// 生成 [ n, m ) 范围内的随机数（大于等于n，小于m）// var random = Math.random()*(m-n)+n a=Math.random()*5+1 toastLog (a) // 生成 [ min, max ] 范围内的随机整数（大于等于min，小于等于max）// var random =Math.floor(Math.random()*(max-min+1))+min b=Math.floor(Math.random()*(5))+1 toastLog(b) 字符串 在字符串中换行，需要加一个反斜杠(非ECMAScript标准）： 12document.getElementById(\"demo\").innerHTML = \"Hello \\Kitty!\"; String和Number相加时，会将数字转为字符串；String和Number相减时，会将字符串转为数字； 数组对象JavaScript 对象是变量的容器。但是，我们通常认为 “JavaScript 对象是键值对的容器”。对象也是一个变量，但对象可以包含多个值（多个变量），每个值以 name:value 对呈现。总结：JavaScript 对象是属性和方法的容器。 1var car = {name:\"Fiat\", model:500, color:\"white\"}; null：类型是对象，不存在的事物。 12null === undefined // falsenull == undefined // true 对象属性键值对在 JavaScript 对象通常称为 对象属性。访问对象属性你可以通过两种方式访问对象属性: 121.person.lastName;2.person[\"lastName\"]; 对象方法123456789//也可以通过person.firstName=\"...\"的方式初始化var person = {firstName: \"Bill\",lastName : \"Gates\",id : 678,fullName : function() { //成员函数 return this.firstName + \" \" + this.lastName;}}; 用法脚本放置 HTML 的 或 部分中，或者同时存在于两个部分中。位于 与 标签之间。 也可以把脚本保存到外部文件中，在 标签的 \"src\" 属性中设置该 .js 文件： 基础注释12//单行注释多行注释以 /* 开始，以 */ 结尾。 变量变量必须以字母开头变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）变量名称对大小写敏感（y 和 Y 是不同的变量）1.声明（创建） JavaScript 变量我们使用 var 关键词来声明变量： 2.一条语句，多个变量您可以在一条语句中声明很多变量。该语句以 var 开头，并使用逗号分隔变量即可： var lastname=”Doe”, age=30, job=”carpenter”; undefined：只声明过但未赋值的变量。 ==与===： 前者是equality、后者为identity，即后者不会进行类型转换，类型不同的结果一定不等。 局部变量在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它 局部变量生命期从被声明的时间开始。在函数运行以后被删除。 函数函数就是包裹在花括号中的代码块，前面使用了关键词 function：当您声明函数时，请把参数作为变量来声明： 1234function myFunction(var1,var2)&#123;代码&#125; 箭头函数123456789101112131415//经典格式： 函数名 = ( 参数 ) =&gt; &#123; 方法体 &#125; const sum3 = (x,y)=&gt;&#123; return x+y; &#125;console.log(sum3) //当方法体只有一行时，花括号可以省略： const sum4 = (x,y) =&gt; x+y; console.log(sum4) //当只有一个参数时，括号可以省略： 条件语句123456789101112if (condition1)&#123; 当条件 1 为 true 时执行的代码&#125;else if (condition2)&#123; 当条件 2 为 true 时执行的代码&#125;else&#123; 当条件 1 和 条件 2 都不为 true 时执行的代码&#125; 循环语句for - 循环代码块一定的次数 1234for (语句 1; 语句 2; 语句 3)&#123; 被执行的代码块&#125; for/in - 循环遍历对象的属性while - 当指定的条件为 true 时循环指定的代码块 1234while (条件)&#123; 需要执行的代码&#125; do/while - 同样当指定的条件为 true 时循环指定的代码块 12345do&#123; 需要执行的代码&#125;while (条件); 模块系统module.exports 对象是由模块系统创建的。在我们自己写模块的时候，需要在模块最后写好模块接口，声明这个模块对外暴露什么内容，module.exports 提供了暴露接口的方法。第一种：返回一个实例对象 12345678910//CLASS.jsvar CLASS = function()&#123; this.name = &quot;class&quot;;&#125;CLASS .func = function()&#123; alert(this.name);&#125;module.exports = new CLASS(); 1234//调用var c = require(&#x27;./CLASS.js&#x27;);c.func();//&quot;class&quot; Thymeleaf模板引擎https://developer.aliyun.com/article/769977 模板引擎模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的html文档。 将模板设计好之后直接填充数据即可而不需要重新设计整个页面。让网站实现界面和数据分离，提高页面、代码的复用性。 介绍Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎 特点1.动静分离： Thymeleaf选用html作为模板页，这是任何一款其他模板引擎做不到的！Thymeleaf使用html通过一些特定标签语法代表其含义，但并未破坏html结构，即使无网络、不通过后端渲染也能在浏览器成功打开，大大方便界面的测试和修改。 2.开箱即用： Thymeleaf提供标准和Spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改JSTL、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 3.Springboot官方大力推荐和支持，Springboot官方做了很多默认配置，开发者只需编写对应html即可，大大减轻了上手难度和配置复杂度。 第一个Thymeleaf程序步骤 创建程序，添加依赖首先，打开你的IDEA创建新项目，选择Spring Initializr方式创建Springboot项目 ，然后点击next，然后填写项目名 勾选其中Web 模块的Spring web依赖以及Template 模块的Thymeleaf依赖。finish 即可： 如果你创建项目时没有勾选依赖也不要紧，在pom.xml中添加以下依赖： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 文件说明pom.xml：是项目中的Maven依赖，因为Springboot使用Maven来管理外部jar包依赖，我们只需填写依赖名称配置即可引入该依赖，在本系统中引入Spring web模块(Springmvc)和Thymeleaf的依赖.我们不需要自己去招相关jar包。application.properties: 编写Springboot与各框架整合的一些配置内容。controller：用来编写控制器，主要负责处理请求以及和视图(Thymeleaf)绑定。static：用于存放静态资源，例如html、JavaScript、css以及图片等。templates：用来存放模板引擎Thymeleaf(本质依然是.html文件) 编写Controller项目基于Springboot框架，且选了Spring web(Springmvc)作为mvc框架，其中Thymeleaf就是v(view)视图层，我们需要在controller中指定Thymeleaf页面的url，然后再Model中绑定数据。 我们在com.Thymeleaf文件下创建controller文件夹，在其中创建urlController.java的controller文件，文件内容(代码)为： 12345678910111213141516package com.Thymeleaf.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class urlController &#123; @GetMapping(&quot;index&quot;)//页面的url地址 public String getindex(Model model)//对应函数 &#123; model.addAttribute(&quot;name&quot;,&quot;bigsai&quot;); return &quot;index&quot;;//与templates中index.html对应 &#125;&#125; 部分含义如下：@controller 注解的意思就是声明这个java文件为一个controller控制器。@GetMapping(“index”) 其中@GetMapping的意思是请求的方式为get方式(即可通过浏览器直接请求)，而里面的index表示这个页面(接口)的url地址(路径)。即在浏览器对项目网页访问的地址。getindex() 是@GetMapping(“index”)注解对应的函数，其类型为String类型返回一个字符串，参数Model类型即用来储存数据供我们Thymeleaf页面使用。model.addAttribute(“name”,”bigsai”) 就是Model存入数据的书写方式，Model是一个特殊的类，相当于维护一个Map一样，而Model中的数据通过controller层的关联绑定在view层(即Thymeleaf中)可以直接使用。return “hello”：这个index就是在templates目录下对应模板(本次为Thymeleaf模板)的名称，即应该对应hello.html这个Thymeleaf文件(与页面关联默认规则为：templates目录下返回字符串.html)。 编写Thymeleaf页面咱们在项目的resources目录下的templates文件夹下面创建一个叫index.html的文件，咱们在这个html文件中的标签修改为这样在Thymeleaf中就可以使用Thymeleaf的语法和规范啦。 对于第一个Thymelaf程序，你只需将index.html文件改成这样即可： 1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello 第一个Thymeleaf程序&lt;div th:text=&quot;$&#123;name&#125;&quot;&gt;name是bigsai(我是离线数据)&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Thymeleaf语法详解常用标签链接表达式: @{…}变量表达式: ${…}选择变量表达式: *{…}消息表达: #{…}Bootstrap前端框架教程 Bootstrap 可视化布局系统！ Bootstrap:前端页面框架，用于快速开发响应式页面，一套代码就可以适应平板和PC 引入bootstrap框架1、直接引入： 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 优点：方便，简单； 缺点：使网页加载缓慢，需要有网络的情况； 2.下载好库再进行引入：优点：加载网页会快点，没有网络的情况也可用； jQueryjQuery菜鸟教程jQuery ：是一个 JavaScript 函数库。使用选择器（$）选取DOM对象，并对其进行赋值、取值、事件绑定等操作；主要是操作DOM 获取国内用百度CDN 1234&lt;head&gt;&lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; jQuery 语法基础语法： $(selector).action() 美元符号定义 jQuery选择符（selector）”查询”和”查找” HTML 元素jQuery 的 action() 执行对元素的操作 jQuery 选择器jQuery 事件Ajax可实现页面无刷新更新数据 Ajax相当于浏览器发送请求与接受响应的代理人，以实现在不重新加载整个页面下，与服务器交换数据并局部更新网页数据 向服务器发送请求open(method,url,async)规定请求的类型、URL 以及是否异步处理请求。参数 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) 将请求发送到服务器。 string：仅用于 POST 请求 实例1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script&gt;function loadXMLDoc()&#123; var xmlhttp; if (window.XMLHttpRequest) &#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 // 创建 XMLHttpRequest 对象 xmlhttp=new XMLHttpRequest(); &#125; else &#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125; &#125; xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true); xmlhttp.send();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;使用 AJAX 修改该文本内容&lt;/h2&gt;&lt;/div&gt;&lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;修改内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; axiosaxios实现了对ajax的封装。Axios 是可以发出 http 请求的 JavaScript 库，在 浏览器 和 node.js 环境中都可以运行。 axios与ajax的优缺点1.axios优点：（1）从浏览器中创建 XMLHttpRequest；（2）支持 Promise API；（3）从 node.js 创建 http 请求；（4）转换请求和响应数据；（5）自动转换JSON数据。 1.ajax缺点:（1）基于原生的XHR开发，XHR本身的架构不清晰；（2）JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理；（3）不符合关注分离（Separation of Concerns）的原则；（4）配置和调用方式非常混乱，而且基于事件的异步模型不友好。 GET 请求和POST 请求12345678910111213141516171819202122232425262728293031&lt;script src=&quot;../js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt;// 1、向给定ID的用户发起GET 请求axios.get(&#x27;/user?ID=12345&#x27;) .then(function (response) &#123; // 处理成功情况 console.log(response); &#125;) .catch(function (error) &#123; // 处理错误情况 console.log(error); &#125;) .then(function () &#123; // 总是会执行 &#125;);// 2.POST 请求axios.post(&#x27;/user&#x27;, &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);&lt;/script&gt; Vue.js官方文档：http://vuejs.org/v2/guide/syntax.html 中文文档: https://cn.vuejs.org/v2/guide/syntax.html vscode配置Vetur - 格式化vue 文件 1234567// vscode保存后的动作 &quot;editor.codeActionsOnSave&quot;: &#123; // 保存后自动格式化js,css代码，需要安装插件(ESLint,StyleLint) &quot;source.fixAll.eslint&quot;: true, &quot;source.fixAll.stylelint&quot;: true &#125;, js表达式与js代码(语句)的区别1.表达式：一个表达式会生成一个值 (1)a+b (2)x===y ‘a’ ? ‘b’ 2.代码 (1)if (){} 模板语法插值语法功能：用于解析标签体内容写法：容器中的是js表达式，可以自动读取vue实例中data的所有属性 指令语法功能：用于解析标签(包括标签属性，标签体内容，绑定事件) v-bind:v-bind用于单向绑定数据和元素属性 123 &lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 可简写为： --&gt; &lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; v-model双向数据绑定,一般用在表单类元素如：input，select 1234双向&lt;input type=&quot;text&quot; v-model:value=&quot;school.name&quot;&gt;&lt;!-- 因为v-model默认收集的就是value值，所以可简写为 --&gt;双向&lt;input type=&quot;text&quot; v-model=&quot;school.name&quot;&gt; 使用12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 定义一个容器 --&gt;&lt;div id=&quot;root&quot;&gt; &lt;!-- &#123;&#123; &#125;&#125; 用于输出对象属性和函数返回值。 --&gt; &lt;h1&gt;site : &#123;&#123;site&#125;&#125;&lt;/h1&gt; &lt;h1&gt;url : &#123;&#123;url&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;details()&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;!-- 对于制作原型或学习，你可以这样引入最新版本： --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // vue实例 var vm = new Vue(&#123; // el 参数的两种写法 // vm.$mount(&#x27;#rood&#x27;), el: &#x27;#rood&#x27;, // data参数用于定义属性 // 1.data参数的对象式写法 data: &#123; site: &quot;菜鸟教程&quot;, url: &quot;www.runoob.com&quot;, alexa: &quot;10000&quot; &#125;, // 2.data参数的函数式写法(vue管理的函数，不能用箭头函数) // data:function()&#123; // return&#123; // name:&#x27;菜鸟&#x27; // &#125; // &#125; // methods参数用于定义函数 methods: &#123; details: function() &#123; return this.site + &quot; - 学的不仅是技术，更是梦想！&quot;; &#125; &#125; &#125;)&lt;/script&gt; 钩子函数created() {}VUE对象初始化完成后自动执行 Element UIElement UI 是一套采用 Vue 2.0 作为基础框架实现的组件库 组件 安装1234&lt;!-- 引入样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;!-- 引入组件库 --&gt;&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; 基础Layout 布局Container 布局容器Color 色彩Typography 字体Border 边框Icon 图标Button 按钮Link 文字链接Form 表单Radio 单选框Checkbox 多选框Input 输入框InputNumber 计数器Select 选择器Cascader 级联选择器Switch 开关Slider 滑块TimePicker 时间选择器DatePicker 日期选择器DateTimePicker 日期时间选择器Upload 上传Rate 评分ColorPicker 颜色选择器Transfer 穿梭框Form 表单 数据Table 表格Tag 标签Progress 进度条Tree 树形控件Pagination 分页Badge 标记Avatar 头像Skeleton 骨架屏Empty 空状态Descriptions 描述列表Result 结果 输入框 &lt;el-input v-model=&quot;input1&quot;&gt;&lt;/el-input&gt; 输入内容为：&#123;&#123;input1&#125;&#125; Table表格组件el-table:data属性 单向数据绑定 stripe属性可以创建带斑马纹的表格 Table 组件提供了单选的支持，只需要配置highlight-current-row属性即可实现单选。之后由current-change事件来管理选中时触发的事件，它会传入currentRow，oldCurrentRow。如果需要显示索引，可以增加一列el-table-column，设置type属性为index即可显示从 1 开始的索引号。 el-table-columnprop属性来对应对象中的键名即可填入数据，label属性来定义表格的列名。width属性来定义列宽。align=“center”：设置表格内居中 1234567891011121314151617181920212223&lt;el-table size=&quot;small&quot; current-row-key=&quot;id&quot; :data=&quot;dataList&quot; stripe highlight-current-row&gt; &lt;el-table-column type=&quot;index&quot; align=&quot;center&quot; label=&quot;序号&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;type&quot; label=&quot;图书类别&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;图书名称&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;description&quot; label=&quot;描述&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;handleUpdate(scope.row)&quot;&gt;编辑&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; @click=&quot;handleDelete(scope.row)&quot;&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt;&lt;/el-table&gt; 通知Alert 警告Loading 加载Message 消息提示MessageBox 弹框Notification 通知NavigationNavMenu 导航菜单Tabs 标签页Breadcrumb 面包屑PageHeader 页头Dropdown 下拉菜单Steps 步骤条 导航其他Dialog 对话框Tooltip 文字提示Popover 弹出框Popconfirm 气泡确认框Card 卡片Carousel 走马灯Collapse 折叠面板Timeline 时间线Divider 分割线Calendar 日历Image 图片Backtop 回到顶部InfiniteScroll 无限滚动Drawer 抽屉¶Button 按钮 通过js触发按钮的点击事件1234567891011121314151617&lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;handleUpdate(scope.row)&quot;&gt;编辑&lt;/el-button&gt;&lt;script&gt; //弹出编辑窗口 handleUpdate(row) &#123; axios.get(&quot;/books/&quot;+row.id).then((res)=&gt;&#123; if(res.data.flag &amp;&amp; res.data.data != null )&#123; this.dialogFormVisible4Edit = true; this.formData = res.data.data; &#125;else&#123; this.$message.error(&quot;数据同步失败，自动刷新&quot;); &#125; &#125;).finally(()=&gt;&#123; //2.重新加载数据 this.getAll(); &#125;); &#125;,&lt;/script&gt; NodejsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。电脑安装了Node.js后， Node.js 相当于浏览器，也可以在里面运行 JavaScript 了！ Nodejs的组成：ECMAScript(语言基础，如：语法、数据类型结构以及一些内置对象) os(操作系统) file(文件系统) net(网络系统) database(数据库) 安装Node.js下载地址 打开cmd输入命令检查是否安装成功： 12node -v 查看node版本npm -v 查看npm版本 Node.js 安装成功时也默认安装了 npm， npm 是随 Node.js 一起被安装的包管理工具，你可以理解成 Node.js 自带的应用商店。是用来安装/卸载Node.js需要装的东西 环境配置1.修改全局模块路径和缓存路径当我们在执行npm install express -g命令时，会默认下载到c盘，更改下载盘在nodejs安装目录下创建创建两个文件夹，名称分别为：node_global(全局模块)和node_cache(缓存)，在node_global文件夹下再建一个node_modules文件夹，配置环境变量用 2.win+R打开运行窗口，输入cmd，再输入以下两条指令npm config set prefix “创建的node_global文件夹所在路径”npm config set cache “创建的node_cache文件夹所在路径” 3.修改完毕后，再配置环境变量右键此电脑——&gt;高级系统设置——&gt;环境变量在系统变量中，新建，变量名：NODE_PATH变量值：node_global文件夹下的node_modules文件夹。如：E:\\develop\\nodejs\\node_global\\node_modules 修改用户变量中的Path变量，将默认的npm路径修改为新建的node_global路径如：D:\\ruanjian\\nodejs\\node_global npm参考npm (node package manager) 是 JavaScript 世界的包管理工具，是 Node.js 平台的默认包管理工具，简单地说，就是通过 npm 下载模块，复用已有的代码，提高工作效率。 组成npm 由三个独立的部分组成： 网站 注册表（registry） 命令行工具 (CLI) 网站 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。 注册表 是一个巨大的数据库，保存了每个包（package）的信息。 CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。 npm中文文档 切换为 taobao 镜像源国内使用 npm 可能很慢。你可以考虑切换为 taobao 镜像源。 1npm config set registry https://registry.npm.taobao.org 使用123456# 安装npm install# 卸载npm uninstall# 清理缓存npm cache clean -f cnpm 是什么？简单的讲就是中国版的 NPM，因为 npm 安装插件是从国外服务器下载，受网络影响大，可能出现异常，需要安装 cnpm 模块，命令如下： 1npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm 支持可以使用支持 npm 除 publish 之外的所有命令。 因为 cnpm 的仓库只是 npm 仓库的一个拷贝，它不承担 publish 工作，所以执行 cnpm publish 命令会失败的。 yarn 是什么？Yarn 是一个软件包管理器，还可以作为项目管理工具，你可以通过它使用全世界开发者的代码， 或者分享自己的代码。 从 npm 安装软件包并保持相同的包管理流程。 特点：1.速度超快。Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。 2.超级安全在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。 3.超级可靠使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。通过命令安装 1npm install -g yarn 常用命令yarn init：初始化项目，会在根目录下生成一个 package.json，与 npm 类似具体不做解释 yarn add ：安装依赖包，会自动安装最新版本，会覆盖指定版本号 yarn add ：一次性添加多个包 yarn add @version：添加指定版本的包 yarn upgrade @version：将包更新到指定版本 yarn upgrade –latest ：将包更新到最新版本 yarn remove ：删除包 yarn remove ：一次性删除多个包 yarn info ：可以用来查看某个模块的最新版本信息 yarn install：安装 package.json 里所有包，并将包及它的所有依赖项保存进 yarn.lock yarn install –force ：强制重新下载所有包 yarn install –flat：安装一个包的单一版本 yarn install –production：只安装 dependencies 里的包 yarn install –no-lockfile：不读取或生成 yarn.lock yarn install –pure-lockfile：不生成 yarn.lock 遇到的问题安装npm模块时，没有权限解决方法：打开nodejs安装目录的属性把权限全部勾上 npm的包安装分为本地安装（local）、全局安装（global）两种 本地安装: npm install xxx 安装到命令行所在目录的node_module目录。 全局安装: npm install xxx -g 安装到 \\AppData\\Roaming\\npm\\node_modules目录。","categories":[{"name":"前端","slug":"前端","permalink":"https://wenkexia.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://wenkexia.github.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"qq机器人","slug":"qq机器人","date":"2022-03-26T09:09:00.000Z","updated":"2022-03-26T09:09:00.000Z","comments":true,"path":"2022/032659541.html","link":"","permalink":"https://wenkexia.github.io/2022/032659541.html","excerpt":"","text":"https://github.com/mamoe/mirai/blob/dev/docs/mirai-ecology.md Mirai使用 Kotlin 编写的高效率 QQ 机器人框架github地址 mirai官方生态文档 下载 MiraiMCL Installer支持自动下载Java运行环境 和 Mirai Console Loader 了解运行环境MCL Installer安装时自动下载了 Mirai Console Loader（简称 MCL）。启动器会帮你准备运行环境，下载和更新 Mirai 核心 文件夹名称 用途scripts 存放启动器的脚本，一般不需要在意他们plugins 存放插件data 存放插件的数据，一般不需要在意它们config 存放插件的配置，可以打开并修改配置logs 存放运行时的日志，日志默认保留 7 天 插件刚刚装好的 Mirai Console 是没有任何功能的。功能将由插件提供。 插件发布如果是 JAR 文件的插件，放入 plugins 即可。其他插件一般都有特殊说明如何使用，请参考它们的说明。 自动定义回复插件https://mirai.mamoe.net/topic/636/console-%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%B9%89%E5%9B%9E%E5%A4%8D%E6%8F%92%E4%BB%B6 浏览器进入http://localhost:20044/index.html 思知机器人插件https://github.com/thetbw/my-bot 滑动验证助手https://github.com/mzdluo123/TxCaptchaHelper 下载手机客户端在mcl控制台中使用命令login &lt;qq&gt; [password] [protocol]会弹出url,把它复制到滑动验证助手app中 第二种登录方式（将弹出的链接发送给手机QQ打开，会得到一个二维码，使用手机QQ扫码验证） ANDROID_PAD是ipad login 3385642151 密码 ANDROID_PAD 问题解决libc.so.6: version `GLIBC_2.18’ not found问题https://www.cnblogs.com/music-liang/p/13029205.html 参考https://zhuanlan.zhihu.com/p/411513359 IDEA下载插件：Mirai Console","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"qq","slug":"qq","permalink":"https://wenkexia.github.io/tags/qq/"}]},{"title":"python高级","slug":"python高级","date":"2022-03-26T01:55:02.000Z","updated":"2022-03-26T01:55:02.000Z","comments":true,"path":"2022/03267198.html","link":"","permalink":"https://wenkexia.github.io/2022/03267198.html","excerpt":"","text":"re正则模块Python提供了re模块来支持正则表达式相关操作《正则表达式30分钟入门教程》 正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉） 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 脱字符 表示字符串的开始 ^The 可以匹配The开头的字符串 $ 表示字符串的结束 .exe$ 可以匹配.exe结尾的字符串 [^] 匹配不在字符集中的任意单一字符，^在[]表示取反 [^aeiou] 可以匹配任一非元音字母字符 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 说明： 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\\进行转义处理，例如想匹配小数点可以写成\\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\\(和\\)，否则圆括号被视为正则表达式中的分组。 核心函数re.compile()compile(pattern, flags=0)re.compile()是用来优化正则的，它将正则表达式转化为对象。单独使用没有任何意义，需要和findall(), search(), match(）搭配使用re.search(pattern, string)的调用方式就转换为 pattern.search(string)的调用方式，多次调用一个正则表达式就重复利用这个正则对象，可以实现更有效率的匹配参数： pattern : 一个字符串形式的正则表达式 flags : 可选，表示匹配模式， re.search()search(pattern, string, flags=0)搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None pattern: 匹配的规则, string : 要匹配的内容 flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 w, W, 方形, B, s, S 依赖于当前环境 re.M 多行模式 re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符） re.U 表示特殊字符集 w, W,方形, B, d, D, s, S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和 # 后面的注释 re.findall()findall(pattern, string, flags=0)查找字符串所有与正则表达式匹配的模式 返回字符串的列表 函数 说明 | match(pattern, string, flags=0) | 用正则表达式匹配字符串 成功返回匹配对象 否则返回None | | split(pattern, string, maxsplit=0, flags=0) | 用正则表达式指定的模式分隔符拆分字符串 返回列表 || sub(pattern, repl, string, count=0, flags=0) | 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 || fullmatch(pattern, string, flags=0) | match函数的完全匹配（从字符串开头到结尾）版本 | | finditer(pattern, string, flags=0) | 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 || purge() | 清除隐式编译的正则表达式的缓存 || re.I / re.IGNORECASE | 忽略大小写匹配标记 || re.M / re.MULTILINE | 多行匹配标记 | 说明： 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。 下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。 例子例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。12345678910111213141516171819202122232425\"\"\"验证输入用户名和QQ号是否有效并给出对应的提示信息要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0\"\"\"import redef main(): username = input('请输入用户名: ') qq = input('请输入QQ号: ') # match函数的第一个参数是正则表达式字符串或正则表达式对象 # 第二个参数是要跟正则表达式做匹配的字符串对象 m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username) if not m1: print('请输入有效的用户名.') m2 = re.match(r'^[1-9]\\d{4,11}$', qq) if not m2: print('请输入有效的QQ号.') if m1 and m2: print('你输入的信息是有效的!')if __name__ == '__main__': main() 提示： 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\\\，例如表示数字的\\d得书写成\\\\d，这样不仅写起来不方便，阅读的时候也会很吃力。 例子2：从一段文字中提取出国内手机号码。下面这张图是截止到2017年底，国内三家运营商推出的手机号段。 123456789101112131415161718192021222324252627import redef main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern = re.compile(r'(?&lt;=\\D)1[34578]\\d{9}(?=\\D)') sentence = ''' 重要的事情说8130123456789遍，我的手机号是13512346789这个靓号， 不是15600998765，也是110或119，王大锤的手机号才是15600998765。 ''' # 查找所有匹配并保存到一个列表中 mylist = re.findall(pattern, sentence) print(mylist) print('--------华丽的分隔线--------') # 通过迭代器取出匹配对象并获得匹配的内容 for temp in pattern.finditer(sentence): print(temp.group()) print('--------华丽的分隔线--------') # 通过search函数指定搜索位置找出所有匹配 m = pattern.search(sentence) while m: print(m.group()) m = pattern.search(sentence, m.end())if __name__ == '__main__': main() 说明： 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?&lt;=\\D)(1[38]\\d{9}|14[57]\\d{8}|15[0-35-9]\\d{8}|17[678]\\d{8})(?=\\D)，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。 例子3：替换字符串中的不良内容123456789101112import redef main(): sentence = '你丫是傻叉吗? 我操你大爷的. Fuck you.' purified = re.sub('[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔', '*', sentence, flags=re.IGNORECASE) print(purified) # 你丫是*吗? 我*你大爷的. * you.if __name__ == '__main__': main() 说明： re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。 例子4：拆分长字符串12345678910111213import redef main(): poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。' sentence_list = re.split(r'[，。, .]', poem) while '' in sentence_list: sentence_list.remove('') print(sentence_list) # ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡']if __name__ == '__main__': main() 校验数字的表达式数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d*[1-9]\\d*))|0?.0+|0$ 正浮点数：^[1-9]\\d.\\d|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d.\\d|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0)$ 校验字符的表达式汉字：^[\\u4e00-\\u9fa5]{0,}$ 表示匹配1个数字或1个字母：^[0-9a-zA-Z]$表示匹配至少1个数字或字母 ^[0-9a-zA-Z]+$“+”表示匹配前面的子表达式一次或多次(大于等于1次） 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20} 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\"等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有的字符[^\\x22]+其它： .*匹配除&nbsp;\\n&nbsp;以外的任何字符。 /[\\uFF00-\\uFFFF]/&nbsp;全角符号/[\\u0000-\\u00FF]/&nbsp;半角符号 特殊需求表达式Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式：1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3}))(.[0-9]{1,2})?$（搜索公众号Java后端，回复“2021”，送你一份Java面试题宝典）备注：这就是最终结果了,别忘了+可以用替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff]&nbsp;(包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r&nbsp;(可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.*? /&gt;&nbsp;(网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$)&nbsp;(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,}&nbsp;(腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d)&nbsp;(中国邮政编码为6位数字) IP地址：\\d+.\\d+.\\d+.\\d+&nbsp;(提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) IP-v4地址：\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b&nbsp;(提取IP地址时有用) 校验IP-v6地址:(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 子网掩码：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 校验日期:^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$(“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。) 抽取注释： 查找CSS属性:^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1} 提取页面超链接:(&lt;a\\s*(?!.\\brel=)[^&gt;])(href=”https?:\\/\\/)((?!(?:(?:www\\.)?’.implode(‘|(?:www\\.)?’, $follow_list).’))[^” rel=”external nofollow” ]+)”((?!.\\brel=)[^&gt;])(?:[^&gt;]*)&gt; 提取网页图片:\\&lt; [img][^\\\\&gt;][src] *= [\\“\\‘]{0,1}([^\\“\\‘\\ &gt;]) 提取网页颜色代码:^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 文件扩展名效验:^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)[^\\/:?”&lt;&gt;|]+\\.txt(l)?$ 判断IE版本：^.*MSIE 5-8?(?!.Trident\\/[5-9]\\.0).$ 进程和线程今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。 概念进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实，如下图所示。 当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。 Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。 Python中的多进程Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等。 下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。 123456789101112131415161718192021from random import randintfrom time import time, sleepdef download_task(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() download_task('Python从入门到住院.pdf') download_task('Peking Hot.avi') end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 下面是运行程序得到的一次运行结果。 12345开始下载Python从入门到住院.pdf...Python从入门到住院.pdf下载完成! 耗费了6秒开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒总共耗费了13.01秒. 从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。 12345678910111213141516171819202122232425262728from multiprocessing import Processfrom os import getpidfrom random import randintfrom time import time, sleepdef download_task(filename): print('启动下载进程，进程号[%d].' % getpid()) print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() p1 = Process(target=download_task, args=('Python从入门到住院.pdf', )) p1.start() p2 = Process(target=download_task, args=('Peking Hot.avi', )) p2.start() p1.join() p2.join() end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 在上面的代码中，我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。 1234567启动下载进程，进程号[1530].开始下载Python从入门到住院.pdf...启动下载进程，进程号[1531].开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒Python从入门到住院.pdf下载完成! 耗费了10秒总共耗费了10.01秒. 我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。 123456789101112131415161718192021from multiprocessing import Processfrom time import sleepcounter = 0def sub_task(string): global counter while counter &lt; 10: print(string, end='', flush=True) counter += 1 sleep(0.01) def main(): Process(target=sub_task, args=('Ping', )).start() Process(target=sub_task, args=('Pong', )).start()if __name__ == '__main__': main() 看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共享的队列，底层是通过管道和信号量（semaphore）机制来实现的，有兴趣的读者可以自己尝试一下。 Python中的多线程在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。 1234567891011121314151617181920212223242526from random import randintfrom threading import Threadfrom time import time, sleepdef download(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))def main(): start = time() t1 = Thread(target=download, args=('Python从入门到住院.pdf',)) t1.start() t2 = Thread(target=download, args=('Peking Hot.avi',)) t2.start() t1.join() t2.join() end = time() print('总共耗费了%.3f秒' % (end - start))if __name__ == '__main__': main() 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。 1234567891011121314151617181920212223242526272829303132from random import randintfrom threading import Threadfrom time import time, sleepclass DownloadTask(Thread): def __init__(self, filename): super().__init__() self._filename = filename def run(self): print('开始下载%s...' % self._filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (self._filename, time_to_download))def main(): start = time() t1 = DownloadTask('Python从入门到住院.pdf') t1.start() t2 = DownloadTask('Peking Hot.avi') t2.start() t1.join() t2.join() end = time() print('总共耗费了%.2f秒.' % (end - start))if __name__ == '__main__': main() 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from time import sleepfrom threading import Threadclass Account(object): def __init__(self): self._balance = 0 def deposit(self, money): # 计算存款后的余额 new_balance = self._balance + money # 模拟受理存款业务需要0.01秒的时间 sleep(0.01) # 修改账户余额 self._balance = new_balance @property def balance(self): return self._balanceclass AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money)def main(): account = Account() threads = [] # 创建100个存款的线程向同一个账户中存钱 for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() # 等所有存款的线程都执行完毕 for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__': main() 运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from time import sleepfrom threading import Thread, Lockclass Account(object): def __init__(self): self._balance = 0 self._lock = Lock() def deposit(self, money): # 先获取锁才能执行后续的代码 self._lock.acquire() try: new_balance = self._balance + money sleep(0.01) self._balance = new_balance finally: # 在finally中执行释放锁的操作保证正常异常锁都能释放 self._lock.release() @property def balance(self): return self._balanceclass AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money)def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__': main() 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。 多进程还是多线程无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。 但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。 是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到过Python中有嵌入C/C++代码的机制。 除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。 说明： 上面的内容和例子来自于廖雪峰官方网站的《Python教程》，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。 单线程+异步I/O现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下并发编程的一种流行方案。 在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，在后续的课程中会进行讲解。 应用案例例子1：将耗时间的任务放到线程中以获得更好的用户体验。如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。 123456789101112131415161718192021222324252627282930313233import timeimport tkinterimport tkinter.messageboxdef download(): # 模拟下载任务需要花费10秒钟时间 time.sleep(10) tkinter.messagebox.showinfo('提示', '下载完成!')def show_about(): tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)')def main(): top = tkinter.Tk() top.title('单线程') top.geometry('200x150') top.wm_attributes('-topmost', True) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text='下载', command=download) button1.pack(side='left') button2 = tkinter.Button(panel, text='关于', command=show_about) button2.pack(side='right') panel.pack(side='bottom') tkinter.mainloop()if __name__ == '__main__': main() 如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243import timeimport tkinterimport tkinter.messageboxfrom threading import Threaddef main(): class DownloadTaskHandler(Thread): def run(self): time.sleep(10) tkinter.messagebox.showinfo('提示', '下载完成!') # 启用下载按钮 button1.config(state=tkinter.NORMAL) def download(): # 禁用下载按钮 button1.config(state=tkinter.DISABLED) # 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行) # 在线程中处理耗时间的下载任务 DownloadTaskHandler(daemon=True).start() def show_about(): tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)') top = tkinter.Tk() top.title('单线程') top.geometry('200x150') top.wm_attributes('-topmost', 1) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text='下载', command=download) button1.pack(side='left') button2 = tkinter.Button(panel, text='关于', command=show_about) button2.pack(side='right') panel.pack(side='bottom') tkinter.mainloop()if __name__ == '__main__': main() 例子2：使用多进程对复杂任务进行“分而治之”。我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。 12345678910111213141516from time import timedef main(): total = 0 number_list = [x for x in range(1, 100000001)] start = time() for number in number_list: total += number print(total) end = time() print('Execution time: %.3fs' % (end - start))if __name__ == '__main__': main() 在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839from multiprocessing import Process, Queuefrom random import randintfrom time import timedef task_handler(curr_list, result_queue): total = 0 for number in curr_list: total += number result_queue.put(total)def main(): processes = [] number_list = [x for x in range(1, 100000001)] result_queue = Queue() index = 0 # 启动8个进程将数据切片后进行运算 for _ in range(8): p = Process(target=task_handler, args=(number_list[index:index + 12500000], result_queue)) index += 12500000 processes.append(p) p.start() # 开始记录所有进程执行完成花费的时间 start = time() for p in processes: p.join() # 合并执行结果 total = 0 while not result_queue.empty(): total += result_queue.get() print(total) end = time() print('Execution time: ', (end - start), 's', sep='')if __name__ == '__main__': main() 比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过multiprocessing.managers模块中提供的管理器将Queue对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。 处理Excel电子表格Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，由于微软从Office 2007开始使用了新的文件格式，这使得Office Excel和LibreOffice Calc、OpenOffice Calc是完全兼容的，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。 123456789101112import datetimefrom openpyxl import Workbookwb = Workbook()ws = wb.activews['A1'] = 42ws.append([1, 2, 3])ws['A2'] = datetime.datetime.now()wb.save(\"sample.xlsx\") 处理Word文档利用python-docx模块，Python可以创建和修改Word文档，当然这里的Word文档不仅仅是指通过微软的Office软件创建的扩展名为docx的文档，LibreOffice Writer和OpenOffice Writer都是免费的字处理软件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344from docx import Documentfrom docx.shared import Inchesdocument = Document()document.add_heading('Document Title', 0)p = document.add_paragraph('A plain paragraph having some ')p.add_run('bold').bold = Truep.add_run(' and some ')p.add_run('italic.').italic = Truedocument.add_heading('Heading, level 1', level=1)document.add_paragraph('Intense quote', style='Intense Quote')document.add_paragraph( 'first item in unordered list', style='List Bullet')document.add_paragraph( 'first item in ordered list', style='List Number')document.add_picture('monty-truth.png', width=Inches(1.25))records = ( (3, '101', 'Spam'), (7, '422', 'Eggs'), (4, '631', 'Spam, spam, eggs, and spam'))table = document.add_table(rows=1, cols=3)hdr_cells = table.rows[0].cellshdr_cells[0].text = 'Qty'hdr_cells[1].text = 'Id'hdr_cells[2].text = 'Desc'for qty, id, desc in records: row_cells = table.add_row().cells row_cells[0].text = str(qty) row_cells[1].text = id row_cells[2].text = descdocument.add_page_break()document.save('demo.docx') time模块123456789import time# 返回当前时间的时间戳time.time()time.loaltime() #本地时间 Sat Apr 16 22:34:40 2022#格式化时间print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())) 命令行模块 click123456789import click # 装饰器@click.command()会将函数包装成 click 对象@click.command() def main(): click.echo(\"hello click\") if __name__ == '__main__': main()","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/tags/python/"}]},{"title":"python-图像处理","slug":"python-图像处理","date":"2022-03-22T14:44:39.000Z","updated":"2022-03-22T14:44:39.000Z","comments":true,"path":"2022/032217173.html","link":"","permalink":"https://wenkexia.github.io/2022/032217173.html","excerpt":"","text":"计算机图像相关知识我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。 名称 RGBA值 名称 RGBA值 White (255, 255, 255, 255) Red (255, 0, 0, 255) Green (0, 255, 0, 255) Blue (0, 0, 255, 255) Gray (128, 128, 128, 255) Yellow (255, 255, 0, 255) Black (0, 0, 0, 255) Purple (128, 0, 128, 255) 像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。 PIL，cv2，plt的使用与区别 建议使用opencv的库来进行图像处理的基本操作，数据格式为numpy，可以直接进行numpy的处理； 进行折线图这类图绘制的时候，一般使用matplotlib库。 Opencv默认为 BGR顺序，而其他软件（PIL、scopy.misc）一般使用RGB。 1234567891011121314151617181920212223242526272829from PIL import Imageimport cv2import matplotlib.pyplot as pltimport numpy as np# 比较三者的打开图片、显示图片、打开图片的类型# ************PIL************PIL_img = Image.open('D:/images/Rimi.jpg')print(type(PIL_img)) # &lt;class 'PIL.JpegImagePlugin.JpegImageFile'&gt;print(PIL_img.size) # (1152, 720) (w,h)print(np.array(PIL_img).shape) # (720, 1152, 3) (h,w,c)PIL_img.show()# ************cv2************cv2_img = cv2.imread('D:/images/Rimi.jpg')print(type(cv2_img)) # &lt;class 'numpy.ndarray'&gt;print(cv2_img.shape) # (720, 1152, 3) (h,w,c)cv2.imshow('cv2', cv2_img)# cv2.waitKey()# ************plt***********plt_img = plt.imread('D:/images/Rimi.jpg')print(type(plt_img)) # &lt;class 'numpy.ndarray'&gt;print(plt_img.shape) # (720, 1152, 3) (h,w,c)plt.imshow(plt_img) # PIL_img也可以显示plt.show() OpenCVOpenCV中已经包含如下应用领域功能：二维和三维特征工具箱、运动估算、人脸识别系统、姿势识别、人机交互、移动机器人、运动理解、对象鉴别、分割与识别、立体视觉、运动跟踪、增强现实（AR技术）。基于上述功能实现需要，OpenCV中还包括以下基于统计学机器学习库：Boosting算法、Decision Tree(决策树)学习、Gradient Boosting算法、EM算法(期望最大化)、KNN算法、朴素贝叶斯分类、人工神经网络、随机森林、支掌向量机。 cv2默认为 BGR顺序，而其他（PIL、scopy.misc）一般使用RGB 导入的时候采用 import cv2。 基本库函数cv2.imread(filepath,flags) #读入一张图像 filepath：要读入图片的完整路径flags：读入图片的标志cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道cv2.IMREAD_GRAYSCALE：读入灰度图片cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道 cv2.imshow(wname,img) #显示图像 第一个参数是显示图像的窗口的名字第二个参数是要显示的图像（imread读入的图像），窗口大小自动调整为图片大小cv2.imshow(‘image’,img) cv2.waitKey(0) #等待键盘输入，单位为毫秒，即等待指定的毫秒数看是否有键盘输入，若在等待时间内按下任意键则返回按键的ASCII码，程序继续运行。 #若没有按下任何键，超时后返回-1。参数为0表示无限等待。不调用waitKey的话，窗口会一闪而逝，看不到显示的图片。 cv2.destroyAllWindow() #销毁所有窗口 cv2.destroyWindow(wname) #销毁指定窗口 cv2.imwrite(file，img，num) #保存一张图像 第一个参数是要保存的文件名第二个参数是要保存的图像。可选的第三个参数，它针对特定的格式：对于JPEG，其表示的是图像的质量，用0 - 100的整数表示，默认95。第三个参数表示的是压缩级别。默认为3.img.copy() #图像复制 cv2.cvtColor() #图像颜色空间转换 img2 = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY) #灰度化：彩色图像转为灰度图像img3 = cv2.cvtColor(img,cv2.COLOR_GRAY2RGB) #彩色化：灰度图像转为彩色图像 cv2.COLOR_X2Y，其中X,Y = RGB, BGR, GRAY, HSV, YCrCb, XYZ, Lab, Luv, HLScv2.resize(image, image2,dsize) #图像缩放：(输入原始图像，输出新图像，图像的大小)cv2.flip(img,flipcode) #图像翻转，flipcode控制翻转效果。 flipcode = 0：沿x轴翻转；flipcode &gt; 0：沿y轴翻转；flipcode &lt; 0：x,y轴同时翻转cv2.warpAffine(img, M, (400, 600)) #图像仿射变换 ：平移；裁剪、剪切、旋转、仿射变换，M、M_crop、M_shear、M_rotate cv2.putText(img,’text’,(50,150) #图像添加文字：(照片，添加的文字，左上角坐标，字体，字体大小，颜色，字体粗细) cv2.putText(image, caption, (b[0], b[1] - 10), cv2.FONT_HERSHEY_PLAIN, 1, (255, 0, 0), 1) cv2.putText(I,’there 0 error(s):’,(50,150),cv2.FONT_HERSHEY_COMPLEX,6,(0,0,255),25) cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2) #画出矩行：img原图、(x，y)是矩阵的左上点坐标、(x+w，y+h)是矩阵的右下点坐标、(0,255,0)是画线对应的rgb颜色、2是所画的线的宽度。 cv2.boundingRect(img) #返回图像的四值属性：img是一个二值图，即是它的参数； 返回四个值，分别是x，y，w，h； x，y是矩阵左上点的坐标，w，h是矩阵的宽和高。 PIL库PIL（Python Imaging Library）是Python常用的图像处理库，而Pillow是PIL的一个友好Fork，提供了了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。相比opencv更为轻巧。Image模块是在Python PIL图像处理中常见的模块，对图像进行基础操作的功能基本都包含于此模块内。如open、save、show等功能。 使用#安装pillowpip install pillow from PIL import ImageImage 是 PIL 库中代表一个图像的类（对象） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 1. 剪裁图像image = Image.open('./res/guido.jpg')rect = 80, 20, 310, 360image.crop(rect).show()# 2. 生成缩略图 image = Image.open('./res/guido.jpg')size = 128, 128image.thumbnail(size)image.show()# 3. 缩放和黏贴图像image1 = Image.open('./res/luohao.png')image2 = Image.open('./res/guido.jpg')rect = 80, 20, 310, 360guido_head = image2.crop(rect)width, height = guido_head.sizeimage1.paste(guido_head.resize((int(width / 1.5), int(height / 1.5))), (172, 40))# 4. 旋转和翻转 image = Image.open('./res/guido.png') image.rotate(180).show() image.transpose(Image.FLIP_LEFT_RIGHT).show()# 5. 操作像素 image = Image.open('./res/guido.jpg') for x in range(80, 310): for y in range(20, 360): image.putpixel((x, y), (128, 128, 128)) image.show()# 6. 滤镜效果from PIL import Image, ImageFilterimage = Image.open('./res/guido.jpg')image.filter(ImageFilter.CONTOUR).show() Matplotlib库Matplotlib是一个Python 2D绘图库，它可以在不同的平台上以各种硬拷贝格式和交互环境生成发布质量数据。Matplotlib可以用于Python脚本、Python和IPython shell、Jupyter notebook、web应用服务器和四个图形用户界面工具包。对于简单的绘图，pyplot模块提供了一个类似于matlab的接口，特别是与IPython结合使用时。对于power用户，您可以通过面向对象的界面或通过MATLAB用户熟悉的一组函数来完全控制线样式、字体属性、轴属性等. matplotlib.pylot是绘制各类可视化图形的命令字库 更多学习，可参考Matplotlib中文网：https://www.matplotlib.org.cn #安装pip install matplotlib#导库import matplotlib.pyplot as plt pyplot模块方法1.plt.imread(fname， format=None)将图像从文件读取到数组中。返回一个numpy.array fname: 要读取的图像文件：文件名、URL 或以读取二进制模式打开的类似文件的对象。 不推荐传递 URL。请打开URL进行阅读并将结果传递给Pillow format: 用于读取数据而假定的图像文件格式。如果格式设置为”png”，如果 fname 是扩展名为”.png”的路径或打开的文件，或者如果它是 URL，则图像将作为 PNG 文件加载。在所有其他情况下，格式将被忽略，PIL 会自动检测格式 2.plt.imshow(numpy.array)将数据显示为图像3.plt.show()显示所有打开的图表","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"图像","slug":"图像","permalink":"https://wenkexia.github.io/tags/%E5%9B%BE%E5%83%8F/"}]},{"title":"python-pandas","slug":"python-pandas","date":"2022-03-22T13:29:33.000Z","updated":"2022-03-22T13:29:33.000Z","comments":true,"path":"2022/03226351.html","link":"","permalink":"https://wenkexia.github.io/2022/03226351.html","excerpt":"","text":"pandas是python第三方库，提供高性能易用数据类型和分析工具。 pandas基于numpy实现，常与numpy和matplotlib一同使用 更多学习，请参考pandas中文网：https://www.pypandas.cn/ SeriesSeries是一种类似于一维数组的对象，它由一维数组（各种numpy数据类型）以及一组与之相关的数据标签（即索引）组成. 可理解为带标签的一维数组，可存储整数、浮点数、字符串、Python 对象等类型的数据。 Seris中可以使用index设置索引列表。 12345678910111213import pandas as pdimport numpy as np#与字典不同的是：Series允许索引重复s = pd.Series(['a','b','c','d','e'],index=[100,200,100,400,500])#Series 可以用字典实例化d = {'b': 1, 'a': 0, 'c': 2}pd.Series(d)#通过Series的values和index属性获取其数组表示形式和索引对象print(s)print(s.values)print(s.index) DataFrameDataFrame是一个表格型的数据结构，类似于Excel或sql表 它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）DataFrame可以进行行索引和列索引，它可以被看做由Series组成的字典（共用同一个索引） 123456789101112#用多维数组字典、列表字典生成 DataFramedata = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'], 'year': [2000, 2001, 2002, 2001, 2002], 'pop': [1.5, 1.7, 3.6, 2.4, 2.9]}frame = pd.DataFrame(data) print(frame)frame2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'], index=['one', 'two', 'three', 'four', 'five'])print(frame2)#列可以通过赋值的方式进行修改,例如，给那个空的“delt”列赋上一个标量值或一组值frame2['debt'] = 16.5print(frame2)","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"https://wenkexia.github.io/tags/pandas/"}]},{"title":"python-NumPy","slug":"python-NumPy","date":"2022-03-22T06:42:45.000Z","updated":"2022-03-22T06:42:45.000Z","comments":true,"path":"2022/032261592.html","link":"","permalink":"https://wenkexia.github.io/2022/032261592.html","excerpt":"","text":"数学矩阵知识https://paul.pub/the-matrix/#id-%E6%A0%87%E9%87%8F%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5%E5%92%8C%E5%BC%A0%E9%87%8F 矩阵算术加减法矩阵的加减法只在两个矩阵具有相同大小时才有意义。 两个矩阵的加（减）法通过对应元素相加（减）得到 标量乘法设A为一矩阵，b为一标量，则bA为将A中的每一个元素乘以b而构成的一个矩阵 转置矩阵的转置是以对角线为轴的镜像。 这条从左上角到右下角的对角线被称之为主对角线 矩阵乘法第一个矩阵的列要等于第二个矩阵的行，则两矩阵可以相乘。一个m∗n的的A矩阵，和一个n∗p的B矩阵相乘，将得到一个m∗p的矩阵C 逆逆(Inverse)设A为n阶方阵，如果存在一个n阶方阵B，使得AB=BA=InAB=BA=In 则称A为可逆矩阵，B为A的逆阵，记作 B=A−1B=A−1(A−1)−1=A(A−1)−1=A(kA)−1=1kA−1(k≠0)(kA)−1=1kA−1(k≠0)A、B均是同阶可逆矩阵，则(AB)−1=B−1A−1A、B均是同阶可逆矩阵，则(AB)−1=B−1A−1(A−1)T=(AT)−1(A−1)T=(AT)−1 求逆矩阵一般有三种方法。1、方阵的逆矩阵等于方阵的伴随矩阵与方阵对应的行列式的值的倒数的积； 即A^-1=A*/(|A|). 只有当|A|≠0时，方阵A才可逆。 这种方法并不简便。 2、利用初等变换求逆矩阵； 一般是将矩阵(A,E)化为(E,A^-1)的形式；从而得到A逆矩阵； 创建数组为了创建一个2D（二维）数组，我们传递一个列表的列表（或者是一个序列的序列）给array()函数。如果我们想要一个3D（三维）数组，我们就要传递一个列表的列表的列表，如果是一个4D（四维）数组，那就是列表的列表的列表的列表，以此类推。 多维数组切片通过对每个以逗号分隔的维度执行单独的切片，你可以对多维数组进行切片。因此，对于2D数组，我们的第一片定义了行的切片，第二片定义了列的切片。 函数np.zeros():可以创建指定长度或者形状的全0数组 ones():可以创建指定长度或者形状的全1数组 empty():创建一个数组，其初始内容是随机的,取决于内存的状态 为了创建数字组成的数组，NumPy提供了一个类似于range的函数，该函数返回数组而不是列表。array = np.arange( 10, 31,5 ) -&gt;array([10, 15, 20, 25, 30]) 数组属性array = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]]) #数组维度print(array.ndim) #数组形状print(array.shape) #数组元素个数print(array.size) #数组元素类型print(array.dtype) 数组的计算数组很重要，因为它可以使我们不用编写循环即可对数据执行批量运算。这通常叫做矢量化 基础运算对应位置的数相运算 12345678910arr1 = np.array([[1,2,3],[4,5,6]])arr2 = np.ones([2,3],dtype=np.int64)print(arr1 + arr2)print(arr1 - arr2)print(arr1 * arr2)print(arr1 / arr2)print(arr1 ** 2) print(np.dot(arr3,arr4))","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"numpy","slug":"numpy","permalink":"https://wenkexia.github.io/tags/numpy/"}]},{"title":"python-selenium","slug":"python-selenium","date":"2022-03-18T14:31:09.000Z","updated":"2022-03-18T14:31:09.000Z","comments":true,"path":"2022/031841897.html","link":"","permalink":"https://wenkexia.github.io/2022/031841897.html","excerpt":"","text":"定位页面元素123456789101112from selenium import webdriverfrom selenium.webdriver.common.by import By#定位一个元素ele = driver.find_element(By.XPATH,'')#表示定位一组元素(元素相同时使用)lis = driver.find_elements(By.XPATH,'')if len(lis)&gt;0: lis[0].click()else： print('没有元素') id 定位name 定位class 定位tag 定位xpathxpath 是一种在 XML 文档中定位元素的语言，它拥有多种定位方式 123456789101112&lt;html&gt; &lt;head&gt;...&lt;head/&gt; &lt;body&gt; &lt;div id=\"csdn-toolbar\"&gt; &lt;div class=\"toolbar-inside\"&gt; &lt;div class=\"toolbar-container\"&gt; &lt;div class=\"toolbar-container-left\"&gt;...&lt;/div&gt; &lt;div class=\"toolbar-container-middle\"&gt; &lt;div class=\"toolbar-search onlySearch\"&gt; &lt;div class=\"toolbar-search-container\"&gt; &lt;input id=\"toolbar-search-input\" autocomplete=\"off\" type=\"text\" value=\"\" placeholder=\"C++难在哪里？\"&gt; 根据上面的标签需要定位 最后一行 input 标签，以下列出了四种方式，xpath 定位的方式多样并不唯一，使用时根据情况进行解析即可。 123456789# 绝对路径（层级关系）定位 （绝对路径以/开头）driver.find_element_by_xpath( \"/html/body/div/div/div/div[2]/div/div/input[1]\")# 利用元素属性定位 （相对路径以//开头）driver.find_element_by_xpath(\"//*[@id='toolbar-search-input']\"))# 层级+元素属性定位driver.find_element_by_xpath( \"//div[@id='csdn-toolbar']/div/div/div[2]/div/div/input[1]\")# 逻辑运算符定位driver.find_element_by_xpath(\"//*[@id='toolbar-search-input' and @autocomplete='off']\") 1.相对路径+索引先定位要找的元素，再找它唯一的父标签2.相对路径+属性3.相对路径+通配符定位4.相对路径+部分属性值5.相对路径+文本css 定位link 定位partial_link 定位 常用操作下拉框的处理12345&lt;!--select标签--&gt; &lt;select name=\"city\" size=\"5\" multiple=\"multiple\"&gt; &lt;option value=\"1\" tabindex=\"1\"&gt;北京&lt;/option&gt; &lt;option value=\"2\" tabindex=\"2\" selected=\"selected\"&gt;河南&lt;/option&gt; 1234567from selenium.webdriver.support.select import Selectele = driver.find_element_by_name(\"city\")#创建Select类对象sel = Select(ele)sel.select_by_value(\"3\") select类中的函数列表options 返回select元素所有的optionsall_selected_options 返回select元素中所有已选中的选项first_selected_option 返回select元素中选中的第一个选项select_by_index(index) 通过索引定位，index索引是从“0”开始select_by_value(value) 通过value属性值定位select_by_visible_text(text)t 通过文本值定位，visible_text是在option标签中间的值，即显示在下拉框的值；deselect_all() 取消全部的已选择项deselect_by_index(index) 取消已选中的索引项deselect_by_value(value) 取消已选中的value值deselect_by_visible_text(text) 取消已选中的文本值 文件上传定位到元素后用.send_keys(r’文件路径’) 1driver.find_element_by_name(\"city\").send_keys(r'文件路径') 处理弹窗alert(只有确定)，confirm(有确认和取消)，prompt(有确认取消还可以输入值) 12345678910111213#alert是一个属性#创建一个alert对象ale = driver.switch_to.alert#点击确定ale.accept()#点击取消ale.dismiss() #获得文本ale.text()#输入值ale.send_keys() 设计模式（封装）pom(page object model)页面对象模式 分三层1.基础层：base 主要放seleni原生的方法2.页面对象层：主要用于放页面的元素和页面的动作3.测试用例层:testcase存放测试用例，测试数据 页面对象层调用基础层的方法，测试用例层调用页面对象的方法","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"web自动化","slug":"web自动化","permalink":"https://wenkexia.github.io/tags/web%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"python爬虫学习","slug":"python爬虫学习","date":"2022-03-16T23:56:59.000Z","updated":"2022-03-16T23:56:59.000Z","comments":true,"path":"2022/031717083.html","link":"","permalink":"https://wenkexia.github.io/2022/031717083.html","excerpt":"","text":"网络数据采集概述爬虫（crawler）也经常被称为网络蜘蛛（spider），是按照一定的规则自动浏览网站并获取所需信息的机器人程序（自动化脚本代码），被广泛的应用于互联网搜索引擎和数据采集。使用过互联网和浏览器的人都知道，网页中除了供用户阅读的文字信息之外，还包含一些超链接，网络爬虫正是通过网页中的超链接信息，不断获得网络上其它页面的地址，然后持续的进行数据采集。正因如此，网络数据采集的过程就像一个爬虫或者蜘蛛在网络上漫游，所以才被形象的称为爬虫或者网络蜘蛛。 爬虫的应用领域爬虫的应用领域其实非常广泛，下面我们列举了其中的一部分 搜索引擎 新闻聚合 社交应用 舆情监控 行业数据爬虫合法性探讨 经常听人说起“爬虫写得好，牢饭吃到饱”，那么编程爬虫程序是否违法呢？关于这个问题，我们可以从以下几个角度进行解读。 网络爬虫这个领域目前还属于拓荒阶段，虽然互联网世界已经通过自己的游戏规则建立起了一定的道德规范，即 Robots 协议（全称是“网络爬虫排除标准”），但法律部分还在建立和完善中，也就是说，现在这个领域暂时还是灰色地带。 “法不禁止即为许可”，如果爬虫就像浏览器一样获取的是前端显示的数据（网页上的公开信息）而不是网站后台的私密敏感信息，就不太担心法律法规的约束，因为目前大数据产业链的发展速度远远超过了法律的完善程度。 在爬取网站的时候，需要限制自己的爬虫遵守 Robots 协议，同时控制网络爬虫程序的抓取数据的速度；在使用数据的时候，必须要尊重网站的知识产权（从Web 2.0时代开始，虽然Web上的数据很多都是由用户提供的，但是网站平台是投入了运营成本的，当用户在注册和发布内容时，平台通常就已经获得了对数据的所有权、使用权和分发权）。如果违反了这些规定，在打官司的时候败诉几率相当高。 适当的隐匿自己的身份在编写爬虫程序时必要的，而且最好不要被对方举证你的爬虫有破坏别人动产（例如服务器）的行为。 不要在公网（如代码托管平台）上去开源或者展示你的爬虫代码，这些行为通常会给自己带来不必要的麻烦。 相关工具下面我们先介绍一些开发爬虫程序的辅助工具，这些工具相信能帮助你事半功倍。 Chrome Developer Tools：谷歌浏览器内置的开发者工具。该工具最常用的几个功能模块是： 元素（ELements）：用于查看或修改 HTML 元素的属性、CSS 属性、监听事件等。CSS 可以即时修改，即时显示，大大方便了开发者调试页面。 控制台（Console）：用于执行一次性代码，查看 JavaScript 对象，查看调试日志信息或异常信息。控制台其实就是一个执行 JavaScript 代码的交互式环境。 源代码（Sources）：用于查看页面的 HTML 文件源代码、JavaScript 源代码、CSS 源代码，此外最重要的是可以调试 JavaScript 源代码，可以给代码添加断点和单步执行。 网络（Network）：用于 HTTP 请求、HTTP 响应以及与网络连接相关的信息。 应用（Application）：用于查看浏览器本地存储、后台任务等内容，本地存储主要包括Cookie、Local Storage、Session Storage等。 Postman：功能强大的网页调试与 RESTful 请求工具。Postman可以帮助我们模拟请求，非常方便的定制我们的请求以及查看服务器的响应。 HTTPie：命令行HTTP客户端。 安装。 1pip install httpie 使用。 1234567891011121314http --header http --header https://movie.douban.com/HTTP/1.1 200 OKConnection: keep-aliveContent-Encoding: gzipContent-Type: text/html; charset=utf-8Date: Tue, 24 Aug 2021 16:48:00 GMTKeep-Alive: timeout=30Server: daeSet-Cookie: bid=58h4BdKC9lM; Expires=Wed, 24-Aug-22 16:48:00 GMT; Domain=.douban.com; Path=/Strict-Transport-Security: max-age=15552000Transfer-Encoding: chunkedX-Content-Type-Options: nosniffX-DOUBAN-NEWBID: 58h4BdKC9lM builtwith库：识别网站所用技术的工具。 安装。 1pip install builtwith 使用。 123456import sslimport builtwithssl._create_default_https_context = ssl._create_unverified_contextprint(builtwith.parse('http://www.bootcss.com/')) python-whois库：查询网站所有者的工具。 安装。 1pip3 install python-whois 使用。 123import whoisprint(whois.whois('https://www.bootcss.com')) 爬虫的基本工作流程获取网页获取网页源代码 提取信息获取网也源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。首先，最通用的方法便是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。 由于网页的结构有一定的规侧，所以还有一些根据网页节点属性、CSS选择器或XPath来提取网顶信息的库，如Beautifu1Soup、pyquery、1xm1等。使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。 保存数据提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。这里保存形式有多种多样，如可以简单保存为TXT文本或json文本，也可以保存到数据库，如MySQL和MongoDB等，也可保存至远程服务器，如借助SFTP进行操作等。 代理ip基本原理代理实际上指的就是代理服务器，英文叫作proxy server，它的功能是代理网络用户去取得网络信息。形象地说，它是网络信息的中转站。在我们正常请求一个网站时，是发送了请求给Web服务器，Web服务器把响应传回给我们。如果设置了代理服务器，实际上就是在本机和服务器之间搭建了一个桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发出请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机。这样我们同样可以正常访问网页，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP了，就成功实现了IP伪装，这就是代理的基本原理。 代理的作用突破自身IP访问限制，访问一些平时不能访问的站点。访问一些单位或团体内部资源：比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP，防止自身的IP被封锁。 requests库添加请求头在发起一个 HTTP 请求的时候，会有一个请求头 Request Headers，如果不设置Request Headers 信息，某些网站会发现这不是一个正常的浏览器发起的请求，网站可能会返回异常的结果，导致网页抓取失败。 123456使用 headers 参数来指定请求头headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36',}requests.get(url, headers=headers) Response对象r = requests.get(url)是构造一个向服务器请求资源的Request对象 ,返回一个包含服务器资源的Response对象。 Response对象的方法r.text() Response对象的属性r.status_code： HTTP请求的返回状态，200表示连接成功，404表示失败r.text： HTTP响应内容的字符串形式，即，ur对应的页面内容 r.encoding：从HTTP header中猜测的响应内容编码方式 r.apparent_encoding：从内容中分析出的响应内容编码方式（备选编码方式） r.content： HTTP响应内容的二进制形式 抓取二进制数据图片、音频、视频这些文件本质上都是由二进制码组成的，由于有特定的保存格式和对应的解析方式，我们才可以看到这些形形色色的多媒体。 123import requests r = requests.get('https://github.com/favicon.ico')with open('favicon.ico', 'wb') as f: f.write(r.content) 文件上传1234import requestsfiles = {'file': open('favicon.ico', 'rb')} r = requests.post('http://httpbin.org/post', files=files) print(r.text) 获取和设置 Cookies12345678import requests # 获取r = requests.get('http://www.baidu.com') # 先调用 cookies 属性即可成功得到 Cookies，可以发现它是 RequestCookieJar 类型print(r.cookies) # 用 items 方法将其转化为元组组成的列表，遍历输出每一个 Cookie 的名称和值，实现 Cookie 的遍历解析。for key, value in r.cookies.items(): print(key + '=' + value) Session维持在 requests 中，如果直接利用 get 或 post 等方法的确可以做到模拟网页的请求，但是这实际上是相当于不同的 Session，相当于你用两个浏览器打开了不同的页面。 设想这样一个场景，第一个请求利用 post 方法登录了某个网站，第二次想获取成功登录后的自己的个人信息，你又用了一次 get 方法去请求个人信息页面。实际上，这相当于打开了两个浏览器，是两个完全不 相关的 Session，能成功获取个人信息吗？当然不能。 有人会问，我在两次请求时设置一样的 Cookies 不就行了？可以，但这样做起来很烦琐，我们有更简单的解决方法。 解决这个问题的主要方法就是维持同一个 Session，相当于打开一个新的浏览器选项卡而不是新开一个浏览器。但我又不想每次设置 Cookies，那该怎么办呢？这时候就有了新的利器 ——Session对象。 利用它，我们可以方便地维护一个 Session，而且不用担心 Cookies 的问题，它会帮我们自动处理好。 BeautifulsoupBeautiful Soup 4.4.0 文档一个灵活又方便的HTML解析库，处理高效，支持多种解析器，利用它不使用正则表达式也能抓取网页内容。from bs4 import BeautifulSoup BeautifulSoup对象Tag , NavigableString , , Comment .","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://wenkexia.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"matlab学习","slug":"matlab学习","date":"2022-03-15T07:15:30.000Z","updated":"2022-03-15T07:15:30.000Z","comments":true,"path":"2022/031551719.html","link":"","permalink":"https://wenkexia.github.io/2022/031551719.html","excerpt":"","text":"https://www.w3cschool.cn/matlab/matlab-5use28gb.html 常用命令matlab常用命令 % 这是一行注释 ,ctrl +r 快捷注释 在命令行中，以逗号或分号分隔多条命令 变量变量名长度不超过63位区分大小写在使用变量之前，必须进行赋值。 123456789101112MATLAB可以多个赋值`a = 2; b = 7; c = a * b`显示所有已经使用的变量名。who显示变量信息whos删除所有（或指定）从内存中的变量（S）。clearclear s matlab数据类型数字字符和字符串单引号括起来 结构体数组Matlab中结构体数组与python中字典概念差不多，使用方法也类似 直接定义1234567students.name = 'John';students.sex = 'Boy';%输出结果为 包含以下字段的 struct:name: 'John'sex: 'Boy' 矩阵https://blog.csdn.net/weixin_49167174/article/details/119939748 矩阵的规则矩阵元素必须在”[ ]”内； 矩阵的同行元素之间用空格（或”,”）隔开； 矩阵的行与行之间用”;”（或回车符）隔开； 矩阵的元素可以是数值、变量、表达式或函数； 利用函数创建矩阵(1) ones()函数：产生全为1的矩阵，ones(n)：产生nn维的全1矩阵，ones(m,n)：产生mn维的全1矩阵； (2) zeros()函数：产生全为0的矩阵； (3) rand()函数：产生在（0，1）区间均匀分布的随机阵； (4) eye()函数：产生单位阵； (5) randn()函数：产生均值为0，方差为1的标准正态分布随机矩阵。 冒号表达式(初始值：步长：终止值） linspace(a, b, n)产生行向量（a：第一个元素, b：最后一个元素, n：元素总数）若元素总数n省略，则自动默认产生100个元素 矩阵元素的引用1.通过下标引用矩阵元素：第几行，第几列 2.通过序号引用矩阵元素在matlab中，矩阵的元素是按列存储的即首先存储第一列元素、第二列…一直到最后一列。 矩阵元素的序号就是矩阵元素在内存中的排列顺序。 矩阵拆分利用冒号表达式获得子矩阵： (1) A(:,j)表示取A矩阵的第j列全部元素；A(i,:)表示A矩阵第i行的全部元素；A(i,j)表示取A矩阵第i行、第j列的元素。 (2) A(i:i+m,:)表示取A矩阵第ii+m行的全部元素；A(:,k:k+m)表示取A矩阵第kk+m列的全部元素，A(i:i+m,k:k+m)表示取A矩阵第ii+m行内，并在第kk+m列中的所有元素。此外，还可利用一般向量和end运算符来表示矩阵下标，从而获得子矩阵。end表示某一维的末尾元素下标。 利用空矩阵[]删除矩阵的元素： 在MATLAB中，定义[]为空矩阵。给变量X赋空矩阵的语句为X=[]。注意，X=[]与clear X不同，clear是将X从工作空间中删除，而空矩阵则存在于工作空间中，只是维数为0。 常用命令求矩阵的大小size() 求矩阵某个元素的下标[row,col]=find(a==5) (下标变序号)D=sub2ind(size(a),[I],[J]) I是行下标，J是列下标 (序号变下标)[I,J]=ind2sub(S,D)D是序号 结构矩阵结构矩阵名.成员名=表达式 元胞数组(cell)是由可以包括任何数据类型的元胞组成的数组。也叫单元矩阵通过元胞数组的使用，可以在同一个变量中存储不同数据类型的数据。单元矩阵元素用大括号括起来 当要将数据放入一个元胞数组中时，请使用元胞数组构造运算符 {} 创建该数组。 结构体函数文件文件第一行必须以function开头，文件名字必须以函数名.m命名function 应变量名= 函数名(自变量名) 基本绘图函数plot(xn,yn,sn,…)s参数为线型 图形标注在绘制图形时，可以对图形加上一些说明，如图形的名称、坐标轴说明以及图形某一部分的含义等，这些操作称为添加图形标注。title(‘图的题目’)xlabel(‘横轴的名称’)ylabel(‘纵轴的名称’)text(0.5,25,’说明示例’) 坐标、图形和图层窗口控制在绘制图形时，Matlab可以自动根据要绘制曲线数据的范围选择合适的坐标刻度，使得曲线能够尽可能清晰的显示出来。所以，一般情况下用户不必选择坐标轴的刻度范围。但是，如果用户对坐标不满意，可以利用axis函数对其重新设定。 axis equal %纵横坐标轴采用等长刻度axis square %产生正方形坐标系（默认为矩形）axis auto %使用默认设置axis off %取消坐标轴axis on %显示坐标轴grid on %显示网格grid off %不显示网格box on %显示其他轴(上、右)box off %不显示其他轴(上、右)hold on %继续在同一图层绘图figure(1) %新生成一个图层","categories":[{"name":"学习","slug":"学习","permalink":"https://wenkexia.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://wenkexia.github.io/tags/matlab/"}]},{"title":"深度学习","slug":"深度学习","date":"2022-03-08T10:41:51.000Z","updated":"2022-03-08T10:41:51.000Z","comments":true,"path":"2022/030811061.html","link":"","permalink":"https://wenkexia.github.io/2022/030811061.html","excerpt":"","text":"人工智能、机器学习、深度学习的关系人工智能 &gt; 机器学习 &gt; 深度学习。 迁移学习神经网络需要用数据来训练，它从数据中获得信息，进而把它们转换成相应的权重。这些权重能够被提取出来，迁移到其他的神经网络中，我们“迁移”了这些学来的特征，就不需要从零开始训练一个神经网络了 预训练模型预训练模型(pre-trained model)是前人为了解决类似问题所创造出来的模型。你在解决问题的时候，不用从零开始训练一个新模型，可以从在类似问题中训练过的模型入手。 当在训练经网络的时候我们的目标是什么？我们希望网络能够在多次正向反向迭代的过程中，找到合适的权重。 通过使用之前在大数据集上经过训练的预训练模型，我们可以直接使用相应的结构和权重，将它们应用到我们正在面对的问题上。这被称作是“迁移学习”，即将预训练的模型“迁移”到我们正在应对的特定问题中。 实践平台如果学员想了解更多关于飞桨、深度学习、机器学习或Python课程，可以通过如下三个途径获取。 AI Studio：https://aistudio.baidu.com/飞桨官网：https://www.paddlepaddle.org.cn/百度技术学院：http://bit.baidu.com/index 机器学习机器学习是专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构，使之不断改善自身的性能。 机器学习的实现机器学习的实现可以分成两步：训练和预测，类似于归纳和演绎： 归纳： 从具体案例中抽象一般规律，机器学习中的“训练”亦是如此。从一定数量的样本（已知模型输入XXX和模型输出YYY）中，学习输出YYY与输入XXX的关系（可以想象成是某种表达式）。演绎： 从一般规律推导出具体案例的结果，机器学习中的“预测”亦是如此。基于训练得到的YYY与XXX之间的关系，如出现新的输入XXX，计算出输出YYY。通常情况下，如果通过模型计算的输出和真实场景的输出一致，则说明模型是有效的。 深度学习基础人工神经网络包括多个神经网络层，如：卷积层、全连接层、LSTM等，每一层又包括很多神经元，超过三层的非线性神经网络都可以被称为深度神经网络。通俗的讲，深度学习的模型可以视为是输入到输出的映射函数，如图像到高级语义（美女）的映射，足够深的神经网络理论上可以拟合任何复杂的函数。因此神经网络非常适合学习样本数据的内在规律和表示层次，对文字、图像和语音任务有很好的适用性。这几个领域的任务是人工智能的基础模块，因此深度学习被称为实现人工智能的基础也就不足为奇了。 神经元： 神经网络中每个节点称为神经元，由两部分组成： 加权和：将所有输入加权求和。 非线性变换（激活函数）：加权和的结果经过一个非线性函数变换，让神经元计算具备非线性的能力。 多层连接： 大量这样的节点按照不同的层次排布，形成多层的结构连接起来，即称为神经网络。 前向计算： 从输入计算输出的过程，顺序从网络前至后。 计算图： 以图形化的方式展现神经网络的计算逻辑又称为计算图，也可以将神经网络的计算图以公式的方式表达：Y=f3(f2(f1(w1⋅x1+w2⋅x2+w3⋅x3+b)+…)…)…)​神经网络并没有那么神秘，它的本质是一个含有很多参数的“大公式” 构建神经网络/深度学习模型的基本步骤数据处理数据导入、 数据形状变换、 数据集划分、 数据归一化处理 封装load data函数 模型设计（模型要素1）网络结构设计，相当于模型假设空间，即模型能够表达的关系集合。 训练配置模型要素2）设定模型采用的寻解方法，即优化器，并指定计算资源。PS：神经网络学习的目的是寻找合适的参数，使得损失函数的值尽可能小。解决这个问题的过程为称为最优化。解决这个问题使用的算法叫做优化器。接触到的优化器有：随机梯度下降法（Stachastic gradient desent 简称 SGD）和AdaGrad AdaGard主要是为了解决 SGD 遇到鞍点或者极小值点后学习变慢的问题。我们知道超参数学习率是一个很重要的参数，不同的参数对学习结果的影响很大，如果设置的值较小，会导致学习花费较多的时间，学习率大了就会导致学习发散而不能正常的进行。所以我们可以考虑避免人为的介入，根据需要让程序自己动态地设置学习率。例如对于遇到鞍点的情况，参数变化很小，基本不会改变，那么这个方法就会设置一个较大的学习率，跨过鞍点。 训练过程模型要素3）循环调用训练过程，每轮都包括前向计算、损失函数（优化目标）和后向传播三个步骤。 PS：前向计算是指把输入数据传入模型，然后得到输出；后向传播是指根据前向计算得到的输出通过梯度下降，从后向前优化网络中的参数。（因为梯度下降就是从后向前计算） 模型保存将训练好的模型保存，模型预测是调用。 预测问题对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。下面我们尝试用最简单的线性回归模型解决这个问题，并用神经网络来实现这个模型。 构建模型 模型结构三要素（模型假设、评价函数和优化算法） paddleHub工具端到端的预训练模型管理与迁移学习工具模型一键下载、管理、预测,十行代码完成迁移学习,一键自动超参搜索,一键模型服务化部署 精选效果优秀的算法，提供了百亿级大数据训练的预训练模型，方便用户不用花费大量精力从头开始训练一个模型。 #安装 -i指定镜像源pip install paddlehub -i http://pypi.douban.com/simple/#更新pip install –upgrade paddlehub -i http://pypi.douban.com/simple/ 自然语言处理(NLP)NLP 的4个典型应用情感分析 聊天机器人 语音识别 机器翻译 paddlenlp安装pip install –upgrade paddlenlphttps://aistudio.baidu.com/aistudio/projectdetail/3696243?channelType=0&amp;channel=0 中文分词分词作为许多NLP任务的第一道工序,Taskflow提供了多种中文分词模式供大家选择 文档级输入支持超长文本输入，无需担心『文本截断』问题 12345678910from paddlenlp import Taskflow# 首次调用会有模型下载的额外时间开销seg = Taskflow(\"word_segmentation\")doc = \"苏锦一直记得那个午后，明晃晃的光线穿过教室的窗玻璃洒到自己脸上，有种特别暖和的感觉。那阳光仿佛是能够钻进人的\"print(\"1. 输入长度：\", len(doc))print(\"2. 分词结果：\", seg(doc)) 快速模式分词示例如何通过快速模式分词对数据集进行词频统计、构建词表 精确模式分词用户词典快速配置用户词典来对分词结果进行干预 词性标注，，依存句法分析123456789101112from paddlenlp import Taskflow# 基于百度词法分析工具LAC，训练语料包含近2200万句子，覆盖多种场景# 词性标注tag = Taskflow(\"pos_tagging\")print(tag(\"第十四届全运会在西安举办\")) 命名实体识别基于百度解语的精确模式：最全中文实体标签的命名实体识别工具 精确模式基于百度解语的精确模式：最全中文实体标签的命名实体识别工具，不仅适用于通用领域，也适用于生物医疗、教育等垂类领域。包含66种词性及专名类别标签（同类产品的标签数是15个左右） 12345from paddlenlp import Taskflowner = Taskflow(\"ner\")print(ner([\"李伟拿出具有科学性、可操作性的《陕西省高校管理体制改革实施方案》\", \"诺戴商务咨询（上海）有限公司于2016年08月22日成立\"])) 快速模式基于百度词法分析工具LAC，训练语料包含近2200万句子，覆盖多种场景 123456from paddlenlp import Taskflowner_fast = Taskflow(\"ner\", mode=\"fast\")print(ner_fast(\"三亚是一个美丽的城市\")) 依存句法分析123456789101112131415from paddlenlp import Taskflow# 使用BiLSTM作为编码器，速度最快ddp = Taskflow(\"dependency_parsing\")print(ddp(\"2月8日谷爱凌夺得北京冬奥会第三金\"))# # 编码器部分将BiLSTM替换为ERNIE，模型准确率更高！# ddp = Taskflow(\"dependency_parsing\", model=\"ddparser-ernie-1.0\")# print(ddp(\"2月8日谷爱凌夺得北京冬奥会第三金\"))# 输出概率值和词性标签ddp = Taskflow(\"dependency_parsing\", prob=True, use_pos=True)print(ddp(\"2月8日谷爱凌夺得北京冬奥会第三金\")) 定制化训练利用自己的数据训练/微调模型，通过Taskflow一键装载并使用 数据准备和训练参考PaddleNLP SKEP情感分析训练示例完成数据准备和模型训练。 使用定制化模型通过task_path指定自定义模型路径一键加载即可。 12345from paddlenlp import Taskflowmy_senta = Taskflow(\"sentiment_analysis\", model=\"skep_ernie_1.0_large_ch\", task_path=\"/home/aistudio/custom_model\")print(my_senta(\"不错的酒店,服务还可以,下次还会入住的~\"))","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://wenkexia.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"django学习","slug":"django学习","date":"2022-03-06T13:02:52.000Z","updated":"2022-03-06T13:02:52.000Z","comments":true,"path":"2022/030664874.html","link":"","permalink":"https://wenkexia.github.io/2022/030664874.html","excerpt":"","text":"Python 加 Django 是快速开发、设计、部署网站的最佳组合。 安装pip install django -i http://pypi.douban.com/simple --trusted-host pypi.douban.com 创建项目在想要创建的文件夹中，进入终端执行命令创建项目'django-admin startproject 项目名称 项目文件介绍manage.py 项目的管理，启动项目，创建app,数据管理urls.py url和函数的对应关系asgi.py 和wsgi.py 接受网络请求 创建一个apppython manage.py startapp 名称 Uvicorn 运行 djangodjango 内置的开发服务器在修改代码后的热重载非常缓慢，我发现 uvicorn 的重载速度要快得多，所以新项目第一件事，就是使用在开发环境下使用 uvicorn 运行 django。 首先当然要安装 uvicorn。pip install uvicorn Uvicorn 安装好后，可以在命令行使用 uvicorn 命令来运行 django。但是，每次输命令启动 django 会非常麻烦！最好的做法是创建一个脚本，启动 django 只需要执行脚本就可以了。 在 项目根目录 创建一个 run_uvicorn.py 的脚本（脚本名可以自己随便取），代码如下： 1234567891011121314151617import uvicornimport osdef main(): os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"mysite.settings\") uvicorn.run( \"mysite.asgi:application\", host=\"0.0.0.0\", port=8000, log_level=\"debug\", reload=True, )if __name__ == \"__main__\": main() 运行脚本后，应用已在 8000 端口启动，现在访问 localhost:8000，可以看到熟悉的 django 项目初始页面。 创建views.py 写函数","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"web","slug":"web","permalink":"https://wenkexia.github.io/tags/web/"}]},{"title":"Linux","slug":"Linux","date":"2022-02-26T12:50:16.000Z","updated":"2022-02-26T12:50:16.000Z","comments":true,"path":"2022/022615691.html","link":"","permalink":"https://wenkexia.github.io/2022/022615691.html","excerpt":"","text":"使用linux的好处使用linux的好处在 linux 下，apt install 或者 yum install 之类的命令，就能搞定整个软件安装。 Linux 不需要选择软件是放 c 盘还是 d 盘，已经定义好了哪些文件该放在哪些地方，不需要杀毒软件，不需要清理垃圾，不需要释放内存，不需要激活系统，它是开源免费的，不需要磁盘优化，没有烦人的弹窗，没有强制更新。 linux环境VMware搭建linuxVMWare 和 Hyper-V 共存将 Windows 版本升级到 Windows 10 20H1 或更高版本。将 VMWare Workstation/Player 升级到 15.5.5 或更高版本在安装时，勾选“自动安装 Windows Hypervisor Platform (WHP)”。打开虚拟机的设置选项，找到“处理器”，去掉如图所示的三个选项前面的钩，点击“确定” 网络连接方式NAT模式（默认）：网络地址转换方式，linux可以访问外网，不会造成ip冲突 桥接模式：可以与其它系统进行通信，但可能造成ip冲突 主机模式：你的Linux是一个独立的主机，不能访问外网 WSL2搭建Linux官方文档WSL2采用在Hyper-V虚拟机中运行的方案,实现了与 windows 的高度集成,wsl2 的开启速度有了非常明显的提升，几乎无需等待。 启用适用于 Linux 的 Windows 子系统 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启用虚拟机平台功能 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 以管理者模式进入cmd安装wsl --install 切换WSL的默认版本为WSL2。wsl --set-default-version 2 以管理者cmd进行更新操作wsl --update 重启，更新才能生效wsl --shutdown Microsoft Store 中找一个 Linux 发行版进行安装 查看系统版本wsl -l -v 修改默认安装目录命令格式：wsl –import &lt;文件位置&gt; &lt;安装位置&gt; 查看已安装的linux发行版本 wsl -l --all -v 导出分发版为tar文件到d盘wsl --export Ubuntu-20.04 D:\\data\\WSL2\\Ubuntu-20.04.tar 注销当前分发版wsl --unregister Ubuntu-20.04 重新导入并安装WSL在D盘wsl --import Ubuntu-20.04 D:\\data\\WSL2\\Ubuntu-20.04 D:\\data\\WSL2\\Ubuntu-20.04.tar --version 2 设置默认登陆用户为安装时用户名ubuntu config --default-user USERNAME 删除wsl-ubuntu20.04.tardel d:\\wsl-ubuntu.tar 设置 Linux 用户名和密码若要更改或重置密码，请打开 Linux 发行版并输入命令：passwd如果忘记了 Linux 分发版的密码：1.请打开 PowerShell，并使用以下命令进入默认 WSL 分发版的根目录：wsl -u root 如果需要在非默认分发版中更新忘记的密码，请使用命令：wsl -d Debian -u root，并将 Debian 替换为目标分发版的名称。 2.在 PowerShell 内的根级别打开 WSL 发行版后，可使用此命令更新密码：passwd ，其中 是发行版中帐户的用户名，而你忘记了它的密码。 关闭WSL2WSL2实际上是在虚拟机中运行。我们一旦进入WSL2 Linux的命令行，虚拟机会自动启动运行。如果我们查看任务管理器，会发现一个Vmmem进程,它比较占内存。不使用WSL2的时候我们可以关闭它以节省内存。关闭WSL2 Linux的方法如下。使用管理员打开CMD，运行：wsl --shutdown 为发行版linux更换国内源https://blog.csdn.net/weixin_41529012/article/details/117226884 打开\\wsl.localhost\\Ubuntu\\etc\\apt地址下的sources.list文件，更改国内源中科大 1234567891011deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 123sudo apt update &amp;&amp; sudo apt upgrade #更新镜像源列表 使用vscode操作wsl在window的vscode上安装Remote Development扩展包包括Remote - SSH ， Remote - Containers ，Remote - WSL扩展 Remote - WSL 扩展：使你能够打开容器中、远程计算机上或 WSL 中的任何文件夹。 打开 WSL 项目1.从 WSL 发行版打开项目，请打开发行版的命令行并输入：code . 2.从 VS Code 中打开项目，通过使用 VS Code 中的快捷方式 CTRL+SHIFT+P 调出命令面板，以访问更多 VS Code 远程选项。 如果随后键入 Remote-WSL，将看到可用的 VS Code 远程选项列表，使你可以在远程会话中重新打开文件夹，指定要在哪个发行版中打开，等等。 wsl安装Docker1.下载 Docker Desktop 并按照安装说明进行操作。 2.安装后，从 Windows 开始菜单启动 Docker Desktop，然后从任务栏的隐藏图标菜单中选择 Docker 图标。 右键单击该图标以显示 Docker 命令菜单，然后选择“设置”。 3.确保在“设置”“常规”中选中“使用基于 WSL 2 的引擎”。 4.通过转到“设置”“资源”“WSL 集成”，从要启用 Docker 集成的已安装 WSL 2 发行版中进行选择。 5.若要确认已安装 Docker，请打开 WSL 发行版（例如 Ubuntu），并通过输入 docker –version 来显示版本和内部版本号 linux云服务器云服务器可以做什么 云服务器（Elastic Compute Service, 简称ECS），是一种简单高效，处理能力可以弹性伸缩的计算服务。ECS的相关术语说明如下： 实例（Instance）：是一个虚拟的计算环境，由CPU、内存、系统盘和运行的操作系统组成；ECS实例作为云服务器最为核心的概念，其他资源，比如磁盘、IP、镜像、快照等，只有与ECS结合后才具有使用意义。 地域（Region）：指ECS实例所在的物理位置。地域内的ECS实例内网是互通的，不同的地域之间ECS实例内网不互通。 可用区（Zone）：指在同一地域内，电力和网络互相独立的物理区域。 磁盘（Disk）：是为ECS实例提供数据块级别的数据存储。可以分为4类： 普通云盘、SSD云盘、高效云盘和本地SSD磁盘 快照（Snapshot）：是某一个时间点上某个磁盘的数据拷贝。 镜像（Image）：是ECS实例运行环境的模板，一般包括操作系统和预装的软件。 安全组（Security Group）：是一种虚拟防火墙，具备状态检测包过滤功能。每个实例至少属于一个安全组。同一个安全组内的实例之间网络互通，不同安全组的实例之间默认内网不通，但是可以授权两个安全组之间互访。 虚拟主机、ECS云服务器、VPS区别汇总1、虚拟主机 虚拟主机就是利用虚拟化的技术，将一台服务器划分出一定大小的空间，每个空间都给予单独的 FTP 权限和 Web 访问权限，多个用户共同平均使用这台服务器的硬件资源。不同配置的虚拟主机主要是在磁盘空间、数据库大小、流量上面的区别。虚拟主机也有可以分为独享的虚拟主机，和共享的虚拟主机。顾名思义，两者之间的区别在于服务器资源的独享和共享。网站主机、空间、都是一个意思。这一类的主机用户的权限很低，没有远程桌面，只有FTP权限供用户上传文档等操作。优势是比较价格便宜。 2、VPS 先说一下vps，Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。与虚拟主机不同的是，你拥有的是一台虚拟的服务器，类似于Windows上的虚拟机一样，虽然是虚拟的，但是使用起来，和使用客户机没有什么区别。同理，VPS可以使用远程桌面登录对服务器进行维护操作。 3、ECS云服务器 现在的主流的服务器解决方案，一般理解云服务器和VPS一样，同样是虚拟化的技术虚拟出来的服务器。也有人说以前的VPS就是现在的ECS，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合；在这样的平台上虚拟出的服务器，用户可以根据自己的运算需要选择配置不同的云服务器。具体区别总结如下： 使用VScode连接阿里云远程服务器安装Remote-ssh插件在云服务器控制台选择安全组配置，加入ssh(22)的端口 文件操作linux文件目录/home存放所有用户文件的根目录，是用户主目录的基点 比如用户user的主目录就是/home/user，可以用~user表示 /usr用于存放系统应用程序，可以理解为C:/Windows/ /usr/local用户级的程序目录，可以理解为C:/Progrem Files/ 用户自己编译的软件默认会安装到这个目录下 本地系统管理员软件安装目录（安装系统级的应用） 这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录 用的是root的空间。 文件权限12345# 查看当前目录下所有文件权限ls -l #简写 ll #查看指定文件权限ll |grep 文件名 在linux下，文件权限分为三种：可读权限(read)、可写权限(write)以及可执行权限(execute)，三者分别对应的字符为r、w和x； 文件权限身份也分三种：文件所有者（user）、文件所有者所在组（group）以及其他（others） 10个字符每一个文件的第一个字段都是由r、w、x等10个字符构成 ①第1个字符。描述文件\\目录 类型，如果为‘-’则表示这是一个文件，如果为’d’表示这是一个目录； ②第2~4个字符。这3个字符为一组，按照顺序描述了文件所有者对该文件的可读、可写和可执行权限； ②第5~7个字符。这3个字符为一组，按照顺序描述了文件所有者所在组对该文件的可读、可写和可执行权限； ②第8~10个字符。这3个字符为一组，按照顺序描述了其他身份对该文件的可读、可写和可执行权限； 第1个字符反映了文件类型，后面9个字符每3个字符为一组，分别反映了文件所有者、文件所有者所在组和其他身份对该文件的可读、可写和可执行权限，如果为‘r’表示可读，为’w’表示可写，为’x’表示可执行，为’-‘表示无相应权限。 修改文件权限要通过su进入到root权限中chmod abc filename 1chmod 777 指令中的a、b、c分别表示一个数字，其中a对应文件所有者权限，b对应文件所有者所在组权限，c对应其他身份权限。 对于a、b、c各自来讲，它们都是0~7的数字，对应r、w、x三个二进制位按序组成的二进制数，举个例子，如果是只可读，对应的二进制数就是“100”，也就是4；如果是可读可写不可执行，那么对应二进制数为“110”，也就是6…… 再举个最常见的chmod 777 xxxx指令，这里有3个7，但是每个7的含义是不同的。7的二进制形式为111，表示可读可写可执行，第1个7表示文件对于文件所有者来说可读可写可执行；第2个7表示文件对于文件所有者所在组来说可读可写可执行；第3个7表示文件对于其他身份的用户来说可读可写可执行。也就是说，通过chmod 777，文件就没有了读写执行权限限制了。 Linux用户管理12345# 增加用户，并创建主目录useradd -m 用户名# 删除用户，并删除主目录userdel -r 用户名 删除123456789# Linux删除文件夹命令rm -rf /var/log/httpd/access将会删除/var/log/httpd/access目录以及其下所有文件、文件夹# Linux删除文件命令rm -f /var/log/httpd/access.log将会强制删除/var/log/httpd/access.log这个文件 下载linux系统基本上分两大类： RedHat系列：Redhat、Centos、Fedora等常见的安装包格式 rpm 包，安装rpm包的命令是 “rpm -参数”包管理工具 yum支持tar包 Debian系列：Debian、Ubuntu等常见的安装包格式 deb 包，安装deb包的命令是 “dpkg -参数”包管理工具 apt-get支持tar包 yumyum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令 12345678910111213141516171819201. 列出所有可更新的软件清单命令：yum check-update2. 更新所有软件命令：yum update3. 仅安装指定的软件命令：yum install &lt;package_name&gt;4. 仅更新指定的软件命令：yum update &lt;package_name&gt;5. 列出所有可安裝的软件清单命令：yum list6. 删除软件包命令：yum remove &lt;package_name&gt;7. 查找软件包命令：yum search &lt;keyword&gt;8. 清除缓存命令:yum clean packages: 清除缓存目录下的软件包yum clean headers: 清除缓存目录下的 headersyum clean oldheaders: 清除缓存目录下旧的 headersyum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers 配置yum仓库yum就是一个硕大的软件仓库，里面保存了几乎所有的常用工具，只需要为系统提供软件包名称即可。 1234# 先切换到yum源中的配置目录cd /etc/yum.repos.d/ yum无法使用yum服务使用的默认python版本是python2更换yum源 12345678vim /usr/bin/yum #先看下/usr/bin/yum文件内容#查看系统默认安装的yumrpm -qa|grep yumyum update wgetwget是Linux中的一个下载文件的工具，后来被移植到包括Windows在内的各个平台上。 1234#安装wgetyum install -y wget#查看帮助手册wget --help linux压缩文件gzip命令gzip是用来压缩和解压.gz文件的命令。gzip命令只能压缩单个文件，而不能把一个文件夹压缩成一个文件（与打包命令的区别） 1234567891011#会将文件压缩为文件 test.txt.gz，原来的文件则没有了gzip /home/aistudio/work/test.txt#解压文件,原来的文件则没有了gzip -d /home/aistudio/test.gz#参数-r或--recursive：递归压缩指定文件夹下的文件（该文件夹下的所有文件被压缩成单独的.gz文件）；-v或--verbose：显示指令执行过程。 tar命令用来打包或者解包后缀名为.tar 12345678#参数-c或--create：建立新的备份文件；-x或--extract或--get：从备份文件中还原文件；-v：显示指令执行过程；-f或--file：指定备份文件；-C：指定目的目录；-z：通过gzip指令处理备份文件；-j：通过bzip2指令处理备份文件。 zip和unzipzip命令和unzip命令用在在Linux上处理.zip的压缩文件。 12345678910#常用参数#zip:-v：显示指令执行过程；-m：不保留原文件；-r：递归处理。#unzip:-v：显示指令执行过程；-d：解压到指定目录。 vim使用https://www.jianshu.com/p/8b679b35c9d5Vim可以分为三种模式，分别为： 命令行模式（Command mode）控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。进入vim之后，是处于「命令行模式」，要按i切换到「插入模式」才能够输入文字。 插入模式（Insert mode）只有在插入模式下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式（Lastline mode）将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号……等。在命令行模式下，按冒号「:」键，进入底行模式 :w filename 文件以filename为文件名保存 :wq 文件存盘并退出vim :q 文件不存盘并退出vim :q! 文件不存盘强制退出vim 环境变量1、修改 /etc/profile 文件，如果你的计算机仅仅作为开发使用时推存使用这种方法，因为所有用户的shell都有权使用这个环境变量，可能会给系统带来安全性问题。这里是针对所有的用户的，所有的shell vi /etc/profile 在/etc/profile的最下面添加： export PATH=”$PATH:/NEW_PATH” 针对当前特定的用户起作用的环境变量 2、修改bashrc文件，这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，这里是针对某一特定的用户，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的 .bashrc文件就可以了。 vi ~/.bashrc 在下面添加： Export PATH=”$PATH:/NEW_PATH” shell常见的 Shell 有 sh、bash、csh、tcsh、ash 等。#!/bin/bash是指此脚本使用/bin/bash来解释执行。脚本文件后缀是.sh100个shell脚本 linux使用用户操作12su root #切换到 root 用户 Linux常用命令linux区分大小写，使用tab来自动补全命令 如果想要输入和执行多条命令，用分号分隔命令 Linux开机自动启动软件/可执行程序首先关注几个脚本/etc/rc.d/rc.local：该脚本在系统启动时被执行一次；/etc/profile:该脚本在所有用户登陆时会被执行一次；~/.bashrc:该脚本在用户登陆时被执行一次，与/etc/profile不同的是，bashrc文件每个用户拥有独立的一个。 若设置开机启动，应该修改：/etc/rc.d/rc.local文件。 xshellXShell是一个强大的安全终端模拟软件,可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。安装参考 远程连接选择导航菜单的文件 –&gt; 新建，输入名称和主机IP，协议默认SSH，端口默认22，如果不知道主机IP可以登录虚拟机的Linux系统，输入命令ifconfig查看(inet addr) 然后在左侧用户身份验证中输入用户名和密码，这样下次就可以直接连接了，当然如果为了安全考虑也可以不输入密码，在每次连接时再输入。 Xshell怎么与云服务器连接打开Xshell，新建一个会话 主机填服务器ip,点击连接 用户名默认为root,而不是实例名，也不是你服务器中Linux的用户名；密码则为服务器实例密码 centos内核1234# 版本信息cat /etc/centos-release # 查看Linux内核信息uname -a NAT配置检查环境: 能上网，安装了net-tools.（1）能否上网（ping www.baidu.com)如不能上网。配置/etc/sysconfig/network-scripts/ifcfg-ens33（2）是否安装了 net-tools. (因为需要使用命令 route )如没有， yum -y install net-tools 搭建网络一台Sever (2张网卡） + 一台 Client（一张网卡） 安装（或克隆）一台虚拟机名为：Client. 原来那台可改名叫（Server)。Server 上再安装一张网卡，并配成“仅主机模式”。（原来应该那一张应该为NAT模式）。Client 网卡配成 “仅主机模式” 配置NAT（1）开启Server 和 Client, 用 root 登录。（2）在Server 上运行： ip addr记录下 ens37 (也就是Server 的第二张网卡） 的ip：192.168.221.128（3）设置Client网关，在Client 上 运行:route add default gw 192.168.221.128 #添加一条默认网关（如要查看网关 是否设置成功，可以运行：route -n) （4）在Server设置地址伪装 ， 运行： (5）重启防火墙systemctl restart firewalld.service (6)在Client 上ping测试是否成功 (7)在Client上配置本地DNS:去到目录 /etc 下， 用vi 编辑 文件 “resolv.conf” 搭建云上博客不知道教程是不是太旧了，跟着做，都是报错 部署环境安装Apache服务及其扩展包跟着官网做发现安装失败 12345yum -y install httpd httpd-manual mod_ssl mod_perl mod_auth_mysqlLast metadata expiration check: 0:30:48 ago on Thu 17 Mar 2022 08:21:43 AM CST.No match for argument: mod_auth_mysqlError: Unable to find a match: mod_auth_mysql 搜索到的解决方案 yum -y install httpd httpd-manual mod_ssl mod_perl yum -y install httpd httpd-devel 启动Apache服务。systemctl start httpd.service 设置安全组教程上没有说清楚 进入实例，点击安全组链接进去 然后点击快速添加选端口范围为http(80) 打开浏览器输入ECS服务器的公网IP，显示测试页面表示Apache服务安装成功。 搭建网盘Cloudreve官网官网： cloudreve.org github： https://github.com/cloudreve/Cloudreve 下载： https://github.com/cloudreve/Cloudreve/releases 安装文档： https://docs.cloudreve.org/getting-started/install 安装123456cd /opt #选定/opt作为安装目录wget https://github.com/cloudreve/Cloudreve/releases/download/3.1.1/cloudreve_3.1.1_linux_amd64.tar.gztar -zxvf cloudreve_3.1.1_linux_amd64.tar.gz #解压获取到的主程序chmod +x ./cloudreve #赋予执行权限./cloudreve #启动 Cloudreve Cloudreve 在首次启动时，会创建初始管理员账号，请注意保管管理员密码，此密码只会在首次启动时出现。如果您忘记初始管理员密码，需要删除同级目录下的“cloudreve.db”，重新启动主程序以初始化新的管理员账户。 Cloudreve 默认会监听“5212”端口。你可以在浏览器中访问 http://服务器ip:5212 进入 Cloudreve。如果宝塔面板需要在安全中放行“5212”端口。注意用默认的管理账号和密码登录。 添加守护进程软件商店→系统工具 ，找到Supervisor管理器安装打开Supervisor管理器添加守护进程 什么是反向代理反向代理是充当Web服务器网关的代理服务器。当您将请求发送到使用反向代理的Web服务器时，他们将先转到反向代理，由该代理将确定是将其路由到Web服务器还是将其阻止。 这意味着有了反向代理，您永远不会与使用它的Web服务器进行直接通信。可以将它们看作web服务器或服务器集群的某种包装器。通过负载平衡和缓存，它们可以保护web免遭攻击，并提供更好的web性能。 宝塔Linux面板https://blog.csdn.net/vpssws/article/details/117136583?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3 安装12345678910111213141516# Centos安装命令：yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh# Ubuntu/Deepin安装命令：wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh#显示面板的使用帮助菜单选项。bt#卸载面板wget http://download.bt.cn/install/bt-uninstall.sh#执行脚本：sh bt-uninstall.sh 安装软件时，推荐使用编译安装 面板特色功能：一键配置服务器环境（LAMP/LNMP）一键安全重启一键创建管理网站、ftp、数据库一键部署SSL证书一键部署源码（discuz、wordpress、dedecms、z-blog、微擎等等）一键配置（定期备份、数据导入、伪静态、301、SSL、子目录、反向代理、切换PHP版本）一键安装常用PHP扩展(fileinfo、intl、opcache、imap、memcache、apc、redis、ioncube、imagick)数据库一键导入导出系统监控（CPU、内存、磁盘IO、网络IO）防火墙端口放行SSH开启与关闭及SSH端口更改禁PING开启或关闭方便高效的文件管理器（上传、下载、压缩、解压、查看、编辑等等）计划任务（定期备份、日志切割、shell脚本）软件管理（一键安装、卸载、版本切换） 添加站点添加站点就是添加一个域名进去，通过这个域名可以访问你的网页，或者直接填写你的ip进去，然后浏览器输入你的ip访问一下就看到结果了 LNMP 环境LNMP 是 Linux、Nginx、MariaDB 和 PHP 的缩写，这个组合是最常见的 Web 服务器的运行环境之一。用宝塔面板一键安装 ftp服务python自动化部署Python提供了一个paramiko库，能够支持SSH和SFTP协议，可以取代Xshell和Xftp，下面是把本机的jar文件上传到服务器并运行的Python脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243# coding=utf-8import threadingimport paramiko IP = '106.14.19.127'user = 'root'password = 'server-pwd' local_jar = '/target/ser1-1.0.jar'server_jar = '/root/ser1-1.0.jar'server_property = '/root/ser1.properties' def execute_cmds(ip, name, pwd, cmd): try: ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(ip, 22, name, pwd, timeout=5) print '连接成功' sftp = ssh.open_sftp() print '正在上传...' sftp.put(local_jar, server_jar) print 'jar上传成功' for m in cmd: print m stdin, stdout, stderr = ssh.exec_command(m) out = stdout.readlines() for o in out: print o, print '运行成功' ssh.close() print '关闭连接' except Exception, error: print '错误: %s' % (error) if __name__ == '__main__': print 'Start deploying %s to server %s' % (server_jar, IP) cmd = [ 'echo Start spring...', 'nohup java -jar -Dspring.config.location=' + server_property + ' ' + server_jar + ' &amp;', 'echo All done.' ] a = threading.Thread(target=execute_cmds, args=(IP, user, password, cmd)) a.start()","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wenkexia.github.io/tags/linux/"}]},{"title":"python数据结构","slug":"数据结构","date":"2022-02-19T04:04:47.000Z","updated":"2022-02-19T04:04:47.000Z","comments":true,"path":"2022/02191106.html","link":"","permalink":"https://wenkexia.github.io/2022/02191106.html","excerpt":"","text":"https://www.yiibai.com/python/py_data_structure/python_data_structure_introduction.html 线性数据结构这些是以顺序方式存储数据元素的数据结构。例如 - 数组: 它是与数据元素的索引配对的数据元素的顺序排列。链表: 每个数据元素都包含一个指向另一个元素的链接及其中的数据。链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据。链表中每一个节点都包含此节点的数据和指向下一节点地址的指针。由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高。 这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点。不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用。 一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表。 链表和数组对比链表和数组在实际的使用过程中需要根据自身的优劣势进行选择。链表和数组的异同点也是面试中高频的考察点之一。这里对单链表和数组的区别进行了对比和总结。 堆栈: 这是一种仅遵循特定操作顺序的数据结构。LIFO(后进先出)或FILO(先进先出)。队列: 与堆栈(Stack)类似，但操作顺序仅为FIFO(先进先出)。矩阵: 它是二维数据结构，其中数据元素由一对索引引用。 非线性数据结构这些数据结构中没有数据元素的顺序链接。任何一对或一组数据元素都可以相互关联，并且可以在没有严格顺序的情况下进行访问。 二叉树:它是一个数据结构，每个数据元素可以连接到最多两个其他数据元素，并以一个根节点开始。堆: 这是树形数据结构的特殊情况，其中父节点中的数据严格大于/等于子节点或严格小于其子节点。哈希表: 它是一个数据结构，它由使用散列函数相互关联的数组构成。它使用键而不是数据元素的索引来检索值。图: 它是顶点和节点的排列，其中一些节点通过链接彼此连接。 数组数组可以说是最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。 跳表从上面的对比中可以看出，链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化。特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低。跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率。这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)。 图片 跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下。目前redis和levelDB都有用到跳表。 从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查询的目的。 栈栈是一种比较简单的数据结构，常用一句话描述其特性，后进先出。栈本身是一个线性表，但是在这个表中只有一个口子允许数据的进出。这种模式可以参考腔肠动物…即进食和排泄都用一个口… 栈的常用操作包括入栈push和出栈pop，对应于数据的压入和压出。还有访问栈顶数据、判断栈是否为空和判断栈的大小等。由于栈后进先出的特性，常可以作为数据操作的临时容器，对数据的顺序进行调控，与其它数据结构相结合可获得许多灵活的处理。 图片 队列队列是栈的兄弟结构，与栈的后进先出相对应，队列是一种先进先出的数据结构。顾名思义，队列的数据存储是如同排队一般，先存入的数据先被压出。常与栈一同配合，可发挥最大的实力。 图片 树树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。常见的数的表示形式更接近“倒挂的树”，因为它将根朝上，叶朝下。 树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。 这意味着树是具备层次关系的，父子关系清晰，家庭血缘关系明朗；这也是树与图之间最主要的区别。 图片 别看树好像很高级，其实可看作是链表的高配版。树的实现就是对链表的指针域进行了扩充，增加了多个地址指向子结点。同时将“链表”竖起来，从而凸显了结点之间的层次关系，更便于分析和理解。 树可以衍生出许多的结构，若将指针域设置为双指针，那么即可形成最常见的二叉树，即每个结点最多有两个子树的树结构。二叉树根据结点的排列和数量还可进一度划分为完全二叉树、满二叉树、平衡二叉树、红黑树等。 图片 完全二叉树：除了最后一层结点，其它层的结点数都达到了最大值；同时最后一层的结点都是按照从左到右依次排布。 满二叉树：除了最后一层，其它层的结点都有两个子结点。 平衡二叉树平衡二叉树又被称为AVL树，它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 二叉排序树：是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。 树的高度：结点层次的最大值 平衡因子：左子树高度 - 右子树高度 二叉排序树意味着二叉树中的数据是排好序的，顺序为左结点&lt;根节点&lt;右结点，这表明二叉排序树的中序遍历结果是有序的。（还不懂二叉树四种遍历方式[前序遍历、中序遍历、后序遍历、层序遍历]的同学赶紧补习！） 图片 平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象。由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化。 图片 平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡。主要的四种调整方式有LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。这里先给大家介绍下简单的单旋转操作，左旋和右旋。LR和RL本质上只是LL和RR的组合。 在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。 左旋：S为当前需要左旋的结点，E为当前结点的父节点。 图片 左旋的操作可以用一句话简单表示：将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子。可用动画表示： 图片 右旋：S为当前需要左旋的结点，E为当前结点的父节点。右单旋是左单旋的镜像旋转。 图片 左旋的操作同样可以用一句话简单表示：将当前结点S的左孩子E的右孩子旋转为当前结点S的左孩子，同时将当前结点S旋转为左孩子E的右孩子。可用动画表示： 图片 红黑树平衡二叉树（AVL）为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1。高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN)。但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡。这导致AVL的插入和删除效率并不高。 为了解决这样的问题，能不能找一种结构能够兼顾搜索和插入删除的效率呢？这时候红黑树便申请出战了。 红黑树具有五个特性： 每个结点要么是红的要么是黑的。根结点是黑的。每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。如果一个结点是红的，那么它的两个儿子都是黑的。对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。图片红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低。红黑树不追求完全平衡，只要求达到部分平衡。这是一种折中的方案，大大提高了结点删除和插入的效率。C++中的STL就常用到红黑树作为底层的数据结构。 红黑树VS平衡二叉树图片 除了上面所提及的树结构，还有许多广泛应用在数据库、磁盘存储等场景下的树结构。比如B树、B+树等。这里就先不介绍了诶，下次在讲述相关存储原理的时候将会着重介绍。（其实是因为懒） 7 堆了解完二叉树，再来理解堆就不是什么难事了。堆通常是一个可以被看做一棵树的数组对象。堆的具体实现一般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应，因此堆总是一颗完全二叉树。 对于任意一个父节点的序号n来说（这里n从0算），它的子节点的序号一定是2n+1，2n+2，因此可以直接用数组来表示一个堆。 不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 图片 堆常用来实现优先队列，在面试中经常考的问题都是与排序有关，比如堆排序、topK问题等。由于堆的根节点是序列中最大或者最小值，因而可以在建堆以及重建堆的过程中，筛选出数据序列中的极值，从而达到排序或者挑选topK值的目的。 8 散列表散列表也叫哈希表，是一种通过键值对直接访问数据的机构。在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射。散列表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率。在映射的过程中，事先设定的函数就是一个映射表，也可以称作散列函数或者哈希函数。 图片 散列表的实现最关键的就是散列函数的定义和选择。一般常用的有以下几种散列函数： 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。 数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。 平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。 取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。 除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。 确定好散列函数之后，通过某个key值的确会得到一个唯一的value地址。但是却会出现一些特殊情况。即通过不同的key值可能会访问到同一个地址，这个现象称之为冲突。 冲突在发生之后，当在对不同的key值进行操作时会使得造成相同地址的数据发生覆盖或者丢失，是非常危险的。所以在设计散列表往往还需要采用冲突解决的办法。 常用的冲突处理方式有很多，常用的包括以下几种： 开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。 再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。 链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的。 公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。 目前比较常用的冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的。 图片 左侧数组的每个成员包括一个指针，指向一个链表的头。每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部。这样一来，就可以保证冲突的数据能够区分并顺利访问。考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性。 9 图图相较于上文的几个结构可能接触的不多，但是在实际的应用场景中却经常出现。比方说交通中的线路图，常见的思维导图都可以看作是图的具体表现形式。 图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线。边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1。此外根据边的方向性，还可将图分为有向图和无向图。 图片 图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了。但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事。 邻接矩阵目前常用的图存储方式为邻接矩阵，通过所有顶点的二维矩阵来存储两个顶点之间是否相连，或者存储两顶点间的边权重。 图片 无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，若能从此顶点能够到达彼顶点，那么彼顶点自然也能够达到此顶点。此外，由于顶点本身与本身相连没有意义，所以在邻接矩阵中对角线上皆为0。 图片 有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再。用邻接矩阵可以直接从二维关系中获得任意两个顶点的关系，可直接判断是否相连。但是在对矩阵进行存储时，却需要完整的一个二维数组。若图中顶点数过多，会导致二维数组的大小剧增，从而占用大量的内存空间。 而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储。那么存储的邻接矩阵实际上会存在大量的0。虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性。 因此，为了解决上述问题，一种可以只存储相连顶点关系的邻接表应运而生。 邻接表在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点。相较于无向图，有向图的情况更为复杂，因此这里采用有向图进行实例分析。 图片在邻接表中，每一个顶点都对应着一条链表，链表中存储的是顶点能够达到的相邻顶点。存储的顺序可以按照顶点的编号顺序进行。比如上图中对于顶点B来说，其通过有向边可以到达顶点A和顶点E，那么其对应的邻接表中的顺序即B-&gt;A-&gt;E，其它顶点亦如此。 通过邻接表可以获得从某个顶点出发能够到达的顶点，从而省去了对不相连顶点的存储空间。然而，这还不够。对于有向图而言，图中有效信息除了从顶点“指出去”的信息，还包括从别的顶点“指进来”的信息。这里的“指出去”和“指进来”可以用出度和入度来表示。 入度：有向图的某个顶点作为终点的次数和。 出度：有向图的某个顶点作为起点的次数和。 由此看出，在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度。这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点。这个表称作逆邻接表。 逆邻接表逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点。也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点。 图片 邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示。可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表。 十字链表十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可。 图片 但这并不是最优的表示方式。虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储。因此，上图的表示方式还可以进行进一步优化。 十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储：（下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端） data：用于存储该顶点中的数据； firstin指针：用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点； firstout指针：用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点； 边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接： tailvex：用于存储作为弧尾的顶点的编号； headvex：用于存储作为弧头的顶点的编号； headlink 指针：用于链接下一个存储作为弧头的顶点的节点； taillink 指针：用于链接下一个存储作为弧尾的顶点的节点； 图片 以上图为例子，对于顶点A而言，其作为起点能够到达顶点E。因此在邻接表中顶点A要通过边AE（即边04）指向顶点E，顶点A的firstout指针需要指向边04的tailvex。同时，从B出发能够到达A，所以在逆邻接表中顶点A要通过边AB（即边10）指向B，顶点A的firstin指针需要指向边10的弧头，即headlink指针。依次类推。 十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性。具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示。 10 总结数据结构博大精深，没有高等数学的讳莫如深，也没有量子力学的玄乎其神，但是其在计算机科学的各个领域都具有强大的力量。本文试图采用图解的方式对九种数据结构进行理论上的介绍，但是其实这都是不够的。 即便是简单的数组、栈、队列等结构，在实际使用以及底层实现上都会有许多优化设计以及使用技巧，这意味着还需要真正把它们灵活的用起来，才能够算是真正意义上的熟悉和精通。但是本文可以作为常见数据结构的一个总结，当你对某些结构有些淡忘的时候，不妨重新回来看看。","categories":[{"name":"pytohn","slug":"pytohn","permalink":"https://wenkexia.github.io/categories/pytohn/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://wenkexia.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"微信小程序","slug":"微信小程序","date":"2022-01-24T09:33:43.000Z","updated":"2022-01-24T09:33:43.000Z","comments":true,"path":"2022/012435506.html","link":"","permalink":"https://wenkexia.github.io/2022/012435506.html","excerpt":"","text":"目录结构pages用来存放所有小程序的页面utils用来存放工具性质的模块(例如：格式化时间的自定义模块)app. js小程序项目的入口文件app.json小程序项目的全局配置文件app.Wxss小程序项目的全局样式文件project. config. json项目的配置文件sitemap json用来配置小程序及其页面是否允许被微信索引","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://wenkexia.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"window使用","slug":"window使用","date":"2022-01-22T01:09:49.000Z","updated":"2022-01-22T01:09:49.000Z","comments":true,"path":"2022/012246677.html","link":"","permalink":"https://wenkexia.github.io/2022/012246677.html","excerpt":"","text":"输入法不认识的汉字怎么打u+汉字各部分的拼音 扩展屏幕如何在笔记本盖上盖子时，扩展显示屏也能显示。在设置中搜索打开控制面板，然后找到电源选项打开，找到选择关闭笔记本计算机盖的功能 文件无法删除解决Windows10中“其中文件夹或文件已在另一程序中打开”引起的文件删不掉问题 打开任务管理器打开资源监视器1.切换任务管理器到“性能”选项页，点击最下方的“打开资源监视器”字。2.搜索与该文件关联的程序并关闭 以删除word文件“文件123.docx”为例：删除桌面上“文件123.docx”文件，显示该文件已被其他程序打开，暂时无法删除。 此时在资源监视器搜索句柄处填上文件123，即可搜索与这个文件相关联的应用程序句柄。点击与文件123相关联的句柄，然后点击鼠标右键，选择结束进程此时会弹出结束进程确认对话框。点击“结束进程”关闭与“文件123.docx”关联的进程。 怎样关闭Win10安装软件、改变设置时的弹窗？打开更改用户账户设置 Windows系统hosts文件路径为：C:\\Windows\\System32\\drivers\\etc Win10电脑设置定时关机命令：Win +r 输入：shutdown -s -t 3600 一小时后关机 Win10进入开机自启文件夹Win+r进入运行，输入shell:startup 快捷键汇总win+上下箭头键：【最大化】【还原】【最小化】当前窗口 win+左右箭头键：将窗口靠左、靠右。如果有两个窗口则并列 按住ctrl 可多选文件 Win+Shift+S 截图、 Win+g 截图录屏 在英文输入状态下，按住shift输入字母可以大写 按住alt双击文件 快速打开属性 Ctrl+shift+Esc 一键打开任务管理器 Ctrl +shift+n 快速新建文件夹 按住ctrl拖动文件 就是复制 Alt+F4键：关闭当前窗口，如果没有活动窗口就带开【关闭计算机】对话框 win+A键：快速打开【系统通知和控制中心】 Win+E键：快速打开【资源管理器】 win+G键：快速打开【Xbox工具】，这个工具非常实用，包含了截图、录屏等功能 win+I键：快速打开【计算机设置】 win+K键：快速打开【无线连接】 win+L键：快速【锁定屏幕】，如果你要暂时离开电脑，这个快捷键一定要知道 win+P键：快速打开【投影】，如果你要连接第二块屏幕或投影，这是最快捷的方法 win+Q键或者win+S键：快速打开【搜索】 win+R键：快速打开【运行】 win+T键：在【任务栏程序】中进行切换 win+V键：快速打开【剪贴板】 win+W键：快速打开【全屏截图】 win+X键：打开【系统快捷菜单】，这个菜单继承了巨大部分的系统功能。 win+数字键：打开【任务栏】上相应顺序的应用程序 win+加号：启动【放大镜】，加号放大，减号缩小 win+Tab键：打开【任务视图】，还可以按时间线查看近期任务 Alt+Tab键：在打开的程序间进行切换，这是笔者最常用的快捷键 网页ctrl + w 关闭一个网页Ctrl + Tab 切换网页Ctrl+h 打开历史记录 远程微软自带的远程连接联想小新pro16win10专业版两台设备都连着校园网，测试时，控制端不能连着电脑的热点。控制端要下载：RDclient成功后，你就可以不用带上你的电脑去机房上课了，直接在机房控制你的电脑，体验感翻倍 注意1.window要用微软账号登录2.用户名是自己设置的，可以是中文，打开图二密码中的更新安全问题选项也可以看到3. 密码是你的账户密码，不是PIN码哦4. 显示屏关闭后，微软远程就连接不上的原因 联想小新pro16可能是因为开了智能感知功能的原因，因此显示屏关闭或者盖上屏幕，控制端就无法连接上电脑 快捷键打开远程桌面，win+r 输入mstsc查询ip地址：win+r进入cmd,输入ipconfig ToDeskToDesk目前还是免费的且支持三台设备，而且界面简洁大气。 向日葵特点1.控制端和被控制端使用同一账号即可2.可以实时查看远程主机摄像头周围的情况3.方便快捷的让远程文件或本地文件互相传输和同步，安全稳定。4.无需内网穿透即可实现外网连接。需求①是在需要被控的电脑上安装被控端;②在手机上安装向日葵主控端③注册一个向日葵账号。在两端同时登录就可以远程控制了。 Windows Terminal是管理各种命令行的工具，它把目前 Windows 上的 PowerShell、CMD 以及 Windows Linux 子系统（WSL）三大环境实现了统一。 安装打开系统自带的 Microsoft Store，搜索 Windows Terminal 直接安装就可以了。 PowerShell是命令行程序，真正执行指令的程序， 在 Windows 上安装 PowerShellhttps://docs.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.1 安装 oh-my-posh 和 posh-gitoh-my-posh 是 PowerShell 主题管理工具posh-git 可以实现类似 oh-my-zsh 一样的 Git 命令增强工具（命令别名和显示分支信息等） 12Install-Module posh-gitInstall-Module oh-my-posh 配置 PowerShell1234# 这是开启默认配置的Set-Prompt# 设置主题，Agnoster 是主题名Set-Theme Agnoster 美化安装Scoop强大的 Windows 包管理工具 ScoopScoop 可以帮你一行命令安装 git 工具、java 环境、chrome 浏览器、vscode 等等，统一目录管理，而且自动配置环境变量，卸载也只需要一行命令，方便的不能在方便了设置安装路径（可选）。默认 Scoop 是安装在 C 盘的，以及通过 Scoop 安装的软件也是在 C 盘的。如果你的 C 盘空间不够或想安装到其他盘，可以执行以下操作。 123# 设置 scoop 安装路径为 D:\\scoop$env:SCOOP='D:\\scoop'[environment]::setEnvironmentVariable('SCOOP',$env:SCOOP,'User') 安装 Scoop 1234# 将执行权限改为本地无需签名Set-ExecutionPolicy RemoteSigned -scope CurrentUser# 下载并执行脚本iwr -useb get.scoop.sh | iex git bash是Windows下的命令行工具。有git分布式版本控制工具，也主要用于git。 1 在windows下使用linux命令操作 2 登陆远程linux服务器&nbsp;ssh 在window terminal中添加git bashhttps://www.cnblogs.com/cong-wang/p/15026535.html打开设置文件settings.json，在profiles的list中添加一项： 123456{ \"guid\" : \"{5D1F95DF-36E8-56AD-C203-EA75CE06422C}\", \"name\" : \"Git Bash\", \"commandline\" : \"D:\\\\ruanjian\\\\Git\\\\bin\\\\bash.exe --login -i\", \"icon\" : \"D:\\\\ruanjian\\\\Git\\\\git-bash.png\"}, guid：唯一标识本命令行配置，可以使用在线guid工具随机生成一个和list中其他配置不一样的guid即可name：本命令行配置的名字，会显示在菜单中commandline：表示怎么启动一个命令行，这里填的是”E:\\Git\\bin\\bash.exe –login -i”，需要找到你的Git的安装目录，将E:\\Git\\bin\\bash.exe替换成你自己的路径icon：显示在菜单中的图标 沙盒控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能 打开沙盒（在开始菜单中）,直接将要运行的程序，不确定安全性的程序复制粘贴进去就行,关机就清空数据了","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"window","slug":"window","permalink":"https://wenkexia.github.io/tags/window/"}]},{"title":"python自动化办公库","slug":"python自动化办公库","date":"2022-01-21T13:57:05.000Z","updated":"2022-01-21T13:57:05.000Z","comments":true,"path":"2022/012151162.html","link":"","permalink":"https://wenkexia.github.io/2022/012151162.html","excerpt":"","text":"原文 微信自动化库wxpy 库官网：https://wxpy.readthedocs.io/zh/latest/ 特点：微信机器人/可能是最优雅的微信个人号API，wxpy 在 itchat 的基础上，通过大量接口优化提升了模块的易用性，并进行丰富的功能扩展。Excel自动化库 // 1.xlwings 库官网：https://www.xlwings.org/ 特点：xlwings 是开源且免费的，预装了 Anaconda 和 WinPython，可在 Windows 和 macOS 上运行。通过 Python 脚本或 Jupyter notebook 自动化 Excel，通过宏从 Excel 调用 Python，并编写用户定义的函数（UDF 仅适用于 Windows） // 2.openpyxl 库官网：https://openpyxl.readthedocs.io 特点：openpyxl 是一个用于读取 / 编写 Excel 2010 xlsx/xlsm/xltx/xltm 文件的 Python 库。它是由于缺乏从 Python 中读取 / 编写 Office Open XML 格式的现有库而诞生的。 // 3.xlrd 库官网：https://pypi.python.org/pypi/xlrd 特点：在 python 中，xlrd 库是一个很常用的读取 excel 文件的库，其对 excel 文件的读取可以实现比较精细的控制。 // 4.xlwt 库官网：https://pypi.org/project/xlwt/ 特点：类比于 xlrd 的 reader，那么 xlwt 就相对于 writer，而且很纯正的一点就是它只能对 Excel 进行写操作。xlwt 和 xlrd 不光名字像，连很多函数和操作格式也是完全相同。 // 5.xlutils 库官网：https://pypi.org/project/xlutils/ 特点：xlutils（excel utilities）是一个提供了许多操作修改 excel 文件方法的库。xlutils 库也仅仅是通过复制一个副本进行操作后保存一个新文件，xlutils 库就像是 xlrd 库和 xlwt 库之间的一座桥梁，因此，xlutils 库是依赖于 xlrd 和 xlwt 两个库的。 // 6.xlsxwriter 库官网：https://xlsxwriter.readthedocs.io/ 特点：xlsxwriter 是用于创建 Excel XLSX 文件的 Python 模块，可用于将文本、数字、公式和超链接写入 Excel2007 + XLSX 文件中的多个工作表。它支持格式化等功能。可以说除了 Excel 本身，就属这个功能最齐全了。 // 7.pandas 库官网：https://www.pypandas.cn/docs/ 特点：pandas 是基于 NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。 // 8.Marmir 库官网：https://github.com/brianray/mm 特点：Marmir 采用 Python 数据结构并将其转换为电子表格。它是类固醇上的 xlwt 和 google 电子表格。目标是使用最少的配置轻松生成多种类型的有用表文件。 Python Word自动化库 // 9.python-docx 库官网：https://python-docx.readthedocs.io/en/latest/ 特点：python-docx 是一个用于创建和更新 Microsoft Word (.docx) 文件的 Python 库。快速开始、处理文档、处理文本、使用截面、使用页眉和页脚、API基础理、解样式、使用样式理解图片和其他形状。只对 windows 平台有效。 // 10.textract 库官网：https://gitee.com/mirrors/textract 特点：它同时兼顾 “doc” 和 “docx”，但安装过程需要一些依赖。你可以批量的用 python 生成 word 文件，推荐使用 docx，不需要会太多。 Python PPT自动化库 // 11.python-pptx 库官网：https://python-pptx.readthedocs.io 特点：python-pptx 是一个用于创建和更新 PowerPoint (.pptx) 文件的 Python 库。典型用途是从数据库内容生成自定义 PowerPoint 演示文稿，可通过单击 Web 应用程序中的链接下载。 Python ODF自动化库 // 12.Relatorio 库官网：https://pypi.org/project/relatorio/ 特点：Relatorio 是一个模板库，它提供了一种轻松输出多种文件（odt、ods、png、svg 等）的方法。通过为它们创建插件可以轻松添加对更多文件类型的支持。Relatorio 还提供了一个报告存储库，允许您将 python 对象和报告链接在一起，按 mimetype/name/python 对象查找报告。ODF：开放文档格式（外文名：OpenDocument Format，外语简称：ODF）是一种规范，基于 XML（标准通用标记语言的子集）的文件格式，因应试算表、图表、演示稿和文字处理文件等电子文件而设置。 Python PDF自动化库 // 13.PyPDF2 库官网：https://github.com/mstamy2/PyPDF2 特点：PyPDF2 是一个纯 Python PDF 库，能够拆分、合并、裁剪和转换 PDF 文件的页面。它还可以向 PDF 文件添加自定义数据、查看选项和密码。它可以从 PDF 中检索文本和元数据，也可以将整个文件合并在一起。 // 14.ReportLab 库官网：https://www.reportlab.com/opensource/ 特点：ReportLab 是久经考验、超强大的开源引擎，用于创建复杂的、数据驱动的 PDF 文档和自定义矢量图形。它是免费的、开源的，并且是用 Python 编写的。 // 15.PDFminer 库官网：https://github.com/euske/pdfminer 特点：PDFMiner 是一款用于 PDF 文档的文本提取工具。 Python 邮件自动化库 // 16.Django Celery SES 库官网：https://github.com/StreetVoice/django-celery-ses 特点：这个包提供了一个 EmailBackend 来利用 django-celery 发送电子邮件。您可以将 EmailBackend 插入您的项目中，而无需对代码进行任何修改。 // 17.Envelopes 库官网：http://tomekwojcik.github.io/envelopes/ 特点：Envelopes 是 Python 的电子邮件和 smtplib 模块的包装器。它旨在使在 Python 中处理外发电子邮件变得简单而有趣。 // 18.Flanker 库官网：https://github.com/mailgun/flanker 特点：由 mailgun 开源的 Flanker - email address and MIME parsing for Python 是一个解析高效、容错率不错的 python 第三方扩展库。python 3 也可以正常使用，该库包含了邮件地址解析和邮件 mime 格式解析。 // 19.imbox 库官网：https://github.com/martinrusev/imbox 特点：用于读取 IMAP 邮箱并将电子邮件内容转换为机器可读数据的 Python 库 // 20.inbox.py 库官网：https://github.com/billzhong/inbox.py 特点：这是您见过的最简单的 SMTP 服务器。它是异步的。一个实例每秒应该处理一千多封电子邮件。 // 21.sync-engine 库官网：https://github.com/nylas/sync-engine 特点：Nylas 同步引擎在强大的电子邮件同步平台之上提供了一个 RESTful API，可以轻松地在电子邮件之上构建应用程序。 // 22.Lamson 库官网：https://github.com/zedshaw/lamson 特点：Lamson 是一个纯 Python SMTP 服务器，旨在以现代 Web 框架（如 Django）的风格创建强大而复杂的邮件应用程序。 // 23.Marrow Mailer 库官网：https://github.com/marrow/mailer 特点：Marrow Mailer 是一个 Python 库，可以轻松地从您的应用程序发送电子邮件。通过使用 Marrow Mailer，您可以：轻松构建纯文本和 HTML 电子邮件；提高电子邮件传递的可测试性；使用不同的邮件投递管理策略；例如立即，延迟，甚至多服务器等。 // 24.Modoboa 库官网：https://github.com/modoboa/modoboa 特点：Modoboa 是一个邮件托管和管理平台，包括一个现代和简化的 Web 用户界面。它提供了有用的组件，例如管理面板或网络邮件。 // 25.smtplib 库官网：https://docs.python.org/zh-cn/3/library/smtplib.html 特点：smtplib 模块是 python 中 smtp (简单邮件传输协议) 的客户端实现。我们可以使用 smtplib 模块，轻松的发送电子邮件。 Python 文件处理自动化库 // 27.os 库官网：https://docs.python.org/zh-cn/3/library/os.html?highlight=os#module-os 特点：本模块提供了一种使用与操作系统相关的功能的便捷式途径。如果你只是想读写一个文件，请参阅 open()，如果你想操作文件路径，请参阅 os.path 模块，如果你想读取通过命令行给出的所有文件中的所有行，请参阅 fileinput 模块。为了创建临时文件和目录，请参阅 tempfile 模块，对于高级文件和目录处理，请参阅 shutil 模块。 Python 综合功能自动化库 // 28.win32com 库官网：https://pypi.org/project/pywin32/ 特点：win32com 模块主要为 Python 提供调用 windows 底层组件对 word 、Excel、PPT 等进行操作的功能，只能在 Windows 环境下使用，并且需要安装 office 相关软件才行（WPS 也行）。 // 29.unoconv 库官网：https://github.com/unoconv/unoconv 特点：是一个命令行工具，可以将 LibreOffice 可以导入的任何文档格式转换为 LibreOffice 可以导出的任何文档格式。它利用 LibreOffice 的 UNO 绑定进行文档的非交互式转换，也支持 OpenOffice。 // 30.Tablib 库官网：https://www.osgeo.cn/tablib/ 特点：Python tablib 模块是第三方模块，主要作用是将数据导出为各种不同的格式，包括 excel，json，html，yaml，csv，tsv 等格式，怎么样，有点心动了吧，当然这个模块使用起来也是超级简单的。 // 31.SnowNLP 库官网：https://github.com/isnowfy/snownlp 特点：SnowNLP 是一个 python 写的类库，可以方便的处理中文文本内容，是受到了 TextBlob 的启发而写的，由于现在大部分的自然语言处理库基本都是针对英文的，于是写了一个方便处理中文的类库，并且和 TextBlob 不同的是，这里没有用 NLTK，所有的算法都是自己实现的，并且自带了一些训练好的字典。注意本程序都是处理的 unicode 编码，所以使用时请自行 decode 成 unicode。 // 32.TextBlob 库官网：https://textblob.readthedocs.io 特点：TextBlob 是一个用于处理文本数据的 Python（2 和 3）库。它提供了一个简单的 API，用于深入研究常见的自然语言处理 (NLP) 任务，例如词性标注、名词短语提取、情感分析、分类、翻译等。 // 33.TextGrocery 库官网：https://textgrocery.readthedocs.io 特点：TextGrocery 是一个基于 LibLinear 和结巴分词的短文本分类工具，特点是高效易用，同时支持中文和英文语料。 // 34.NumPy 库官网：https://www.numpy.org.cn/ 特点：NumPy 是 Python 中科学计算的基础包。它是一个 Python 库，提供多维数组对象，各种派生对象（如掩码数组和矩阵），以及用于数组快速操作的各种 API，有包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数，基本统计运算和随机模拟等等。","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"https://wenkexia.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"markdown语法","slug":"markdown语法","date":"2022-01-09T03:24:32.000Z","updated":"2022-01-09T03:24:32.000Z","comments":true,"path":"2022/010947193.html","link":"","permalink":"https://wenkexia.github.io/2022/010947193.html","excerpt":"","text":"官方文档 概述Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。 Markdown 是 HTML 的一种简写，在显示时会『解压缩』成 HTML。理论上你可以在 Markdown 里直接插入合法的 HTML 块，他们会成为最终的 HTML 的一部分，做到 Markdown 本身做不到的事。Markdown 的格式可以由 CSS 描述 标题语法要创建标题，请在单词或短语前面添加# 。#的数量代表了标题的级别用一个空格在#和标题之间进行分隔。 强调语法粗体（Bold）加斜体（Italic） 要加粗文本，请在单词或短语的前后各添加三个星号（asterisks） 删除线删除线就是给文本加上删除线，在文本两端使用两个波浪线~ 1~~文本~~ 文本 引用语法要创建块引用，请在段落前添加一个&gt;符号。 列表语法要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 围栏代码块在代码块之前和之后的行上使用三个反引号（(```）或三个波浪号（~~~）。 在反引号后面加上语言的名字就可以享受到对应语言的语法高亮。 用反引号括起来，反引号是英文输入下，tab的上一个键 分隔线在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。为了兼容性，请在分隔线的前后均添加空白行 链接语法超链接Markdown语法代码：[超链接显示名](超链接地址 “超链接title”)使用尖括号可以很方便地把URL或者email地址变成可点击的链接。 转义字符语法要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 。 图片语法12![ddfdfd](图片链接 \"图片title\") 表格Markdown表格工具Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 hexo文章表格要与正文空两行才可以渲染 表格的对齐方式-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。 1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 任务列表任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。 Write the press release Update the website Contact the media使用 Emoji 表情复制使用https://emojipedia.org/ https://gist.github.com/rxaviers/7360908 工具vscode微信Markdown编辑器这个项目名doocs-md，在编写时，Markdown 文档自动即时渲染为微信图文，让你不再为微信文章排版而发愁！项目地址：https://github.com/doocs/md 在线体验地址： • Gitee Pages：https://doocs.gitee.io/md • GitHub Pages：https://doocs.github.io/md 功能特性• 支持自定义 CSS 样式 • 支持 Markdown 所有基础语法 • 支持浅色、暗黑两种主题模式 • 支持 Ctrl + F 快速格式化文档 • 支持色盘取色，快速替换文章整体色调 • 支持多图上传，可自定义配置图床 • 支持自定义上传逻辑 • 支持在编辑框右键弹出功能选项卡 • 支持批量转换本地图片为线上图片 使用 Docker 镜像docker run -d -p 8080:80 doocs/md:latest容器运行起来之后，打开浏览器，访问 http://localhost:8080 即可。 使用 npm cli通过我们的 npm cli 你可以轻易搭建属于自己的微信 Markdown 编辑器。 1234567891011121314# 安装npm i -g @doocs/md-cli# 启动md-cli# 访问open http://127.0.0.1:8800/md/# 启动并指定端口md-cli port=8899# 访问open http://127.0.0.1:8899/md/","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://wenkexia.github.io/tags/markdown/"}]},{"title":"vscode使用","slug":"vscode使用","date":"2022-01-09T03:18:05.000Z","updated":"2022-01-09T03:18:05.000Z","comments":true,"path":"2022/01093653.html","link":"","permalink":"https://wenkexia.github.io/2022/01093653.html","excerpt":"","text":"vscode快捷键F1 或 Ctrl+Shift+P（俗称万能键） ：打开命令面板 编辑器与窗口管理新建文件: Ctrl+N 文件之间切换: Ctrl+Tab 打开一个新的VS Code编辑器: Ctrl+Shift+N 关闭当前窗口: Ctrl+W 关闭当前的VS Code编辑器: Ctrl+Shift+W 切出一个新的编辑器窗口(分屏–最多3个): Ctrl+\\ 切换左中右3个编辑器窗口的快捷键: Ctrl+1 Ctrl+2 Ctrl+3 格式调整代码行向左或向右缩进: Ctrl+[ 、 Ctrl+] 复制或剪切当前行/当前选中内容: Ctrl+C 、 Ctrl+V 代码格式化: Shift+Alt+F 向上或向下移动一行: Alt+Up 或 Alt+Down 向上或向下复制一行: Shift+Alt+上键 或 Shift+Alt+下键 在当前行下方插入一行: Ctrl+Enter 在当前行上方插入一行: Ctrl+Shift+Enter 光标相关移动到行首: Home 移动到行尾: End 移动到文件结尾: Ctrl+End 移动到文件开头: Ctrl+Home 移动到定义处: F12 查看定义处缩略图(只看一眼而不跳转过去): Alt+F12 选择从光标到行尾的内容: Shift+End 选择从光标到行首的内容： Shift+Home 删除光标右侧的所有内容(当前行): Ctrl+Delete 扩展/缩小选取范围： Shift+Alt+Right 和 Shift+Alt+Left 多行编辑(列编辑): Alt+Shift+鼠标左键 或 Ctrl+Alt+Down/Up 同时选中所有匹配编辑(与当前行或选定内容匹配): Ctrl+Shift+L 下一个匹配的也被选中: Ctrl+D 回退上一个光标操作: Ctrl+U 撤销上一步操作: Ctrl+Z 手动保存: Ctrl+S 重构代码找到所有的引用: Shift+F12 同时修改本文件中所有匹配的: Ctrl+F2 跳转到下一个 Error 或 Warning: 当有多个错误时可以按 F8 逐个跳转 查找替换查找: Ctrl+F 查找替换: Ctrl+H 显示相关全屏显示(再次按则恢复): F11 放大或缩小(以编辑器左上角为基准): Ctrl +/- 侧边栏显示或隐藏： Ctrl+B 显示资源管理器(光标切到侧边栏中才有效): Ctrl+Shift+E 显示搜索(光标切到侧边栏中才有效): Ctrl+Shift+F 显示源代码管理(光标切到侧边栏中才有效): Ctrl+Shift+G+G 显示 Debug: Ctrl+Shift+D 显示 Output: Ctrl+Shift+U 插件推荐Beautify按下f1打开命令，搜索Beautify，点击Beautify file美化整个文件。代码被自动换行，也进行了格式化。这个美化操作支持多种格式的源代码。 匹配的括号着色Bracket Pair Colorizer：缩进带颜色Indent-Rainbow 会了吧打开源码可以自动分析所有包含的英语单词，并显示解释结果，还可以添加已经会的单词。 background加入设置的setting.json 12345678910111213141516171819 \"background.enabled\": true, \"background.useDefault\": false, \"background.customImages\": [ \"file:///E:/wenke_source/my picture/壁纸.jpg\" ], \"background.style\": { \"content\": \"''\", \"pointer-events\": \"none\", \"position\": \"absolute\", \"top\": \"0\", \"right\": \"0\", \"background-size\": \"cover\", \"opacity\": 0.1, \"z-index\": \"99999\", \"width\": \"100%\", \"height\": \"100%\", \"background-repeat\": \"no-repeat\",},\"bracketPairColorizer.depreciation-notice\": false 同步配置。Settings Sync 1.用Github账户登录2.创建一个新的GIST或选择存在的GIST3.上传配置按下 Shift + Alt + U 4.下载配置按下 Shift + Alt + D 美化文件图标Material Icon Theme： 实时预览图片Image Preview 路径补充Path Intellisense gitlensGitLens 增强了VS Code 中的 Git，并解锁了每个存储库中未开发的知识。它可以帮助您通过 Git 责备注释和 CodeLens直观地可视化代码作者身份，无缝导航和探索Git 存储库，通过丰富的可视化和强大的比较命令获得有价值的见解等等。 绘图工具vscode-drawio 展示数据结构形成过程debug-visualizer database-client支持MySQL/MariaDB, PostgreSQL, SQLite, Redis, ClickHouse, 达梦以及ElasticSearch的管理, 且可以作为一个SSH客户端, 最大程度地提高你的生产力! CodeTourCodeTour 允许我们为代码添加备注，并且将这些备注串联起来，动态地展示我们的思路以及代码逻辑。 小技巧1.查看函数或者类的定义Ctrl+鼠标左键点击函数名或者类名即可跳转到定义处，在函数名或者类名上按F12也可以实现同样功能 2.更改变量名在变量名上按F2即可实现重命名变量 4.添加注释注释有两种形式，单行注释和块注释(在js中，单行注释//,块注释/**/)单行注释&nbsp; Ctrl +/ 开发用户代码片段 snippets 语法原文 12345678910{ \"alpha\": { \"prefix\": [\"a\", \"z\"], \"body\": [ \"abcdefghijklmnopqrstuvwxyz\" ], \"description\": \"字母\", \"scope\": \"javascript\" }} prefix 是触发的前缀，可以指定多个body 是插入到编辑器中的内容，支持很多语法description 是描述scope 是生效的语言，不指定的话就是所有语言都生效 vscode代码片段生成器utools插件","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://wenkexia.github.io/tags/vscode/"}]},{"title":"python基础","slug":"python基础","date":"2022-01-08T14:30:18.000Z","updated":"2022-01-08T14:30:18.000Z","comments":true,"path":"2022/010834543.html","link":"","permalink":"https://wenkexia.github.io/2022/010834543.html","excerpt":"","text":"我的gittee中的python仓库 配置python开发环境Linux下配置pythonlinux安装ancondaAnaconda 是一个用于python/R科学计算和机器学习的开源工具(也称为Python的一种发行版)，支持 Linux, macOS, Windows, 包含了conda等众多工具包及其依赖项，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题 直接使用linux命令行下载 安装anaconda#首先安装wgetsudo apt-get install wget # Ubuntusudo yum install wget # CentOS #然后使用wget从清华源上下载Anaconda3-2021.05-Linux-x86_64.shwget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.05-Linux-x86_64.sh #安装Anaconda：sh Anaconda3-2021.05-Linux-x86_64.sh#查看许可时可输入q来退出 将conda加入环境变量加入环境变量是为了让系统能识别conda命令 #1.在终端中打开~/.bashrc：vim ~/.bashrc #2.在/.bashrc中将conda添加为环境变量：#先按i进入编辑模式在第一行输入：export PATH=”/anaconda3/bin:$PATH”#若安装时自定义了安装位置，则将~/anaconda3/bin改为自定义的安装目录下的bin文件夹 3.修改完成后，先按esc键退出编辑模式，再输入:wq!并回车，以保存退出 4.验证是否能识别conda命令： 在终端中输入source ~/.bash_profile以更新环境变量再在终端输入conda info --envs，若能显示当前有base环境，则conda已加入环境变量 Windows下安装Anaconda下载：https://docs.anaconda.com/anaconda/install/windows/ 环境变量123E:\\anacondaE:\\anaconda\\ScriptsE:\\anaconda\\Library\\bin 浏览器驱动放在D:\\ruanjian\\anaconda\\Scripts 管理虚拟环境virtualenvwrapper管理python虚拟环境window下安装并配置virtualenvwrapper由于 virtualenvwrapper 是 virtualenv 的一组扩展，所以如果要使用 virtualenvwrapper，就必须先安装 virtualenv。 123pip install virtualenvpip install virtualenvwrapper-win 默认创建的虚拟环境位于C:\\Users\\username\\envs,可以通过环境变量 WORKON_HOME 来定制。 通过计算机–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;在系统变量中新建“变量名”：WORKON_HOME,变量值：“你自定义的路径”。 Linux下安装并配置123pip install virtualenvwrapper # 安装find / -name virtualenvwrapper.sh #先find一下virtualenvwrapper.sh文件的位置 在~/.bashrc 文件新增配置 1234export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$HOME/workspaceexport VIRTUALENVWRAPPER_SCRIPT=/usr/bin/virtualenvwrapper.shsource /usr/bin/virtualenvwrapper.sh 通用命令12345678910111213141516171819202122232425262728293031323334353637383940414243# 列出所有的虚拟环境，两种方法workonlsvirtualenv#创建虚拟环境mkvirtualenv 虚拟环境名称 mkvirtualenv --python=D:\\Python\\python.exe test4 #指定python版本workon 虚拟环境名称 # 进入虚拟环境,进入后使用pip将安装在虚拟环境下deactivate # 退出虚拟环境# 在虚拟环境内直接切换到其他环境$ workon my_env02rmvirtualenv my_env01 # 删除虚拟环境# 列出帮助文档$ virtualenvwrapper# 拷贝虚拟环境$ cpvirtualenv ENVNAME [TARGETENVNAME]# 在所有的虚拟环境上执行命令$ allvirtualenv pip install -U pip# 删除当前环境的所有第三方包$ wipeenv# 进入到当前虚拟环境的目录$ cdsitepackages# 进入到当前虚拟环境的site-packages目录$ cdvirtualenv# 显示 site-packages 目录中的内容$ lssitepackages conda管理python虚拟环境conda 创建虚拟环境有个好处，它可以换python版本。如果你使用的virtualenv，它虽然也可以创建虚拟环境，但python版本无法换 下载anaconda安装的python直接可以使用conda工具 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 列出系统存在虚拟环境：conda env list# 创建虚拟环境conda create -n xxx python=3.9# 切换虚拟环境activate xxx #on windowssource activate xxx #on linux#conda 版本查看conda --version#更新conda：conda update conda#更新第三方所有包：conda upgrade --all#退出虚拟环境deactivate #on windowssource deactivate #on linux#删除虚拟环境conda remove --name xxx --all# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n xxx# 查找package信息conda search numpy# 安装packageconda install -n xxx numpy# 如果不用-n指定环境名称，则被安装在当前激活环境# 也可以通过-c指定通过某个channel安装# 更新packageconda update -n xxx numpy# 删除packageconda remove -n xxx numpy 添加清华源123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 说明 12345678#查看当前channelconda config --show#删除channel：conda config –remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free#增加channel：conda config ‐‐add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ venv自 3.6 版本之后，成为官方推荐的多环境管理工具。也就是说，你不需要安装任何第三方库就可以实现多环境管理了 优缺点分析：1、venv是python3自带的，不需要额外安装库就能运行。2、只能在3.3版本以后，2.x用不了3、venv过于简单，没有额外的api。只能创建个虚拟环境，不能指定系统不存在的python环境版本，不能查看环境列表。 1234567python3 -m venv D:\\ruanjian\\python #使用venv创建虚拟隔离环境：cd /data/myproj source ./bin/activate #激活虚拟环境:#退出虚拟环境：(myproj) [root@ops-130 myproj] deactivate Jupyter Notebook使用Anaconda已经自动为你安装了Jupter Notebook及其他工具 Jupyter Notebook是以网页的形式打开，可以在网页页面中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示的程序。如在编程过程中需要编写说明文档，可在同一个页面中直接,编写支持Markdown语法。 Jupyter Notebook中所有交互计算、编写说明文档、数学公式、图片以及其他富媒体形式的输入和输出，都是以文档的形式体现的。这些文档是保存为后缀名为.ipynb的JSON格式文件，不仅便于版本控制，也方便与他人共享。此外，文档还可以导出为：HTML、LaTeX、PDF等格式。 以富媒体格式展示计算结果。富媒体格式包括：HTML，LaTeX，PNG，SVG等。 支持使用LaTeX编写数学性说明。 命令模式编辑模式下按esc键进入命令模式。命令模式下，单元格边框为灰色，且左侧边框线为蓝色粗线条。 ctrl+回车 运行当前cell dd 删除当前cell y 切换cell类型为Code m 切换cell类型为Markdown b 下方插入cell 编辑模式命令模式下按enter或return键进入编辑模式。编辑模式下，单元格边框和左侧边框线均为绿色。 魔法命令加个‘！’就可以执行shell命令，可以直接在单元格内执行”!pwd”, “!ls” 等Linux里面的命令呢，但是windows环境中，要把”!”改成魔法命令“%”即可执行 单元格内执行shell命令还有一个高频操作就是安装需要的第三方库!pip install you-package==version %who会输出当前notebook中已经存在的变量 %whos除了输出变量外，变量的类型以及当前值也会显示 一个单元格多输出例如我们使用pandas读取一个文件生成dataframe后，想了解这个df的size, columns, 前5行等信息，正常情况下df.head, df.shape, df.info等内容要分成三个单元格来完成。但其实有更好的方法，可以让一个单元格内输出多个内容。具体方法是「增加一个单元格」执行下面两行代码即可： 1from IPython.core.interactiveshell import InteractiveShell InteractiveShell.ast_node_interactivity = \"all\" Mito插件官方文档Mito是Jupyter notebook的一个插件，作用是编辑电子表格，并在编辑表格（带格式转换功能）时，可以生成相对应的Python代码。 变量Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。 为多个变量赋值例如：a = b = c = 1为多个对象指定多个变量。例如：a, b, c = 1, 2, \"runoob\" 123456a = 3b = 10print(\"a = {}, b = {}\".format(a,b) )# 一行代码更换变量的值a,b= b,aprint(\"a = {}, b = {}\".format(a,b) ) 变量的作用域局部变量和全局变量局部变量：在一个函数中定义的变量就是局部变量（包括形参），其作用域是从定义局部变量的位置至函数结束的位置。全局变量：在所有函数外定义的变量就是全局变量，其在所有的函数中都能使用。 global关键字如果我们想要在一个函数中对全局变量进行修改，怎么办呢？这个时候就可以使用 global 关键字了。在函数体内定义，并且使用global关键字修饰后，该变量也就变为全局变量。在函数体外也可以访问到该变量，并且在函数体内还可以对其进行修改。 tip: 尽管Python允许全局变量和局部变量重名，但是在实际开发时，不建议这么做，因为这样容易让代码混乱，很难分清哪些是全局变量，哪些是局部变量。 nonlocal 关键字在 Python 中，函数的定义可以嵌套，即在一个函数中包含另一个函数的定义。通过 nonlocal 关键字，可以使内层的函数直接使用外层函数中定义的变量。 12345678910def outer(): x = 10 def inner(): nonlocal x x = 20 print('inner 函数中 x 的值为', x)#20 inner() print('outer 函数中 x 的值为', x) #20outer() 闭包闭包的定义：如果在一个内部函数里，对在外部函数内（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure) 函数嵌套/闭包中的作用域： 运算符Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，运算符的优先级指的是多个运算符同时出现时，先做什么运算然后再做什么运算。除了我们之前已经用过的赋值运算符和算术运算符，我们稍后会陆续讲到其他运算符的使用。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ | 按位异或，按位或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &amp;= ` = ^= &gt;&gt;= &lt;&lt;=` 算数运算符1236 // 4 = 1 #整除6 / 4 =1.5 说明： 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。 比较运算符比较运算符(关系运算符)，包括==、!=、&lt;、&gt;、&lt;=、&gt;=，比较运算符会产生布尔值，要么是True要么是False。 比较两个值是否相等用的是==，请注意这个地方是两个等号，因为=是赋值运算符，==才是比较相等的比较运算符。 12345# 一行中的多个比较0&lt;n&lt;100# 代替(n&gt;0)and (n&lt;100) 逻辑运算符逻辑运算符有三个，分别是and、or和not。 and字面意思是“而且”，所以and运算符会连接两个布尔值，如果两个布尔值都是True，那么运算的结果就是True；如果and左边的布尔值是False，不管右边的布尔值是什么，最终的结果都是False，所以在做运算的时候右边的值会被跳过（短路处理）即右边的表达式根本不会执行。 or字面意思是“或者”，如果两个布尔值有任意一个是True，那么最终的结果就是True。当然，or运算符也是有短路功能的，在它左边的布尔值为True的情况下，右边的表达式根本不会执行。 not运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值， 12345678910\"\"\"比较运算符和逻辑运算符的使用\"\"\"flag0 = 1 == 1 #Trueflag1 = 3 &gt; 2 # flag1 = Trueflag2 = 2 &lt; 1 # flag2 = Falseflag3 = flag1 and flag2 # flag3 = Falseflag4 = flag1 or flag2 # flag4 = Trueflag5 = not (1 != 2) # flag5 = False 说明：比较运算符的优先级高于赋值运算符，所以flag0 = 1 == 1先做1 == 1产生布尔值True，再将这个值赋值给变量flag0。 赋值运算符赋值运算符优先级最低，它的作用是将右边的值赋给左边的变量 12345678\"\"\"赋值运算符和复合赋值运算符\"\"\"a = 10b = 3a += b # 相当于：a = a + ba *= a + 2 # 相当于：a = a * (a + 2)print(a) # 算一下这里会输出什么 三目运算符（三元表达式）为真时的结果 if 判断条件 else 为假时的结果（注意，没有冒号） 1234567max = a if a &gt; b else b# 实现一个基础版本（递归版本）的斐波那契数列：def fn(n): return n if n &lt; 2 else fn(n-1)+fn(n-2) 序列123456789list() 将一个可迭代对象转换成列表tuple() 将一个可迭代对象转换成元组str() 将数据转化成字符串bytes() 把字符串转化成bytes类型reversed() 将一个序列翻转, 返回翻转序列的迭代器slice() 列表的切片random.choice() #可以从序列中获取一个随机元素； 迭代切片排序sorted(iterable, cmp=None, key=None, reverse=False) 函数对所有可迭代的对象进行排序操作。返回一个列表 参数： key是一个函数 拼接序列支持+和*操作，不修改原有序列，构建一个新的序列 生成器表达式迭代器迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 next()。 数据类型（8种）字符串string(不可变) Python 中单引号 ‘ 和双引号 “ 使用完全相同。 使用三引号(‘’’ 或 “””)可以指定一个多行字符串。 转义符 ,反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \\n” 则 \\n会显示，并不是换行。 字符串可以用 + 运算符连接在一起，用 * 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量[头下标:尾下标:步长] 123456789101112131415161718192021222324252627282930#字符串连接：+a = \"He-ll-o \"b = \"World \"print(a + b)print(a * 3) #重复输出字符串：*a=a.replace('-','') #用空字符串代替-#通过索引获取字符串中字符[]print(a[0])#字符串截取[:] 牢记：左闭右开print(a[1:4])#判断字符串中是否包含给定的字符: in, not inprint('e' in a)print('e' not in a)#join():以字符作为分隔符，将字符串中所有的元素合并为一个新的字符串new_str = '-'.join('Hello')H-e-l-l-o#转义字符 \\print(\"The \\t is a tab\")print('I\\'m going to the movies')#三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，保持一小块字符串的格式是所见即所得print('''I'm going to the movies''') 字符串驻留机制对相同字符串，只保留一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的相同字符串对应的变量 驻留机制的几种情况：字符串长度为0或1时符合标识符的字符串字符串只在编译时进行驻留，而非运行时[-5,256]之间的整数 优缺点当需要值相同的字符串时，可以直接从字符池里拿来用，避免频繁的创建和销毁，提升效率和节约内存 在需要进行字符串拼接时建议使用str类型的join方法，而非+，因为join()是先计算出所有字符中的长度，然后再拷贝，只new一次对象，效率更高 格式化字符串12345678910111213# 1.%做占位符name = \"wenke\"age =21print(\"我的名字是%s,年龄是%d\"%(name,age))# 2.{}做占位符 print(\"我的名字是{0},年龄是{1} \".format(name,age))# 3.f-stringprint(f'我的名字是{name},年龄是{age }') list（列表）List（列表） 是 Python 中使用最频繁的数据类型。类似于栈 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。 特点1.查找和插入的时间随着元素的增加而增加；2.占用空间小，浪费内存很少。 常用123456a = [1,1,1,2,2,3,6,56,3,2]b = set(a) #列表去重c = a[::-1] #反转列表 列表生成式1234567891011lst = [[0]*10 for t in range(k)] #输出一个k行10列的矩阵l=['H','Q']# 将一个列表中所有字符串变小写a = [s.lower() for s in l]# 生成扑克所有组合a =['黑桃','草花','红桃','方块']b=['A','1','2','3','4','5','6','7','8','9','10','J','K','Q']print([m+n for m in a for n in b ]) 列表的索引和截取和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。列表截取的语法格式如下：变量[头下标:尾下标] 用索引来访问list中每一个位置的元素 123 添加元素12list1.append('g') # 在末尾添加元素list1.insert(2, 'o') # 在指定位置添加元素，如果指定的下标不存在，就在末尾添加 常用函数12345678910111213lis1=['a','b','c','d']lis2=['1','2','3','4']len(lis) # 获得list元素的个数lis1.pop() # 删除list末尾的元素，删除指定位置的元素，用pop(索引)list1.extend(list2) #将list2合并到list1，list2不变 排序list.sort(cmp=None, key=None, reverse=False) [cmp] -- 可选参数, 如果指定了该参数会使用该参数的方法进行排序。 [key] 排序规则(排序函数), 在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数. 根据函数运算的结果进行排序。 [reverse] -- 排序规则，默认升序，True为降序 12345678910li = [[1, 7], [1, 5], [2, 4], [1, 1]]def fun(li): return li[1]# 传入了key参数的sort()函数对li中的每个子元素[1,7],[1,5],[2,4],[1,1]都执行了fun()函数，返回它们的第1个数# 分别为7,5,4,1。然后再排序得到1,4,5,7。使的出的结果对本来的li进行排序最后就得到了[[1,1],[2,4],[1,5],[1,7]]。# 指定第二个元素排序li.sort(key=fun)print(li) 列表转字符串join()语法格式：&lt;需要在每个元素中间添加的字符&gt; .join (&lt;目标list，且所有元素都为str类型&gt;) , 返回一个新的字符串。注意：此方法可以直接跟在return后。 123456a = ['j','1','ksk','lplps']print('***'.join(a))# 将列表内的每个元素组合成一个字符串print(''.join(a)) 字典(dict)使用键-值（key-value）存储 1.查找和插入的速度极快，不会随着key的增加而变慢；2.需要占用大量的内存，内存浪费多。但键必须是不可变的，如字符串，数字或元组。 常用12345678910111213141516171819202122232425262728293031323334dit[key] # 访问字典的值dit.get(key,default) #返回一个键值，若没有返回defaultdit[key]='' #修改字典的值dit[key]=value #添加键值del dict['key'] #删除某个键值# 删除del dit #删除整个字典dit.clear() #将字典置空dit.keys() #返回所有KEY的列表dit.values() #返回所有 valuel的列表dit.items() #返回所有键值对#同时迭代key和valuefor k,v in dit.items():#list可以转成字典，但前提是列表中元素都要成对出现lis=[('name','杨超越'),('weight',45)]dic = dict(lis)a = {'a':1,'b':2}b = {'c':3}c = {**a,**b} #合并两个字典 字典推导tuple（元组）与列表类似，元祖中的内容不可修改 1234567891011121314151617181920212223242526272829#元组中只有一个元素时，需要在后面加逗号！tuple3 = ('hello',)#元组不能修改，所以不存在往元组里加入元素,可将列表转换成元组list = [14, 10, 9, 15, 6, 10, 12, 5, 15, 8]t = tuple(list)#元组的修改：t1 = (1,2,3)+(4,5) #(1, 2, 3, 4, 5)t2 = (1,2) * 2 #(1, 2, 1, 2)#元组的一些函数：print(max(t))print(min(t))print(sum(t))print(len(t))#统计元组中4的个数print(t1.count(4))#元组中4所对应的下标，如果不存在，则会报错print(t.index(4))#判断元组中是否存在1这个元素print(4 in t)#返回元组中4所对应的下标,不会报错if(4 in t): print(t.index(4)) 元组的拆包与装包123456789101112131415161718#定义一个元组t3 = (1,2,3)#将元组赋值给变量a,b,ca,b,c = t3#打印a,b,cprint(a,b,c)#当元组中元素个数与变量个数不一致时#定义一个元组，包含5个元素t4 = (1,2,3,4,5)#将t4[0],t4[1]分别赋值给a,b;其余的元素装包后赋值给ca,b,*c = t4print(a,b,c)print(c)print(*c) number（数字）Number 数据类型用于存储数值，包括整数、浮点型、复数 int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。float (浮点数), 如 1.23、3E-2complex (复数), 如 1 + 2j、 1.1 + 2.2j 2 / 4 # 除法，得到一个浮点数0.52 // 4 # 除法，得到一个整数017 % 3 # 取余 22 ** 5 # 乘方 32 math 模块Python 中数学运算常用的函数基本都在 math 模块 1234567891011import mathprint(math.ceil(4.1)) #返回数字的上入整数print(math.floor(4.9)) #返回数字的下舍整数print(math.fabs(-10)) #返回数字的绝对值print(math.sqrt(9)) #返回数字的平方根print(math.exp(1)) #返回e的x次幂 Python随机数1234567import random#随机生成[0,1)的实数ran1 = random.random()#从指定范围内，按指定基数递增的集合中 获取一个随机数random.randrange ([start], stop, step]) set（集合）是一个无序不重复的序列,用于成员关系测试，删除重复元素a=set (‘abcd’) #与a={‘a’,’b’,’c’,’d’}等价 Boolean（布尔值）总结一下为假的情况有： None, False数值中的0, 0.0, 0j(虚数), Decimal(0), Fraction(0, 1)空字符串(‘’)、空元组(())、空列表([])空字典({})、空集合(set())对象默认为True，除非它有bool()方法且返回False或len()方法且返回0. 逻辑运算符|运算 |表达式 |结果||——|——-|—–||或运算 |x or y |两个变量只要有一个为True则为True。||与运算 |x and y| 两个变量都为True时结果才为True。||非运算 |not x| not的优先级比非布尔运算符低，not a == b解释为not (a == b)| 结构化函数内置函数进制转换bin() 将给的参数转换成二进制otc() 将给的参数转换成八进制hex() 将给的参数转换成十六进制 数学运算1234567abs() 返回绝对值round() 四舍五入pow(a, b) 求a的b次幂, 如果有三个参数. 则求完次幂后对第三个数取余sum() 求和min() 求最小值max() 求最大值divmod(20,3) # 求商和余数:(6,2) setset() 函数创建一个无序不重复元素集合，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等set([iterable])参数： iterable – 可迭代对象对象；返回值： 返回新的集合对象。 lambda表达式匿名函数lambda：是指一类无需定义函数名的函数，可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值。lambda 参数 : 表达式 12345lambda x:x# 第一个x，在冒号前，表示判断等效于 if x : ,后面则为返回x ,也可以对x进行操作if x ： return x 函数返回值函数使用return返回值，也可以使用lambda表达式作为函数的返回值 高阶函数接受函数为参数，或者把函数作为结果返回值的函数 map()python3中返回一个迭代器 装饰器装饰器函数的参数是一个函数，返回值也是一个函数。 特殊方法(双下方法)模块（module）任何py文件都可以作为一个模块。文件名就是模块名使用python模块大大提高了代码的可维护性和代码复用性,避免了函数名与变量名冲突。 if name == ‘main‘的意思是：当.py文件被直接运行时，if name == ‘main‘之下的代码块将被运行； 当.py文件以模块形式被导入时，if name == ‘main‘之下的代码块不被运行。 12345678910import somemodule #导入整个模块from somemodule import * #将某个模块中的全部函数导入 from somemodule import somefunction #从某个模块中导入某个函数from somemodule import firstfunc, secondfunc, thirdfunc #从某个模块中导入多个函数 包( package)在比較大型的项目中常常需要编写、用到大量的模块，此时我们可以使用包( Package)来管理这些模块。 里面装了一个_init_.Py文件的文件夹。这个模块的模块名不是__init__，而是这个包的名字，也就是装着__init__.py文件的文件夹的名字。它的作用是将一个文件夹变为一个Python模块 1.import 包名[.模块名[as别名] 2.from 包名 import 模块名[as别名] 3.from 包名.模块名 import成员名[as别名] 我们在导入包的时候，实际上是导入了它的 init.py文件文件。 一键安装依赖包#requirements.txt 用来记录项目所有的依赖包和版本号pip freeze &gt; requirements.txt #一次性安装 requirements.txt 里面所有的依赖包，pip install -r requirements.txt pip123456789101112131415pip 安装第三方库速度太慢,可设置 pip 从国内的镜像源下载安装阿里云 http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/豆瓣 http://pypi.douban.com/simple/清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/# 临时使用pip install -i https://pypi.tuna.tsinghua.edu.cn/simple xxxxxxx# 永久设置pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 面向对象定义类在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。 123456789101112131415161718class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print('%s正在学习%s.' % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_movie(self): if self.age &lt; 18: print('%s只能观看《熊出没》.' % self.name) else: print('%s正在观看岛国爱情大电影.' % self.name) 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。 创建和使用对象12345678910# 创建学生对象并指定姓名和年龄stu1 = Student('骆昊', 38)# 给对象发study消息stu1.study('Python程序设计')# 给对象发watch_av消息stu1.watch_movie()stu2 = Student('王大锤', 15)stu2.study('思想品德')stu2.watch_movie() 访问可见性在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头 1234567891011121314151617181920class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar')def main(): test = Test('hello') # AttributeError: 'Test' object has no attribute '__bar' test.__bar() # AttributeError: 'Test' object has no attribute '__foo' print(test.__foo)if __name__ == \"__main__\": main() 但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是”We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。 在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻 面向对象进阶@property装饰器之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') def __init__(self, name, age): self._name = name self._age = age # 访问器 - getter方法 @property def name(self): return self._name # 访问器 - getter方法 @property def age(self): return self._age # 修改器 - setter方法 @age.setter def age(self, age): self._age = age def play(self): if self._age &lt;= 16: print('%s正在玩飞行棋.' % self._name) else: print('%s正在玩斗地主.' % self._name)def main(): person = Person('王大锤', 12) person.play() person.age = 22 person.play() # person.name = '白元芳' # AttributeError: can't set attributeif __name__ == '__main__': main() __slots__魔法:Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 静态方法之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839from math import sqrtclass Triangle(object): def __init__(self, a, b, c): self._a = a self._b = b self._c = c @staticmethod def is_valid(a, b, c): return a + b &gt; c and b + c &gt; a and a + c &gt; b def perimeter(self): return self._a + self._b + self._c def area(self): half = self.perimeter() / 2 return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c))def main(): a, b, c = 3, 4, 5 # 静态方法和类方法都是通过给类发消息来调用的 if Triangle.is_valid(a, b, c): t = Triangle(a, b, c) print(t.perimeter()) # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数 # print(Triangle.perimeter(t)) print(t.area()) # print(Triangle.area(t)) else: print('无法构成三角形.')if __name__ == '__main__': main() 类方法和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445from time import time, localtime, sleepclass Clock(object): \"\"\"数字时钟\"\"\" def __init__(self, hour=0, minute=0, second=0): self._hour = hour self._minute = minute self._second = second @classmethod def now(cls): ctime = localtime(time()) return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec) def run(self): \"\"\"走字\"\"\" self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): \"\"\"显示时间\"\"\" return '%02d:%02d:%02d' % \\ (self._hour, self._minute, self._second)def main(): # 通过类方法创建对象并获取系统时间 clock = Clock.now() while True: print(clock.show()) sleep(1) clock.run()if __name__ == '__main__': main() 类之间的关系简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。 is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。 has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。 use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。 继承,重写与多态我们可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person(object): \"\"\"人\"\"\" def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): print('%s正在愉快的玩耍.' % self._name) def watch_av(self): if self._age &gt;= 18: print('%s正在观看爱情动作片.' % self._name) else: print('%s只能观看《熊出没》.' % self._name)class Student(Person): \"\"\"学生\"\"\" def __init__(self, name, age, grade): super().__init__(name, age) self._grade = grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade = grade def study(self, course): print('%s的%s正在学习%s.' % (self._grade, self._name, course))class Teacher(Person): \"\"\"老师\"\"\" def __init__(self, name, age, title): super().__init__(name, age) self._title = title @property def title(self): return self._title @title.setter def title(self, title): self._title = title def teach(self, course): print('%s%s正在讲%s.' % (self._name, self._title, course))def main(): stu = Student('王大锤', 15, '初三') stu.study('数学') stu.watch_av() t = Teacher('骆昊', 38, '砖家') t.teach('Python程序设计') t.watch_av()if __name__ == '__main__': main() 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。 12345678910111213141516171819202122232425262728293031323334353637from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta): \"\"\"宠物\"\"\" def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): \"\"\"发出声音\"\"\" passclass Dog(Pet): \"\"\"狗\"\"\" def make_voice(self): print('%s: 汪汪汪...' % self._nickname)class Cat(Pet): \"\"\"猫\"\"\" def make_voice(self): print('%s: 喵...喵...' % self._nickname)def main(): pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')] for pet in pets: pet.make_voice()if __name__ == '__main__': main() 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。 三个基本概念结构化（函数、模块、包）面向对象（类及派生类、重载）虚拟环境（版本管理、环境隔离）文件操作文本文件：存储的是普通“字符”文本，默认为unicode字符集，可以使用记本事程序打开 二进制文件：把数据内容用“字节”进行存储，无法用记事本打开，必须使用专用的软件打开，举例：mp3音频文件，jpg图片。doc文档等 打开文件with语句（上下文管理器）wth语句可以自动管理上下文资源，不论什么原因跳出with都能确保文件正确的关闭，以此来达到释放资源的目的 open(name[, mode[, buffering]])参数： name : 一个包含了你要访问的文件名称的字符串值。 mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 打开模式 描述 r: 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb: 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 r+: 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+: 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w: 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb: 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 w+: 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb+: 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a: 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab: 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+: 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+: 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 12with open('Hi.text', 'w') as f: f.write(\"Hello, there\") os库123456789import osimport os.path as opos.path.join()： #用于路径拼接 os.listdir(path) #返回指定路径下所有文件的列表。# 如果文件不存在，创建文件if not os.path.exists(folder_path): os.mkdir(folder_path) shutil 模块(拷贝、删除、移动、压缩和解压)shutil可以简单地理解为sh + util，shell工具的意思。shutil模块是对os模块的补充，主要针对文件的拷贝、删除、移动、压缩和解压操作。 1import shutil 拷贝文件shutil会自动识别拷贝的到底是文件还是文件夹, 如果存在同名的文件将会自动进行覆盖。 shutil.copy($file_path, $dir_path) 移动或重命名文件，但如果路径下已有重名的文件，将报错！shutil.move($file_path, $dir_path) # 移动到另外一个文件夹中shutil.move($file_path, $new_file_path) # 重命名为新的绝对路径 拷贝文件夹/删除文件夹shutil.copytree($file_path, $dir_path) # 拷贝所有文件到新的文件夹下，保持原有的文件结构。shutil.rmtree($dir_path) # 删除此路径的文件夹 生成压缩文件:shutil.make_archive(base_name, ‘gztar’, root_dir, [base_dir) base_name : 创建的目标文件名，包括路径，减去任何特定格式的扩展。 format : 压缩包格式。”zip”, “tar”, “bztar”或”gztar”中的一个。 root_dir : 需要打包的文件夹路径。打包完成时存储在上一级目录。 base_dir : 使用后会将base_dir作为路径，解压后有个有层级的文件夹，而仅非只有单独的打包内容。 解压文件:shutil.unpack_archive(filename[, extract_dir[, format]]) filename是压缩文档的完整路径 extract_dir是解压缩路径，默认为当前目录。 format是压缩格式。默认使用文件后缀名代码的压缩格式。”zip”, “tar”, “bztar”或”gztar”中的一个。 五大基本语句赋值语句标识符第一个字符必须是字母表中字母或下划线 _ 。标识符的其他的部分由字母、数字和下划线组成。标识符对大小写敏感。在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。 输入输出语句（print, input函数）格式化输出123print(\"{} {}\".format(\"hello\", \"world\") ) # 不设置指定位置，按默认顺序print(\"{1} {0} {1}\".format(\"hello\", \"world\")) # 设置指定位置 条件判断语句（if-elif-else语句）三目运算符（三元表达式）为真时的结果 if 判断条件 else 为假时的结果（注意，没有冒号） 123# 实现一个基础版本（递归版本）的斐波那契数列：def fn(n): return n if n &lt; 2 else fn(n-1)+fn(n-2) 循环语句遍历循环for-in-else range(1, 101)：可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。 range(1, 101, 2)：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。 range(100, 0, -2)：可以用来产生100到1的偶数，其中-2是步长，即每次数字递减的值。 for…else语句for…else 语句块可以被理解为当循环条件不满足时，我们来处理我们需要做的事，伪代码逻辑如下： 1234567for i in range(n): if condition: you_find_your_stuff() breakelse: you_did_not_find_your_stuff() 上述代码中，如果条件condition 满足，此时 break 运行，这个时候 else 代码块将不会执行。如果条件condition 不满足，此时else 代码块将会执行。 return语句return 语句会终止函数的执行，并且返回函数的值。return语句只能出现在函数体内 当函数体内的程序执行到return这一步时，会退出函数，即使是在一个循环体内，程序也不会再执行 条件循环while-else如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环。while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True则继续循环；表达式的值为False则结束循环。 123456789#无限循环while True:#while 循环使用 else 语句while (): passelse； pass break/continuebreak结束本层循环 异常处理语句(try-except-else-finally)算法递归思想使用辅助函数简化复杂表达式123456789101112131415def the_max(x, y): return x if x &gt; y else ya = int(input('a = '))b = int(input('b = '))c = int(input('c = '))print('The max is:', the_max(the_max(a, b), c))# 复杂the_max = a &gt; b and a or bthe_max = c &gt; the_max and c or the_maxprint('The max is:', the_max) IDE使用pycharm快捷键ctrl + alt + L ：一键格式化代码 代码模板PyCharm”→“File”→“Settings”→“Editor”→“File and Code Templates 123456789# -*- coding: utf-8 -*-\"\"\"@author: ${USER}@software: ${PRODUCT_NAME}@file: ${NAME}.py@time: ${DATE} ${TIME}\"\"\" vscode插件AI Doc write:ai帮你写注释只要选中函数代码，然后按一个快捷键就会自动生成该方法的注释，可用来生成函数文档， Sourcegraph你可以直接从 VS Code IDE 免费搜索数百万个开源存储库。从有用的代码示例中学习，搜索最佳实践，并从开源宇宙中数百万个存储库中重用代码。 Krinql如果你看不懂代码，可以让 Krinql 来回答，或者让它编写文档字符串： 用户代码片段12345678910111213141516171819202122232425{ \"python\":{ \"prefix\": \"!py\", \"body\": [ \"#!/usr/bin/env python3.8.8\", \"# -*- encoding: utf-8 -*-\", \"'''\", \"@File : $TM_FILENAME\", \"@Time : $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\", \"@Author : wenke \", \"@Version : 1.0\", \"@Contact : 1184664659@qq.com\", \"@WebSite : https://wenkexia.github.io\", \"@Desc : None\", \"'''\", \"\", \"if __name__ == '__main__':\", \"\", \"$0\" ], } }","categories":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/tags/python/"}]},{"title":"AutoJS","slug":"AutoJS","date":"2022-01-08T09:17:39.000Z","updated":"2022-01-08T09:17:39.000Z","comments":true,"path":"2022/010827358.html","link":"","permalink":"https://wenkexia.github.io/2022/010827358.html","excerpt":"","text":"介绍官方文档 史上最全的autojs代码仓库 Appium 和 Airtest 编写的自动化脚本都依赖于 PC 端运行，没有办法直接运行在移动端；无障碍服务需要单独创建一个 Android 项目，没有完整的使用文档，使用起来有一定的门槛 AutoJS 它通过编写 JavaScript 脚本，结合系统的「 无障碍服务 」对 App 进行自动化操作脚本文件体积小，可以打包成 APK 直接安装拥有丰富的 UI 组件用于构建 GUI 界面非 Root 设备也能完成自动化操作，可以摆脱 PC 直接运行提供多种元素定位方式，可以适配各种机型官方文档非常详细，学习成本低 Auto.JS作为一款基于JavaScript语言的一款脚本，基本语法和结构可通过学习JavaScript来了解。要知道，安卓的app界面就是由一堆控件组成的，这些父子控件相互嵌套，组成了我们熟悉的app界面，因此，你要执行自动化操作，那么最常用的就是先精确的找到这个控件(唯一性)，再来说下一步对其进行操作，而我个人认为Auto.JS之所以方便好用，最大的一点就是查找你想要操作的控件(包括但不限于点击、设置文本等)时特别方便明了，一眼就能看懂并能迅速定位。 比如，在Auto.JS悬浮窗点击[探测]按钮，选择[布局范围分析]之后Auto.JS会自动分析当前范围界面的控件组成，在分析探测完成后(图1.2)，可以点击[查看控件信息]来查看想要操作的控件的各种属性，控件最基本也最常见的属性有： 环境准备vscode插件Auto.js-VSCodeExt Auto.js-VSCodeExt-Fixed对插件 Auto.js-VSCodeExt 进行了部分优化 Autojs Clipboard同步手机剪贴板到电脑剪贴板 然后，使用 VS Code 快捷键「 Ctrl/Command + Shift + P 」，选择「 Auto.js:Start Server 」开启 AutoJS 服务 在同一wifi下无法连接，手机开热点给电脑，即可连接 scrcpy投屏Github地址 手机数据线连接电脑后，开启usb调试，自动连接 鼠标右键是返回 要想卸载scrcpy,先在目录下进入cmd,输入adb kill-server,再删除整个scrcpy文件即可 adb功能异常，重启adb（1）把adb服务杀死：adb kill-server（2）重启adb服务：adb reconnect 结合webditorautojs本身就有布局分析，但不一定所有手机都能用，使用weditor进行布局分析 weditor 地址 https://github.com/openatx/weditor 先把weditor安装好并运行起来。然后： .设备通过USB线连接电脑。在cmd命令行中输入adb tcpip 5555拔掉数据线在cmd命令行中输入adb connect 192.168.1.5(设备在局域网中的ip)在weditor 网页中输入手机的ip并且点击Connect连接 连接成功后，点击“Dump Hierarchy” 获取最新的界面。这里以微信为例，然后我们会看到布局分析，点击我们需要操作的控件，可以获取到resourceId、className、text等信息，然后我们运用autojs进行操作。 小技巧强制分配vivo手机有些应用无法分屏。【开发者模式】并点击进入；下拉页面，将【强制将活动设为可调整大小】开关打开；重启手机，重启后应用就支持强制分屏了。设置完后。先进入不能分屏的界面，然后上拉进入任务界面，点击另一个想要分屏应用的分屏按钮 快捷打开无障碍，长按两个音量键三秒 如何打开控制台依次点击 帮助—–切换开发者工具——console 问题查找控件存不存在使用exists ()。一般情况下Autojs生成的代码是：if (text(“刷视频赚”).exists()) {}，不建议这样写，有很多时候找不到或者是有多个文字一样的内容故：let earnVideo= className(“android.widget.TextView”).text(“刷视频赚”).findOnce();这样写准确率更高。 为什么有时候launchApp(‘应用名’);会失效第一,这是因为你手机存在同名软件.找不到你想要的app，要使用launch(‘应用包名’)。第二,是因为你没有给软件(后台弹出界面)权限 auto.waitFor();语句增加是非常必要的这个在你没有无障碍时候会提示你无障碍模式的开启。并且开启之后,会接着继续运行. AutoJs创建项目后打包成Apk后Apk无法运行。 AutoJs单文件打包成Apk说是风险Apk。这个问题现在已经比较好解决了.就是使用AUTO.JS Pro版本即可. https://mp.weixin.qq.com/s/nUgyBkn9kZYamnRuSkzMlg autojs提取软件自带例子通过mt管理器点击autojspro的安装包，然后点击查看，依次打开assets/sample/中文，这就是例子文件。然后长按文件夹解压到任意目录 如果没有mt管理器，可以直接将autojspro.apk的后缀改成.zip,当成压缩包来提取文件。 推送信息到微信12345678910111213141516171819// 通过息知推送信息到微信// https://xz.qqoq.net/#/index// 发送消息支持get,post两种方式// {key}填的是你在息知控制台的单点推送中获取到的let url = \"https://xizhi.qqoq.net/{key}.send?title=标题&amp;content=测试\";let r = http.get(url);log(r.body.string());// let url = \"https://xizhi.qqoq.net/{key}.send\";// let r = http.postJson(url, {// title: \"this is title\",// content: \"this is content\",// });// log(r.body.string()); 基于控件的操作 牢记最基础也是最核心的操作也就是如何确定要操作的控件(唯一性)，总结有以下三个方法基本可满足日常： depth-desc-id-classname等控件的常规的唯一属性 findone.parent().child(xx)等控件的父子依存顺序关系 最后实在无法确定可用坐标法bounds，click(x,y)操作控件 UiSelector.textContains(str)str {string} 要包含的字符串为当前选择器附加控件”text需要包含字符串str”的筛选条件。 UiSelector（选择器）用于通过各种条件选取屏幕上的控件，再对这些控件进行点击、长按等动作 通常用一个唯一的属性来定位一个控件 UiObjectUiObject表示一个控件，可以通过这个对象获取到控件的属性，也可以对控件进行点击、长按等操作。 获取一个UiObject通常通过选择器的findOne(), findOnce()等函数，也可以通过UiCollection来获取，或者通过UiObject.child(), UiObject.parent()等函数来获取一个控件的子控件或父控件。 1text(\"微信\").findOne() //返回的时一个控件对象，想要操作这个控件，其属性必须为true bounds()返回 Rect返回控件在屏幕上的范围，其值是一个Rect对象。 RectUiObject.bounds(), UiObject.boundsInParent()返回的对象。表示一个长方形(范围)。 Rect.centerX()返回 {number}长方形中点x坐标。 Rect.centerY()返回 {number}长方形中点y坐标。 控件属性className 类名。类名表示一个控件的类型，例如文本控件为”android.widget.TextView”, 图片控件为”android.widget.ImageView”等。 packageName 包名。包名表示控件所在的应用包名，例如QQ界面的控件的包名为”com.tencent.mobileqq”。 bounds 控件在屏幕上的范围。drawingOrder 控件在父控件的绘制顺序。indexInParent 控件在父控件的位置。clickable 控件是否可点击。longClickable 控件是否可长按。checkable 控件是否可勾选。checked 控件是否可已勾选。scrollable 控件是否可滑动。selected 控件是否已选择。editable 控件是否可编辑。visibleToUser 控件是否可见。enabled 控件是否已启用。depth 控件的布局深度。 对选取的控件进行操作click(text[, i])text {string} 要点击的文本i {number} 如果相同的文本在屏幕中出现多次，则i表示要点击第几个文本, i从0开始计算 click() 点击。点击一个控件，前提是这个控件的clickable属性为truelongClick() 长按。长按一个控件，前提是这个控件的longClickable属性为truesetText() 设置文本，用于编辑框控件设置文本。scrollForward();scrollBackward() 滑动。滑动一个控件(列表等), 前提是这个控件的scrollable属性为trueexits() 判断控件是否存在waitFor() 等待控件出现 //确保无障碍服务已启用。auto.waitFor() //直接提示你无障碍模式的开启。 click(text[, i])text {string} 要点击的文本i {number} 如果相同的文本在屏幕中出现多次，则i表示要点击第几个文本, i从0开始计算while(!click(\"扫一扫\")); 基于控件属性确定控件通过查看这些属性，我们不难发现有其中一项属性desc(“更多选项”)，很可能是不和其他控件相同的，也就是此控件属性具有唯一性，能唯一的确定此控件，这个属性就是我们要找的。因此，我们想要对其进行操作只需要： 12345if(desc(\"更多选项\").exists()){ sleep(1000); desc(\"更多选项\").findonce().click(); } 上述代码执行后，在该界面时，desc(“更多选项”)首先会被查找(findonce)，查找后执行点击(click)，从而【⋮】按钮也就被点击了。总结下无非就是我们找到了此按钮的唯一控件属性desc(“更多选项”)从而再对其操作，仅此而已。 另外，加上“.exist()”是为了增加程序鲁棒性，万一控件不存在或者没找到，则程序不会执行，否则对不存在(或没找到)的控件操作会抛出异常。基于此，往往要判定控件存在与否后再进行操作，而“.exist()”返回的是一个布尔值，方便后续进行判断和操作。另外一个常用的操作就是加上“while(!)”死循环等待控件出现，如： 12345678910//当\"更多选项\"不存在等价于此按钮还没出现while(!desc(\"更多选项\").exists()){ //继续循环等待，直到按钮出现 sleep(1000);} //执行到这里说明\"更多选项\"存在了，对该按钮执行点击操作desc(\"更多选项\").findonce().click();return; 当分析了很多控件后不难发现，控件的文本信息往往是以desc或text属性来呈现的，比如一个该按钮名为”更多选项”，其控件的desc属性或text属性就是其按钮名字，确定其名字也就确定了此控件，针对此按钮具体来说，就是其desc属性是”更多选项”。（此处要说的意思就是要具体问题具体分析，文本信息不是desc就是text，如果是desc属性就操作desc，是text属性就操作text）但是，往往就有时候我们只知道包含的部分desc或text，这时候可用这四个函数来确定： 1234567891011//descContains即desc包含部分信息即可匹配if(descContains(\"选项\").exists()){ //需要执行的操作} //descStartsWith即desc以此信息开头即可匹配if(descStartsWith(\"更多\").exists()){ //需要执行的操作} 同理，text也有对应的两个函数,比如一个按钮text属性为(“我的学习积分”)/ 1234567891011//textContains即text包含部分信息即可匹配if(textContains(\"学习积分\").exists()){ //需要执行的操作} //textStartsWith即text以此信息开头即可匹配if(textStartsWith(\"我的\").exists()){ //需要执行的操作} 当然，更多情况是desc和text属性并不能唯一确定要操作的控件，我们往往用其他属性(常用的有className、id、depth等)一起叠加使用来尽可能的使之唯一，比如： 123//往往是诸多控件属性一起才可唯一确定待操作的控件var myObject = className(“XXX”).depth(xx).id(“XXX”).text(“XXX”).findone();myObject.click(); 需要注意的是：在不同的Android系统上，同一版本的app的控件属性可能会变化。同样，app版本更新后，控件属性、布局也可能发生变化，所以，若要对不同版本不同系统具有兼容性，应尽可能选择不变化的控件属性。 基于控件父子关系确定控件有时候，控件属性是变化的、随机的，这时候我们便不能通过控件的本身固有属性如id，className，depth等来唯一的确定出需要的控件，这时候我们可以通过控件之间的上下级关系(也叫父子关系)来确定出需要操作的控件。 首先需要了解的是控件间的依存关系，还是以之前的app界面为例，我们这次来分析右下角的的“+”号按钮，和之前一样利用Auto.JS分析控件布局，我们点击右下角的“+”号按钮，点击[在布局层次中查看]，便可以查看当前控件在整个布局层次中的上下级关系(父子关系)，如图1.6所示，不难发现，从上到下，左侧五颜六色的竖棍丨就代表着其层级关系，竖棍丨越多也就越处于底层，该“+”号按钮控件名为“ImageButton”，对应着拥有8根竖棍丨，所以其是在第八级。 另外，和“ImageButton”平级的控件是图1.6所示的8.2—“ImageView”控件，“ImageButton”的父控件也就是它的上级控件是图1.6所示的7.3—“android.view.View”控件，所以我们可以建立以下关系： 123456789101112138.1中“ImageButton”的parent() = 7.3中“android.view.View”7.3中“android.view.View”的child(0) = 8.1中“ImageButton”7.3中“android.view.View”的child(1) = 8.2中“ImageView”7.3中“android.view.View”的parent() = 6中“android.view.View”6中“android.view.View”的child(0) = 7.1中“LinearLayout”6中“android.view.View”的child(1) = 7.2中“android.view.View”6中“android.view.View”的child(2) = 7.3中“android.view.View” 建立了以上隶属关系，我们就可以通过唯一确定任意其中一个不变的固定控件，便可通过控件间的隶属关系来确定我们想要的控件，从而规避了我们要找的控件属性动态变化这一情况。 在这里，我们假定以之前右上角的【⋮】按钮为固定控件(因为”更多选项”这几个字基本不会变化)，通过【⋮】按钮来和控件间的父子关系来确定出右下角的“+”号按钮。 首先分析右上角的【⋮】按钮的层级关系，如图1.7所示，【⋮】按钮位于第10级，它的父级parent是图1.7所示的9.3—“android.support.v7.widget.LinearLayoutCompat”，9.3的父级是8—“android.view.View”,以此类推，发现我们想要操作的控件也就是“ImageButton”控件(8.1)和右上角的【⋮】按钮即“ImageView”控件(10)关系是： 12345“ImageView”控件(10)是从7.1—“LinearLayout”继承下来的；“ImageButton”控件(8.1)是从7.3—“android.view.View”继承下来的； 而7.1和7.3是平级关系，拥有共同的父级6—“android.view.View” 图1.7 控件的布局层次分析2 明白了这一点，我们便可通过【⋮】按钮(10)来确定右下角的“+”号按钮(8.1)，如下所示： 1234567891011121314151617181920//首先，通过desc属性确定出【⋮】按钮(图1.7所示的10)//属性.findone()首先找到一个控件，再在此基础上加.parent等var moreButton = desc(\"更多选项\").findone(); //其次，找到【⋮】按钮和右下角“+”号按钮共同的父级parent//在这里是一层层往上找是为了方便理解，实际操作可一步到位var 9_3Supportv7 = moreButton.parent(); //找到图1.7所示的9.3控件var 8viewView = moreButton.parent().parent(); //找到图1.7所示的8控件var 7_1LinearLayout = moreButton.parent().parent().parent(); //找到图1.7所示的7.1控件var 6viewView = moreButton.parent().parent().parent().parent(); //找到图1.7所示的6控件 //最后，通过共同的父级parent找到右下角“+”号按钮//在这里是一层层往下找是为了方便理解，实际操作可一步到位var 7_3viewView = 6viewView.child(2); //找到图1.7所示的7.3控件var plusButton = 6viewView.child(2).child(0); //找到图1.7所示的8.1控件（也就是+号按钮） //所以，如果一步到位，总结如下：var plusButton = moreButton.parent().parent().parent().parent().child(2).child(0);//再对+号按钮进行点击plusButton.click(); 此处例子里的的两个控件【⋮】按钮(10)和右下角的“+”号按钮(8.1)之间相差了很多层，因此显着有些复杂，在实际情况中，我们往往不需要跨越这么多的层级来确定控件，一般情况下不会那么复杂。实际上，父子关系嵌套两三层往往即可确定出另一控件。最后，在这里需要注意的是，确定控件时要加上“.findone()”，此方法调用后会返回所有符合条件的控件集合。因此，首先要找到一个不容易变化的或容易找的控件“.findone()”后再在此基础上进行“.parent()”“.child(index)”操作找到另一控件。 基于坐标来确定控件如果一个控件本身无法通过click()点击，那么我们可以利用bounds()函数获取其坐标，再利用坐标点击。总体来说，基于坐标来确定要操作的控件比较简单，核心是确定要操作的控件的坐标即可。Auto.JS里可以直接获取控件的坐标，每一个控件包含其“.bounds()”属性，bounds()其实表示的是一个范围矩阵。此处还是以右下角的“+”号按钮为例，查看控件属性信息，包含“.bounds()”属性如下图： 从上图看，bounds()属性是四个坐标值，其分别为(left, top, right, buttom)，各值含义如图1.9所示： 1234567left：控件左边缘与屏幕左边的距离top：控件上边缘与屏幕上边的距离right：控件右边缘与屏幕左边的距离buttom ： 控件下边缘与屏幕上边的距离 因此，在获得控件的坐标bounds()属性后，就可以对控件执行基于坐标的操作，常见的操作有： 12345678910111213141516171819bounds().left：长方形左边界的x坐标bounds().right：长方形右边界的x坐标bounds().top：长方形上边界的y坐标bounds().bottom：长方形下边界的y坐标bounds().centerX()：长方形中点x坐标bounds().centerY()：长方形中点y坐标bounds().width()：长方形宽度也就是控件宽度bounds().height()：长方形高度也就是控件高度click(x,y)：坐标(x,y)处执行点击操作 //注意:安卓7以下点击需要root权限且函数为Tap(x,y)bounds(left, right, top, bottom).clickable().click()：点击该长方形区域 另外，因为不同设备的分辨率大小是不同的，那么我们click(x,y)在不同分辨率下就会出错，Auto.JS针对这一问题内置了一个函数”setScreenMetrics(width, height)”，具体用法如下： //设置在特定屏幕分辨率下要点击的坐标值(x,y) setScreenMetrics(1080, 1920); //声明是基于分辨率1080，1920的点击 click(800, 200); //分辨率1080，1920下点击(800，200) longClick(300, 500); //分辨率1080，1920下长点击(300，500) 当我们使用540，960分辨率的设备（x，y各缩小了一半）后执行上述代码时，他会自动计算缩放的比例，从而实际点击的是坐标(400，100)和（150，250）这两个坐标值。 当然，基于坐标的操作不仅有click()操作，常用的还有swipe()滑动操作，gesture()手势滑动操作等，具体可查看官方文档，在这里仅对swipe()，gesture()这两个函数进行介绍。 swipe(x1,y1,x2,y2,time)：(x1,y1)代表起始点坐标，(x2,y2)代表终点坐标，time代表滑动所需要的时间 //注意：安卓7以下的滑动需要root权限，且函数名变为Swipe(x1,y1,x2,y2,time) gesture(time,[x1,y1],[x2,y2],[x3,y3]…)：time同，(x1,y1)是起始点坐标，(x2,y2)是途径点坐标，最后一个坐标是终点 下面以一个某APP注册时的滑动验证为例(为防止被人恶意利用，在此打上码。再次声明，此处做仅举例用，所有代码仅供学习交流！)，如图2.0所示，当我们输入手机号点击注册时，此时需要将滑块拖动到指定位置处才可以发送验证码从而进行下一步的注册。在这里，我们将想要拖动的滑块称为控件①，想要拖到的目标处称为控件②。那么，如果想要实现一个自动化拖动首先就要确定的是控件①和控件②的坐标，又因为其坐标每次都是随机的，所以只需要根据两个控件的特有属性唯一确定出控件①和控件②，再每次获取其坐标即可。 通过对两个控件的属性分析，如图2.1所示，我们不难发现，控件①和控件②的indexInParent()不同，因此可通过此分别唯一的定位出两个控件，确定控件后，我们再调用swipe()或gesture()函数来执行滑动，从而实现自动滑动的操作。 图2.1 两个控件属性对比 具体实现代码如下： 1234567891011121314151617181920212223242526272829303132//首先判断是否进入了\"滑动验证\"界面if(text(\"滑动验证\").exists()){ sleep(2000); //判断控件1是否存在 if(className(\"android.widget.Button\").depth(8).indexInParent(1).exists()) { //控件1存在，获取其坐标bounds()属性 var Button1 = className(\"android.widget.Button\").depth(8).indexInParent(1).findOne().bounds(); sleep(500); console.log(\"Button1的坐标为:\"+ Button1); } //判断控件2是否存在 if(className(\"android.widget.Button\").depth(8).indexInParent(3).exists()) { var Button2 = className(\"android.widget.Button\").depth(8).indexInParent(3).findOne().bounds(); sleep(500); console.log(\"Button2的坐标为:\"+ Button2); } //两个控件的坐标都获取到后，执行swipe或gesture操作 sleep(2000); //swipe(x1,y1,x2,y2,[time]) swipe(Button1.left, Button1.top, Button2.left, Button2.top, [random(500,1200)]); sleep(2000); //gesture(time,[x1,y1],[x2,y2]) console.log(\"Swipe完成！\"); gesture(random(500,1200), [Button1.left, Button1.top], [Button2.left, Button2.top]); console.log(\"gesture完成！\"); //结束} 其他的一些方法和函数使用click函数我们可以对坐标进行点击，也可以对控件进行点击，最后也可以对某些特定字符点击，总结如下： 根据控件属性唯一确定出控件后，再对控件进行点击click操作 123desc(\"更多选项\").depth(9).findone().click();text(\"注册\").click(); 根据坐标来实现基于坐标的点击 12setScreenMetrics(1080, 1920); //声明是基于分辨率1080，1920的点击click(800, 200); //分辨率1080，1920下点击(800，200) 有时候控件可能是个Image或是不可点击的(clickable=false)，这时我们可以对屏幕进行点击 123click(\"2020-07-15\"); //点击\"2020-07-15\"click(\"2020-07-15\",0); //点击第一个\"2020-07-15\"click(\"str\",index); //点击第index个字符\"str\"(因为有时str会出现多次，另外注意下标从0开始) 查找函数find/findone/findonce 之前说过，根据我们设定的一些属性，我们可以对屏幕上的控件进行搜索和查找，并返回符合条件的控件。因此，想要对返回的控件进行下一步操作的前提是必须要“.findone()”，如前面所述，要想从父子关系查找关联控件必须先“.findone().parent()”,再比如要想获取控件的坐标矩阵也必须“.findone().bounds()”。三个搜索函数“.find()” “.findone()” “.findonce()”在使用上是有点差别的，具体如下 find()函数会找出所有满足条件的控件并返回一个控件集合,之后可以对控件集合进行操作 var findAssemble = textContains(“2020-07-15”).find(); //找到所有包含”2020-07-15”的控件集合findAssemble findone()函数会对屏幕上的控件进行搜索，直到屏幕上出现满足条件的一个控件为止，并返回该控件 如果找不到控件，当屏幕内容发生变化时会重新寻找，直至找到注意：如果findone不加限制时间且屏幕上一直没有出现所描述的控件，则该函数会阻塞，直到找到为止 12var findoneAssem1 = textContains(\"2020-07-15\").findone(); //找到一个包含\"2020-07-15\"的控件findoneAssem1var findoneAssem2 = textContains(\"2020-07-15\").findone(500); //在500毫秒内找到一个包含\"2020-07-15\"的控件findoneAssem，若找不到，终止搜索返回null findonce(i)函数会根据当前所确定的筛选条件，对屏幕上的控件进行搜索，并返回第 i + 1 个符合条件的控件 如果没有找到符合条件的控件，或者符合条件的控件个数 &lt; i, 则返回null 12var findonce1 = textContains(\"2020-07-15\").findonce(0); //搜索第一个包含\"2020-07-15\"的控件findonce1var findonce2 = textContains(\"2020-07-15\").findonce(1); //搜索第二个包含\"2020-07-15\"的控件findonce2 上下滑动和翻页 Auto.JS上下滑动可以是对整个屏幕的滑动或对某特定控件的滑动，对整个屏幕滑动如下例2.3.1所示 例2.3.1： 123456789//滑动函数swipe(x1,y1,x2,y2,time)var h=device.height; //屏幕高var w=device.width; //屏幕宽var x=(w/3)*2; //横坐标2分之3处var h1=(h/6)*5; //纵坐标6分之5处var h2=(h/6); //纵坐标6分之1处 swipe(x, h1, x, h2, 500); //向下翻页(从纵坐标6分之5处拖到纵坐标6分之1处)swipe(x, h2, x, h1, 500); //向上翻页(从纵坐标6分之1处拖到纵坐标6分之5处) 在很多时候，我们经常会见到className名为“.ListView”的控件，实际上其往往是充当装在很多list的集合，以此控件为例，我们可以实现对此控件的上下滑动，如下例2.3.2所示： 例2.3.2： 12345//scrollForward()函数会对控件执行向前滑动的操作，并返回是否操作成功//scrollBackward()函数会对控件执行向后滑动的操作，并返回是否操作成功var listView = ClassName(“ListView”).id(XXX).findone();ListView.scrollForward(); //向前滑动ListView.scrollBackward(); //向后滑动 在此只是以“.ListView”的控件进行举例，实际使用过程中，只要控件是可上下滑动的，都可以调用函数“scrollForward()”和“scrollBackward()”来实现对控件的滑动操作。 其他通用函数和全局函数 因为Auto.JS是基于JavaScript的语言，因此基本的语法结构、很多两者通用的函数等都是可以在JavaScript里面找到，如常见的“.replace()”“.indexof()”“.test()”等这些都在JavaScript网站上有相关的用法说明。可见：JavaScript学习 另外，Auto.JS的一些全局函数如启动程序函数“launch(“XXX”)”，控制台的函数如“console.show()”、“console.log()”等，再如返回函数“back()”，随机函数“random(start,end)”等这些都可在官方的提取文档里找到。可见：Auto.JS官方提取文档 控件找不到的情况调用UiSelector中的函数返回的是一个控件或null，该控件可以使用UiObject中的函数获取相应属性值，一定要先选择控件（findOne()等..）再使用UiObject中的函数； UISelector在选择的时候，有些界面外的控件也可以选中； 有些控件是不可点击的，可以尝试寻找其父类，其祖父，其祖祖父，其祖祖祖祖祖祖祖祖祖祖父.parent()*n进行点击。 建议使用scollBackward、scollForward进行控件的翻页操作，笔者使用scollUp、scollDown时无效。 免root手机的三种模拟滑动方式开发者模式的指针位置P: X / Y P就是 pointers ; x 是 current number pointers, y 是 max number pointers ，这些都是指在一个完整gesture中的。也就是，当同时用三手指触摸时x=y=3，而当只抬起一根手指时，当前屏幕上只有两根手指了，但是整个手势事件中最大pointers数是3，所以，x=2，y=3。显示为P:2/3 X:640.9 Y:1250.9 X是active pointer的X轴坐标；Y是active pointer的Y轴坐标。当多点触摸时只有一个pointer是激活pointer（ActivePointer），所以X，Y表示的就是这个ActivePointer的X和Y轴坐标。dX和dY分别代表整个手势结束后活动点（ActivePointer）在X轴和Y轴方向上起始点到终止点的差值，其中X轴上从左到右为正值，Y轴上从上到下是正值，否则为负值。 swipe(x1, y1, x2, y2, duration)duration {number} 滑动时长，单位毫秒模拟从坐标(x1, y1)滑动到坐标(x2, y2)，并返回是否成功。只有滑动操作执行完成时脚本才会继续执行。 gesture(duration, [x1, y1], [x2, y2], …) duration {number} 手势的时长 [x, y] … 手势滑动路径的一系列坐标 模拟手势操作。例如gesture(1000, [0, 0], [500, 500], [500, 1000])为模拟一个从(0, 0)到(500, 500)到(500, 100)的手势操作，时长为2秒。 gestures([delay1, duration1, [x1, y1], [x2, y2], …], [delay2, duration2, [x3, y3], [x4, y4], …], …)同时模拟多个手势。每个手势的参数为[delay, duration, 坐标], delay为延迟多久(毫秒)才执行该手势；duration为手势执行时长；坐标为手势经过的点的坐标。 其中delay参数可以省略，默认为0。 例如手指捏合： 12gestures([0, 500, [800, 300], [500, 1000]], [0, 500, [300, 1500], [500, 1000]]); 调用java文件怎么用aj调用java文件，把Java打包成dex或者jar然后runtime.loadDax 踩过的坑如果有界面，那么监听通知需要放在线程里。webview 注入js的js文件需要改后缀，如果还是js,会被加密导致无法使用webview 内页面引用静态文件可以使用相对路径如果多次调用 even.on，event.emit 会触发多次。可以用 even.removeAllListeners进行清除。console.show 调用时范围只是当前线程。不要在UI线程内死循环，要重新开启一个线程，不然会卡死无障碍服务权限申请可以使用auto,直接跳转到设置页。通知使用服务第一次调用后会提示一次之后，如果没有给予权限。大概率不再弹窗，并且不会报错。如果一直没有给权限，而且无法弹窗需要引导用户手动开启，并重启脚本。 支付宝/微信/其他软件https://www.jianshu.com/p/2c7f2c2cbf78在使用autojs时，遇到支付宝和微信以及一些安全意识较强的平台，很难获取到其页面的控件，无论你是使用autojs自带的控件分析或是Android studio的uiautomatorviewer.bat来分析它们的页面控件，都会分析到。但是你在获取的时侯就会发现根本获取不到，能看到却拿不到的痛苦想必是所有autojs的使用者都非常懊恼的一件事情吧。 原因支付宝和微信都把它们的控件藏起来了，可能是封装成某个类型，那个类型的输出就是空行。 我的方法是获取其控件后在其末尾加了个string，使得整个内容强转成string。 12var meId2 = id(\"XXX\").find()+\"\";//找到id为XXX的控件，然后加上空字符串//整个类型现在变成string，现在就可以用字符串截取的方式来获取控件的信息了。 //pro9基本无法使用，低版本可以while(!click(“智慧广工商”)); click(“智慧广工商”) 常用获取设备唯一标识1234567891011121314151617// var uuid = device.fingerprint;// toastLog(uuid)// 使用device.getAndroidId()代替device.getIMEI().这是因为安卓10以上限制了获取imei码var imei = device.getAndroidId()toast(imei)// md5加密函数function md5(string){ var res=java.math.BigInteger(1,java.security.MessageDigest.getInstance(\"MD5\").digest(java.lang.String(string).getBytes())).toString(16); while(res.length&lt;32)res=\"0\"+res; return res;} 强制结束app进程的功能 root方案 123456function forceCloseApp(appName) { //这里传入的是应用名不是包名 var packageName = getPackageName(appName); var sh = new Shell(true);//注册一个对象运用shell命令，true(真) 以root权限运行代码，默认为falae假 sh.exec(\"am force-stop\" + \" \" + packageName); //exec命令执行是\"异步\"的、非阻塞的。也就是不会等待命令完成后才继续向下执行。 sh.exitAndWaitFor();//执行\"exit\"命令并等待执行命令执行完成、退出shell。} 非root方案（曲线救国） 123456789function forceCloseApp(appName) { var packageName = getPackageName(appName); app.openAppSetting(packageName);//打开app的详细信息 if (text(\"强行停止\").findOne().enabled()) {//判断强制停止按钮是否可点击，可点击（enabled值为true）则表示在运行，不可点击（enabled值为false）就代表未运行。 text(\"强行停止\").findOne().click(); text(\"确定\").findOne().click(); } back();} 控制台 使用以下方式在新线程中启动 12345threads.start(function () { if (isShowConsole) { console.show(); }}); 提取文本中的数字的正则表达式123//代码举例：timesText = id(\"tv_remain_times\").findOne().text();times = timesText.replace(/[^0-9]/ig, \"\"); 数据库123456789101112131415161718192021222324252627 // 字段映射 let fieldMapping = { \"id\": \"int\", \"desc\": \"String\", } // 表名 let table = \"record\"; // 建表 let SQL = \"CREATE TABLE IF NOT EXISTS \" + table+\" (\" + \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" + \"desc VARCHAR(255)\" + \")\"; // 数据库名 let db = \"xianyu\"; let dbUtils = new DbUtils(db, SQL, fieldMapping); // 创建数据库和表 dbUtils.updateDatabase();// 清表dbUtils.deleteRows(table, null, null)// 数据查询 let existStatus = dbUtils.isExistRow(\"SELECT * FROM \" + table + \" WHERE desc = ?\", [text]);// 增加数据dbUtils.addRow(table, { desc: text }); 图片与颜色图色助手RGB颜色值与十六进制颜色码转换工具 图片回收机制image对象创建后尽量在不使用时进行回收，同时避免循环创建大量图片。因为图片是一种占用内存比较大的资源 123456// 读取图片var img = images.read(\"./1.png\");// 不用后回收图片img.recycle(); base64编码转换加快图片传输速度 base64图片转换工具 Base641.images.fromBase64(图片的Base64数据)解码Base64数据并返回解码后的图片Image对象。如果base64无法解码则返回null。 2.images.toBase64(Image对象[, 图片格式, 图片质量])返回 {string},把图片编码为base64数据并返回。 bytesimages.fromBytes(bytes)bytes {byte[]} 字节数组解码字节数组bytes并返回解码后的图片Image对象。如果bytes无法解码则返回null。 images.toBytes(Image对象[, 图片格式, 图片质量]) 返回 {byte[]}把图片编码为字节数组并返回。 images模块提供了一些手机设备中常见的图片处理函数，包括截图、读写图片、图片剪裁、旋转、二值化、找色找图等。 读取图片images.read(图片路径) {string}读取图片并返回Image对象。失败返回null。 images.load(图片URL地址)加载在地址URL的网络图片并返回一个Image对象。失败则返回null。 images.copy(Image对象) 返回 {Image}复制一张图片并返回新的副本。该函数会完全复制img对象的数据。 1234// 同级目录images.read(\"1.png\")路径最好写全(\"/sdcard/脚本/1.png\") 保存图片images.save(Image对象, 路径[, 图片格式, 图片质量]) {string} 图片格式，可选的值为:png，jpeg/jpg，webp{number} 图片质量，为0~100的整数值把图片image以PNG格式保存到path中。如果文件不存在会被创建；文件存在会被覆盖。 Image对象.saveTo(path) //保存图片 图片处理images.clip()images.clip(Image对象, x, y, w, h) x {number} 剪切区域的左上角横坐标y {number} 剪切区域的左上角纵坐标w {number} 剪切区域的宽度h {number} 剪切区域的高度返回 {Image}从图片img的位置(x, y)处剪切大小为w * h的区域，并返回该剪切区域的新图片 images.scale()images.scale(img, fx, fy[, interpolation])[v4.1.0新增] img {Image} 图片 fx {number} 宽度放缩倍数 fy {number} 高度放缩倍数 interpolation {string} 插值方法，可选，默认为”LINEAR”（线性插值），可选的值有： NEAREST 最近邻插值 LINEAR 线性插值（默认） AREA 区域插值 CUBIC 三次样条插值 LANCZOS4 Lanczos插值 参见InterpolationFlags 返回 {Image}对象放缩图片，并返回放缩后的图片。例如把图片变成原来的一半：images.scale(img, 0.5, 0.5)。 区域找色多点找色images.findMultiColors(img, firstColor, colors[, options])img:要找色的图片firstColor {number | string} 第一个点的颜色colors {Array} 表示剩下的点相对于第一个点的位置和颜色的数组，数组的每个元素为[x, y, color] options {Object} 选项，包括： region {Array} 找色区域。是一个两个或四个元素的数组。 (region[0], region[1])表示找色区域的左上角；region[2]*region[3]表示找色区域的宽高。如果只有region只有两个元素，则找色区域为(region[0], region[1])到图片右下角。如果不指定region选项，则找色区域为整张图片。 threshold {number} 找色时颜色相似度的临界值，范围为0 -255（越小越相似，0为颜色相等，255为任何颜色都能匹配）。默认为4。threshold和浮点数相似度(0.0~1.0)的换算为 similarity = (255 - threshold) / 255. 多点找色,其过程如下：在图片img中找到颜色firstColor的位置(x0, y0)对于数组colors的每个元素[x, y, color]，检查图片img在位置(x + x0, y + y0)上的像素是否是颜色color，是的话返回(x0, y0)，否则继续寻找firstColor的位置，重新执行第1步整张图片都找不到时返回null 123456789var p = images.findMultiColors(img, \"#123456\", [[10, 20, \"#ffffff\"], [30, 40, \"#000000\"]], {region: [0, 960, 1080, 960]});var point =images.findMultiColors(captureScreen(),\"#1e9e6c\",[[54,4,\"#1e9e6c\"],[-1,-2,\"#1e9e6c\"],[-1,-2,\"#1e9e6c\"]])toastLog(\"x = \" + point.x + \", y = \" + point.y);click (point.x, point.y) colors模块颜色在线转换https://www.sioe.cn/yingyong/yanse-rgb-16/ 在Auto.js有两种方式表示一个颜色。 颜色字符串colors.toString(整数RGB颜色值)参数 {number} 整数RGB颜色值返回 {string}颜色值的字符串，格式为 “#AARRGGBB”。 颜色整数使用一个16进制的”32位整数” 0xAARRGGBB 来表示一个颜色 colors.parseColor(颜色的字符串)参数 {string} 表示颜色的字符串，例如”#112233”返回 {number}颜色的整数值。 两个颜色是否相似colors.isSimilar(color1, color2[, threshold, algorithm])color1 {number} | {string}color1 {number} | {string} threshold {number} 颜色相似度临界值，默认为4。取值范围为0~255。这个值越大表示允许的相似程度越小，如果这个值为0，则两个颜色相等时该函数才会返回true。algorithm {string} 颜色匹配算法，默认为”diff”返回 {Boolean}返回两个颜色是否相似。 两个颜色是否相等colors.equals(color1, color2)color1 {number} | {string} 颜色值1color1 {number} | {string} 颜色值2返回 {Boolean}返回两个颜色是否相等。*注意该函数会忽略Alpha通道的值进行比较。 Autojs 本地验证（一机一码）1、一机一码的实现原理12345机器码：设备的唯一标识注册机：用于激活设备，生成激活码。激活码：用于激活设备 2、一机一码UI界面的开发12345678910111213141516171819202122\"ui\";ui.layout( &lt;vertical padding='10'&gt; &lt;horizontal&gt; &lt;text text=\"机器码：\"/&gt; &lt;input id=\"machineCode\" w='*'/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;text text=\"激活码：\"/&gt; &lt;input id=\"activationCode\" w='*'/&gt; &lt;/horizontal&gt; &lt;button id='activation' text=\"激活\"/&gt; &lt;/vertical&gt;);ui.activation.on('click',function(){ alert('激活成功！');}) 3、注册机UI界面的开发1234567891011121314151617181920\"ui\";ui.layout( &lt;vertical padding='10'&gt; &lt;horizontal&gt; &lt;text text=\"机器码：\"/&gt; &lt;input id=\"machineCode\" w='*'/&gt; &lt;/horizontal&gt; &lt;button id='activation' text=\"生成激活码\"/&gt; &lt;text text=\"激活码：\" textColor=\"red\"/&gt; &lt;text id='activationCode' text='未生成'/&gt; &lt;/vertical&gt;);ui.activation.on('click',function(){ ui.activationCode.setText('123456')}) 4、获取手机唯一标识12345// var uuid = device.fingerprint;var imei = device.getIMEI()toast(imei) 5、完成第一个脚本注册机验证1234567891011121314151617181920212223242526272829303132333435363738394041424344脚本端\"ui\";ui.layout( &lt;vertical padding='10'&gt; &lt;horizontal&gt; &lt;text text=\"机器码：\"/&gt; &lt;input id=\"machineCode\" w='*' text=''/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;text text=\"激活码：\"/&gt; &lt;input id=\"activationCode\" w='*'/&gt; &lt;/horizontal&gt; &lt;button id='activation' text=\"激活\"/&gt; &lt;/vertical&gt;);var uuid = device.fingerprint;ui.machineCode.setText(uuid)ui.activation.on('click',function(){ //取算法得到的值 var res = ui.machineCode.text() +\"aaa\" // log(typeof(ui.activationCode.text())) // log(typeof(res.toString())) if(ui.activationCode.text() === res.toString()){ alert('激活成功！'); }else{ alert('激活失败！'); } // alert('激活成功！');}) 123456789101112131415161718192021222324252627282930313233343536373839注册机端\"ui\";ui.layout( &lt;vertical padding='10'&gt; &lt;horizontal&gt; &lt;text text=\"机器码：\"/&gt; &lt;input id=\"machineCode\" w='*'/&gt; &lt;/horizontal&gt; &lt;button id='activation' text=\"生成激活码\"/&gt; &lt;text text=\"激活码：\" textColor=\"red\"/&gt; &lt;text id='activationCode' text='未生成'/&gt; &lt;/vertical&gt;);//算法是 uuid+\"aaa\" ui.activation.on('click',function(){ var machineCode = ui.machineCode.text(); var activationCode = machineCode + 'aaa' // toast(activationCode) ui.activationCode.setText(activationCode.toString()) setClip(activationCode.toString()) toast('激活码已复制')}) 6、对手机唯一标识符进行加密12345function md5(string){ var res=java.math.BigInteger(1,java.security.MessageDigest.getInstance(\"MD5\").digest(java.lang.String(string).getBytes())).toString(16); while(res.length&lt;32)res=\"0\"+res; return res;} 7、增加时间验证12345678910111213141516171819//格式化时间function dateFormat(thisDate, fmt) { var o = { \"M+\": thisDate.getMonth() + 1, \"d+\": thisDate.getDate(), \"h+\": thisDate.getHours(), \"m+\": thisDate.getMinutes(), \"s+\": thisDate.getSeconds(), \"q+\": Math.floor((thisDate.getMonth() + 3) / 3), \"S\": thisDate.getMilliseconds() }; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (thisDate.getFullYear() + \"\").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmt;} 8、增加时间验证（二）9、开发日卡、月卡、年卡功能1234&lt;horizontal&gt; &lt;text textSize=\"16sp\"&gt;充值类型&lt;/text&gt; &lt;spinner id=\"sp1\" entries=\"月卡|年卡\" textColor=\"red\"/&gt;&lt;/horizontal&gt; 1ui.sp1.getSelectedItemPosition(); 10、激活码限制脚本运行12345678910111213141516171819function validTime(ntime) { if (toTime() &lt; ntime || IntTime() &lt; ntime) { return true; } else { return false; }}function toTime() { return new java.text.SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date());}function IntTime() { try { var recode_suning = http.get(\"http://quan.suning.com/getSysTime.do\"); var suningTime = recode_suning.body.json(); return suningTime.sysTime1; } catch (e) {}} 11、保存激活状态到本地1var storage = storages.create('activation'); 12、解决时间验证bug方法13、完善激活码交互逻辑12345678910111213dialogs.build({ title: \"机器码：\", content: uuid, negative: \"输入激活码\", positive: \"复制机器码\" }).on(\"positive\", ()=&gt;{ setClip(uuid); toast(\"机器码已复制\"); }).on(\"negative\", ()=&gt;{ rawInput(\"请输入激活码\", \"\", 激活码 =&gt; { }); }).show(); 14、封装验证激活码函数(一)12345678910111213141516171819//验证激活码function validateCode(uuid,activation){ //取算法得到的值 var res = uuid +\"aaa\"; //解密激活码 var res2 = activation.split('&amp;'); var activationCode = res2[0]; var timestamp = res2[1]; //获取未来的格式化时间 var timestamp2 = dateFormat(new Date(parseInt(timestamp)), \"yyyyMMddhhmmss\"); if(activationCode === res.toString() &amp;&amp; validTime(timestamp2)){ return true; }else{ return false; }} 15、封装验证激活码函数(二)12345678910111213141516171819202122//验证激活码function validateCode(uuid,activation){ //取算法得到的值 var res = uuid +\"aaa\"; //解密激活码 var res2 = activation.split('&amp;'); var activationCode = res2[0]; var timestamp = res2[1]; //获取未来的格式化时间 var timestamp2 = dateFormat(new Date(parseInt(timestamp)), \"yyyyMMddhhmmss\"); if(activationCode === res.toString()){ if(validTime(timestamp2)){ return 1; }else{ return 2; } }else{ return 0; }} 16、封装注册机加密函数12345678//算法函数function encrypt(machineCode,timestamp){ var activationCode = machineCode + 'aaa&amp;'+timestamp; return activationCode;} 17、升级加密复杂度（一）12345var 加密字符串1 = md5(uuid+timestamp);var 加密时间 = ((timestamp-0+10000)*903)/100000;var 加密字符串2 = md5((md5(\"litikj\" +加密字符串1 +\"litikj\")+\"litikj\") +加密时间 +md5(uuid)+\"112233\");var 激活码 = 加密字符串1+\"&amp;\"+加密时间+\"&amp;\"+加密字符串2 18、升级加密复杂度（二）123456789101112131415161718192021222324252627282930313233343536//验证激活码function validateCode(uuid,activation){ var codeArr = activation.split(\"&amp;\"); var str1 = codeArr[0]; var encryptTime = codeArr[1]; var str2 = codeArr[2]; var timestamp = (Number(encryptTime) * 100000) / 903 -10000; //格式化时间 var timestamp2 = dateFormat(new Date(parseInt(timestamp)), \"yyyyMMddhhmmss\"); //判断激活码是否有效 if(str1 === md5(uuid+timestamp) &amp;&amp; str2 === md5((md5(\"litikj\" +md5(uuid+timestamp) +\"litikj\")+\"litikj\") +encryptTime +md5(uuid)+\"112233\")){ //算法一样 if(validTime(timestamp2)){ //时间正常 ui.end.setText('到期时间:'); ui.time.setText(dateFormat(new Date(parseInt(timestamp)), 'yyyy年MM月dd日 hh:mm:ss')) return 1; }else{ //时间过期 ui.end.setText('时间过期:'); ui.time.setText(dateFormat(new Date(parseInt(timestamp)), 'yyyy年MM月dd日 hh:mm:ss')) return 2; } }else{ //算法不一样 return 0; }} 19、增加运行脚本时的验证方法12345678910111213141516171819function check(){ if(storage.get('activation')){ var res = validateCode(uuid,storage.get('activation')) switch(res){ case 0: scriptStatus = false; break; case 1: scriptStatus = true; break; case 2: scriptStatus = false; break; } }} 20、给脚本添加一机一码功能（一）21、给脚本添加一机一码功能（二）如何写游戏脚本触摸模拟 sleep(n)：暂停运行n毫秒，游戏脚本中最常出现的一个命令；有一些操作必须给它一定的缓冲时间才能正确运行完成。 随机数： random(min,max)指定区间、random()范围是[0,1)；点击坐标时常设置一个随机偏移，防止被检测到（每次都点同一个点还是太明显了） 分辨率适配问题，setScreenMetrics(1080, 1920);、表示脚本适合的屏幕宽高为1080x1920（编脚本时基于的设备），如果在别的分辨率手机上运行则会自动放缩光标。听上去很好的一个功能，一般游戏脚本必加这一行，但具体效果如何我没有测试过。 click(x,y)：点击坐标（无需root权限），返回是否成功，点击过程大约150ms，可能被其他事件中断。更长时间的点击如longClick(x,y)、持续600ms。 press(x,y,duartion)：按住坐标，一般超过500ms才被系统认为是长按。 swipe(x1,y1,x2,y2,duration)： 从(x1,y1)滑动到(x2,y2)，持续duration。 RootAutomator 上面的几个触摸操作都是免root的，而基于RootAutomator对象的触摸需要root权限，优点是执行没有延迟，明显比click要快。 12345678var ra=new RootAutomator(); //初始化一个对象ra.tap(x,y,id); //id代表不同“手指”，用于多点触摸，不需要时可省略该参数ra.swipe(x1,y1,x2,y2,duration,id)ra.press(x,y,duration,id)// 这些命令组合在一起就能完成复杂的操作了~ra.touchDown(x,y,id)ra.touchMove(x,y,id)ra.touchUp(id) 模拟按键；（返回bool值） 1234if(back()){}; //按下返回键home() //返回桌面还有一些需要root权限的，开头字母大写://Home()、Back()、Power()、Menu()、OK()、KeyCode()... colors颜色常用十六进制值或RGB值来表示，如蓝色可表示为#0000FF或(0,0,255)，一般都是#后面带6位十六进制数，分别表示R、G、B，但Autojs是8位，前面多了一个A(Alpha)、表示透明度，即ARGB。 Autojs通过一个16进制整数或一个字符串表示一个颜色，两者可以互相转换 12var myBlue=colors.toString(color.BLUE); //返回#ff0000ff,colors.BLUE代表蓝色，后面必须大写。var numBlue=colors.parseColor(\"#ff0000ff\"); //返回-16776961,至于为什么是这个数我也不清楚，平时还是用字符串表示比较好。 colors对象里还有一些判断两个颜色的相似度、返回A、R、G、B通道值的函数，平时也基本上用不上；颜色的用途主要体现在后面的多点找色上。 images游戏脚本的灵魂所在，images主要有图片处理、找图、找色几个部分；想让脚本识别游戏的某个区域、如果该区域的位置是固定的，通过构造多点比色比较快，而如果位置不固定则常用找图的方式，虽然占用资源比较多但准确性有保障。 images对象使用完后必须回收，防止内存泄漏。 12345var img=images.read(\"./name.png\"); //读取图片，错误时返回null//var img=images.load(url); //从网址获取图片//...图片操作后回收img.recycle();// 例外：captureScreen()返回的图片无需回收 mages对象能对图像进行复制、保存、Base64编码解码、剪切、调整大小、放缩、旋转、拼接、灰度化、阈值化、颜色控件转换、二值化、模糊与平滑处理、滤波…（强是很强大，就是基本上用不上） 获取截图权限：在找图找色之前往往要先获取当前屏幕的截图，这个截图一般是临时的、不会保存到文件（也可以设置保存）。 截图之前要向系统申请一次截图权限： 1234if(!requestScreenCapture()){ //可指定参数true（横屏截图） 或者 false（竖屏截图） toast(\"请求截图失败\"); exit();} 请求截图: captureScreen 12//在此之前记住要请求一次截图权限var img=captureScreen(); //可以指定保存路径path 颜色获取，很重要的一个函数，后面多点找色时可以先用它获取参数值。 12//获取某点的ARGB颜色值var color=images.pixel(img,100,200); //img是之前创建的images对象 区域找色（一种颜色）；findColor、findColorInRegion、findColorEquals 12345678910//首先说下region和threshold这两个参数，后面的找色函数options里都要用到：//region、找色区域，默认全图、指定[x,y]代表左上角点，从(x,y)到右下角；指定[x,y,width,height]则代表从(x,y)到(x+width,y+height)。//threshold、相似度临界值，0~255，默认为4；similarity=1-threshold/255，可以算出默认相似度达到了0.98，觉得太严了可以适当增大thresholdvar point = images.findColor(img, \"#ff0000\", { region: [100, 200], threshold: 10 });//如果找到则返回一个点，如：{463.0, 1242.0}；找不到返回null。//这里颜色值是6位，8位也行不过会忽略A通道（透明度）。// findColorInRegion，功能和findColor一样，只是优化了下参数表示。var point=images.findColorInRegion(img,\"#ff0000\",100,200,1080,1920,10);// findColorEquals，要求颜色完全相等，相当于findColor的threshold参数设为0var point=images.findColorEquals(img,\"#ff0000\",100,200,1080,1920); 多点找色：findMultiColors，先定位第一个点的颜色、根据(x,y)偏移获取并对比第二个点的颜色…以此类推，命令很麻烦，通常需要写一个函数来构造颜色列。 123456var point = images.findMultiColors(img, \"#ff949fc7\", //第一个点 [[60, 60, \"#ffe6efe6\"], //颜色Array， [60, -60, \"#ffeef3e6\"], [-60, 60, \"#ffe6efe6\"], [-60, -60, \"#ffeef3e6\"]], { region: [1548, 803, 140, 140] }) //指定区域 检测某坐标颜色：前几个命令都是根据颜色找坐标，这个是给坐标、比较颜色 12if(images.detectsColor(img,\"#fed9a8\",100,200,16,\"diff\")){}//最后两个参数可省略，代表threshold和匹配算法；x=100,y=200 找图：有时候找颜色会匹配到一些奇怪的地方去，还得用找图来实现，有images.findImage、images.findImageInRegion、images.matchTemplate。 123456var temp1=images.read(pathToImage);var point=images.findImage(img,temp1,{ region: [100, 200], threshold: 10 });//同样findImageInRegion只是优化了下参数排列//matchTemplate可以同时返回找到的多个位置，通过max控制最大的结果数量var result=images.matchTemplate(img,temp1,{ region: [100, 200], threshold: 10 ,max:5});//返回类型是一个MatchingResult对象，有point和similarity这两个数据成员。 脚本结构管理Module在一个文件里通过module.exports =...;把某个对象导出，从而可以在另一个文件通过var name=require('file.js');导入；相当于把整个文件当做一个函数，把exports的东西当做返回值。感觉用起来也不太方便，我选择不用这个功能。 Threads 启动一个子线程，threads.start： 12345678910//启动一个无限循环的线程var thread = threads.start(function(){ //用thread对象可以控制线程运行状态，如果不需要操作可以改为：//threads.start(function(){ while(true){ log(\"子线程运行中...\"); sleep(1000); }});sleep(5000);thread.interrupt(); threads.shutDownAll()： 停止所有通过threads.start()启动的子线程 等待线程开始执行（一般start后需要一段时间）：thread.waitFor();（这里thread是前面创建的thread变量） 等待线程执行完成：thread.join();，参数可以指定一个等待时间 中断线程运行：thread.interrupt(); 注意多线程中的变量问题，涉及到线程安全，文档里说的很详细 线程间的通信与传递变量，通过var connect = threads.disposable();实现；发送结果：connect.setAndNotify(s);，接收结果：connect.blockedGet(s); 交互界面Events、Dialogs、Console Events模块主要用来监听按键、触摸、通知等，但放在单线程里可能会因为程序其他部分而无法及时执行，造成非预期的结果，常常和多线程Threads模块一起使用，如音量键关闭脚本的例子： 1234567891011121314151617auto();threads.start(function(){ //在子线程中调用observeKey()从而使按键事件处理在子线程执行 events.observeKey(); //启用按键监听 events.on(\"key_down\", function(keyCode, events){ //常用事件有key、key_down、key_up、exit、toast、notification、touch(触摸某点) if(keyCode == keys.volume_up){ //音量上键关闭脚本 exit(); } });});events.on(\"exit\", function(){ //脚本停止运行时会触发exit事件 toast(\"脚本已结束\");});while(true){ log(\"脚本运行中...\"); sleep(2000);} Dialogs 这部分提供对话框支持，但由于是弹出一个全屏的消息提示框，实际体验是并不太能用上；如果脚本和用户的交互性比较强的话可以考虑一下。 Console 控制台的作用更像是用于调试，但一般Windows下用VSCode写脚本也不需要在控制台上显示吧，所以这部分给人的感觉也是很鸡肋…不过console的UI是固定的，也可以悬浮、最小化；有时不想设计UI的时候可以偷懒直接拿console过来凑合用用。 Floaty、UI界面设计这部分内容相当多，而且官方文档也有很多写得很简略（甚至一笔带过），要想真正从零开始设计出一个实用好看的UI出来还是有难度的；我是建议去网上多找几个模板文件运行运行，在别人的基础上修改起来就快多了，看不懂的地方再去翻翻文档解决。一般UI设计好后再和程序一对接（通过UI各组件的id），就可以打包做成apk了~ 写一个注册机实战加密解密 我们再测试下解密 看能不能解开 唯一 = device.getIMEI() 我们来回忆一下： 加密1 加密2——-固定加密 加密3 ————随机加密 解密2 解密3——解密使用 开始加密，可以用 加密2 加密3，随便用，都可以 但是你需要记住 加密的次数和加密顺序 ——-3次——-加密2——–加密2——–加密3 看结果 ?wv1%yv%4rv%0v%S0v%7vJ%5v%8Sw%3w%Uxw%9vW%vv%55v%yy%7j5 我们在我们自己的脚本中，开始写解密，相反的顺序 ———-解密3———解密2——–解密2——3次—- 得到 358811051254785 我们测试下 运行 这个函数 358811051254785 完美了，继续 运行到这里了 我们可以得到 一个 “加密结果3” 需要让对方把这个值 发给我们 这样操作 setClip(加密结果3); toast (“已经复制到右键了，请发给我”); 演示一下，运行一下，他发给我们的是这个 ?wvl%yv%4gv%0v%p0v%7vr%5v%8Hw%3w%dxw%9vk%vv%5hv%yy%7j5 说明，我们的方法是对的。继续 对方发给我们之后 我们运行解密 结果也出来了。 还是这个数字。358811051254785。那当然还是它了。 那么，我们就这样，什么也不干就发给他吗？？？不，，，，，，，，稍微有点常识的看一眼都知道，这可能就是手机的某个参数。 这时候，有小白就会问了，这不是没有意义吗？！错。大错特错。你看看对方发给我们的是什么，每次都不一样，他也迷糊，是吧。。。。。。。我们可以把提示代码抹去，虽然他每次都复制了，但是对方不知道呀，嘿嘿。你只需要第一次告诉对方，复制右键发给我们。嘿嘿。 为了彻底迷惑对方，我们再继续对“唯一”进行多次混合加密。这里必须用固定加密。。嘿嘿。 我们在我们自己的脚本中，也复制一模一样的，运行， 得到 “加密结果10”—-这个就是我们要发给对方的验证码了 最后，我们把代码完善下，能删除的log都删了 ok了 需要特别说明的 就是 你发给对方的脚本中 只能有加密函数别傻了胡痴地 把解密函数 也给对方发过去。嘿嘿。 这个只是在脚本上加密解密。还有网络加密解密。如果，有感兴趣的，以后可以出一个教程。非常简单的。因为网站都已经给我们现成的auto.js封装好的啊。只需要随便改一点点东西，就可以使用了。 代码发到下面了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102if(auto.service==null){auto.waitFor();};sleep(1000);唯一 = device.getIMEI()加密结果1 = 加密2(唯一)加密结果2 = 加密2(加密结果1)加密结果3 = 加密3(加密结果2)setClip(加密结果3);//toast (\"已经复制到右键了，请发给我\");sleep(90000)加密结果4 = 加密2(唯一)加密结果5 = 加密2(加密结果4)加密结果6 = 加密1(加密结果5)加密结果7 = 加密1(加密结果6)加密结果8 = 加密2(加密结果7)加密结果9 = 加密1(加密结果8)加密结果10 = 加密2(加密结果9)var 对方输入框里的 = rawInput(\"请输入验证码\");if (对方输入框里的 == 加密结果10) { log(\"验证码正确\") //开始干活喽} else { log(\"验证码错误\"); exit();}// 固定加密function 加密1(string) { return java.math.BigInteger(1, java.security.MessageDigest.getInstance(\"MD5\") .digest(java.lang.String(string).getBytes())).toString(16);}// 固定加密function 加密2(code) { var c = String.fromCharCode(code.charCodeAt(0) + code.length); for (var i = 1; i &lt; code.length; i++) { c += String.fromCharCode(code.charCodeAt(i) + code.charCodeAt(i - 1)); } return escape(c);}// 随机加密function 加密3(stringW) { var str = stringW + \"?\"; var ranWs = random(1, 6); var str1 = \"\"; for (var i = 0; i &lt; str.length; i++) { str1 = str1 + str[i]; if (i % ranWs == 0) { str1 = str1 + ranLetter(); } } log(str1) str1 = ranWs + str1; str1 = str1.split(\"\").reverse(); for (var x = 0; x &lt; str1.length; x++) { str1[x] = charDh(str1[x]); } return str1.join(\"\");}function ranLetter() { var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]; var ran = random(0, 3); if (ran == 0) { return random(0, 9); } else if (ran == 1) { return arr[random(0, arr.length - 1)]; } else { return arr[random(0, arr.length - 1)].toUpperCase(); }}function charDh(cha) { var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]; for (var jw = 0; jw &lt; arr.length; jw++) { if (cha == arr[jw]) { return arr[arr.length - 1 - jw]; } } return cha;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//解密var b = \"\"解密结果3 = 解密3(b)解密结果2 = 解密2(解密结果3)解密结果1 = 解密2(解密结果2)//log(解密结果1)//解密结果1 就是对方手机的IMEI 也就是“唯一”加密结果4 = 加密2(解密结果1)加密结果5 = 加密2(加密结果4)加密结果6 = 加密1(加密结果5)加密结果7 = 加密1(加密结果6)加密结果8 = 加密2(加密结果7)加密结果9 = 加密1(加密结果8)加密结果10 = 加密2(加密结果9)log(加密结果10)function 解密2(code) { code = unescape(code); var c = String.fromCharCode(code.charCodeAt(0) - code.length); for (var i = 1; i &lt; code.length; i++) { c += String.fromCharCode(code.charCodeAt(i) - c.charCodeAt(i - 1)); } return c;}function 解密3(stringJ) { var str2 = stringJ.split(\"\"); for (var x = 0; x &lt; str2.length; x++) { str2[x] = charDh(str2[x]); } str2 = str2.reverse().join(\"\"); log(str2) var tt = parseInt(str2[0]); str2 = str2.substring(1, str2.length - 1); var str3 = \"\"; for (var y = 0; y &lt; str2.length; y++) { if ((y - 1) % (tt + 1) != 0) { str3 = str3 + str2[y]; } } if (str3[str3.length - 1] == \"?\") { str3 = str3.substring(0, str3.length - 1); } return str3;}function charDh(cha) { var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]; for (var jw = 0; jw &lt; arr.length; jw++) { if (cha == arr[jw]) { return arr[arr.length - 1 - jw]; } } return cha;}function 加密1(string) { return java.math.BigInteger(1, java.security.MessageDigest.getInstance(\"MD5\") .digest(java.lang.String(string).getBytes())).toString(16);}function 加密2(code) { var c = String.fromCharCode(code.charCodeAt(0) + code.length); for (var i = 1; i &lt; code.length; i++) { c += String.fromCharCode(code.charCodeAt(i) + code.charCodeAt(i - 1)); } return escape(c);}function 加密3(stringW) { var str = stringW + \"?\"; var ranWs = random(1, 6); var str1 = \"\"; for (var i = 0; i &lt; str.length; i++) { str1 = str1 + str[i]; if (i % ranWs == 0) { str1 = str1 + ranLetter(); } } log(str1) str1 = ranWs + str1; str1 = str1.split(\"\").reverse(); for (var x = 0; x &lt; str1.length; x++) { str1[x] = charDh(str1[x]); } return str1.join(\"\");}function ranLetter() { var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]; var ran = random(0, 3); if (ran == 0) { return random(0, 9); } else if (ran == 1) { return arr[random(0, arr.length - 1)]; } else { return arr[random(0, arr.length - 1)].toUpperCase(); }}","categories":[{"name":"自动化","slug":"自动化","permalink":"https://wenkexia.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"}],"tags":[{"name":"autojs","slug":"autojs","permalink":"https://wenkexia.github.io/tags/autojs/"}]},{"title":"鸿蒙开发","slug":"鸿蒙开发","date":"2022-01-08T07:37:55.000Z","updated":"2022-01-08T07:37:55.000Z","comments":true,"path":"2022/010839456.html","link":"","permalink":"https://wenkexia.github.io/2022/010839456.html","excerpt":"","text":"HarmonyOS概述HarmonyOS是一款面向万物互联时代的、全新的分布式操作系统。在传统的单设备系统能力基础上，HarmonyOS提出了基于同一套系统能力、适配多种终端形态的分布式理念，能够支持手机、平板、智能穿戴、智慧屏、车机等多种终端设备，提供全场景（移动办公、运动健康、社交通信、媒体娱乐等）业务能力。 HarmonyOS有三大特征：硬件互助，资源共享分布式软总线分布式软总线是手机、平板、智能穿戴、智慧屏、车机等分布式设备的通信基座，为设备之间的互联互通提供了统一的分布式通信能力， 典型应用场景举例： 智能家居场景：在烹饪时，手机可以通过碰一碰和烤箱连接，并将自动按照菜谱设置烹调参数，控制烤箱来制作菜肴。与此类似，料理机、油烟机、空气净化器、空调、灯、窗帘等都可以在手机端显示并通过手机控制。设备之间即连即用，无需繁琐的配置。多屏联动课堂：老师通过智慧屏授课，与学生开展互动，营造课堂氛围；学生通过平板完成课程学习和随堂问答。统一、全连接的逻辑网络确保了传输通道的高带宽、低时延、高可靠。 分布式设备虚拟化分布式设备虚拟化平台可以实现不同设备的资源融合、设备管理、数据处理，多种设备共同形成一个超级虚拟终端。针对不同类型的任务，为用户匹配并选择能力合适的执行硬件，让业务连续地在不同设备间流转，充分发挥不同设备的能力优势 典型应用场景举例： 视频通话场景：在做家务时接听视频电话，可以将手机与智慧屏连接，并将智慧屏的屏幕、摄像头与音箱虚拟化为本地资源，替代手机自身的屏幕、摄像头、听筒与扬声器，实现一边做家务、一边通过智慧屏和音箱来视频通话。游戏场景：在智慧屏上玩游戏时，可以将手机虚拟化为遥控器，借助手机的重力传感器、加速度传感器、触控能力，为玩家提供更便捷、更流畅的游戏体验。 分布式数据管理分布式数据管理基于分布式软总线的能力，实现应用程序数据和用户数据的分布式管理。用户数据不再与单一物理设备绑定，业务逻辑与数据存储分离，跨设备的数据处理如同本地数据处理一样方便快捷，让开发者能够轻松实现全场景、多设备下的数据存储、共享和访问，为打造一致、流畅的用户体验创造了基础条件。分布式数据管理示意图见图3。 典型应用场景举例： 协同办公场景：将手机上的文档投屏到智慧屏，在智慧屏上对文档执行翻页、缩放、涂鸦等操作，文档的最新状态可以在手机上同步显示。照片分享场景：出游时，使用手机拍摄的照片，可以在登录了同帐号的其他设备，比如平板上更方便地浏览、收藏、保存或编辑，也可以通过家中的智慧屏上同家人一起分享记录下的快乐瞬间。 分布式任务调度分布式任务调度基于分布式软总线、分布式数据管理、分布式Profile等技术特性，构建统一的分布式服务管理（发现、同步、注册、调用）机制，支持对跨设备的应用进行远程启动、远程调用、远程连接以及迁移等操作，能够根据不同设备的能力、位置、业务运行状态、资源使用情况，以及用户的习惯和意图，选择合适的设备运行分布式任务。 图4以应用迁移为例，简要地展示了分布式任务调度能力。 典型应用场景举例： 导航场景：如果用户驾车出行，上车前，在手机上规划好导航路线；上车后，导航自动迁移到车机和车载音箱；下车后，导航自动迁移回手机。如果用户骑车出行，在手机上规划好导航路线，骑行时手表可以接续导航。外卖场景：在手机上点外卖后，可以将订单信息迁移到手表上，随时查看外卖的配送状态。 一次开发，多端部署HarmonyOS通过组件化和小型化等设计方法，支持多种终端设备按需弹性部署，能够适配不同类别的硬件资源和功能需求。支撑通过编译链关系去自动生成组件化的依赖关系，形成组件树依赖图，支撑产品系统的便捷开发，降低硬件设备的开发门槛。 支持各组件的选择（组件可有可无）：根据硬件的形态和需求，可以选择所需的组件。支持组件内功能集的配置（组件可大可小）：根据硬件的资源情况和功能需求，可以选择配置组件中的功能集。例如，选择配置图形框架组件中的部分控件。支持组件间依赖的关联（平台可大可小）：根据编译链关系，可以自动生成组件化的依赖关系。例如，选择图形框架组件，将会自动选择依赖的图形引擎组件等。 统一OS，弹性部署对设备开发者而言，HarmonyOS采用了组件化的设计方案，可根据设备的资源能力和业务特征灵活裁剪，满足不同形态终端设备对操作系统的要求。 技术架构HarmonyOS整体遵从分层设计，从下向上依次为：内核层、系统服务层、框架层和应用层。系统功能按照“系统 &gt; 子系统 &gt; 功能/模块”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的子系统或功能/模块。 内核层内核子系统：HarmonyOS采用多内核设计，支持针对不同资源受限设备选用适合的OS内核。内核抽象层（KAL，Kernel Abstract Layer）通过屏蔽多内核差异，对上层提供基础的内核能力，包括进程/线程管理、内存管理、文件系统、网络管理和外设管理等。驱动子系统：硬件驱动框架（HDF）是HarmonyOS硬件生态开放的基础，提供统一外设访问能力和驱动开发、管理框架。 系统服务层系统服务层是HarmonyOS的核心能力集合，通过框架层对应用程序提供服务。该层包含以下几个部分： 系统基本能力子系统集：为分布式应用在HarmonyOS多设备上的运行、调度、迁移等操作提供了基础能力，由分布式软总线、分布式数据管理、分布式任务调度、方舟多语言运行时、公共基础库、多模输入、图形、安全、AI等子系统组成。其中，方舟运行时提供了C/C++/JS多语言运行时和基础的系统类库，也为使用方舟编译器静态化的Java程序（即应用程序或框架层中使用Java语言开发的部分）提供运行时。基础软件服务子系统集：为HarmonyOS提供公共的、通用的软件服务，由事件通知、电话、多媒体、DFX（Design For X） 、MSDP&amp;DV等子系统组成。增强软件服务子系统集：为HarmonyOS提供针对不同设备的、差异化的能力增强型软件服务，由智慧屏专有业务、穿戴专有业务、IoT专有业务等子系统组成。硬件服务子系统集：为HarmonyOS提供硬件服务，由位置服务、生物特征识别、穿戴专有硬件服务、IoT专有硬件服务等子系统组成。根据不同设备形态的部署环境，基础软件服务子系统集、增强软件服务子系统集、硬件服务子系统集内部可以按子系统粒度裁剪，每个子系统内部又可以按功能粒度裁剪。 框架层框架层为HarmonyOS应用开发提供了Java/C/C++/JS/TS等多语言的用户程序框架和Ability框架，两种UI框架（包括适用于Java语言的Java UI框架、适用于JS/TS语言的方舟开发框架），以及各种软硬件服务对外开放的多语言框架API。根据系统的组件化裁剪程度，HarmonyOS设备支持的API也会有所不同。 应用层应用层包括系统应用和第三方非系统应用。HarmonyOS的应用由一个或多个FA（Feature Ability）或PA（Particle Ability）组成。其中，FA有UI界面，提供与用户交互的能力；而PA无UI界面，提供后台运行任务的能力以及统一的数据访问抽象。FA在进行用户交互时所需的后台数据访问也需要由对应的PA提供支撑。基于FA/PA开发的应用，能够实现特定的业务功能，支持跨设备调度与分发，为用户提供一致、高效的应用体验。 用户应用程序包结构HarmonyOS的用户应用程序包以APP Pack（Application Package）形式发布，它是由一个或多个HAP（HarmonyOS Ability Package）以及描述每个HAP属性的pack.info组成。HAP是Ability的部署包，HarmonyOS应用代码围绕Ability组件展开。 一个HAP是由代码、资源、第三方库及应用配置文件组成的模块包，可分为entry和feature两种模块类型，如图1所示。 entry：应用的主模块。一个APP中，对于同一设备类型，可以有一个或多个entry类型的HAP，来支持该设备类型中不同规格（如API版本、屏幕规格等）的具体设备。如果同一设备类型存在多个entry模块，则必须配置distroFilter分发规则，使得应用市场在做应用的云端分发时，对该设备类型下不同规格的设备进行精确分发。feature：应用的动态特性模块。一个APP可以包含一个或多个feature类型的HAP，也可以不含。只有包含Ability的HAP才能够独立运行。 AbilityAbility是应用所具备的能力的抽象，一个应用可以包含一个或多个Ability。Ability分为两种类型：FA（Feature Ability）和PA（Particle Ability）。FA/PA是应用的基本组成单元，能够实现特定的业务功能。FA有UI界面，而PA无UI界面。 库文件库文件是应用依赖的第三方代码（例如so、jar、bin、har等二进制文件），存放在libs目录。 资源文件应用的资源文件（字符串、图片、音频等）存放于resources目录下，便于开发者使用和维护，详见资源文件的分类。 配置文件配置文件 (config.json) 是应用的Ability信息，用于声明应用的Ability，以及应用所需权限等信息，详见应用配置文件。 pack.info描述应用软件包中每个HAP的属性，由IDE编译生成，应用市场根据该文件进行拆包和HAP的分类存储。HAP的具体属性包括：delivery-with-install: 表示该HAP是否支持随应用安装。“true”表示支持随应用安装；“false”表示不支持随应用安装。name：HAP文件名。module-type：模块类型，entry或feature。device-type：表示支持该HAP运行的设备类型。 HARHAR（HarmonyOS Ability Resources）可以提供构建应用所需的所有内容，包括源代码、资源文件和config.json文件。HAR不同于HAP，HAR不能独立安装运行在设备上，只能作为应用模块的依赖项被引用。","categories":[{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkexia.github.io/categories/%E9%B8%BF%E8%92%99/"}],"tags":[{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkexia.github.io/tags/%E9%B8%BF%E8%92%99/"}]},{"title":"内网穿透","slug":"内网穿透","date":"2022-01-08T00:23:00.000Z","updated":"2022-01-08T00:23:58.000Z","comments":true,"path":"2022/01086932.html","link":"","permalink":"https://wenkexia.github.io/2022/01086932.html","excerpt":"","text":"内网穿透是指将内网中的软件服务通过网络代理方式暴露给广域网用户。可以实现内网穿透的方式很多，比如通过防火墙硬件、网络穿透软件来进行实现。先简单解释一下，大多数情况下，我们的个人电脑都处于内网，即没有可公开访问的独立 IP 地址（上网要通过其他网关），因此其他内网用户找不到你，就没办法和你建立连接。 而内网穿透的作用，就是将内网的电脑暴露到公共网络。可以理解为一个中间人，由于他知道你的电脑地址，所以能帮助其他用户访问到你的计算机。「无公网IP实现外网访问内网群晖.docx」链接：https://www.aliyundrive.com/s/ftxwXuv2SAi「开源内网穿透工具 frp 简单使用教程.docx」链接：https://www.aliyundrive.com/s/3K6okzrMght「常见内网穿透工具使用总结.docx」链接：https://www.aliyundrive.com/s/DDhaPQfR6SS「使用内网穿透访问内网ssh图文教程.docx」链接：https://www.aliyundrive.com/s/9U1Migig8yB「内网渗透之内网穿透.docx」链接：https://www.aliyundrive.com/s/Uh88x4GSjz4「内网穿透神器NPS的使用.docx」链接：https://www.aliyundrive.com/s/7XQUhDhPGBm 参考 nps-npc原文 简介nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。 一台有公网IP的服务器（VPS）运行服务端（NPS） 一个或多个运行在内网的服务器或者PC运行客户端（NPC） 特点Go语言编写 支持跨平台 支持多种协议的代理 web管理端 使用方法其官方网站为：https://ehang-io.github.io/nps 其官网文档对软件的安装、使用描述的非常完整，基本根据官方文档就可以进行顺利安装与使用。其官方网站为：https://ehang-io.github.io/nps 其官网文档对软件的安装、使用描述的非常完整，基本根据官方文档就可以进行顺利安装与使用。 NATAPP原文 未整理原文：https://zhuanlan.zhihu.com/p/303175108首先解释一下“内网”与“外网”的概念：内网：即所说的局域网，比如学校的局域网，局域网内每台计算机的IP地址在本局域网内具有互异性，是不可重复的。但两个局域网内的内网IP可以有相同的。外网：即互联网，局域网通过一台服务器或是一个路由器对外连接的网络，这个IP地址是唯一的。也就是说内网里所有的计算机都是连接到这一个外网IP上，通过这一个外网IP对外进行交换数据的。也就是说，一个局域网里所有电脑的内网IP是互不相同的,但共用一个外网IP。（用ipconfig/all查到的IP是你本机的内网IP；在http://www.ip138.com上看到的是你连接互联网所使用的IP，即外网）。 然后解释一下公有 IP 和私有 IP 的区别：公有地址(Public address)：由 Inter NIC(Internet Network Information Center 因特网信息中心)负责。这些 IP 地址分配给注册并向Inter NIC提出申请的组织机构，公有 IP 全球唯一，通过它直接访问因特网(直接能上网)。私有地址(Private address)：属于非注册地址，专门为组织机构内部使用，说白了，私有 IP 不能直接上网。而我们平时通过运营商(电信、移动、联通宽带等)上网，家里面通过路由器分出来的 IP 都是私有 IP(局域网 IP)，大家可能会疑问，我们可以上网啊，怎么会是私有 IP 呢?租用(申请)公有 IP 是需要钱的。 运营商买了一些公有 IP，然后通过这些公有 IP 分出来，再分给一个一个的用户使用。这个过程有点类似于，我们去安装了宽度，通过路由器分出几个 IP，让好几个人都能上网，当然运营商通过公有 IP 分出来的过程肯定比这个复杂多了。所以，我们平时上网用的 IP 是私有 IP，真正拥有公有 IP 的是运营商(当然，我们可以租用一个公有 IP )。所以，A 家庭的局域网 IP 和 B 家庭的局域网 IP 相同很正常，但是，最终 A 和 B 能上网(数据走出去)还是通过运营商的公有 IP，毕竟，公有 IP 的资源有限，这一片区域的用户使用的很有可能(实际上就是这样的)是同一个公有 IP最后需要解释一下端口映射：端口映射是 NAT 的一种，它将外网主机的 IP 地址的一个端口映射到内网中一台机器，提供相应的服务。当用户访问该 IP 的这个端口时，服务器自动将请求映射到对应局域网内部的机器上。之前提到的内网，是不能被外网直接的访问的，只能通过一些中转技术，让内网“假装”成外网。这就平常所说的内网穿透。内网穿透原理 内网穿透的概念 内网穿透，即NAT穿透，网络连接时术语，计算机是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透。就是说映射端口，能让外网的电脑找到处于内网的电脑，提高下载速度。不管是内网穿透还是其他类型的网络穿透，都是网络穿透的统一方法来研究和解决。 内网穿透原理对于内网来说，其不是不能主动访问公网端口，而是不能反过来有效的被公网访问。内网穿透的主要思路就是利用这一点，让在内网的节点主动访问一个拥有公网IP地址的服务器，并由中间服务器搭桥，打通经过该服务器从其他主机到NAT之后节点的隧道。 有哪些应用场景提供内网穿透服务连接内网服务器，在外网演示内网web站点无需服务器部署，快速调试本地程序，微信公众号开发利器支持http、https协议站点，省去证书中间件复杂配置，http协议站点直接升级为https站点支持TCP，UDP协议端口转发。支持数据库、SSH、远程桌面、网络摄像头等等开放到外网 建立隧道的工具 钉钉穿透 工具基于ngrok封装，简单、见效快，新手、个人开发者最佳选择 Ngrok项目主页：https://ngrok.com/项目介绍： 一个通过任何NAT或防火墙为您的本地主机服务器提供即时访问、安全的URL的命令。类似花生壳，分为服务端和客户端，也可以自己搭建服务端。开源，老牌穿透工具，源码很久没有更新了 Ssh&nbsp;配合autossh工具使用，因为autossh会容错项目主页：http://www.harding.motd.ca/autossh/项目介绍：自动重新启动SSH会话和隧道。autossh是一个程序，用于启动ssh的副本并进行监控，在死亡或停止传输流量时根据需要重新启动它。 这个想法来自rstunnel（Reliable SSH Tunnel），但是在C中实现。作者的观点是，它不像匆匆忙忙的工作那么容易。使用端口转发环路或远程回显服务进行连接监视。在遇到连接拒绝等快速故障时，关闭连接尝试的速度。在OpenBSD，Linux，Solaris，Mac OS X，Cygwin和AIX上编译和测试; 应该在其他BSD上工作。免费软件。Natapp项目主页：https://natapp.cn/项目介绍：基于ngrok的国内收费内网穿透工具，4包卫龙辣条的费用可以享有不限流量，自定义域名等好处类似花生壳，有免费版本，比花生壳好。免费版本：提供http,https,tcp全隧道穿透，随机域名/TCP端口，不定时强制更换域名/端口，自定义本地端口 Spike项目主页：https://github.com/slince/spike项目介绍：Spike是一个可以用来将你的内网服务暴露在公网的快速的反向代理，基于ReactPHP，采用IO多路复用模型。采用Php实现。 个人不推荐花生壳项目主页：https://hsk.oray.com/项目介绍：商业化比较成功的内网穿透。个人开发很不推荐，收费贵，企业可以考虑使用。需要建立账号实名认证，支付2包卫龙辣条费用，可自选一个壳域名，注册过程比较麻烦，流量限制Lanproxy项目主页：https://github.com/ffay/lanproxy项目介绍：lanproxy是一个将局域网个人电脑、服务器代理到公网的内网穿透工具，目前仅支持tcp流量转发，可支持任何tcp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面…）。目前市面上提供类似服务的有花生壳、TeamView、GoToMyCloud等等，但要使用第三方的公网服务器就必须为第三方付费，并且这些服务都有各种各样的限制，此外，由于数据包会流经第三方，因此对数据安全也是一大隐患。Frp项目主页：https://github.com/fatedier/frp项目介绍：frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。开源，强大牛逼，适合企业中开发使用，可穿透任意常规合法端口（包含22），需要提供云服务器，自己的域名，宽带上限由你的服务器所决定。 工具选择https://juejin.cn/post/6860694239412649991?share_token=26950be9-39b6-432c-b29a-a26df3e8cae4内网穿透工具比较(ngrok,frp,lanproxy,goproxy,nps)https://blog.csdn.net/a1035434631/article/details/108010819 ngork基本原理是通过客户端与公网服务端建立通道及映射关系，然后服务端提供可访问的公网地址。当外网访问此公网地址时，ngrok服务端根据映射关系找到客户端，然后转发给客户端的服务https://juejin.cn/post/6844903993911558157?share_token=1b8c42ab-1174-48a2-9122-00e008829d45","categories":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"待分","slug":"待分","permalink":"https://wenkexia.github.io/tags/%E5%BE%85%E5%88%86/"}]},{"title":"Docker学习","slug":"Docker入门","date":"2022-01-05T01:02:52.000Z","updated":"2022-01-05T01:02:52.000Z","comments":true,"path":"2022/010511205.html","link":"","permalink":"https://wenkexia.github.io/2022/010511205.html","excerpt":"","text":"简介Docker 是一个开源的应用容器引擎，基于 GO 语言开发，开发者可以打包应用及依赖包到一个可移植的容器中，然后发布到任何操作系统的机器上，也可以实现虚拟化。 简单理解:Docker就是一个虚拟机，可以让你在一个虚拟的，类似于沙盒的环境下进行环境搭建、软件安装、软件使用、程序编码等操作，并且这个环境是Linux系统。实际上：是在Linux系统下的一种容器，容器技术把一个系统需要的资源划分给一个独立的组(Linux系统下每个组的权限不同，互不干扰)，可以将此看作是一个新的Linux系统，因为它包含了Linux系统所需要的环境。与虚拟机不同的是，虚拟机下的系统是有虚拟硬件的，而Docker内的系统实际上是一个环境。 安装window下安装安装想要使用Docker-desktop首先安装WSL2内核 通过wsl命令将这两个子系统进行迁移docker-desktop：保存的是程序docker-desktop-data: 保存的镜像wsl --help:查看wsl命令提醒 12345678910111213141516#1.查看所有WSL。wsl -l --all -v#2、导出WSL。wsl --export docker-desktop D:\\data\\WSL2\\docker-desktop.tarwsl --export docker-desktop-data D:\\data\\WSL2\\docker-desktop-data.tar#3、注销待迁移WSL。wsl --unregister docker-desktopwsl --unregister docker-desktop-data#4、在新位置导入WSL。wsl --import docker-desktop D:\\data\\WSL2\\docker-desktop D:\\data\\WSL2\\docker-desktop.tar --version 2wsl --import docker-desktop-data D:\\data\\WSL2\\docker-desktop-data D:\\data\\WSL2\\docker-desktop-data.tar --version 2 配置国内源设置-&gt;Docker Engine 1234\"registry-mirrors\": [ \"https://docker.mirrors.ustc.edu.cn/\", \"https://hub-mirror.c.163.com/\"] centos下安装123456789101112131415161718192021222324# 卸载可能存在的旧版本yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine# 安装必要的系统工具yum install -y yum-utils device-mapper-persistent-data lvm2# 配置阿里云Docker Yum源yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# ​ 更新yum缓存yum makecache fast# 安装docker-CE(docker社区版)yum -y install docker-ce# 启动dockersystemctl start docker #查看dockers状态systemctl status docker#设置docker开机自启systemctl enable docker 组成Docker Client：客户端，命令行Docker Daemon：服务端守护进程，接受并处理来自客户端的消息镜像(Image)相当于面向对象编程 类 的概念 一个只读层被称为镜像，一个镜像是永久不会变的。因为 Docker 使用统一文件系统，Docker 进程认为整个文件系统是以读写方式挂载的，由于所有的变更都发生在顶层的可写层，所以下层的原始的只读镜像文件并未发生变化。 12345# 查找镜像docker search mysql#查看已有镜像docker images 拉取镜像123456789101112# 官方镜像docker pull 镜像名称# 个人镜像docker pull 仓库名称/镜像名称docker pull xunmi/django# 第三方仓库拉取docker pull 第三方仓库地址/仓库名称/镜像名称docker pull hub.c.163.com/library/mysql:latest(默认仓库名为library,所有从官方获取镜像相当于`sudo docker image pull library/镜像名称`) 删除镜像1234# 要删除镜像，要先删除其下的容器docker image rm 镜像名或镜像ID 或 docker rmi 镜像名或镜像ID 容器(Container)相当于面向对象编程 对象 的概念 镜像运行后的进程。因为 Docker 的容器实在太轻量级了，很多时候用户都是随用随建，用完即删。 参考 容器状态(STATUS)exited:此时使用start命令可以将容器b1从die状态重新启动为running状态，并进行交互 查看容器(docker ps)123456789# 查看当前所有正在运行的容器docker ps# 查看当前所有的容器docker ps -a 启动和关闭容器123456789101112131415161718192021222324#新建并启动一个容器# 宿主机目录挂载到容器里docker run -d redis:latest -p 6379:6379 redis-server --appendonly yes --name=\"myredis\" docker run -it redis:latest -p 6379:6379 --appendonly yes --name \"myredis\" --requirepass \"123456\"# 重新启动已存在的容器docker start 容器名或容器id#进入容器# -i 表示已交互模式运行容器# -t 为容器重新分配一个伪输入终端docker exec -it 容器ID bash# 停止容器docker stop 容器名或容器id# 强制关闭容器docker kill 容器名或容器id 操作后台容器123# 更改容器名docker rename 容器原来名 要改为的名字 删除容器(docker rm)123docker rm 容器名或容器id 容器制作成镜像1234567# 将容器制作成镜像docker commit 容器名 镜像名# 镜像打包备份(打包备份的文件会自动存放在当前命令行的路径下,如果想让保存的文件可以打开,可以加.tar后缀)docker save -o 保存的文件名 镜像名# 镜像解压docker load -i 文件路径/备份文件 镜像与容器的关系镜像是一个linux虚拟机，容器是启动虚拟机，每次启动的时候，是一个副本，是先把镜像复制一份后直接启动，启动不干扰镜像，一个镜像可以启动无数个容器。 镜像：可以理解为没有运行的程序及其运行所依赖的操作系统文件和依赖库。而容器可以理解为运行中的镜像。其实一个就是程序，一个就是进程。相比普通的程序，多了运行所支持的操作系统文件和依赖库，所以镜像可以随便部署都能以一样状态运行。 Docker 卷可以利用卷来持久化容器内的数据docker inspect CONTAINER ID vscode使用dockerhttps://docs.microsoft.com/zh-cn/visualstudio/docker/tutorials/docker-tutorialVS Code 提供可让你使用本地 Docker 桌面服务的扩展。 可以创建容器化应用，将应用部署到容器，并调试容器上运行的应用。 前提下载安装Docker Desktop 安装 VS Code Remote-WSL 扩展：使你能够在 VS Code 中打开在 WSL 上运行的 Linux 项目（无需担心路径问题、二进制兼容性或其他跨 OS 的难题）。 安装 VS code Remote-Containers 扩展：使你能够打开容器内的项目文件夹或存储库，并利用 Visual Studio Code 的完整功能集在容器中执行开发工作。 安装 VS Code Docker 扩展。 添加了从 VS Code 内生成、管理和部署容器化应用程序的功能。 （需要 Remote-Container 扩展才能实际使用容器作为开发环境。） 使用创建容器1.在 VS Code 中，选择 终端 &gt; 新终端。 2.在终端窗口或 Bash 窗口中运行以下命令。docker run -dp 80:80 docker/getting-started参数 -d 在后台以分离模式运行容器。 -p 80:80 将主机的端口80映射到容器中的端口80。 docker/getting-started 指定要使用的映像。 3.在 VS Code 中，选择左侧的 docker 图标以查看 docker 扩展。 制作镜像制作docker镜像（image），最主要的是编写Dockerfile文件(一种基于文本的说明脚本) 需要在项目根目录创建Dockerfile文件 12345678FROM golang:alpine RUN mkdir /filesCOPY firstDockerImage.go /filesWORKDIR /filesRUN go build -o /files/firstImage firstDockerImage.goENTRYPOINT [\"/files/firstImage\"] 第1行：FROM 说明将要使用的基础镜像来自：golang:alpine （go语言alpine标签的镜像，alpine是阿尔卑斯，一种Linux系统，非常小） 第3行：在Docker镜像中创建一个新目录.【run 开始的命令是在镜像中操作】 第4行：将当前用户目录中的文件 firstDockerImage.go复制到镜像中的 /files目录下 【COPY是从用户复制到镜像】 第5行：修改Docker镜像的当前目录 第6行：run命令，依然是在镜像中执行go build命令，生成firstImage可执行程序。 第7行：指定运行镜像时，将要执行的【镜像中】程序的路径。 在文件资源管理器的 VS Code 中，右键单击 Dockerfile ，然后选择 “生成映像”。 启动应用容器更新代码并替换容器上传到仓库1、使用docker login命令登录docker hub账户 输入自己的用户名和密码。 2、使用docker tag命令给镜像打标签 docker tag image:tag “user/repo:tag” 3、使用docker push命令上传镜像到docker hub docker push “user/repo:tag” 在新的实例上运行映像安装RabbitMQ的Docker环境1234docker pull rabbitmq:3.7-managementdocker run -d --name e3-mall-rabbitmq -p 5672:5672 -p 15672:15672 --hostname e3-mall-rabbitmq -e RABBITMQ_DEFAULT_VHOST=mq_vhost -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -e TZ=Asia/Shanghai rabbitmq:3.7-management","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"容器","slug":"容器","permalink":"https://wenkexia.github.io/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"各平台软件分享","slug":"各平台软件分享","date":"2022-01-04T10:10:17.000Z","updated":"2022-01-04T10:10:17.000Z","comments":true,"path":"2022/010422249.html","link":"","permalink":"https://wenkexia.github.io/2022/010422249.html","excerpt":"","text":"多平台软件海阔视界安卓下载最新版软件地址如下https://haikuo.lanzoux.com/u/GoldRiver 备用地址： https://haikuo.lanzoui.com/u/GoldRiver 如果上面的地址都不可用，可以在公众号(新方圆小棉袄)对话框回复“最新版”这几个字获取新版下载地址。 桌面版airhttps://www.123pan.com/s/fajA-meLQh 规则合集 1海阔视界，空气支持规则合集￥home_rule_url￥https://cdn.jsdelivr.net/gh/Lingyan000/share@main/air-rule-share telegramhttps://telegram.org/ 汉化Telegram的具体方法是在浏览器的网址输入框里输入这个网址：”t.me/zh_CN“，打开页面后，点击”VIEW CHANNEL 隐藏自己的电话号码Telegram注册要使用电话号码，如果设置不当，你电报账号的电话号码可能被别人看到，如果你用国内手机注册，那么如果有关部门能查到你的电话号码，你也就完全暴露了。为防止这种情况，你可以在“隐私和安全”（Privacy and Security）的设置里把你的电话号码设置成完全不可见（或仅联系人可见），并把“谁能通过电话号码找到我”设成我的联系人，而不是所有人。 如果有海外的电话号码（包括虚拟号码如Google Voice等），尽量使用海外号码注册Telegram 频道推荐电报群集合@hao1234bot 【超级索引】：Telegram上的Hao123，频道大全，也有个频道，是发送关键词，然后BOT提供关键词相关群组的机器人。可以拉到群组使用。 @zh_secretary_bot 【TGX-频道秘书】：TGX-索引公告板 @zh_secretary 的群组频道登记机器人，优点：和【TGCN-群组索引计划】差不多，又有可以看群组频道推荐的地方了，缺点：不能通过关键词查找 自定义代理作用：这样就不用打开clash的系统代理也能使用电报设置-高级-网络代理-自定义代理 服务器地址：127.0.0.1 代表本机ip端口：7890 clash默认端口 window软件RSS订阅器下载github RSS订阅[好工具周刊订阅]：https://discuss-cn.bestxtools.com/t/weekly 聚客盒子订阅源：https://jukebox.pipecraft.net/atom/discussions 重复文件查找duplicate file finder 4 pc是一款完全免费的重复文件查找清理工具，这种重复文件查找并不是简单的通过文件名查找，还会根据文件内容本身进行比对，算法非常牛。 https://www.seeksunslowly.com/tss-files-mirror/duplicate-file-finder-free.exe power automate直接在微软商店安装 任意门它可以把电脑上的文件夹或者文件直接映射到公网访问，下载软件双击exe文件就能运行这里映射文件下载速度就取决于你的电脑上传最大速度，文件大小也完全没有限制下载地址https://pan.quark.cn/s/c7e3ca13b73e 备用地址：https://xiaomianao.lanzoum.com/i2HKw022tumb 伪pandownloadhttp://pandownload.net/index.htmlpandownload 一个百度网盘的不限速下载方案：原理简析：百度网盘移动端对.doc(x).ppt(x).pdf等之类的文件会有个预览模式，在预览模式中加载文件到本地是满速的。方法：可运用该原理，将文件重命名并添加上述后缀，点击文件即可进入预览模式，待文件下载完成后再将添加的后缀名删除掉，即可享受原文件。（还没试过） everything本地快速搜索https://www.voidtools.com/zh-cn/ uTools是一个极简、插件化的现代桌面软件，通过自由选配丰富的插件，打造得心应手的工具集合。通过快捷键（默认 alt + space ）就可以快速呼出这个搜索框。你可以往输入框内粘贴文本、图片、截图、文件、文件夹等等，唤出超级面板即可使用插件 插件推荐图床图床管理工具 程序员手册内置了十多个实用离线的中文文档。文档包括Linux、php、Python、Js等，还可以根据需要添加自己的文档，启用需要的文档。 Ctool开发者常用功能 本地搜索 搭配everything食用 批量重命名 在线流程图 Diagram 快速跳转至drawio，用于流程图绘制。 知悉思维导图 一个免费的思维导图插件，用于快速启动知犀思维导图网页，账号和uTools同步。主要是启动方便，而且还免费，市场上还有许多共享的资源。 快捷命令 插件介绍：快速打开软件，网站，运行shell命令等。我个人认为最牛x的还是直接运行代码，几乎支持所有的开发语言，程序员必备，有时候想调试一下代码片段，这个功能最方便了。可以去分享中心安装别人分享的快捷命名，有种逛油猴市场的感觉。 自动化助手 和上文快捷命令相似，只不过这个插件提供了其它实用的功能：图片去背景（removebg），图片一键上传到图床（目前支持路过图床和ＳＭ图床） Excalidraw 在线绘图白板 在线绘图工具，漫画风格非常nice。非常适合用于绘制手稿和灵感！ tinypng压缩图片使用tinypng压缩图片，支持批量操作，鼠标选中，右键快捷操作。 图片聊天 将文字转换为图片 Caesium参考Caesium是一款开源免费的无损压缩工具，它能够在保证图像质量的前提下，最大化压缩图像大小，节省存储空间。 Caesium目前支持Windows和macOS系统，因此，无论你是Windows用户还是macOS用户，都可以体验到它的强大。 Caesium的使用非常简单，直接打开要压缩的图片，选择输出文件夹即可，它支持单幅图压缩，也支持批量压缩。 scrcpy投屏Github地址 使用手机数据线连接电脑后，开启usb调试，自动连接 鼠标右键是返回 要想卸载scrcpy,先在目录下进入cmd,输入adb kill-server,再删除整个scrcpy文件即可 adb功能异常，重启adb（1）把adb服务杀死：adb kill-server（2）重启adb服务：adb reconnect OOAPB通过这个应用程序可以卸载在Windows10/11上预装的应用程序，应用无需安装，个人使用完全免费https://www.oo-software.com/en/ooappbuster 大学出题2022优势：1.编辑题库，2.加入题库，3.生成试卷，4.自动生成答案，5.生成word，6.一键打印。解锁新增试题，修改试题功能，比如你可以新增1000个题目，然后出5个题，系统会自动抽选题目，带答案方便老师改卷。这是目前能找到的比较方便很好的题库软件了，而且是2022新版的。适合：企业内训、小学、初中、高中、大学、培训机构、职业院校等老师的出题工作，由于是独立提取的，无在线题库功能，你们单位找一个专门电脑，所有老师都在里面增加题库内容，然后可以共享题库。非常方便，这是目前能找到的最好的出题软件了！ 可以无上限增加新题 链接：https://pan.baidu.com/s/1MhMUVJCm_T9apOQj8YKDPw提取码：52pj WxDatViewer是一款非常好用的微信dat图片批量解密、查看、整理工具 https://pan.lanzoui.com/b0405repg 系统工具分区微pe工具箱 window激活KWI, KEU 数据恢复WinFR界面版支持在Win/1110、NTFS、FAT、exFAT、ReFS 下从 SSD/HDD/USB/存储卡中恢复丢失的文件。文件手滑意外删除、磁盘格式化、磁盘损坏、中病毒等导致的文件丢失都可以使用这款工具尝试恢复。https://maxiaobang.lanzoup.com/iTnW5yztejg ApowerRecoverhttps://mp.weixin.qq.com/s/W_DHyZFt9j13VuLns8X4ew 安装后，将Crack文件夹中的文件复制到软件安装目录中，即可免费使用了蓝奏云下载：https://idege.lanzouw.com/i6M2Nylj5qf app虚拟引擎 · BlackBox黑盒BlackBox，是一款虚拟引擎，可以在Android上克隆、运行虚拟应用，拥有免安装运行能力。免 root 自带 Xposed 模块https://github.com/FBlackBox/BlackBoxPs：类似太极框架，可以虚拟定位，微X模块等功能太极框架：https://taichi.cool/zh/ mt管理器https://www.mianshigee.com/tutorial/mt-manual/practice.md AidLuxAidLux平台全面覆盖手机、边缘端、终端云等，并且打通手机、电脑、平板、电视、工业自动化控制、机器人成一个统一的平台，实现跨终端无缝协同体验，并且该平台能使用全部安卓应用、Arm环境下的Linux应用，对于智能硬件开发者，不用再面对硬件的复杂性，AI环境的多样性，通过AidLux的智能AI加速模块，实现CPU、GPU、NPU和DSP多种方式的AI加速。 软件特色 各种机器人套件：ROS，PCL点云，Eigen，Protobuf和G2o等多种工具 支持多种开发语言：C/C++，Python,Java,JavaScript，Ruby，PHP，Go，Shell等 丰富Linux软件，AidCode，Git，Mysql，Hadoop，Nigix，Apache，Vim，Ssh，Vscode，Jupyter，积木编程等 扩展性好：内置了极简的外设极速互连模块，通过USB和网络等方式控制Arduino、机械臂、机器人、高清摄像机等 集成主流AI框架(Caffe、Mxnet、Keras、Pytorch、Tensorflow、Ncnn、MindSpore、PaddlePaddle、TNN、Opencv)，无需配置，直接使用 内置丰富的AI案例：人脸识别、人脸关键点识别、肢体识别、手势识别、头发识别、物体分类、物体跟踪、3D检测-、身体交换、人体抠图等 主研发AI智能加速模块，支持CPU+GPU+NPU+DSP加速智能加速，自动适配主流深度学习模型格式，无需格式转换即可自动加速和Forward ……………………………………………… 下载方式: 1.手机各大应用商店搜索AidLux下载 2.百度网盘: https://pan.baidu.com/s/1QYDvCKSl_H-B6YVCqdf8Qg?pwd=1v5y 提取码:1v5y Vmos pro手机虚拟机使用用mt管理器查看虚拟机里的文件 SD Maid支持卸载残留扫描、系统/应用缓存清理、文件管理、应用管理、提取安装包、重复文件扫描、查看存储信息等。 ZArchiver安卓上最强的压缩/解压缩应用，有这一个就够了。基本上我们能用到的所有格式压缩包都可以处理。支持带密码的压缩包、分卷解压、免解压预览、自定义界面、文件管理等。 图叨叨宫格切图、模板拼图、以图搜图、电影台词、图片水印、图片打码、压缩裁剪、网页截图、动图制作、图片边框、图文卡片、手持弹幕等。 而且无广告、无后台，相当好用。 便捷下载一款万能手机下载器，简单方便。只要把链接粘贴进去，就可以自动解析下载图片、视频、音频、文档。 还支持音频提取、视频压缩、一键转换网页为 PDF 等。 kiwi brower一款基于Chromium核心的手机浏览器，强大的可扩展性让你轻松安装chrome应用商店里的扩展，真正支持Chrome电脑版插件 Via浏览器[下载]https://viayoo.com/zh-cn/ 参考：https://mp.weixin.qq.com/s/aUBBfdWrzXReW8DRmQ24sA启动秒开，没有杂七杂八的附加功能会自主学习的搜索引擎：Magi：https://magi.com/search?q=via相关插件：http://via-app.cn广告过滤1：https://cats-team.coding.net/p/adguard/d/AdRules/git/raw/main/adguard.txt广告过滤2：https://cats-team.coding.net/p/adguard/d/AdRules/git/raw/main/AdKillRules.txt&nbsp;广告过滤3：https://cdn.jsdelivr.net/gh/DoingDog/xXKiller@main/w.txt&nbsp; 李跳跳v1.75原文 【软件链接】 https://wwn.lanzoul.com/iKcrtywtuhc 密码:3m3m 两仪原文 一个免 ROOT 的 Android 系统级容器 【下载地址】 百度网盘: https://pan.baidu.com/s/1tRFnXwc2An4pLNn0gmNvew?pwd=anlu提取码:anlu 微云:https://share.weiyun.com/3vUDEtdN 天翼:https://cloud.189.cn/t/N77Vn2Eb2YZv 迅雷:https://pan.xunlei.com/s/VMtzo7gpJ2nEJFrH-MTa9HtNA1 提取码：z2za 太极关注 虚拟框架微信公众号即可发现全部内容 太极是一个无需Root，无需解释Bootloader，也不需要刷机就能使用 Xposed 模块的一个APP。太极拥有无需刷机、无需解锁、使用简单的优点，支持目前大部分xposed模块，该应用搭配各种xpose模块使用时，可以让你的应用程序拥有强大的功能。 太极v9.0.1下载链接 模块下载最全模块下载模块更新 3000Xposed [wx密友]http://dl.dimensionalzone.com/f/19604958-571565583-1e467c [colorqq2]http://dl.dimensionalzone.com/f/19604958-571576448-2f650f [指纹支付]http://dl.dimensionalzone.com/f/19604958-571576615-0048ee [killergram]http://dl.dimensionalzone.com/f/19604958-571577088-64b8c1 [QAuxiliary]http://dl.dimensionalzone.com/f/19604958-571578027-201ba1 [TSBattery]http://dl.dimensionalzone.com/f/19604958-571596194-1f2f5c [xmitools]http://dl.dimensionalzone.com/f/19604958-571603494-0ed2e4 [验证码提取器]http://dl.dimensionalzone.com/f/19604958-571605865-de6041 [叼毛]http://dl.dimensionalzone.com/f/19604958-571606444-be6ef9 [哔哩漫游]http://dl.dimensionalzone.com/f/19604958-571621885-eb978f [大圣净化]http://dl.dimensionalzone.com/f/19604958-571622398-a0796a [wx群消息助手]http://dl.dimensionalzone.com/f/19604958-571622999-f93fa2 [微博猪手]http://dl.dimensionalzone.com/f/19604958-571625557-1c357b [自动记账]http://dl.dimensionalzone.com/f/19604958-571627029-83a724 [联壁模块]http://dl.dimensionalzone.com/f/19604958-571627034-4e7483 [知了]http://dl.dimensionalzone.com/f/19604958-571627042-307820 [抖音伴侣]http://dl.dimensionalzone.com/f/19604958-571627064-37efef AppMgr Pro III5.35原文【免root】需要开启无障碍隐藏应用: 允许您隐藏系统（内置）应用，让隐藏的应用从你的桌面程序列表中消失不见。 冻结应用: 允许您冻结应用，被冻结的应用将不会被启动、执行或使用任何 CPU 或存储，自然也不会消耗任何电力。 应用管理: 可以帮助您管理所安装的应用，例如批次卸载应用，批次移动应用或分享你安装的应用给朋友等等。【下载地址】https://rtkcxzh.lanzouw.com/i8YZSzu9psh Android开发工具箱安卓开发助手它能够用来反编译其他应用、查看其他应用布局和控件信息、快速查看 Activity 历史记录、查看其他应用 Manifest、查看最近使用和最近安装的应用详细信息、提取任何应用 Apk 和 So 文件、调试 【下载链接】：https://wwn.lanzoul.com/igSpq008kxwj【备用链接】：https://wwn.lanzoux.com/igSpq008kxwj 科学https://www.alpacadisk.com/shared/AKYTwnwK5k1fir3V iosTuneProiOS 平台免费听歌 app，曲库很大，一般歌都能听，不支持下载音乐。https://apps.apple.com/cn/app/tunepro-music/id12482625083 苹果快捷指令分享网站https://routinehub.co/相关链接：https://www.rcuts.com/https://applefans.today/category/applefans-classroom/apple-shortcuts/ Userscripts for Safarihttps://www.appinn.com/userscripts-for-safari/Userscripts 就是可以让海量的油猴脚本在 Safari 上运行的脚本管理器，和 Tampermonkey 是一个功能，只不过，它可以在 iPhone 上使用，就很香了。 由于 Userscripts 属于标准的 Safari 扩展，所以在 App Store 安装（Mac/iPhone/iPad）之后，需要前往 Safari 设置中开启扩展，具体路径是： iPhone 系统设置 &gt; Safari 浏览器 &gt; 扩展 &gt; Userscripts： 注意除了打开 Userscripts 之外，在里面的设置中，还需要允许所有网站。注意这里青小蛙尝试过“询问”，但并不成功，所以设置为了允许，如果你有安全顾虑，请谨慎操作。 浏览器插件油猴脚本网页文章转PDF脚本名称：网页限制解除(改)作用：解除网页复制的限制 脚本名称：知乎增强作用：让电脑浏览知乎的时候界面更实用 1、Userscript+一款脚本推荐利器，能够自动帮我们寻找适用于当前网站的所有脚本。AC-baidu-重定向优化去广告、绕过搜索引擎的重定向、自定义网址拦截、添加站点图标、优化搜索结果排版、自动翻页……searchEngineJump 搜索引擎快捷跳转在搜索引擎的输入框下面添加一行快捷菜单。能够快捷地在多个搜索引擎和网站之间进行跳转。支持自定义编辑跳转网站。5、Search By Image以图搜图脚本，内置了 12 个图片搜索引擎， 国内可下载安装Chrome扩展的方法https://www.gugeapps.net/https://www.extfans.com/https://huajiakeji.com/https://www.cnplugins.com/https://www.crx4chrome.com/https://fnd.io/#/https://chrome.zzzmh.cn/#/indexhttps://www.chromefk.com/https://www.yuque.com/eureka007https://crxdl.com/http://blandlifedev.blogspot.com/https://marketplace.visualstudio.com/https://www.chajian5.com/https://173app.com/chrome-exthttps://crxdl.com/https://chrome.zzzmh.cn/#/indexhttps://www.extfans.com/https://www.chromefor.com/http://yurl.sinaapp.com/crx2.php Chrome扩展安装方法1.直接把crx文件拖进扩展管理中心如果顺利，你直接把这个直接拖进 Chrome 扩展程序页面就能安装了2.不过有些时候，你可能会遇到安装 crx 文件报错 这样的话，就用另外一个办法： 在你的文件夹找到这个 crx 文件，确保你打开了文件管理器中的查看「文件扩展名」功能是勾上的 然后对你刚刚下载到的 crx 文件进行重命名，把扩展名改为 zip 然后把这个压缩包解压到一个你不会删除的位置！ 打开 Chrome 扩展程序页面的「开发者模式」 然后「加载已解压的扩展程序」 二管家Chrome 扩展管理工具功能1.根据规则自动开关扩展2.管理扩展3.根据网站推荐扩展4.快速提取CRX 同步书签floccus[地址] https://chrome.google.com/webstore/detail/floccus/fnaicdffflnofjppbagibeoednhnbjhg?utm_source=chrome-ntp-icon[开源地址：] https://github.com/marcelklehr/floccus/[参考教程：] http://chromecj.com/accessibility/2019-07/2622.html 移动的设置和桌面端基本是一样的。但是要注意，教程中的目录设置，桌面端可以选择根，但是移动端不能选择根，要选择移动设备书签。否则无法同步。 WebDAV ：目前支持 「坚果云、nextcloud / owncloud，box」 等 WebDAV 服务器同步 BookmarkHub跨浏览器同步书签它使用 GitHub 的 Gist 记录来存储浏览器的书签，可以放心安全的使用。 获取Github Token登录Github选择“设置-开发者设置-生成新token”，这里记得勾选Gist，然后点击“生成token”即可。 获取Gist ID这里new gist 进入对应的网页之后，输入描述、文件名、内容，这里可以随便输入即可，然后点击创建私有Gist。这时，在地址栏可以看到，URL的尾部就是Gist ID。从4a开始 配置插件点击插件的设置添加信息 Unpaywal当你浏览一篇学术文章时，Unpaywall会从2000万个免费合法的文献库里索引一个PDF副本，如果找到对应的文章，会在侧边出现一个绿色按钮，点击按钮就可以阅读或者下载全文。 WeChatSync（微信公众号同步助手）原文：https://mp.weixin.qq.com/s/oTMc_t_f65ITyTgy4Wdg9g是一款将微信文章同步到知乎， B站，微博，豆瓣，百家号， 简书， 头条号，搜狐号， 大鱼号， 一点资讯， Cnblog， CSDN， 51CTO， 掘金， 慕课网-手记， 开源中国，Typecho，WordPress等许多平台。 automa 自动化处理重复工作原文：https://mp.weixin.qq.com/s/ARID9OYRGcLLWGKT4BSd8QAutoma v0.5.1https://www.123pan.com/s/HQeA-EN1Sh Global Speed: 视频速度控制 支持0.25~16倍速的视频加速播放。而且它能用到的场景很多，比如某奇艺等平台的开头广告，直接点击16倍数，几秒就跳过去了。 ViolentMonkey 让你的Chrome可以使用油猴脚本（相比 Tampermonkey、GreaseMonkey 更为简洁方便） Nimbus一个网页版的多功能截图工具，提供了类似区域截屏、可滚动截屏、延迟截屏等等，花式截屏的小功能，甚至还可以帮你录制视频。 网站分享好用的网站https://hyperbeam.com/注册好账号登录后，需要你创建一个房间，然后把房间链接分享出去就能和远在异地的女朋友交流了，支持文字、GIF、视频、语音通话。 搜索引擎fsou.cc搜索结果排除了百度和搜狗的结果，30%来自Google，30%来自必应，其余的40%来自其他的搜索渠道。 系统密钥分享：https://pkeytools.azurewebsites.net/ShareKeys 设计改图鸭网站提供图片压缩、图片编辑、图片转文字等功能https://www.gaituya.com/用卷积神经网络把小而糊的图片进行放大，支持降噪处理，http://waifu2x.udp.jp/可快速将 JPG、PNG 等格式的图片快速转换为 SVG 矢量图https://www.visioncortex.org/vtracer/ 世界各地的朋友在这里分享他们的桌面布置灵感https://www.makerstations.io/为大家介绍创意相关工作者的工作桌面摆设情况https://www.workspaces.xyz/ 东京大学发布的一款工具 ：paper-digest可利用 AI 为每篇论文生成摘要，将阅读时间缩短为 3 分钟目前该工具仍处于初级阶段，生成的论文摘要仅供参考，深入研究最好还是阅读论文原稿。https://www.paper-digest.com/ 清华大学计算机系课程攻略https://rekcarc-tsc-uht.readthedocs.io/en/latest/https://github.com/PKUanonym/REKCARC-TSC-UHT spider-flow一个无需写代码的爬虫平台https://www.spiderflow.org/https://github.com/ssssssss-team/spider-flow Kmonad，一个自由改变键盘布局的软件可以让你无限地定制和扩展几乎所有键盘功能，包括改建、配置组合键等功能https://www.appinn.com/kmonad/ 用 Fruition + Notion 搭建个人网站DEMO: https://fruitionsite.com/GitHub: https://github.com/stephenou/fruitionsite作者主页： https://stephenou.com/教程：https://the-block.club/Fruition-Notion-e05ddf4392744a8a819a30ac7952520b 2021年【思维导图】盒子，C/C++，Golang，Linux，云原生，数据库，DPDK，音视频开发，TCP/IP，数据结构，计算机原理等https://github.com/0voice/learning_mind_map extract.pics？ Extract.pics 是一个易于使用的工具，允许您从任何公共网站提取、查看和下载图像。只需将网站的 URL 粘贴到输入字段中，然后单击“提取”即可开始该过程。 fffuel：设设设计用的小工具集合 官网 https://fffuel.co/ fffuel 是一个「即将推出」Html 模板的集合网站。除了网页模板，还提供了一些在网页设计中会使用到的工具 ssshape https://fffuel.co/ssshape/ ：矢量形状生成器在画布上添加几个点，点击 ssshape，会自动闭合所有点并对其形状进行平滑处理，最终得到一个边缘平滑的 SVG 形状 llline https://fffuel.co/llline/ ：矢量线段生成器在画布上添加几个点，点击生成后便能得到一条光滑的曲线，然后你可以旋转角度、改变它的颜色以及线段的形态 bbburst https://fffuel.co/bbburst/ ：图形散落分布以往想要制作一个「图形散落」风格的背景图，大多是通过喷枪或逐个逐个放置而成，过程比较繁琐。bbburst 可以帮你在预设的几个图形中，自动生成一张「图形散落」风格的图片 nnnoise https://fffuel.co/nnnoise/ ：「杂色」纹理生成器利用 nnnoise，可以生成一些「杂色」纹理，搭配上你想要的风格，或许别有一番滋味 dddoodle https://fffuel.co/dddoodle/ ：「极其」手绘风格的插图dddoodle 是一套手绘的 doodle 插图，其中有线段、箭头、圆形、星星以及一些有趣的形状，均为 CC 协议 ✅ rrready https://fffuel.co/rrready/ ：CSS 特性兼容列表不同浏览器支持不同 CSS 特性，这个问题长期困扰着开发者，利用 rrready 可以查看要使用到的 CSS 特性在不同浏览器中是否能够达成一致的效果 cccolor https://fffuel.co/cccolor ：选色器除了能够利用色盘、哈希值选取到想要的颜色，cccolor 还会为你生成匹配该颜色的相似色调、适合作为其阴影的颜色，及与其匹配的冷暖色调 ffflux https://fffuel.co/ffflux/ ：流体渐变生成器流体渐变带来的冲击力会比普通渐变色更强，色彩也更加丰富，或许能让你的设计更加活跃 lllook https://fffuel.co/lllook/ ：你想要什么表情lllook 是一套面部的简笔画表情包，比 emoji 丰富得多，也更加有趣 除了这些小工具，fffuel 的作者 Seb https://sebseb.co/ 还有其它有趣的项目，不妨去看看，其中我比较喜欢的是 muted https://muted.io/ 和 rrrelax https://rrrelax.app/ ，这里还有他整理的一些 设计小工具 https://cccreate.co/ 程序员学习网站原文 中国大学MOOC中国大学MOOC原名ICOURSE（爱课程），是教育R部和网易共同合作发布的一个互联网教育平台，旨在推动高等教学资源共享，让大家能免费享受许多985及TOP名校课程。绝大部分领域均有免费国家精品课程，资深教授授课！蹭网课必备！ 网址：https://www.icourse163.org/ 中国国家图书馆中国国家图书馆，收录绝对够全！只有你想不到，没有你搜不到，想要的资料应有尽有，还可以在线阅读~ 无论专业书籍还是人文书籍，均可搜索得到，还配有其ISBN账号，配合某盘资源可以进行pdf搜索下载！ 网址：http://www.nlc.cn/ B站B站不再是一个看番刷鬼畜的地方，学习课程越来越多，你想学的东西基本都可以在这里找到~ 网址：https://www.bilibili.com/ W3CW3School，一个全球最大的中文 Web 技术教程。在 W3School，你可以找到你所需要的所有的网站建设教程。从基础的 HTML 到 CSS，乃至进阶的 XML、SQL、JS、PHP 和 ASP.NET。 网址：https://www.w3school.com.cn/ 菜鸟教程和W3C性质差不多，都是提供各种基础编程教程，可以让你在短时间内实现从0到1的质的飞跃！ 网址：https://www.runoob.com/ MDNMDN Web Docs 站点提供有关开放 Web 技术的信息，包括用于 Web 站点和渐进式 Web 应用程序的 HTML、CSS 和 API。面向Web开发者的文档，权威教程。 网址：https://developer.mozilla.org/zh-CN/docs/Web 掘金掘金是一个帮助开发者成长的社区,是给开发者用的 Hacker News,给设计师用的 Designer News,和给产品经理用的 Medium。有不少技术大牛和极客们在输出优质干货。 网址：https://juejin.cn/ GithubGitHub 是世界上最大的代码托管平台。如果说 P***Hub 对于宅男来说是神一般的存在，那么 GitHub 对于程序员来说是永远滴神！ 网址：https://github.com/ 慕课网慕课网（IMOOC）是IT技能学习平台。慕课网(IMOOC)课程涉及JAVA、前端、Python、大数据等60类主流技术语言，覆盖了面试就业、职业成长、自我提升等需求场景，帮助用户实现从技能提升到岗位提升的能力闭环。 网址：https://www.imooc.com/ 张鑫旭的博客博客语言以简单明了著称，擅长深入挖掘css技巧及内部实现机制。 https://www.zhangxinxu.com/wordpress/ The Odin ProjectOdin 项目使有抱负的 Web 开发人员能够免费一起学习 网址：https://www.theodinproject.com/paths/foundations/courses/foundations angularJS学习资源合集一个 angularJS 资源大全 网址：https://angularjs.zeef.com/gianluca.arbezzano 30 seconds of code当你打开这个网站时，你会发下自己捡到宝了，这个网站分享了1084个有用的简短代码片段,你可以在30秒或更少时间中理解,满足开发者绝大多数开发需求 网址：https://www.30secondsofcode.org/ JS Tips这是一个分享 JavaScript 小技巧的网站,让读者提升撰写代码的能力.每天花不到 2 分鐘，你可以阅读到关于效能、习惯、技术、面试问题以及所有 JavaScript 相关知识 网址：https://www.jstips.co/zh_CN/javascript/ 如何跟上前端开发的最新前沿这是一个帮助前端学子们了解最新推出的工具, 最新的潮流以及开发流程的网站 网址：https://uptodate.frontendrescue.org/zh/ JS RunJSRUN.NET 一个极具活力的代码在线运行平台。有专业的HTML/CSS/JS在线调试工具，适用前端工程师的开发和学习。同时还有C语言、Java、PHP、Python等代码在线编译运行工具 网址：https://jsrun.net/ CodepenCodepen是一个完全免费的前端 Web 开发的在线代码编辑器、学习环境和社区，汇集了大量的优秀前端作品，很多大佬的作品都会上传到这里。 网址：https://codepen.io/ ES6 入门教程《ECMAScript 6 入门教程》一本由阮一峰老师撰写开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。这本书主要引导你进入 React 和 Webpack 世界。 网址：https://es6.ruanyifeng.com/ Stack OverflowStack Overflow 作为全球最大的技术问答网站，几乎没有你找不到的问题 网址：https://stackoverflow.com/ SegmentFaultSegmentFault 思否是中国领先的开发者技术社区。国内风靡的程序员社区，以技术问答、技术专栏、技术课程、技术资讯为核心的产品形态,为开发者提供纯粹、高质的技术交流平台。 网址：https://segmentfault.com/ LeetCodeLeetCode 是一个非常棒的OJ（Online Judge）平台，收录了许多互联网公司的算法题目，被称为刷题神器 网址：https://leetcode-cn.com/ LintCode这个网站可算是个面试的“作弊神器”吧，因为上面有很多国内外大厂面试真题，里面大厂面试真题还挺多的，而且会定期更新，跳槽前可以看一看~ 网址：https://www.lintcode.com/ 程序员一站式导航这个导航站提供了最精华有趣的内容，根据分类可以找到你所需要的站点、工具，能够节省不少时间~ 网址：https://cxy521.com/ 提高web前端开发效率的网站Animista地址：https://animista.net/Animista 是一个简单的 CSS 动画库网站。您可以测试和使用现成的 CSS 动画，也可以下载它们的代码。Web 开发人员一定要上的网站，这个对您提升开发效率非常有帮助。 Ray.so地址：https://ray.so/此网站可以将让您制作的精美图像进行源代码的分享。它支持几乎所有的编程语言格式。您可以设置背景、颜色、字体等。一定要试试这个网站。 FontAwesome地址：https://fontawesome.com/ 如果您在为您的项目寻找一些很棒的图标，您可以访问 FontAwesome 下载任何项目的免费图标。 Jsfiddle地址：http://jsfiddle/ Jsfiddle 是代码编辑器，您可以在其中通过实时预览测试 JavaScript、CSS、Html 代码。该网站是 Web 开发人员的便捷工具。 Unscreen地址：https://www.unscreen.com/ Unscreen 是一个帮助您去除视频背景的网站。它用于制作无背景视频。必须尝试该网站。 Dev Samples地址：https://www.devsamples.com/此网站是您可以自由复制粘贴到项目中的代码集合网站。该网站的重点是 Web 开发人员的源代码。Dev Samples 对新手开发人员来说很方便。 Readme.so 地址：https://readme.so/ Readme.so 是一个在线自述文件制作，可帮助开发人员为其项目创建自述文件。大多数开发人员使用readme.so为其 Github 项目创建自述文件。 ScreenShot.rock地址：https://screenshot.rocks/ Screenshot Rock 是一个可以创建漂亮的移动和浏览器屏幕截图的地方。您只需要上传任何屏幕截图，它就会为浏览器提供移动框架触摸功能。 Undesign地址：https://undesign.learn.uno/ Undesign 是设计工具、插图、开发人员和设计师的源代码、制造商资源等的免费集合。一定要试试这个网站。 Coolors地址：http://coolors/ Coolors 是我推荐的颜色组合网站。每次按“空格键”时，它都会生成新的颜色组合。 参考 服务器和网站在线测速工具http://ping.pehttps://www.ping.cn/站长工具https://ping.aizhan.com阿里云网站运维检测平台 写论文可以用到的网站： 国家哲学社会科学文献中心： www.ncpssd.org现有中文期刊、外文期刊、古籍等资源，收录哲学社会科学相关领域文献共计10,000,000余条，提供有线阅读、全文下载等服务。 文津搜索： find.nlc.cn国家图书馆资源检索，汇聚了60多个资源库、近2亿条文献信息，可以查询包括图书、古文献、论文、期刊报纸、多媒体等在内的多种资料。 术语在线： www.termonline.cn一个可以查询专业术语的在线网站，非常权威，内容更新也很及时。 科塔学术： site.sciping.com学术导航网站，整理了许多论文搜索网站、学术工具、科研软件、期刊出版等，每一个都有细致的分类，并归纳了对应的网站。 Academic Phrasebank： www.phrasebank.manchester.ac.uk论文写作助手，这个网站主要提供论文各部分的模版，如介绍怎么写，总结怎么写，如何描述方法，报告细节等，对非英语母语作者非常有帮助。 iData： www.cn-ki.net一个知网镜像站，可以免费下载论文，知网比较新的没有，每天有免费下载限额。 SCI-Hub： sci-hub.com这个网站就不多介绍了，一个超棒的免费下载论文的网站，输入文献doi号即可搜索下载。 OALib： www.oalib.com目前收录了570万篇学术论文，涵盖多个领域，所有文章均可免费下载，是一个较为高效的论文查找网站。 研享网： www.academicshare.cn检索下载英文文献的利器，页面超级干净，支持关键词、题目、论文doi搜索。 Medsci： www.medsci.cn/sci期刊智能查询系统，支持模糊查询，每一个期刊还有对应的论坛。 Connected Papers： www.connectedpapers.com文献调研必备神器，它可以在线进行分析文献的引文信息，轻松了解某篇文献的引用和被引用关联，分析出文献的前世今生，方便我们对一篇文献或者某个领域进行调研。 近邻词汇检索： tool.mingdawoo.com可免费查找近似短语和相关术语，词穷的时候可以看看。 秘塔写作猫： xiezuocat.com可以校对中文字词错误、标点错误、语序错误、语法问题、同意混淆等，并给出修改建议，支持全文分析和智能排版，免费版基本上能满足日常需求。 Grammarly： www.grammarly.com英文语法错误查询好助手，可以安装为word插件，在你写作的时候就可以纠正你的语法错误了。 知犀思维导图： www.zhixi.com免费好用的论文大纲整理工具，可以借助这个工具做论文大纲。这个网站还提供许多思维导图模板，包括工作方法、考研考证的资料、管理方法、科普知识等方面的模板。 词云统计： cloud.niucodata.com在线中文词汇统计和分析工具，可以帮助用户分析一段话中的词性分类、词频统计并生成词云图。 Linggle： www.linggle.com提供英文常用语、搭配、近义词等检索，可以根据词性来推测完整搭配，还能帮助学习者分析出更准确的英文写作建议。 Netspeak： netspeak.org这个网站也是词汇，不过是用来查找你记不太清楚的词汇，比如congratulations，你不记得全部拼写了，你就可以在这个网站上来查一下。 Linguee： cn.linguee.com一个全能的在线多语言互译平台，提供24种语言的对应查询服务，而且还收集了数亿条译文例句，无论是日常领域的术语，还是专业难度偏大的词汇，在这里都能找到专业的翻译方式。 DocTranslator： www.onlinedoctranslator.com可免费在线翻译文档，支持109种不同语言文档任意转换，并保持排版不变。操作简单，直接上传文档就可以。 学习用CSDN：https://www.csdn.net/ TED（最优质的演讲）： https://www.ted.com/ 谷粉学术： https://gfsoso.99lb.net/scholar.html 大学资源网：http://www.dxzy163.com/ 简答题：http://www.jiandati.com/ 网易公开课：https://open.163.com/ted/ 网易云课堂：https://study.163.com/ 中国大学MOOC：www.icourse163.org 哔哩哔哩弹幕网：www.bilibili.com 我要自学网：www.51zxw.net 知乎：www.zhihu.com 学堂在线：www.xuetangx.com 爱课程：www.icourses.cn 猫咪论文：https://lunwen.im/ iData（论文搜索）：www.cn-ki.net 文泉考试：https://www.wqkaoshi.com 编程题库网(大厂最热题库列表) https://94tiku.com 找书籍用书栈网（极力推荐）：https://www.bookstack.cn/ 码农之家（计算机电子书下载）： www.xz577.com 鸠摩搜书：www.jiumodiary.com 云海电子图书馆：www.pdfbook.cn 周读（书籍搜索）：ireadweek.com 知轩藏书：http://www.zxcs.me/ 脚本之家电子书下载： https://www.jb51.net/books/ 搜书VIP-电子书搜索： http://www.soshuvip.com/all.html 书格（在线古籍图书馆）： https://new.shuge.org/ caj云阅读： http://cajviewer.cnki.net/cajcloud/ 必看网（人生必看的书籍）： https://www.biikan.com/ 冷知识 / 黑科技上班摸鱼必备（假装电脑系统升级）：http://fakeupdate.net/ PIECES 拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）： http://www.species-in-pieces.com/ 图片立体像素画： https://pissang.github.io/voxelize-image/ 福利单词（一个不太正经的背单词网站）： http://dict.ftqq.com 查无此人（刷新网站，展现一张AI 生成的人脸照片）： https://thispersondoesnotexist.com/ 在线制作地图图例：https://mapchart.net/ 创意光线绘画：http://weavesilk.com/ 星系观察：https://stellarium-web.org/ 煎蛋：http://jandan.net/ 渣男-说话的艺术：https://lovelive.tools/ 全历史：https://www.allhistory.com/ iData：https://www.cn-ki.net/ 术语在线：http://www.termonline.cn/ 写代码用GitHub：https://github.com/ 码云：https://gitee.com/ 源码之家：https://www.mycodes.net/ JSON to Dart： https://javiercbk.github.io/json_to_dart/ Json在线解析验证： https://www.json.cn/ 在线接口测试（Getman）： https://getman.cn/ 资源搜索用DogeDoge搜索引擎：www.dogedoge.com 秘迹搜索：https://mijisou.com/ 小白盘：https://www.xiaobaipan.com/ 云盘精灵（资源搜索）： www.yunpanjingling.com 虫部落（资源搜索）： www.chongbuluo.com 如风搜（资源搜索）： http://www.rufengso.net/ 爱扒：https://www.zyboe.com/ 各种小工具奶牛快传（在线传输文件利器）：cowtransfer.com 文叔叔（大文件传输，不限速）： https://www.wenshushu.cn/ 云端超级应用空间（PS，PPT，Excel，Ai）：https://uzer.me/ 香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）： https://www.xiangdang.net/ 二维码生成：https://cli.im/ 搜狗翻译：fanyi.sogou.com 熵数（图表制作，数据可视化）： https://dydata.io/appv2/##/pages/index/home 拷贝兔：https://cp.anyknew.com/ 图片无限变放大：http://bigjpg.com/zh 幕布（在线大纲笔记工具）：mubu.com 在线转换器（在线转换器转换任何测量单位）：https://zh.justcnw.com/ 调查问卷制作： https://www.wenjuan.com/ 果核剥壳（软件下载）： https://www.ghpym.com/ 软件下载：https://www.unyoo.com/ MSDN我告诉你（windows10系统镜像下载）：https://msdn.itellyou.cn/ 网站工具箱https://www.67tool.com/ https://tools.miku.ac/功能：收款码合并 导航页（工具集）世界各国网址大全： http://www.world68.com/ 小森林导航：http://www.xsldh6.com/ 简捷工具：http://www.shulijp.com/ NiceTool.net 好工具网： http://www.nicetool.net/ 现实君工具箱（综合型在线工具集成网站）：http://tool.uixsj.cn/ 蓝调网站：http://lcoc.top/ 偷渡鱼：https://touduyu.com/ 牛导航：http://www.ziliao6.com/ 小呆导航： https://www.webjike.com/index.html 简法主页：http://www.jianfast.com/ KIM主页：https://kim.plopco.com/ 聚BT：https://jubt.net/cn/index.html 精准云工具合集： https://jingzhunyun.com/ 兔2工具合集：https://www.tool2.cn/ 爱资料工具（在线实用工具集合）： www.toolnb.com 工具导航：https://hao.logosc.cn/ 音乐将加密的音乐文件转为可播放的 mp3 文件。目前支持网易云音乐 (.ncm) 、QQ 音乐 (.qmc, .mflac, .mgg) 、酷狗音乐 (.kgm) 、虾米音乐 (.xm) 、酷我音乐 (.kwm) 等格式。项目提供了网页版 浏览器扩展 Docker 和命令行版 等多种使用方式，所有转换都在本地进行，无需担心隐私问题。网页版：https://demo.unlock-music.dev/项目地址：https://github.com/unlock-music/unlock-music代码仓库：https://git.unlock-music.dev/um/web 看视频用阿木影视：https://www.aosk.online/ 电影推荐（分类别致）： http://www.mvcat.com APP影院：https://app.movie 去看TV：https://www.qukantv.net/ 动漫视频网：http://www.zzzfun.com/ 94神马电影网：http://www.9rmb.com/ NO视频官网：http://www.novipnoad.com/ 蓝光画质电影：http://www.languang.co/ 在线看剧：http://dy.27234.cn/ 大数据导航：http://hao.199it.com/ https://qzy998-1.ysgq.xyz/ 片库：https://www.mypianku.net 奈飞中文电影站：https://yanetflix.com 剧嗨：https://www.juhi.cc 555电影网：https://www.o8tv.com Tubitv：https://tubitv.com 片源：http://pianyuan.org/影视导航网站：http://www.549.tv/片吧 https://www.pianba.net/低端影视 https://ddrk.me/片库 https://www.pianku.li/七七看片 https://www.77kpp.com/旋风视频 https://miao101.com/体育直播：https://feisuzhibo.comBD影视分享 https://www.bd2020.com/一刻电影 http://www.yikedy.co/影视教程 https://www.yuque.com/eureka007/ziyuan/rnezaq VIP视频解析网站365t在線免費解析觀看系統http://vip.365tol.top/BL智能解析https://vip.bljiex.com/BL解析-Vip视频在线解析https://vip.bljiex.cc/TVB云播全网VIP视频解析：http://vip.tvyb10.com/Playm3u8解析-PC和手机全无广告!https://www.playm3u8.cn/jiexi.php?url=诺讯全网视频在线解析无广告https://www.nxflv.com/?url=天翼解析https://jsap.attakids.com/?url=kingtail智能解析 https://jx.kingtail.xyz/?url= 在线动漫网站汇总ZzzFun动漫 http://www.zzzfun.com/樱花动漫 http://www.yinghuacd.com/AGE动漫 https://www.agefans.vip/動畫線上看 https://anime1.me/嘀哩嘀哩 https://www.dilidili55.com/哈哩哈哩 http://halihali4.com/ 学设计用码力全开（产品/设计师/独立开发者的资源库）：https://www.maliquankai.com/designnav/ 免费音频素材：https://icons8.cn/music 新CG儿（视频素材模板，无水印+免费下载）： https://www.newcger.com/ Iconfont（阿里巴巴矢量图标库）： https://www.iconfont.cn/ 小图标下载：https://www.easyicon.net/ Flight Icon：https://www.flighticon.co/ 第一字体转换器：http://www.diyiziti.com/ doyoudosh（平面设计）： www.doyoudo.com 企业宣传视频在线制作：https://duomu.tv/ MAKE海报设计官网：http://maka.im/ 一键海报神器： https://www.logosc.cn/photo/utm_source=hao.logosc.cn&amp;utm_medium=referral 字由（字体设计）： http://www.hellofont.cn/ 查字体网站：https://fonts.safe.360.cn/ 爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）：http://www.aigei.com/ 在线视频剪辑： https://bilibili.clipchamp.com/editor 搞文档用即书（在线制作PPT）： https://www.keysuper.com/ PDF处理：https://smallpdf.com/cn PDF处理：https://www.ilovepdf.com/zh-cn PDF处理：https://www.pdfpai.com/ PDF处理：https://www.hipdf.cn/ 图片压缩，PDF处理： https://docsmall.com/ 腾讯文档（在线协作编辑和管理文档）： docs.qq.com ProcessOn（在线协作制作结构图）： www.processon.com iLovePDF（在线转换PDF利器）： www.ilovepdf.com PPT在线制作：https://www.woodo.cn/ PDF24工具（pdf处理工具）： https://tools.pdf24.org/en IMGBOT（在线图片处理）： www.imgbot.ai 福昕云编辑（在线编辑PDF）： edit.foxitcloud.cn TinyPNG（在线压缩图片）：tinypng.com UZER.ME（在线使用各种大应用，在线使用CAD，MATLAB，Office三件套 ）：uzer.me 优品PPT（模板下载）： http://www.ypppt.com/ 第一PPT（模板下载）： http://www.1ppt.com/xiazai/ 三顿PPT导航：sandunppt.com Excel函数表： https://support.office.com/zh-cn/article/excel-%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89-b3944572-255d-4efb-bb96-c6d90033e188 图片图像处理Magic Eraser，中文名为魔术橡皮擦，是一款免费的 AI 工具，可在几秒钟内删除图像中不需要的东西。你只需要上传图片，标记需要删除的位置，平台将快速智能处理，然后将处理后的图片下载到本地即可，一切都在几秒钟内完成！https://www.magiceraser.io/ 在线图片高清化https://bigjpg.com/ 壁纸wallhavenhttps://wallhaven.cc/ 极简壁纸https://bz.zzzmh.cn/index 电脑壁纸：http://lcoc.top/bizhi/ https://unsplash.com/ https://pixabay.com/ https://www.pexels.com/ https://visualhunt.com/ https://www.ssyer.com/ 彼岸图网：http://pic.netbian.com/ 极像素（超高清大图）： https://www.sigoo.com/ 免费版权图片搜索： https://www.logosc.cn/so/ 多功能图片网站：https://www.logosc.cn/so/ 牛牛TV：http://www.ziliao6.com/tv/ VideoFk解析视频： http://www.videofk.com/ 蓝调网站：http://lcoc.top/vip2.3/ 永久资源采集网： http://www.yongjiuzy1.com/","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://wenkexia.github.io/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"github","slug":"github","date":"2022-01-01T04:01:32.000Z","updated":"2022-01-01T04:01:32.000Z","comments":true,"path":"2022/010114187.html","link":"","permalink":"https://wenkexia.github.io/2022/010114187.html","excerpt":"","text":"加速访问GitHub参考文章参考 基础知识 DNS能帮你在访问域名的时候查到实际的IP地址Github 在全球各地都有服务器，而在国内，DNS解析服务基本上都是把域名解析到了美国的服务器，所以访问起来会比较慢但我们可以通过修改本地 hosts 文件来绕过公共DNS解析，直接访问 Github 在韩国、日本等的服务器，从而达到加速访问的目的 hosts 文件就相当于本地通讯录，你的通讯录里面记了公司的电话。 steamcommunity 302（WIN）羽翼城大佬后来又开发的 steamcommunity 302 就是通过反代来加速访问 Github 等网站 软件可以到这里下载：https://www.dogfight360.com/blog/686/比较棘手的是可能会出现80／443端口被占用的情况，这个需要关闭对应监听端口的进程／服务来解决，具体教程可见羽翼城大佬在下载页面做出的说明 FastGithub（WIN／Mac／Linux）FastGithub 则是另一款同样基于反代来加速 Gtihub 访问的工具，支持WIN／Mac／Linux三端，还能在docker上一键部署：https://github.com/dotnetcore/FastGithub Windows端的话，下载后双击即可运行，软件没有程序界面，直接就是跑的命令行，所以开启之后不要关闭命令行窗口！ 而 FastGithub 除了可以加速访问 Gtihub ，最大的优势是它顺便还能助你直连V2EX 网易UU加速器网易在一款游戏加速器里面竟然还提供了Github网站访问加速 修改本地hosts1.打开本地host文件C:\\Windows\\System32\\drivers\\etc在这个项目https://github.com/521xueweihan/GitHub520复制添加内容到本地host2.更新DNS缓存 FasterHosts谷歌插件1.在Chromium内核的浏览器上，你可以安装FasterHosts这款浏览器扩展来解决：https://github.com/gauseen/faster-hosts 2.FasterHosts的 hosts 资源就是来自 GitHub520，每 1 小时更新一次，所以你无需配置，一装好之后就可以用 FastGithub下载地址GitHub：https://github.com/dotnetcore/FastGithub 清华网盘：https://cloud.tsinghua.edu.cn/d/df482a15afb64dfeaff8/ 软件功能提供域名的纯净IP解析； 提供IP测速并选择最快的IP； 提供域名的tls连接自定义配置； Google的CDN资源替换，解决大量国外网站无法加载js和css的问题； SwitchHosts软件1.这个工具来实现自动更新 hosts 中的IP地址2.我们先到 SwitchHosts 官网下载这款管理工具：https://swh.app/zh/3.下载安装好SwitchHosts之后标题随意取，URL地址填这个：https://raw.hellogithub.com/hosts4.自动刷新最好建议选1小时5.点击确认后，还要手动启用一下，接着稍等片刻本地 hosts 即会更新 UsbEAm Hosts Editor软件下载 上传本地文件到githubgithub在线上传文件夹在线上传也可以上传完整的文件夹结构，直接拖拽到上传文件页面的框 通过git工具上传本地文件夹（本地项目）跳转git使用文章 项目推荐Awesome GitHub RepoAwesome GitHub Repo 是逛逛 GitHub 创建的开源项目，会收集整理 GitHub 上高质量、有趣的开源项目，并将他们进行归类。地址：https://github.com/Wechat-ggGitHub/Awesome-GitHub-Repo 新一代爬虫平台平台以流程图的方式定义爬虫，是一个高度灵活可配置的爬虫平台。新一代爬虫平台，以图形化方式定义爬虫流程，不写代码即可完成爬虫。开源地址：https://github.com/ssssssss-team/spider-flow 开发者技术路线技术发展日新月异的，行业也是瞬息万变。技术迭代更新，有没有一个不断更新的指南，为技术进阶之路指一条明路？这个 GitHub 项目就是，它为前端、后端、DevOps等开发着准备可详细的技术路线图。 开源地址：https://github.com/kamranahmedse/developer-roadmap 自学编程之路Python 开源项目之「自学编程之路」，保姆级教程：AI实验室、宝藏视频、数据结构、学习指南、机器学习实战、深度学习实战、网络爬虫、大厂面经、程序人生、资源分享。 开源地址：https://github.com/Jack-Cherish/PythonPark","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://wenkexia.github.io/tags/GitHub/"}]},{"title":"数据库-mysql","slug":"数据库-mysql","date":"2021-12-31T17:12:58.000Z","updated":"2021-12-31T17:12:58.000Z","comments":true,"path":"2022/010151482.html","link":"","permalink":"https://wenkexia.github.io/2022/010151482.html","excerpt":"","text":"安装docker下安装 Mysql1234567891011#创建容器并后台启动# --name 后面是这个镜像的名称# -p 3306:3306 表示在这个容器中使用(第二个)端口映射到本机的端口号(第一个)# -d 表示使用守护进程运行，即服务挂在后台# -v 表示挂载数据卷，格式是-v localPath:containerPath 本地目录:容器目录docker run -d mysql:latest -p 3306:3310 --name mysqlll -e MYSQL_ROOT_PASSWORD=1234docker run --name mysqll -p 3306:3310 -e MYSQL_ROOT_PASSWORD=Lzslov123! -d mysql:latest# 查看容器docker ps -a# 进入容器docker exec -it ID bash window下安装下载https://dev.mysql.com/downloads/mysql/ 下载完后，我们将 zip 包解压到相应的目录，这里我将解压后的文件夹放在D:\\ruanjian\\mysql-8.0.28-winx64 配置MySQL 的配置文件在安装目录下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息： 1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\\\web\\\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 环境变量新建系统变量MYSQL_HOME，变量值为你的安装目录D:\\ruanjian\\mysql-8.0.28-winx64在系统变量里，找到Path变量，点击“编辑”按钮，我们将;%MYSQL_HOME%\\bin添加到path变量（一般放在最后面） 启动MySQL 数据库1.初始化数据库：mysqld --initialize --console 执行完成后，会输出 root 用户的初始默认密码 12018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: qwsctyr(2+Da qwsctyr(2+Da 就是初始密码，后续登录需要用到，你也可以在登陆后修改密码。2.安装mysqld install3.启动net start mysql linux下安装1.安装mysql命令 ：$ sudo apt-get install -y mysql-server2.查看mysql的版本命令（注意-V是大写，不然会出现如下错误）：$ mysql -V3.启动mysql命令(关闭，重启等只需将start换成stop,restart等即可)：$sudo service mysql start4.登录mysql命令为：$ mysql -u用户名 -p密码5.连接远程数据库：$ mysql -h -P -u -p 用户相关操作注：以下命令均需先以root身份登录mysql：mysql -uroot -p1.添加新用户（1）创建新用户：&gt; insert into mysql.user(Host,User,Password) values(“localhost”,”user1”,password(“password1”));（2）为用户分配权限： 设置用户可以在本地访问mysql：grant all privileges on . to username@localhost identified by “password” ; 设置用户只能访问指定数据库：grant all privileges on 数据库名.* to username@localhost identified by “password” ;（3）刷新系统权限表：&gt;flush privileges;2.查看MySql当前所有的用户：&gt;SELECT DISTINCT User FROM mysql.user;3.删除用户及其数据字典中包含的数据：&gt;drop user ‘xbb‘@’localhost’; 常用命令命令行执行sql文件source xxx.sql ; 工具vscode链接MySQL安装插件MySQL ，MySQL syntax配置MySQL插件，点击+号，输入密码即可 sql语句快速生成器utools插件 可以将excel或word表格中的内容快速生成sql的插入语句或更新语句 数据库的基础知识及概念 数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中的数据。 数据库（DATA BASE）指长期保存在计算机的存储设备上，按照一定规则组织起来，可以被各种用户或应用共享的数据集合。 表中用来存放数据信息，以二维行列存储数据。行（row）在sql中称作一条记录也叫实体，列（column）在sql中称作字段。 SQL：Structure Query Language。（结构化查询语言） 数据模型的分类：层次模型、网状模型和关系模型 数据库分类关系型数据库： 采用关系模型（二维表）来组织数据结构的数据库 oracle DB2 SQLServer Mysql SQLite 优点：*容易理解，逻辑类似常见的表格 *使用方便，都使用sql语句，sql语句非常成熟 *数据一致性高，冗余低，数据完整性好，便于操作 *技术成熟，功能强大，支持很多复杂操作 缺点：*每次操作都要进行sql语句的解析，消耗较大 *不能很好的满足并发需求，特别是海量数据爆发，关系型数据库读写能力会显得不足 *关系型数据库往往每一步都要进行加锁的操作，也造成了数据库的负担 *数据一致性高，有时也会使数据的存储不灵活 非关系型数据库（NoSql） 优点：*高并发，读写能力强 *弱化数据结构一致性，使用更加灵活 *有良好的可扩展性 缺点：*通用性差，没有sql语句那样通用的语句 *操作灵活导致容易出错和混乱 *没有外键关联等复杂的操作 Nosql的使用情况： 1、对数据存储灵活性要求高，一致性要求低 2、数据处理海量并发，要求瞬间效率速度比较高 3、数据比较容易建立Nosql模型 4、网站灵活时缓冲存储，爬虫应用 Nosql 的分类： 1、键值型数据库 Redis 2、文档型数据库 MongoDB 3、列存储数据库 HBase 4、图形数据库 mysql语句的四大组成成分（DDL、DML、DQL、DCL) SQL语句分类DML语言(Data Manipulation Language):数据操作语言用于操作数据库对象中所包含的数据： 关键字有：insert（插入），update（更改），delete（删除） DQL（Data Query Language）数据查询语言关键字SELECT语句1.基础查询2.条件查询3模查词(LIKE)4.字段控制查询( DISTINCT)5.排序( DRDER BY)6.分组查词 DDL(Data Definition Language):数据定义语言 关键字有：create(创建)，drop（删除） ，truncate（删除表结构，再创一张表），alter（修改） 6.INODB、MYISAM存储引擎的区别（PPT初识MySQL第67页） mysql基础MySQL命令终止符为分号 ; You have an error in your SQL syntax;这种错误是sql写错了，一般在near中所示例的sql语句之前有错误 库操作CREATE DATABASE xxx; – 创建数据库 SHOW DATABASES; – 查看当前数据库服务器中的所有数据库 DROP DATABASE xxx; – 删除指定数据库 USE xxx; – 使用数据库 表操作show tables; –查看当前库所有表 show 表名 –查看表信息 desc 表名; –查看表结构 DROP TABLE table_name ; –删除表 创建数据表创建MySQL数据表需要以下信息： 表名表字段名定义每个表字段 123456789-- 表名不要用引号括起来CREATE TABLE IF NOT EXISTS 表名( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8; 改表记录 UPDATE 表名 SET 修改字段=’’ WHERE 条件 删除数据表 drop table if exists stu,student; 复制表-修改字段的数据类型 alter table &lt;表名&gt; modify &lt;字段名&gt; &lt;新数据类型&gt;添加字段 alter table &lt;表名&gt; add&lt;字段名&gt; &lt;新数据类型&gt;[约束条件] [first|after 已存在字段名];删除字段 alter table &lt;表名&gt; drop&lt;字段名&gt;; 1.基本操作语句：查看数据库列表，查看数据库中的表名 2.数据类型：字符串类型 char、varchar；一般超过200个汉字：用text；decimal()一般用于价钱、金额，考试会考其两个参数M、D表示什么意思教材27页） 3.表的创建、查询语句、数据的插入 4.创建表时涉及到的知识点，如 default 默认值 5.查询的时候，去掉重复的行：distinct 6.修改表的结构：alter的用法 7.where条件语句的用法 8.in 和 not in的用法 9.group by 分组语句，having子句的使用 10.limit 子句 11.exeits 关键字的用法 12.模糊查询 ：like (‘%’,’_’)（配合百分号、下划线使用） (课本没有) 13.between…and…的用法 ：如between 1 and 10 。包含1和10 14.uoion、 unoin all 的用法 15.truncate table 删除特点：可以删除表中所有的行（书本P56） 16.函数:聚合函数（sum()、max()、min()、count()、avg()）（使用原则书本58页） 17.日期函数：now()获取当前日期和时间 2021-12-16 16：59：30 18.内连接 外连接 基本语法及含义（书本P88）如返回左表中所有的记录和右表中符合连接条件的记录（左外连接） 19.条件筛选 where 和having的区别where语句从数据表中选取满足条件的数据行、列having子句选取满足条件的分组 20.批量子查询ALL、ANY 子查询子查询就是嵌套查询，一个select语句中包含另一个完整的select语句。 1.子查询出现的位置： where后，作为条为被查询的一条件的一部分；from后，作表；2.当子查询出现在where后作为条件时，还可以使用如下关键字： anyall3.子查询结果集的形式： 单行单列（用于条件）单行多列（用于条件）多行单列（用于条件）多行多列（用于表） 1.带比较运算符的子查询2.带 EXISTS关键字的子查询3.带ANY关键字的子查询4.带AL关键字的子查询 多表连接查询内连接查询 select 表1查询的字段，表2查询的字段 from 表1 inner join 表2 on 两表都有的字段； 3外连接查询(只适用于两表) 左（外）连接查询 select 表1查询的字段，表2查询的字段 from 表1 left join 表2 on 条件； 左表的记录将会全部表示出来，而右表只会显示符合搜索条件的记录 右（外）连接查询 22.SQL语句的执行顺序。（PPT数据查询第79页） 存储过程基本格式及使用，怎么调用存储过程 (PPT存储过程与事务第17页）定义 ： 存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。存储过程的特点 1、能完成较复杂的判断和运算 2、可编程行强，灵活 3、SQL编程的代码可重复使用 4、执行的速度相对快一些 5、减少网络之间的数据传输，节省开销创建存储过程的简单语法 1234create procedure 名称()begin.........end 调用存储过程 call 名称();存储函数里的变量 1234567891011create procedure test2()begin -- 使用 declare语句声明一个变量 declare username varchar(32) default ''; -- 使用set语句给变量赋值 set username='xiaoxiao'; -- 将users表中id=1的名称赋值给username select name into username from users where id=1; -- 返回变量 select username;end; 事务mysql事务处理的四种基本特性（原子性、一致性、隔离性、持久性）（书本P102页） 4.事务的基本语法，比如开启事务（start transcation、begin) ,提交事务commit，回滚 rollback（书本P103页） 5.mysql设置了事务的4种隔离级别（读未提交、读提交、可重复读、可串行化）（书本没有） 视图视图是由数据库中的一个表或多个表导出的虚拟表，是一种虚拟存在的表，方便用户对数据的操作。创建视图 create view 视图名 as select 7.数据库的备份与恢复。mysqldump的基本使用格式 索引索引并非越多越好避免对经常更新的表建立过多的索引数据量小的表最好不要使用索引在不同值少的列上不要建立索引为经常需要排序、分组和联接操作的字段建立索引 （2）索引的关键字（PPT 索引视图触发器第21页） 触发器 触发器与函数、存储过程一样，触发器是一种对象，它能根据对表的操作时间，触发一些动作，这些动作可以是insert,update,delete等修改操作。 123456create trigger tr_users_insert after insert on users for each row begin insert into oplog(userid,username,action,optime) values(NEW.id,NEW.name,'insert',now()); end;，三个激活触发器的操作（插入insert、修改update和删除delete）（书本没有）（PPT 索引视图触发器第43页） 数据库规范化设计1.实体之间的映射关系：一对一1:1 、一对多1:n、多对一n:1 、多对多m:n 2.E-R图的绘制 3.E-R图转换成关系模型 4.数据库模型图的概念 命令速查https://blog.csdn.net/horses/article/details/104849500","categories":[{"name":"数据库","slug":"数据库","permalink":"https://wenkexia.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wenkexia.github.io/tags/MySQL/"}]},{"title":"计网学习","slug":"计算机网络","date":"2021-12-24T00:55:20.000Z","updated":"2021-12-24T00:55:20.000Z","comments":true,"path":"2021/122451189.html","link":"","permalink":"https://wenkexia.github.io/2021/122451189.html","excerpt":"","text":"参考计算机网络谢希仁第八版 第一章 概述体系结构OSI的七层协议体系结构物理层，数据链路层，网络层，TCP/IP的四层体系结构链路层（网络接口层），网际层，运输层，应用层 重要内容 计算机网络的一些相关知识 互联网概述 因特网的标准化工作 互联网的组成 计算机网络的类别 计算机网络的性能指标 综合OSI和TCP/IP的优点采用五层协议的体系结构阐述计算机网络的原理 一. 物理层集线器，中继器 相关协议点对点协议PPP用在SONET/SDH链路时，采用零比特填充方法来实现透明传输。 通过传输介质发送和接收二进制比特流。 数据通信的基本知识 编码把数据转换成数字信号（01） 不归零制， 归零制（正脉冲代表1，负脉冲代表0）， 曼彻斯特编码（位周期中心的向上跳变代表0，向下代表1，反之亦可） 差分曼彻斯特编码（每一位的中心处始终有跳变。位开始边界有跳变为0，位开始边界无跳变为1）。 调制方法 转换为模拟信号 调幅：对基带信号的波幅进行调整，例如将上图的1信号波幅进行改变，在接收方读取时有载波输出为1 调相：对基带信号相位进行调制，例如将0信号的初相位调整为0度，1信号的初相位调整为180度。 调频：对基带信号频率进行调整，例如将0信号调制为频率f1，1信号调制为频率f2。 2.数据交换方式 ①分组交换 ②电路交换 信道复用技术 ①频分复用FDM 是有N路信号要在一个信道中传送。可以使用调制的方法，把各路信号分别搬迁到适当的频率位置，使彼此不产生干扰。各路信号在同样的时间占用不同的带宽资源。 ②时分复用TDM 是将时间划分为一段段等长的帧，每一路信号在每一个帧中占用固定信号的时隙。 ③波分复用 ④码分复用CDM 数字传输系统 宽带接入技术 重要内容 使用点对点信道的数据链路层 封装成帧 透明传输 差错检测 字节填充 使用广播通信的数据链路层 二. 数据链路层交换机，网桥 链路层服务组帧：封装高层数据报构成数据帧，加首部和尾部 控制字符SOH放在一帧的最前面，表示帧的首部开始 控制字符EOT放在一帧的最后，表示帧的结束 流量控制：协调相邻的发送结点，接收 差错检测：信号衰减和噪音会引起差错，接收端检测到差错，通知发送端重传或直接丢弃帧 差错纠正：接收端直接纠正比特差错 全双工和半双工通信控制 全双工：同时双向传输。半双工：交替双向传输 数据链路层协议的代表包括：PPP、帧中继等 适配器的作用CSMA/CD协议使用集线器的星形拓扑结构MAC层的硬件地址MAC帧的格式以太网的扩展 三. 网络层提供主机间的逻辑通信机制，在邻接节点间进行数据包可靠传输 负责对子网间的数据包进行路由选择，为分组交换网上的不同主机提供通信服务。 网络层协议的代表包括：IP、ICMP、IGMP等。网络层提供的两种服务 IP目前已经不采用分类表示法，所以大家重点关注CIDR表示法（无分类编址）。例 128.14.35.7/20 = 10000000 00001110 0010|0011 00000111 即前20位是网络前缀，后12位是主机号，那么我们通过令主机号分别为全0和全1就可以得到一个CIDR地址块的最小地址和最大地址，即 最小地址是：128.14.32.0 = 10000000 00001110 0010|0000 00000000 最大地址是：128.14.47.255 = 10000000 00001110 0010|1111 11111111 子网掩码是：255.255.240.0 = 11111111 11111111 1111|0000 00000000 因此就可以看出来，这个CIDR地址块可以指派(47-32+1)*256=4096个地址，这里没有把全0和全1除外。 地址解析协议ARPIP数据报的格式划分子网构造超网网际控制报文协议ICMP互联网的路由选择协议内部网关协议RIP内部网关协议OSPF外部网关协议BGP 路由器IPv6从IPv4向IP v6的过渡IP多播虚拟专用网VPN网络地址转换NAT 四. 运输层（transport layer）概述提供应用进程间的逻辑通信机制应用进程利用该服务传送应用层报文 复用功能多个应用层进程可同时使用下面运输层的服务 分用功能运输层把收到的信息分别交付到上面应用层中的相应进程运输层协议（端到端协议）发送方将应用递交的信息下传给网络层接收方将接收的信息上交给应用层 1.传输控制协议TCP数据传输单位是报文段 提供可靠的，面向连接的运输服务 不提供广播或多播服务3.开销较多 面向字节流，全双工 有流量控制和拥塞控制 TCP可靠传输的实现 三次握手 第一次：主机A向主机B发送一个同步序列号的数据段给主机B，请求建立连接 第二次：主机B收到主机A的请求后，用一个确认应答（ACK）和同步序列（SYN）的数据段响应主机A 第三次:主机A 收到这个数据段后，再发送一个确认应答，确认已收到主机B的数据段，开始传输实际数据 TCP的流量控制 TCP的拥塞控制 TCP的运输连接管理 2.用户数据报协议UDP数据传输单位是用户数据报 1.传输数据前不需要先建立连接 2.收到UDP报后，不需要给出确定 3.不提供可靠交付，但是一种最有效的工作方式 五.应用层（application layer）概述任务是通过应用进程间的交互来完成特定网络应用进程指的是主机正在运行的程序应用层交互的数据单元称为报文 应用层协议定义的是应用进程间通信和交互的规则 域名系统DNS将域名转换为Ip地址 文件传送协议FTPHTTPHTTP协议的服务端口为80 SMTPSMP协议的服务端口为25SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于传输系统之间的邮件信息并提供与来信有关的通知。 远程终端协议TELNET动态主机配置协议应用进程跨网络的通信P2P对等方式1.没有固定的服务请求者和服务提供2.对等方相互之间直接通信3.每个对等方既是服务请求者又是服务提供者 复习题选择题 物理层中指明在接口电缆的各条线上出现的电压的范围（ B ）。A. 机械特性 B. 电气特性C. 功能特性 D. 过程特性 下列属于半双工通信方式的是（ C ）。A. 无线电广播 B. 有线闭路电视C. 无线对讲机 D. 手机通话 光纤通信使用（ C ）。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM 典型应用于传输速率1Gbit/s(距离100米)的绞合线类别是（ C ）。A. 3类线 B. 超5类线C. 6类线 D. 8类线 传输带宽最大的介质是（ C ）。A. 双绞线 B. 同轴电缆C. 光纤 D. 微波 （ A ）是有N路信号要在一个信道中传送。可以使用调制的方法，把各路信号分别搬迁到适当的频率位置，使彼此不产生干扰。各路信号在同样的时间占用不同的带宽资源。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM （ A ）技术是用数字技术对现有模拟电话的用户线进行改造，使它能承载宽带数字业务。A．ADSL B. 光纤同轴混合网（HFC网）C. 光纤接入 D. FTTx技术 控制字符（ A ）放在一帧的最前面，表示帧的首部开始。A. SOH B. EOTC. ESC D. MTU 局域网通常采用的网络拓扑结构不包括（ D ）。A. 星形网 B. 环形网C. 总线网 D. 三角形 10GBASE-ER采用的媒体介质是（ B ）。A. 多模光纤 B. 单模光纤C. 同轴电缆 D. 双绞线 无分类编址CIDR地址块中网络前缀长度为/18相当于包含（ D ）个C类网络数。A. 21 B. 23C. 80 D. 64 CIDR地址块206.0.64.0/18的子网掩码采用点分十进制法是记法是（ C ）。A. 255.255.255.0 B. 255.255.240.0C. 255.255.192.0 D. 255.255.254.0 以下可分配给主机或者路由器的IP地址是（ C ）。A. 131.107.255.80/28 B. 231.211.128.0/17C. 126.1.4.255/23 D. 198.121.204.128/25 Internet的前身是美国的（ A ）。A. ARPANET B. 信息高速公路C. RFC D. 分组交换网络15．下列不属于ISP的是（ D ）。A. 中国联通 B. 中国电信C. 德国电信 D. 优酷16．计算机通信网络的数据传送方式属于（C ）。A. 电路交换 B. 报文交换C. 分组交换 D. 虚电路交换 广州工商学院的校园网属于（ C ）。A. 广域网 B. 城域网C. 局域网 D. 个域网 主机或路由器发送数据帧所需要的时间是（ A ）。A. 发送时延 B. 传播时延C. 处理时延 D. 排队时延 网络协议三要素中的（ A ）表示数据与控制信息的结构或格式。A. 语法 B. 语义C. 同步 D. 协议 以下属于UDP支持的应用程序是（ C ）。A. 浏览器打开网页 B. 收发电子邮件C. 网络视频点播 D. 远程登陆方式连接 物理层中指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等是（ A ）。A. 机械特性 B. 电气特性C. 功能特性 D. 过程特性 下列属于全双工通信方式的是（ D ）。A. 无线电广播 B. 有线闭路电视C. 无线对讲机 D. 手机通话 3G移动通信技术使用（ D ）。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM 通常双绞线的最大传输距离是（ D ）。A. 10米 B. 18米C. 50米 D. 100米 早期有线电视网使用的介质主要是（ B ）。A. 双绞线 B. 同轴电缆C. 光纤 D. 微波 （ B ）是将时间划分为一段段等长的帧，每一路信号在每一个帧中占用固定信号的时隙。A. 频分复用FDM B. 时分复用 TDMC. 波分复用WDM D. 码分复用 CDM （ B ）是目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传达电视节目外，还能提供电话、数据和其他宽带交互型业务。A．ADSL B. 光纤同轴混合网（HFC网）C. 光纤接入 D. FTTx技术 控制字符（ B ）放在一帧的最后，表示帧的结束。A. SOH B. EOTC. ESC D. MTU 总线型以太网通常采用（ A ）访问控制协议。A. CSMA/CD B.CSMA/CAC. 频分复用 D.时分复用 （ B ）的光源要使用昂贵的半导体激光器，而不能使用较便宜的发光二极管。A. 多模光纤 B. 单模光纤C. 同轴电缆 D. 双绞线 无分类编址CIDR地址块中网络前缀长度为/16相当于包含（ A ）个B类网络数。A. 1 B. 2C. 64 D. 256 CIDR地址块206.0.64.0/17的子网掩码采用点分十进制法是记法是（ B ）。A. 255.255.0.0 B. 255.255.128.0C. 255.255.192.0 D. 255.255.254.0 判断题（√）1.*一般的适配器都包括了数据链路层和物理层这两层的功能。（√）2.封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。（√）3.所有的PPP帧的长度都是整数字节。（√）4.PPP协议用在SONET/SDH链路时，采用零比特填充方法来实现透明传输。（√）5.最初的以太网是将许多计算机都连接到一根总线上，也称为共享以太网。（√）1.*一般的适配器都包括了数据链路层和物理层这两层的功能。（√ ）2.封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。（√）3.所有的 PPP 帧的长度都是整数字节。（√）4.PPP 协议用在 SONET/SDH 链路时，采用零比特填充方法来实现透明传输。（√）5.最初的以太网是将许多计算机都连接到一根总线上，也称为共享以太网。（×）6.以太网使用面向连接的工作方式。（√）7.*以太网发送的数据都使用曼彻斯特编码，其特点是可以实现时钟自同步。（√）8.以太网的站点在发送帧时，如果经过2τ后还没有检测到冲突，则本次发送不会再出现冲突了。（ √ ）9.速率达到或超过 100 Mb/s 的以太网称为高速以太网。（ √ ）10.100BASE-T 以太网工作在全双工方式时，不使用CSMA/CD协议( √ )11. CSMA/CD协议采用半双工通信。( × )6. 集线器工作于数据链路层。 //工作于物理层(√ )7. 以太网交换机是一种即插即用设备，其内部的地址表是通过自学习算法自动逐渐建立起来的。 填空题1．OSI/RM的七层协议分别是物理层、数据链路层、____网络层__、运输层、会话层、表示层、应用层。2．双绞线分为无屏蔽双绞线（UTP）和____屏蔽双绞线(STP)__。3．为了解决透明传输问题，在发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个_____转义字符“ESC”_____。 ____物理地址_____是使用数据链路层的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。 在IP层下面每一种数据链路层协议都规定了一个数据帧中的数据字段的最大长度，这称为___最大传送单元MTU ______。 HTTPS应用程序采用熟知的端口号____TCP_____。 万维网使用____超文本标记语言HTML ________来显示各种万维网页面。11．TCP/IP的四层协议包括链路层、网际层IP、运输层、____应用层______。12．数字信号可以通过_____调制器_____转化为模拟信号。13．在带宽W（Hz）的低通信道中，若不考虑噪声影响，则码元传输的最高速率是2W（码元/秒）。传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的识别称为不可能，这就是著名的____奈氏准则___。 ___香农公式_____表明信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。 ___封装成帧____就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。 计算机与外界局域网的连接是通过___网络适配器完成的_________。 网络层提供的服务分为虚电路和____数据报______。 C类地址可容纳的主机数是____254________。 HTTP应用程序采用熟知的端口号______TCP______。 FTP的中文翻译是___文件传输协议_________。 __生存时间或者TTL ___占8位，表明数据报在网络中的寿命。 内部网关协议IGP使用最多的是RIP和_____最短路径优先或者OSPF _______。 外部网关协议EGP使用最多的是_____ BGP的版本4或者BGP-4__。 1．数字信号可以通过___抽样，量化，编码____转化为模拟信号。 简答题1．什么是DNS？什么是DHCP服务器？答：域名系统DNS是互联网使用的命名系统，用来便于人们使用的机器名字转换为IP地址。动态主机配置协议DHCP提供了一种机制，称为即插即用连网。这种机制允许一台计算机自动加入新的网络和获取IP地址而不用手工参与。 什么是虚拟专用网络VPN？（P186）什么是网络地址转换NAT？(P188)答：虚拟专用网络VPN是指这种网络是为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信。如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么多有通过互联网传送的数据都必须加密。网络地址转换NAT是指在专用网连接到互联网的路由器上安装NAT软件。装有NAT软件的路由器叫作NAT路由器，它至少一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和互联网连接。 1.三报文握手建立TCP连接过程 P247第一次握手:客户端将报文标志位SYN置为1,产生一个序号值seq=x,将该数据包发送给服务器端后客户端进入SYN_SENT状态第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=x+1，随机产生一个序号值seq=y，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。第三次握手：客户端收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给服务器端，服务器端检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了 2.TCP和UDP的主要区别TCP提供面向连接、按序可靠的字节流服务（面向字节流）、有流量控制和拥塞控制。UDP提供无连接、不可靠的数据报服务（面向报文）。3.什么是VPN P1864.什么叫网络地址转换为NAT P188 5.什么是DNS P261将域名转换为IP地址 6.什么是DHCP P304动态 主机 配置 协议不需要手动的去配置ip地址以及其他的网络参数 7.什么是超文本传输协议HTTP答：超文本传输协议HTTP是面向事务的应用层协议，它是万维网上能够可靠的交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。协议HTTP不仅传送完成超文本跳转所必需的信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像等。 8.顶级域名分为哪几类 p263（1）国家顶级域名（2）通用顶级域名（3）基础结构域名9.域名服务器有哪几类 P265（1）根域名服务器（2）顶级域名服务器（3）权限域名服务器（4）本地域名服务器 10.什么是超文本标记语言HTML P283超文本标记语言HTML是一种制作万维网页面的标准语言，它消除了不同计算机之间信息交流的障碍11.什么是远程终端协议TELNET P271用户通过TCP登陆远地主机，远程操控远地主机，又称终端仿真协议12.什么是万维网www P272万维网是大规模的，联机式的信息储藏所，简称web13什么是统一资源定位符URL P274从互联网上获取资源位置和访问这些资源的方法6.什么叫做公用网和专用网？公用网：公用网用来提供服务。Client通过此网络与服务器通信。专用网：是某个部门为本单位的特殊工作的需要而建立的网络.这种网络不向本单位以外的人提供服务.例如,军队,铁路,电力等系统均有本系统的专用网。7.时延是由那几部分组成的？发送时延与传输时延的有什么区别？P22 8.IGP和EGP这两类协议的主要区别是什么? 答：内部网关协议IGP，是在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。外部网关协议EGP，是在不同的自治系统边界传递路由信息的协议，不关心自治系统内部使用何种协议。1、什么叫做“三网融合”？“三网融合”又叫“三网合一”，意指电信网络、有线电视网络和计算机网络的相互渗透、互相兼容、并逐步整合成为全世界统一的信息通信网络，其中互联网是其核心部分。2、什么叫做客户-服务器方式(C/S方式)？客户（Client）和服务器（Server）都是指通信种所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服务和被服务的关系。3、 什么叫做P2P方式？是指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机都运行了对等连接软件（P2P软件），它们就可以进行平等的、对等连接通信。这时，双方都可以下载对方已经存储在硬盘中的共享文档。因此这种的方式称为P2P方式。4、什么叫做电路交换？是指在同一电信网用户群中任意两个或多个用户终端之间建立电路暂时连接的交换方式。暂时连接独占一条通信路径并保持到连接释放为止例如，用固定电话拨打电话的数据传送方式属于（电路交换）。5、什么叫做报文交换？报文交换不要求在两个通信节点之间建立专用通路。节点把要发送的信息组织成一个数据包一报文，该报文中含有目标节点的地址，完整的报文在网络中一站一站地向前传送。每一个节点接收整个报文，检查目标节点地址，然后根据网络中的交通情况在适当的时候转发到下一个节点。经过多次的存储一转发，最后到达目标，因而这样的网络叫存储一转发网络。6、什么叫分组交换？分组交换也称为包交换，它将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组。首部指明了该分组发送的地址，当交换机收到分组之后，将根据首部中的地址信息将分组转发到目的地，这个过程就是分组交换。7、什么虚电路交换？所谓交换虚电路(SVC)就是两个数据终端要通信时先用呼叫程序建立电路（即虚电路），然后发送数据，通信结束后用拆线程序拆除虚电路。通过蓝牙无线技术连接起来的网络属于（ ）。8、什么叫做广域网？广域网(Wide Area Network ,简称WAN)是一种跨地区的数据通讯网络,通常包含一个国家或地区。广域网通常由两个或多个局域网组成。9、什么叫做城域网？城域网(Metropolitan Area Network)是在一个城市范围内所建立的计算机通信网，简称MAN。属宽带局域网。10、什么叫做局域网？局域网的覆盖范围一般是方圆几千米之内，其具备的安装便捷、成本节约、扩展方便等特点使其在各类办公室内运用广泛。11、什么叫做个域网？个人域网（PAN），是指能在便携式消费电器与通信设备之间进行短距离通信的网络，其覆盖范围一般在10米半径以内。 作图： P451、能根据比特流画出曼彻斯特编码、差分曼彻斯特编码、归零制和不归零制编码的图。2、能根据基带信号画出最基本调制方法中的调幅和调频图。调幅：对基带信号的波幅进行调整，例如将上图的1信号波幅进行改变，在接收方读取时有载波输出为1.调频：对基带信号频率进行调整，例如将0信号调制为频率f1，1信号调制为频率f2。调相：对基带信号相位进行调制，例如将0信号的初相位调整为0度，1信号的初相位调整为180度。 计算CIDR地址快的使用（即路由聚合方法），如课本129页的图4-13。 有如下的5个/24地址块，试进行最大可能的聚合。 156.152.0/24 156.153.0/24 156.154.0/24 156.155.0/24 156.156.0/24解：这几块地址前面两个字节一样，只需比较第三个字节： 156.152.0/24 第三个字节 1001 1000 156.153.0/24第三个字节 1001 1001 156.154.0/24第三个字节 1001 1010 156.155.0/24第三个字节 1001 1011 156.156.0/24第三个字节 1001 1100那么这五个地址块的共同前缀有21位：212.156. 1001 1最大可能聚合地址块是：212.156.1001 1000.00000000/21=212.156.152.0/21 2、 某单位分配到一个地址块136.23.12.32 /27。现在需要进一步划分为4 个一样大的子网。试问：（1）每个子网的网络前缀有多长？（2）每一个子网中有多少个地址？（3）每一个子网的地址块是什么？（4）每一个子网可分配给主机使用的最小地址和最大地址是什么？答：将136.23.12.32 /27转换为二进制：10001000 00010111 00001100 00100000/27（1）根据题意，建立4个子网，要借2位为子网号，22=4，所以网络前缀为27+2=29位，剩下32-29=3位作主机位。 所以每个子网前缀有29位。 （2）每个子网的地址中有3位留给主机用，因此共有23=8个地址。 （3）（4）四 个子网的地址块以及每个子网分配给主机的最小地址和最大地址是：第一个地址块136.23.12.32 /29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00100 000/29最小地址：136.23.12.33（00100 001）最大地址: 136.23.12.38（00100 110）第二个地址块136.23.12.40/29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00101 000/29最小地址：136.23.12.41（00101 001）最大地址：136.23.12.46（00101 110）第三个地址块136.23.12.48 /29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00110 000/29最小地址：136.23.12.49（00110 001）最大地址：136.23.12.54（00110 110）第四个地址块：136.23.12.56/29，可分配给主机使用的转为二进制 10001000 00010111 00001100 00111 000/29最小地址：136.23.12.57（00111 001）最大地址：136.23.12.62（00111 110） 3、 某单位分配到地址块136.230/16。该单位有2000 台机器，平均分布在 8个不同的地点。试给每一个地点分配一个地址块，并计算出每个地址块中IP地址的最小值和最大值（说明：必须有完整的解题步骤，否则不得分。）答：2000/8=250，每个点平均250台电脑。如选255.255.255.0为掩码，每个子网有28-2=254&gt;250，共有子网数=28-2=254&gt;8，能满足实际需求。每个地点的网络前缀和主机IP地址的最小值和最大值为：地点 子网号 子网络地址 主机的最小值和值1 00000001 136.230.1.0/24 : 136.230.1.1–136.230.1.2542 00000002 136.230.2.0/24 : 136.230.2.1–136.230.2.2543 00000003 136.230.3.0/24 : 136.230.3.1–136.230.3.254………………………………..7 00000007 136.230.7.0/24 : 136.230.7.1–136.230.7.2548 00000001 136.230.8.0/24 : 136.230.8.1–136.230.8.254 4、某组织分配到一个地址块，其中第一个地址是14.24.74.0/24。这个组织需要划分为11个子网。具体要求是：具有64个地址的子网两个；具有32个地址的子网两个；具有16个地址的子网三个；具有4个地址的子网四个（这里的地址包括网络地址和广播地址）。试设计这些子网。分配结束后还剩下多少地址？（说明：必须有完整的解题步骤，否则不得分。）解答：将14.24.74.0/24转换为二进制：00001110 00011000 01001010 00000000/24 具有64个地址的子网2个：根据要求可知，要借2位为子网号，因为每个子网为64个地址，所以主机号最少要保留6位才能满足每个子网64个地址，主机号共有8位，剩下8-2=6位可借给网络号。00001110 00011000 01001010 00 000000 转为十进制：14.24.74.0/2600001110 00011000 01001010 01 000000 转为十进制：14.24.74.64/262）具有32个地址的子网2个因为每个子网为32个地址，所以主机号最少要保留5位才能满足每个子网32个地址，主机号共有8位，剩下8-5=3位可借给网络号。00001110 00011000 01001010 100 00000 转为十进制：14.24.74.128/2700001110 00011000 01001010 101 00000 转为十进制：14.24.74.160/273）具有16个地址的子网3个因为每个子网为16个地址，所以主机号最少要保留4位才能满足每个子网16个地址，主机号共有8位，剩下8-4=4位可借给网络号。00001110 00011000 01001010 1100 0000 转为十进制：14.24.74.192/2800001110 00011000 01001010 1101 0000 转为十进制：14.24.74.208/2800001110 00011000 01001010 1110 0000 转为十进制：14.24.74.224/284）具有4个地址的子网4个因为每个子网为4个地址，所以主机号最少要保留2位才能满足每个子网4个地址，主机号共有8位，剩下8-2=6位可借给网络号。00001110 00011000 01001010 111100 00 转为十进制：14.24.74.240/3000001110 00011000 01001010 111101 00 转为十进制：14.24.74.244/3000001110 00011000 01001010 111110 00 转为十进制：14.24.74.248/3000001110 00011000 01001010 111111 00 转为十进制：14.24.74.252/30全部256个地址已经分配完毕，没有剩下的地址。 TCP/IP模型实现网络通信的基础是网络通信协议，这些协议通常是由互联网工程任务组 （IETF）制定的。所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层，如下图所示。 IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个局域网（LAN）中的内部IP地址，通过网络地址转换（NAT）服务我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“路由器”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。 TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情： 数据不传丢不传错（利用握手、校验和重传机制可以实现）。 流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。 拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。 网络应用模式 C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。 去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。 JSON格式JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和XML一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。 XML的例子： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;message&gt; &lt;from&gt;Alice&lt;/from&gt; &lt;to&gt;Bob&lt;/to&gt; &lt;content&gt;Will you marry me?&lt;/content&gt;&lt;/message&gt; JSON的例子： 12345{ \"from\": \"Alice\", \"to\": \"Bob\", \"content\": \"Will you marry me?\"} 基于传输层协议的套接字编程套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。 TCP套接字所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。 下面的代码实现了一个提供时间日期的服务器。 12345678910111213141516171819202122232425262728293031323334from socket import socket, SOCK_STREAM, AF_INETfrom datetime import datetimedef main(): # 1.创建套接字对象并指定使用哪种传输服务 # family=AF_INET - IPv4地址 # family=AF_INET6 - IPv6地址 # type=SOCK_STREAM - TCP套接字 # type=SOCK_DGRAM - UDP套接字 # type=SOCK_RAW - 原始套接字 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(端口用于区分不同的服务) # 同一时间在同一个端口上只能绑定一个服务否则报错 server.bind(('192.168.1.2', 6789)) # 3.开启监听 - 监听客户端连接到服务器 # 参数512可以理解为连接队列的大小 server.listen(512) print('服务器启动开始监听...') while True: # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行 # accept方法返回一个元组其中的第一个元素是客户端对象 # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成) client, addr = server.accept() print(str(addr) + '连接到了服务器.') # 5.发送数据 client.send(str(datetime.now()).encode('utf-8')) # 6.断开连接 client.close()if __name__ == '__main__': main() 运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。 1telnet 192.168.1.2 6789 当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。 123456789101112131415from socket import socketdef main(): # 1.创建套接字对象默认使用IPv4和TCP协议 client = socket() # 2.连接到服务器(需要指定IP地址和端口) client.connect(('192.168.1.2', 6789)) # 3.从服务器接收数据 print(client.recv(1024).decode('utf-8')) client.close()if __name__ == '__main__': main() 需要注意的是，上面的服务器并没有使用多线程或者异步I/O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。 服务器端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from socket import socket, SOCK_STREAM, AF_INETfrom base64 import b64encodefrom json import dumpsfrom threading import Threaddef main(): # 自定义线程类 class FileTransferHandler(Thread): def __init__(self, cclient): super().__init__() self.cclient = cclient def run(self): my_dict = {} my_dict['filename'] = 'guido.jpg' # JSON是纯文本不能携带二进制数据 # 所以图片的二进制数据要处理成base64编码 my_dict['filedata'] = data # 通过dumps函数将字典处理成JSON字符串 json_str = dumps(my_dict) # 发送JSON字符串 self.cclient.send(json_str.encode('utf-8')) self.cclient.close() # 1.创建套接字对象并指定使用哪种传输服务 server = socket() # 2.绑定IP地址和端口(区分不同的服务) server.bind(('192.168.1.2', 5566)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print('服务器启动开始监听...') with open('guido.jpg', 'rb') as f: # 将二进制数据处理成base64再解码成字符串 data = b64encode(f.read()).decode('utf-8') while True: client, addr = server.accept() # 启动一个线程来处理客户端的请求 FileTransferHandler(client).start()if __name__ == '__main__': main() 客户端代码： 1234567891011121314151617181920212223242526272829from socket import socketfrom json import loadsfrom base64 import b64decodedef main(): client = socket() client.connect(('192.168.1.2', 5566)) # 定义一个保存二进制数据的对象 in_data = bytes() # 由于不知道服务器发送的数据有多大每次接收1024字节 data = client.recv(1024) while data: # 将收到的数据拼接起来 in_data += data data = client.recv(1024) # 将收到的二进制数据解码成JSON字符串并转换成字典 # loads函数的作用就是将JSON字符串转成字典对象 my_dict = loads(in_data.decode('utf-8')) filename = my_dict['filename'] filedata = my_dict['filedata'].encode('utf-8') with open('/Users/Hao/' + filename, 'wb') as f: # 将base64格式的数据解码成二进制数据并写入文件 f.write(b64decode(filedata)) print('图片已保存.')if __name__ == '__main__': main() 在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从000000到111111的64种状态。维基百科上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。 说明： 上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。 UDP套接字传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。 网络应用开发发送电子邮件在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。 就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。 下面的代码演示了如何在Python发送邮件。 12345678910111213141516171819202122from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextdef main(): # 请自行修改下面的邮件发送者和接收者 sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com', 'uvwxyz@126.com'] message = MIMEText('用Python发送邮件的示例代码.', 'plain', 'utf-8') message['From'] = Header('王大锤', 'utf-8') message['To'] = Header('骆昊', 'utf-8') message['Subject'] = Header('示例代码实验邮件', 'utf-8') smtper = SMTP('smtp.126.com') # 请自行修改下面的登录口令 smtper.login(sender, 'secretpass') smtper.sendmail(sender, receivers, message.as_string()) print('邮件发送完成!')if __name__ == '__main__': main() 如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartimport urllibdef main(): # 创建一个带附件的邮件消息对象 message = MIMEMultipart() # 创建文本内容 text_content = MIMEText('附件中有本月数据请查收', 'plain', 'utf-8') message['Subject'] = Header('本月数据', 'utf-8') # 将文本内容添加到邮件消息对象中 message.attach(text_content) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/hello.txt', 'rb') as f: txt = MIMEText(f.read(), 'base64', 'utf-8') txt['Content-Type'] = 'text/plain' txt['Content-Disposition'] = 'attachment; filename=hello.txt' message.attach(txt) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/汇总数据.xlsx', 'rb') as f: xls = MIMEText(f.read(), 'base64', 'utf-8') xls['Content-Type'] = 'application/vnd.ms-excel' xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx' message.attach(xls) # 创建SMTP对象 smtper = SMTP('smtp.126.com') # 开启安全连接 # smtper.starttls() sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com'] # 登录到SMTP服务器 # 请注意此处不是使用密码而是邮件客户端授权码进行登录 # 对此有疑问的读者可以联系自己使用的邮件服务器客服 smtper.login(sender, 'secretpass') # 发送邮件 smtper.sendmail(sender, receivers, message.as_string()) # 与邮件服务器断开连接 smtper.quit() print('发送完成!')if __name__ == '__main__': main() 发送短信发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了互亿无线短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。 1234567891011121314151617181920212223import urllib.parseimport http.clientimport jsondef main(): host = \"106.ihuyi.com\" sms_send_uri = \"/webservice/sms.php?method=Submit\" # 下面的参数需要填入自己注册的账号和对应的密码 params = urllib.parse.urlencode({'account': '你自己的账号', 'password' : '你自己的密码', 'content': '您的验证码是：147258。请不要把验证码泄露给其他人。', 'mobile': '接收者的手机号', 'format':'json' }) print(params) headers = {'Content-type': 'application/x-www-form-urlencoded', 'Accept': 'text/plain'} conn = http.client.HTTPConnection(host, port=80, timeout=30) conn.request('POST', sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read() jsonstr = response_str.decode('utf-8') print(json.loads(jsonstr)) conn.close()if __name__ == '__main__': main() URL 组成部分详解URL 是 Uniform Resource Locator 的简写，中文名叫统一资源定位符，用于表示服务端的各种资源 先来看一个我们经常见到的 URL 形式：http://www.imooc.com/wiki/html5上面这个 URL 由以下几部分组成scheme://host:port/path?key=valuescheme：代表的是访问的协议，一般为 http 或者 https。例如，https://www.baidu.com 的协议是 https； host：主机名、域名，例如，https://www.baidu.com 的 host 为 www.baidu.com； port：端口号，http 协议默认使用 80 端口，https 协议默认使用 443 端口。通常情况下，使用默认值，不需要显式的写明端口号，例如，https://www.baidu.com 的端口是 443。某些情况下，可以显式的写明端口号，例如，http://localhost:5000 的端口号是 5000； path：页面路径，例如：http://www.imooc.com/wiki/html5 的 path 是 wiki/html5； key=value：查询字符串，例如：https://www.baidu.com/s?wd=python，查询字符串是 wd=python，查询字符串包括两部分：参数名和参数值，这个例子中，参数名是 wd，参数值是 python。 HTTP协议超文本传输协议（HTTP）因为我们在网页上看到的内容通常是浏览器执行 HTML （超文本标记语言）得到的结果，而 HTTP 就是传输 HTML 数据的协议。HTTP 和其他很多应用级协议一样是构建在 TCP（传输控制协议）之上的，它利用了 TCP 提供的可靠的传输服务实现了 Web 应用中的数据交换。 关于 HTTP 的详细信息以及目前的发展状况，大家可以阅读《HTTP 协议入门》、《互联网协议入门》、《图解 HTTPS 协议》等文章进行了解。 HTTP请求 一个HTTP请求报文由请求行（request line）、请求头部（headers）、空行（blank line）和请求数据（request body）4个部分组成。 如果没有数据发给服务器，消息体就不是必须的部分。请求行中包含了请求方法（GET、POST 等，如下表所示）、资源路径和协议版本；请求头由若干键值对构成，包含了浏览器、编码方式、首选语言、缓存策略等信息；请求头的后面是空行和消息体。 请求行 HTTP/1.1 定义的请求方法有8种：GET（完整请求一个资源）、POST（提交表单）、PUT（上传文件）、DELETE（删除）、PATCH、HEAD（仅请求响应首部）、OPTIONS（返回请求的资源所支持的方法）、TRACE（追求一个资源请求中间所经过的代理）。最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。 2.POST 方法和 GET 方法浏览器使用 method 属性设置的方法将表单中的数据传送给服务器进行处理。共有两种方法：POST 方法和 GET 方法。 如果采用 POST 方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器。 在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数。 另一种情况是采用 GET 方法，这时浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔。 一般浏览器通过上述任何一种方法都可以传输表单信息，而有些服务器只接受其中一种方法提供的数据。可以在 标签的 method （方法）属性中指明表单处理服务器要用方法来处理数据，使 POST 还是 GET。 3.POST 还是 GET？如果表单处理服务器既支持 POST 方法又支持 GET 方法，那么你该选择哪种方法呢？下面是有关这方面的一些规律： 如果希望获得最佳表单传输性能，可以采用 GET 方法发送只有少数简短字段的小表单。 一些服务器操作系统在处理可以立即传递给应用程序的命令行参数时，会限制其数目和长度，在这种情况下，对那些有许多字段或是很长的文本域的表单来说，就应该采用 POST 方法来发送。 如果你在编写服务器端的表单处理应用程序方面经验不足，应该选择 GET 方法。如果采用 POST 方法，就要在读取和解码方法做些额外的工作，也许这并不很难，但是也许你不太愿意去处理这些问题。 如果安全性是个问题，那么我们建议选用 POST 方法。GET 方法将表单参数直接放在应用程序的 URL 中，这样网络窥探者可以很轻松地捕获它们，还可以从服务器的日志文件中进行摘录。如果参数中包含了信用卡帐号这样的敏感信息，就会在不知不觉中危及用户的安全。而 POST 应用程序就没有安全方面的漏洞，在将参数作为单独的事务传输给服务器进行处理时，至少还可以采用加密的方法。 如果想在表单之外调用服务器端的应用程序，而且包括向其传递参数的过程，就要采用 GET 方法，因为该方法允许把表单这样的参数包括进来作为 URL 的一部分。而另一方面，使用 POST 样式的应用程序却希望在 URL 后还能有一个来自浏览器额外的传输过程，其中传输的内容不能作为传统 标签的内容。 HTTP响应 HTTP 响应通常是由响应行、响应头、空行、响应体四个部分构成。 响应行中包含了协议版本和响应状态码，响应状态码有很多种，常见的如下表所示。 响应头响应头与 HTTP 请求中的请求头类似，同样由头部字段名、冒号、空格和值组成响应头中包含了一系列服务器的信息，以及服务器对请求的响应。 空行与响应体HTTP 响应中同样使用空行来表示响应头结束。响应体则是服务器根据客户端的请求返回给客户端的具体数据。可能是 HTML 页面，也有可能是JSON或二进制数据等 Session和 Cookies我们在浏览网站的过程中，经常会遇到需要登录的情况，而有些网页只有登录之后才可以访问，而且登录之后可以连续访问很多次网站，但是有时候过一段时间就需要重新登录。 还有一些网站，在打开浏览器时就自动登录了，而且很长时间都不会失效，这种情况又是为什么？其实这里面涉及 Session和 Cookies 的相关知识， 静态网页和动态网页在开始介绍它们之前，我们需要先了解一下静态网页和动态网页的概念。这里还是前面的示例代码，内容如下： 这是最基本的 HTML代码，我们将其保存为一个 .html文件，然后把它放在某台具有固定公网 IP 的主机上，主机上装上 Apache 或 Nginx等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服 务器看到这个页面，这就搭建了一个最简单的网站。 这种网页的内容是 HTML代码编写的，文字、图片等内容均通过写好的 HTML代码来指定，这种页面叫作静态网页。它加载速度快，编写简单，但是存在很大的缺陷，如可维护性差，不能根据 URL灵活多变 地显示内容等。例如，我们想要给这个网页的 URL传入一个 name 参数，让其在网页中显示出来，是无法做到的。 因此，动态网页应运而生，它可以动态解析 URL中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。我们现在遇到的大多数网站都是动态网站，它们不再是一个简单的 HTML，而是可能由 JSP、PHP、Python等语言编写的，其功能比静态网页强大和丰富太多了。 此外，动态网站还可以实现用户登录和注册的功能。再回到开头来看提到的问题，很多页面是需要登录之后才可以查看的。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似凭证的东 西，有了它，我们才能保持登录状态，才能访问登录之后才能看到的页面。 那么，这种神秘的凭证到底是什么呢？其实它就是 Session和 Cookies 共同产生的结果，下面我们来一探究竟。 无状态 HTTP在了解 Session和 Cookies 之前，我们还需要了解 HTTP 的一个特点，叫作无状态。 HTTP 的无状态是指 HTTP 协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。 当我们向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。 这意味着如果后续需要处理前面的信息，则必须重传，这也导致需要额外传递一些前面的重复请求，才能获取后续响应，然而这种效果显然不是我们想要的。为了保持前后状态，我们肯定不能将前面的请求全 部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更是棘手。 这时两个用于保持 HTTP 连接状态的技术就出现了，它们分别是 Session和 Cookies。 SessionSession在服务端，也就是网站的服务器，用来保存用户的 Session信息；Session，中文称之为会话，其本身的含义是指有始有终的一系列动作 / 消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 Session。 而在 Web 中，Session对象用来存储特定用户 Session所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session对象中的变量将不会丢失，而是在整个用户 Session中一直存在下 去。当用户请求来自应用程序的 Web 页时，如果该用户还没有 Session，则 Web 服务器将自动创建一个 Session对象。当 Session过期或被放弃后，服务器将终止该 Session。 CookiesCookies 在客户端，也可以理解为浏览器端，有了 Cookies，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别 Cookies 并鉴定出是哪个用户，然后再判断用户是否是登录状态，进而返回对应的响应。 我们可以理解为 Cookies 里面保存了登录的凭证，有了它，只需要在下次请求携带 Cookies 发送请求而不必重新输入用户名、密码等信息重新登录了。 因此在爬虫中，有时候处理需要登录才能访问的页面时，我们一般会直接将登录成功后获取的 Cookies 放在请求头里面直接请求，而不必重新模拟登录。 Cookies 指某些网站为了辨别用户身份、进行 Session跟踪而存储在用户本地终端上的数据。 会话Cookie 和持久Cookie从表面意思来说，会话 Cookie 就是把 Cookie 放在浏览器内存里，浏览器在关闭之后该 Cookie 即失效；持久 Cookie 则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态。 其实严格来说，没有会话 Cookie 和持久 Cookie 之 分，只是由 Cookie 的 MaxAge 或 Expires 字段决定了过期的时间。 因此，一些持久化登录的网站其实就是把 Cookie 的有效时间和 Session有效期设置得比较长，下次我们再访问页面时仍然携带之前的 Cookie，就可以直接保持登录状态。 属性结构在浏览器开发者工具中打开 Application选项卡，然后在左侧会有一个 Storage 部分，最后一项即为 Cookies，将其点开 其中每个条目可以称为 Cookie。它有如下几个属性。Name，即该 Cookie 的名称。Cookie 一旦创建，名称便不可更改。Value，即该 Cookie 的值。如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据，则需要使用 BASE64 编码。 MaxAge，即该 Cookie 失效的时间，单位秒，也常和 Expires 一起使用，通过它可以计算出其有效时间。MaxAge 如果为正数，则该 Cookie 在 MaxAge 秒之后失效。如果为负数，则关闭浏览器时 Cookie 即 失效，浏览器也不会以任何形式保存该 Cookie。Path，即该 Cookie 的使用路径。如果设置为 /path/，则只有路径为 /path/ 的页面可以访问该 Cookie。如果设置为 /，则本域名下的所有页面都可以访问该 Cookie。Domain，即可以访问该 Cookie 的域名。例如如果设置为 .zhihu.com，则所有以 zhihu.com，结尾的域名都可以访问该 Cookie。Size 字段，即此 Cookie 的大小。 Http 字段，即 Cookie 的 httponly属性。若此属性为 true，则只有在 HTTP Headers 中会带有此 Cookie 的信息，而不能通过 document.cookie 来访问此 Cookie。 Secure，即该 Cookie 是否仅被使用安全协议传输。安全协议。安全协议有 HTTPS、SSL等，在网络上传输数据之前先将数据加密。默认为 false。 Session维持那么，我们怎样利用 Cookies 保持状态呢？当客户端第一次请求服务器时，服务器会返回一个响应头中带有 Set-Cookie 字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把 Cookies 保存起来。当浏 览器下一次再请求该网站时，浏览器会把此 Cookies 放到请求头一起提交给服务器，Cookies 携带了 Session ID 信息，服务器检查该 Cookies 即可找到对应的 Session是什么，然后再判断 Session来以此来辨认用户 状态。 在成功登录某个网站时，服务器会告诉客户端设置哪些 Cookies 信息，在后续访问页面时客户端会把 Cookies 发送给服务器，服务器再找到对应的 Session加以判断。如果 Session中的某些设置登录状态的变量是 有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。 反之，如果传给服务器的 Cookies 是无效的，或者 Session已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录。 所以，Cookies 和 Session需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录 Session控制。 常见误区常在谈论 Session机制的时候，常常听到这样一种误解 ——“只要关闭浏览器，Session就消失了”。可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对 Session 来说，也是一样，除非程序通知服务器删除一个 Session，否则服务器会一直保留。比如，程序一般都是在我们做注销操作时才去删除 Session。 但是当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉，是因为大部分网站都使用会话 Cookie 来保存 Session ID 信息，而关闭浏览器后 Cookies 就消失了，再次连接服务器时，也就无法找到原来的 Session了。如果服务器设置的 Cookies 保存到硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 Cookies 发送给服务器，则再次打开浏览器，仍然能够找到原来的 Session ID，依旧还是可以保持登录状态的。 而且恰恰是由于关闭浏览器不会导致 Session被删除，这就需要服务器为 Session设置一个失效时间，当距离客户端上一次使用 Session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才 会把 Session删除以节省存储空间。 域名域名解析就是将域名转换为IP地址去访问 A记录是用来记录域名对应的IP地址。CNAME也叫别名记录，用来把域名解析到别的域名上。一般情况下都建议使用CNAME记录。CNAME记录可用于CDN加速，通过CDN加速别名解析网站域名，这样既可以起到加速网站的作用，又能隐藏网站的真实IP，减少被攻击的几率。","categories":[{"name":"前端","slug":"前端","permalink":"https://wenkexia.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://wenkexia.github.io/tags/web/"},{"name":"计网","slug":"计网","permalink":"https://wenkexia.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"java基础","slug":"java基础","date":"2021-12-24T00:53:47.000Z","updated":"2021-12-24T00:53:47.000Z","comments":true,"path":"2021/122465132.html","link":"","permalink":"https://wenkexia.github.io/2021/122465132.html","excerpt":"","text":"基础字符标识符命名规则可以包含数字，但不能以数字开头除了下划线_,和$符之外，不能有其它特殊字符，如空格区分字母大小写不能使用Java关键字换行符\\n要加双引号System.out.println(“名字”+“\\n”); 注释单行注释：//多行注释：从“/”开始到“/”结束，文档注释：从“/*”开始到“/”结束文档注释可以用javadoc命令提取出来，生成类似于jdk文档的网页文件，以便于他人了解一个类的功能。 变量变量基本结构：类型 变量名 =值 前面不可以有访问符 8种基本数据类型数值型 整数short型（短整型）数据在内存中占用2个字节long型（长整型）数据在内存中占用8个字节。int型（整型）数据在内存中占用4个字节。byte型（字节型）数据在内存中占用1个字节，表示的存储数据范围为：-128~127。 浮点数 float型（单精度浮点型）数据在内存中占用4个字节。 float t = 3.1f f转为double型 double型（双精度浮点型）数据在内存中占用8个字节。 一般小数默认是double型 布尔型boolean：数据值只有true或false，适用于逻辑计算。 字符型(char)char每个字符占2个字节，定义时用单引号’ ‘ 字符串类型String最常用的一种存储文本的数据类型，用双引号“”任何数据+字符串操作结果都是字符串使用关键字和构造方法来创建 String 对象。String str2=new String(“Runoob”);有内置方法hashCode() 方法用于返回字符串的哈希码。length() 方法，它返回字符串对象包含的字符数。 流程控制判断语句if条件语句switch多重选择循环语句while循环do while循环for循环12345for (初始条件; 循环检测条件; 循环后更新计数器) { // 执行语句}break语句通常都是配合if语句使用。要特别注意，break语句总是跳出自己所在的那一层循环continue则是提前结束本次循环，直接继续执行下次循环 for each循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的List、Map等。 数组遍历数组for循环通过索引来访问 12345int[] ns = { 1, 4, 9, 16, 25 };for (int i=0; i&lt;ns.length; i++) { int n = ns[i]; System.out.println(n);} for each循环直接迭代数组的每个元素 第七章异常 Error严重的错误 OutOfMemoryError：内存耗尽 NoClassDefFoundError：无法加载某个Class StackOverflowError：栈溢出 Exceptio是运行时的错误，它可以被捕获并处理。 RuntimeException以及它的子类； 非RuntimeException （包括IOException、ReflectiveOperationException等等） 异常类分为两种 1.错误。一般指与虚拟机相关的问题，这些错误无法恢复和捕获 2.异常（Exception），因编码错误或外在因素导致的问题 两种异常处理机制 1.使用try catch捕获异常 存在多个catch的时候，catch的顺序非常重要：子类必须写在前面 2.trrows抛出异常 对象和类类类是一个模板，描述一类对象的属性(状态)和方法(行为) 1.属性直接把field用public暴露给外部可能会破坏封装性，所以用private外部代码可以调用get()方法和set()方法来间接获取和修改指定的私有成员变量的值 2.方法一个类可以有很多种方法，逻辑运算，数据修改都是在方法中完成的 定义语法 1234修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值;} 若方法中没有returun返回值，则该方法的返回类型为void类型 参数方法的参数传递机制形参：声明方法时定义的参数，形参前必须有数据类型 格式：方法名（数据类型 形参）实参：调用方法时给方法传递的实际数据，使用格式：对象名.方法名（实参） 可变参数：定义格式方法名（参数列表，数据类型 … 变量）注意：可变参数只能处于参数列表的最后一个方法最多只能包含一个可变参数可变参数本质是一个数组，因此在调用时，既可以传入多个参数，也可传入一个数组 构造方法作用：在创建对象时初始化对象中的属性值构造方法的名称必须是类名。构造方法没有返回类型（也没有void），调用构造方法，必须用new操作符。不能被static、final、synchronized、abstract和native修饰。构造方法不能被子类继承，所以用final和abstract修饰没有意义。 构造方法用于初始化一个新建的对象，所以用static修饰没有意义 语法：访问符 类名 （参数）{} this关键字：this代表当前对象的内存地址，在实例方法或者构造方法中，为了区分局部变量和实例变量，this不能省略代表当前类将来产生的对象，即将来用该类new出来的对象，用于获取当前类的对象的引用 set方法和get方法封装性即对类中的域变量进行封闭操作，即用private来修饰他们，如此一来其他类则不能对该变量访问 程序仅通过对象的方法与对象数据进行交互，即通过set和get方法间接地操作这些私有域变量 命名规则： 返回类型都是void 方法名是set 加上成员变量名字的首字母大写 带一个参数 参数类型是成员变量的类型 方法的调用1.调用非静态方法 对象名.方法名（）2.调用静态方法 类名.方法名() 12Person p1 = new Person(\"Xiao Ming\", 15); // 既可以调用带参数的构造方法Person p2 = new Person(); // 也可以调用无参数构造方法 方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。目的：功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。 方法重写子类重写了父类的方法注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法 对象对象是类的一个实例，有状态和行为 创建对象语法：类名 对象名=new 类名(); 创建类的对象分为两步1.定义该类的一个变量，此时在栈上会分配空间储存对象在堆中的地址（即对象的引用）2.创建该对象的实际物理空间，即在堆中为该对象分配空间，并把此空间的地址（即引用）赋给对象名，此步骤通过new关键字来实例化该类的一个对象 使用对象创建对象后就可以使用对象访问对象的属性 语法：对象名.属性名调用对象的方法 语法：对象名.方法名（） 面对对象面向对象三大特征封装实际上就是信息隐藏，将类中的成员属性和成员方法修饰为私有化，数据被保护在对象的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系，即get/set方法。 其他对象只能通过该对象提供的get/set方法，与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外提供的接口来访问该对象。 访问符：用于指明类、属性或方法的访问权限public公共访问权限，可被同一包或不同包的所有类访问protected子类访问权限，可以被同一包的其它类访问，也可以被其他包的子类访问friendly包访问权限，如果没设置访问符则默认friendly包访问权限，可被同一包中所有类访问private 当前类访问权限，只能被当前类的其它成员访问 修饰符：用于指明类的特性 abstarct（抽象） static（静态） final（最终） 如果有很多代码都使用了Dog这个类；当某一天这个类的age属性需要换成String类型，那么，外部使用它的任何地方都需要需改xxx.age=”xxx”，这将是非常繁琐的一个过程，那该怎么办呢？很简单，使用private修饰符将属性封装，开放访问接口的方法，我们只需要修改一下set方法就能完美解决。 1234567891011121314151617public static void main(String[] args) { Dog d1 = new Dog(); //调用时发生变化 d1.setName(\"旺财\"); d1.setAge(3); }}class Dog{ private String age;//修改为String类型 private String name; //将属性私有化，提供set方法，将int类型的值转成String public void setAge(int age) { this.age = String.valueOf(age); } public void setName(String name) { this.name = name; } 这样外部使用它的地方都不用修改，我们只用简单的修改对象内部就可以了，更加方便快捷。到了这里我们应该可以看出，封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。 这里还可以体现出一些封装属性的优势，案例如下： 12345678910111213141516171819202122public static void main(String[] args) { Dog d1 = new Dog(); d1.setName(\"旺财\"); d1.setAge(300);//狗的年龄赋值很明显不合理，这里就需要在set方法中给出提示 }}class Dog{ private String age; private String name; public void setAge(int age) { if(age&gt;100||age&lt;0) { System.out.println(\"你见过超过100岁的狗狗吗？\"); }else { this.age = String.valueOf(age); } } public void setName(String name) { this.name = name; } } 继承作用：通过继承，子类可以使用父类中的非私有属性和非私有方法，从而提高代码的重用性，提高开发效率。子类自动获得了父类的所有字段，严禁定义与父类重名的字段！为了让子类可以访问父类的字段，把private改为protected。用protected修饰的字段可以被子类访问除了父类中私有的属性和方法，子类必须全部继承。3、子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。4、子类可以用自己的方式实现父类的方法（即方法的重写/覆盖）。5、构造器而言，它只能够被调用，而不能被继承，子类可以使用super()调用父类构造器。6、对于继承而已，子类会默认调用父类的无参构造，但是如果父类没有无参构造，子类必须要在其构造方法中的第一行代码调用指定父类的构造器，传递对应参数。7、Java 的继承是单继承，即每个子类只能拥有一个直接父类，但是该父类可以有多个子类通过extends关键字实现继承语法格式访问符 修饰符 class 子类 extends 父类{ } 12345678910111213141516171819202122232425class Father{ //父类中的非私有属性都会被继承 public int age; private double money; String home; //父类中的非私有方法都会被继承 void eat() {} //吃东西 public void sleep() {}//睡觉 private void soner() {}//打呼噜 //父类构造方法如果有参数，子类必须在构造方法第一行中调用 public Father(int x) { //父类如果写了有参构造，那么默认的无参构造将不再生效 }}class Son extends Father{ public Son(int x) { super(x);//调用父类构造 super() age=12;//继承后拥有父类的属性 home=\"王者峡谷河道下边的草丛\"; //money=3.0; 父类私有属性无法访问 sleep();//可以执行父类中的非私有方法 } } 子类继承父类，默认在子类构造方法中调用父类构造，在创建子类实例对象时，实际上的执行顺序是（父类构造——子类构造）。在类的构造器中还有一段特别的代码，优先与构造器，在创建对象时优先执行，话不多说直接看代码： 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) { Z z1 = new Z();//创建子类实例对象时，实际上的执行顺序 } }class F { static { //静态代码块，只有方法的大括号，没有方法名返回值等任何内容 System.out.println(\"父类静态代码块\"); } { //构造代码块，只有方法的大括号，没有方法名返回值等任何内容 System.out.println(\"父类构造代码块\"); } public F() { // 父类构造器 System.out.println(\"父类构造器\"); }}class Z extends F{ static { //静态代码块，只有方法的大括号，没有方法名返回值等任何内容 System.out.println(\"子类静态代码块\"); } { //构造代码块，只有方法的大括号，没有方法名返回值等任何内容 System.out.println(\"子类构造代码块\"); } public Z() { // 父类构造器 System.out.println(\"子类构造器\"); }} 运行结果 123456父类静态代码块子类静态代码块父类构造代码块父类构造器子类构造代码块子类构造器 多态面向对象三大特征，封装、继承、多态。从某种意义上来讲，封装和继承几乎就是为了多态而准备的，也是三大特征中最重要的知识点。 多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。简单来说就是不同类型的对象（父类或子类）调用同一个方法，根据发出调用的对象不同，执行的方法也就不同。 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 多态的作用：消除类型之间的耦合关系。 这里举一个简单的小例子：父类是个农民，技能是使用锄头耕地。子类继承了父类，重写了父类的锄头耕地技能，更新换代为使用拖拉机耕地。如果是父类对象调用这个技能，就是使用锄头手动耕地，如果是子类对象调用这个技能，就是使用拖拉机耕地。 java实现多态有三个必要条件：继承、重写、父类引用指向子类对象。继承：在多态中必须存在有继承关系的子类和父类。重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。父类引用指向子类对象（向上转型）：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 123456789101112131415161718192021222324252627282930public class People {//人类 作为所有职业的父类 public int age; public String name; void work() {//父类的方法 System.out.println(\"劳动\"); } public static void main(String[] args) { //父类引用指向子类对象就是多态性的体现 People p1 = new Doctor();// p1的类型是人类类型，但是指向的实例对象是医生 p1.work();//父类引用发出的调用，调用到的是医生类中重写父类的方法 People p2 = new Teacher(); p2.work();//父类引用发出的调用，调用到的是教师类中重写父类的方法 } } class Doctor extends People{ @Override void work() {//医生类继承人类，重写工作方法 System.out.println(\"救死扶伤\"); } }class Teacher extends People{ @Override void work() {//教师类继承人类，重写工作方法 System.out.println(\"教书育人\"); }} 运行结果 12救死扶伤教书育人 注意：指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的。比如说方法的重载，尽管方法名称相同，但是父类只能调用到子类重写的方法，调用不到重载方法。 12345678910 class Teacher extends People{ @Override void work() {//教师类继承人类，重写work方法 System.out.println(\"教书育人\"); } void work(String name) {//重载了work方法，但是此方法父类引用无法调用 System.out.println(\"负责教导的课程是\"+name); }}多态的好处： 1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如：医生、律师、程序员都是人类的子类，根据使用场景不同随时可以替换为符合的职业。2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在拥有了医生、律师的继承上，还可以继续添加新的职业，比如主播，运动员等，都是添加为人类的多态性。3.接口性（interface-ability）。多态是超类通过抽象方法，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。每个子类都可以根据自身的特性去重写父类的抽象方法。4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 https://blog.csdn.net/weixin_37942054/article/details/119081228?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164069407816780265482575%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164069407816780265482575&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-119081228.pc_search_insert_es_download&amp;utm_term=java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&amp;spm=1018.2226.3001.4187 类之间的关系继承依赖关系在一个类的方法中操作另一个类的对象，则称其依赖于第二个类例如方法的参数时某个类的对象 关联关系体现为一个类中使用另一个类的对象作为该类的成员变量 聚合关系聚合关系是关联关系的一种特例，体现是整体与部分的关系，表现为一个类（整体）由多个其他类的对象（部分）作为该类的成员变量 组成关系抽象类定义抽象类语法格式： 123访问符 abstract class 类名{ 访问符 abstract 返回类型 方法名（参数列表）} 抽象方法有抽象方法的类只能被定义为抽象类，但抽象类中可以没有抽象方法抽象类不能被实例化，即无法用new创建一个抽象类的对象抽象类作为子类的模版，避免子类设计的随意性对象不能由抽象类直接创建，只可以通过抽象类派生出新的子类，再由其子类来创建对象abstract 关键字不能用来修饰属性和构造方法抽象方法必须被子类重写才有意义，因此不能用private修饰抽象方法抽象方法,没有方法体 12public abstract void call（）； //抽象方法，没有{}括起来的方法体public void call（）{}. //空方法 使用抽象类写一个子类继承抽象类，重写抽象方法虽然不能直接new一个抽象类，但可以先声明一个抽象类变量，再用这个变量指向其子类对象 12抽象类名 a;a = new 子类名(); 接口接口规定一批类必须提供某些方法，但不提供实现方法不能用final关键字修饰接口 接口与类的区别接口不能用于实例化对象接口没有构造方法接口中所有方法必须是抽象方法接口中不能包含成员变量，除了static和final变量接口不是被类继承了，而是被类实现了接口支持多重继承 接口特性接口是隐性抽象的，接口中的每个方法也是隐形抽象的，声明时不必使用abstract关键字接口中的属性和方法都是公有的，默认为public,可以不写成员变量被隐含地声明为public static final，属性只能是静态常量接口中的方法被隐形指定为public absrtact接口定义的方法只能是抽象方法，默认方法，类方法接口访问符可以是public或默认，默认是采用包权限访问控制，即在相同包内才可以访问该接口 定义接口用关键字interface定义 12345678910111213访问符 interface 接口名 {//接口定义的只能是静态常量int a = 5;//接口定义的普通方法只能是public的抽象方法void display();//接口中定义默认方法，用default修饰default void print(int b){}//接口中定义类方法，用static修饰static void del(){}} 实现接口用implements实现接口一个类可实现多个接口，且必须实现接口中定义的所有抽象方法，否则该类必须定义为抽象类语法格式： 12345678910111213访问符 class implements 接口1，接口2{}public static void main (String[]args){//先声明一个接口类型的变量，new一个该接口实现类的实例对象，并将其引用赋值给变量接口名 变量名 = new 接口实现类（）;//调用接口的默认方法，必须通过实例对象来调用变量名.默认方法（）;//调用接口的类方法接口名.类方法（）;//声明接口实现类的变量，并实例化该类型对象接口实现类名 变量名 = new 接口实现类名（）;} 接口的继承接口可以继承多个接口，不能继承类使用interface可以声明一个接口： 1234interface Person { void run(); String getName();} 属性只能是常量 一个类可以实现多个interface，例如： 123class Student implements Person, Hello { // 实现了两个interface ...} 核心类字符串类每个用双引号括起来的字符串都是String类的一个实例 内部类java允许在一个类的类体里再定义一个类，该情况下外面的类叫外部类，里面的叫内部类内部类可以访问其所在内部类的所有属性 成员内部类在外部类的内部定义一个类 静态内部类非静态内部类局部内部类匿名内部类final class就不能被别的类继承 习题简答题1、java源程序在控制台环境下编译和运行的命令是什么？编译之后生成了什么文件？编译Javac name.java 生成.class文件运行Java name 2．Java的数据类型分为哪几种？请列举出8个Java的基本数据类型。 byte short int long double float char boolean 继承的主要作用是什么？如何使用一个子类继承一个父类？通过继承，子类可以使用父类的非私有属性和非私有方法，从而提高代码重用性，提高开发效率 4、continue的功能是什么？break的功能是什么？两者的区别？continue跳出本次循环，直接执行下一次循环break直接跳出本层循环 toString 方法的功能是什么？如何使用toString 来实现方法重写？toString()将对象的内容转换为字符串当需要将一个对象输出到显示器时,通常要调用他的toString()方法,将对象的内容转换为字符串.java中的所有类默认都有一个toString()方法 默认情况下 System.out.println(对象名)或者System.out.println(对象名.toString())输出的是此对象的类名和此对象对应内存的首地址 如果想自定义输出信息必须重写toString()方法 12345678/*注意事项1.必须被声明为public2.返回类型为String3.方法的名称必须为toString,且无参数4.方法体中不要使用输出方法System.out.println()语法格式为*/public String toString(){ } 6、构造方法的作用是什么？在创建对象时，初始化对象的属性 什么是抽象方法？什么是抽象类？抽象类就是不能使用new方法进行实例化的类，即没有具体实例对象的类抽象方法：抽象方法就是以abstract修饰的方法，这种方法只声明返回的数据类型，方法名称和所需要的参数，没有方法体，这个方法必须被子类的方法所重写 8 什么是类间的依赖关系？什么是类的关联关系？什么是类的聚合关系？什么是类的组成关系？ 依赖关系在一个类的方法中操作另一个类的对象，则称其依赖于第二个类例如方法的参数时某个类的对象 关联关系体现为一个类中使用另一个类的对象作为该类的成员变量 聚合关系是关联关系的一种特例，表现为一个类（整体）由多个其他类的对象（部分）作为该类的成员变量 super关键字的主要作用是什么？对于有继承关系的类，子类可以通过这个关键字调用父类中的方法写法，即 super（构造方法名），而且必须是这个构造方法的第一句。在子类的构造方法中调用父类的构造方法在子类方法访问父类的属性和方法 this代表什么？this大部分情况下是可以省略的，请说明什么时候不能省略this。this是一个变量，保存了当前对象的内存地址，指向这个对象自身。this代表的就是 “当前对象”在实例方法或者构造方法当中，为了区分同名的局部变量和实例变量，this不能省略 Java中包含哪几种内部类？什么是成员内部类？什么是局部内部类？什么是最终类？包含：成员内部类、局部内部类、静态内部类、匿名内部类成员内部类：在“外部类”的内部定义一个类，作为一个成员存在，与外部类的属性、方法并列局部内部类：在方法中定义的内部类称为局部内部类，不仅可以访问包含它的外部类成员，还可以访问局部变量最终类：最终类有final关键字修饰，最终类不可被继承 什么是类？类里面包含什么？什么是对象？两者之间的区别是什么？类：类是具有相同属性和方法的一组对象的集合类包含字段和方法对象：对象是一具体事物区别：对象是类的一个实例，拥有类定义的属性和方法 java中有哪几种注释？分别用什么符号表示？单行注释：//多行注释：从“/”开始到“/”结束，文档注释：从“/*”开始到“/”结束文档注释可以用javadoc命令提取出来，生成类似于jdk文档的网页文件，以便于他人了解一个类的功能。 什么是缺省构造器？它的作用是什么？缺省构造器什么时候无法产生作用？如果一个类没有定义构造方法，编译器会自动创建一个缺省构造器作用在创建对象时初始化对象的属性如果你已经定义了一个无参构造方法， public、private、protected三个访问控制符代表了不同的访问级别，请分别进行说明。public公共访问权限，可被同一包或不同包的所有类访问protected子类访问权限，可以被同一包的其它类访问，也可以被其他包的子类访问friendly包访问权限，如果没设置访问符则默认friendly包访问权限，可被同一包中所有类访问private 当前类访问权限，只能被当前类的其它成员访问 什么是多态？多态在代码中的表现形式是什么？多态的作用？同一个对象在不同阶段，多种状态表现形式：继承、重写、父类引用指向子类对象作用：可以将子类对象直接赋值给一个父类引用变量，无须任何类型转换 一个”.java”源文件中是否可以包括多个类(不是内部类)?有什么限制?可以，但只能有一个public类，并且public的类名必须和文件名一致 final关键字的主要作用是什么？被final关键字修饰的类不能被继承，被final关键字修饰的类属性和类方法不能被覆盖（重写）； 什么是接口？接口如何定义？接口中能够包含哪些方法？接口和类在继承方面的区别。接口可以定义抽象方法，默认方法，类方法接口可以多继承，即一个接口可以继承多个接口类只能单继承，一个子类只能有一个直接父类 什么是方法重载？什么是方法重写？两者的区别？方法重载是指在同一个类中定义多个同名的方法，但要求每个方法具有不同的参数类型或者参数个数方法重写是指在子类创建一个与父类中除了方法体的实现不同外，其它都相同的方法，以便实现不同于父类的功能 判断一个变量的数据是奇数还是偶数12345678910111213141516171819public class Test { public static void main(String[] args) { judgeNum(2); judgeNum(3);}/*** 判断是奇数还是偶数的方法* @param num*/public static void judgeNum(int num) { if(num % 2 == 0) { System.out.println(num + \"是偶数\");} else { System.out.println(num + \"是奇数\");}}} 计算 1000 以内不能被 7 整除的整数之和。1234567891011public class Test02 { public static void main(String[] args) { int s=0; for(int i=1;i&lt;=1000;i++){ if((i%7)!=0){ s=s+i; } } System.out.println(s); }} 计算 1+2-3+4-5+…+100 的结果。12345678910111213141516171819public class Method03 { public static void main(String[] args) { int res = getSum(); System.out.println(res); } /* 返回值类型: int 方法名称： getSum 参数列表： */ public static int getSum(){ int sum = 0; for (int i = 1; i &lt;= 100; i++) { sum += i; } return sum; } 定义一个方法，计算某个整数的阶乘。1234567891011121314public class Method04 { public static void main(String[] args) { int res = jieCheng(5); System.out.println(res); } public static int jieCheng(int num) { int result = 1; for (int i = num; i &gt; 1; i--) { result *= i; } return result; }} 定义一个方法，判断某个整数是否为质数。（质数是指大于 1 的自然数中，除了 1 和它本身之外不再有其它因数的自然数。） 12345678910111213141516171819202122232425public class Test02 { public static void main(String[] args) { System.out.println(prime(3)); } //定义方法 public static boolean prime(int n) { //先判断小于0的 if (n &lt; 0) { return false; } if (n == 1 || n == 2) { return true; } else { int a = (int) Math.sqrt(n); //如9%3=0 他除了1合本身还有别的数 for (int i = 2; i &lt;= a; i++) { if (n % i == 0) { return false; } } return true; } }} 小红的妈妈每天都会给她 2.5 元钱，她都会存起来。但是，如果这一天是存钱的第 5 天或者是 5 的倍数的话，她都会花去 6 元。请问：经过多少天，小红才可以存到 100 元钱。 123456789101112131415public class XiTi5 { public static void main(String[] args){ double sum = 0; for(int i=1;;i++){ sum = 2.5 + sum; if(i%5==0){ sum = sum-6; } if(sum&gt;=100){ System.out.println(\"经过\"+i+\"天可以存到100元钱\"+\",\"+\"钱的总数是\"+sum+\"元\"); break; } } }} 水仙花数一个数如果是一个三位数，并且它的十位、个位、百位的数字立方和等于它本身，这个数就叫做水仙花数。例如：371 = 3 的立方+7 的立方+1 的立方。 请求出所有水仙花数。 123456789101112131415public class XiTi6 { public static void main(String[] args) { int a,b,c,s; for(int i=100;i&lt;1000;i++) { c=i%10; b=(i/10)%10; a=i/100; if(Math.pow(a,3)+Math.pow(b,3)+Math.pow(c,3)==i) { System.out.print(\" \"+i); } } }} 求出数组中的最大值[5, 15, 30, 20, 1000] 12345678910111213141516public class Array03 { public static void main(String[] args) { int[] array = {5, 15, 30, 20, 1000}; int max; max = array[0]; for (int i = 1; i &lt; array.length; i++) { if(array[i] &gt; max) { max = array[i]; } } System.out.println(\"max:\" + max); }} 数组元素反转本来：[10, 30, 20, 40, 50]结果：[50，40, 20, 30, 10]要求不能使用新数组，就用原来的唯一一个数组。 12345678910111213141516171819202122232425262728293031323334public class Array04 { public static void main(String[] args) { int[] array = {10, 20, 30, 40, 50}; //遍历打印数组本来的样子 for (int i = 0; i &lt; array.length; i++) { System.out.println(array[i]); } System.out.println(\"==================\"); /* 初始化语句： int min = 0, max = array.length - 1; 条件判断： min &lt; max 步进表达式： min++, max-- 循环体：交换 */ for(int min = 0, max = array.length - 1; min &lt; max; min++, max--) { //交换 int temp = array[min]; array[min] = array[max]; array[max] = temp; } for (int i = 0; i &lt; array.length; i++) { System.out.println(array[i]); } }} 对象数组定义一个数组，用来存储 3 个 Person 类的对象break &amp; continue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class Person { //属性 == 实例变量 private String name; private int age; //构造方法 public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } //setter getter public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}public class PersonTe { public static void main(String[] args) { //首先创建一个长度为3的数组，用来存放Person类型的对象 Person[] array = new Person[3]; System.out.println(array[0]); //创建3个对象 Person p1 = new Person(\"ZhangSan\", 18); Person p2 = new Person(\"ZhangSa\", 19); Person p3 = new Person(\"Zhang\", 20); //赋值 array[0] = p1; array[1] = p2; array[2] = p3; System.out.println(array[1].getName()); }}public class PersonTest { public static void main(String[] args) { Person01 p1 = new Person01(); p1.name = \"ZhangSan\"; p1.sayHello(\"Lisi\"); System.out.println(p1); }}class Person01{ //实例变量 String name; //实例方法 public void sayHello(String name) { System.out.println(name + \" , hello, I am \" + this.name); System.out.println(this); }} 实现一个 student 类包含属性：name age address zipCode要求：全部属性都私有化，并提供相应的 get/set 方法以及无参构造方法和有参构造方法。并为该类添加一个方法，返回 student 对象的地址和邮编。最后编写测试类，返回自己的地址邮编。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Student { //实例变量 private String name; private int age; private String address; private String zipcode; //静态变量：类级别 static String job = \"study\"; //无参构造 public Student(){ } //有参构造 public Student(String name, int age, String address, String zipcode) { this.name = name; this.address = address; this.age = age; this.zipcode = zipcode; } //返回地址和邮编 public String getPostAddress() { return \"地址：\" + this.address + \" , 邮编：\" + this.zipcode; //return \"地址：\" + this.g + \" , 邮编：\" + this.zipcode; } public void study() { System.out.println(this.getName() + \"is studying.\"); } //静态方法 public static void testStatic() { System.out.println(\"static\"); } //getter and setter public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}public class StudentTest { public static void main(String[] args) { Student s1 = new Student(); s1.setName(\"XiaoMei\"); s1.setAge(20); System.out.println(s1.getName() + \",\" + s1.getAge()); Student s2 = new Student(\"XiaoMing\", 18, \"佛山\", \"374893748\"); System.out.println(s2.getPostAddress()); }} 实现一个日期类，表示年月日信息。要求：全部属性都私有化，并提供相应的 get/set 方法以及无参构造方法和有参构造方法。如果调用无参构造方法，默认创建的日期为 1970 年 1 月 1 号。并为该类添加一个可以打印日期的方法。最后编写测试类输出 2022 年 1 月 1 日。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Date { //实例变量 private int year; private int month; private int day; //无参构造 public Date() { this.year = 1999; this.month = 1; this.day = 1; } //有参构造 public Date(int year, int month, int day){ this.year = year; this.month = month; this.day = day; } //setter and getter public void setYear(int year) { //设立关卡 this.year = year; } public int getYear() { return year; } //打印的日期方法 public void printDate() { //System.out.println(this.year + \"年\" + this.month + \"月\" + this.day + \"日\"); //System.out.println(year + \"年\" + month + \"月\" + day + \"日\"); System.out.println(this.getYear() + \"年\" + this.month + \"月\" + this.day + \"日\"); }}public class DateTest { public static void main(String[] args) { Date d1 = new Date(); d1.printDate(); Date d2 = new Date(2021, 11, 16); //System.out.println(d2.printDate()); }} 继承和方法覆盖： 实现说话中国人说中文，输出 小美说中文美国人说英文， 输出 jack 说英文（要求用多态实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class PersonTest { public static void main(String[] args) { Chinese chinese = new Chinese(); chinese.setName(\"XiaoMei\"); chinese.speak(); American american = new American(); american.setName(\"Jack\"); american.speak(); }}//父类class Person{ //属性 private String name; //构造方法 public Person(){} public Person(String name){ this.name = name; } //setter and getter public void setName(String name) { this.name = name; } public String getName() { return name; } //speak public void speak(){ System.out.println(name + \" is speaking...\"); }}//子类class Chinese extends Person{ @Override public void speak(){ System.out.println(this.getName() + \" is speaking Chinese.\"); }}class American extends Person{ @Override public void speak(){ System.out.println(this.getName() + \" is speaking English.\"); }}## 1、编写程序模拟 主人 喂养 宠物 的场景。 主人养了一只狗作为宠物， 主人会喂狗，只要主人喂狗，狗就吃 最后输出：主人喂了食物，狗吃的很香 过了一段时间，主人又养了一个新的宠物：猫咪 最后输出：主人喂了食物，猫吃的很香 ```javaclass Testfeed{ public static void main(String[] args) { //创建一个宠物对象 Pet pet = new Pet(); //创建一个狗对象 Dog dog = new Dog(); //创建一个主人对象 Master master = new Master(); //调用主人投喂方法 master.feed(dog); }}class Pet{//创建宠物类让其它类都继承他 public void eat(){//创建宠物吃方法 System.out.println(\"动物在吃\"); }}class Dog extends Pet//创建狗类{ public void eat(){//覆盖父类吃方法对吃方法重写 System.out.println(\"狗在吃\"); }}class Cat extends Pet{ public void eat(){ System.out.println(\"猫在吃\"); }}class YingWu extends Pet{ public void eat(){ System.out.println(\"鹦鹉在吃\"); }}class Master{ public void feed(Pet p){//此处实际上是 Pet p = new Dog();此处涉及到父类引用指向子类对象，即多态 p.eat();//调用父类吃方法，此处为编译器识别通过，具体调用哪个子类的吃方法还要看动态绑定的那个子类是啥 }} 2、编写程序实现乐手弹奏乐器，可以弹奏不同的乐器从而发出不同的声音。乐器包括：二胡、钢琴和琵琶实现乐器类 Instrument, 包括方法 makeSound()通过测试类，让乐手弹奏不同的乐器参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void play(Instrument instrument){ instrument.makeSound() }//测试类public class TestMusic { public static void main(String[] args) { Musician m = new Musician(); Violin v = new Violin(); m.play(v); }}//乐器类class Instrument{ public void makeSound(){ System.out.println(\"乐器发声\"); }}//二胡class Erhu extends Instrument{ public void makeSound(){ System.out.println(\"二胡在拉\"); }}//钢琴class Piano extends Instrument{ public void makeSound(){ System.out.println(\"弹钢琴\"); } }//小提琴class Violin extends Instrument{ public void makeSound(){ System.out.println(\"拉小题琴\"); } }class Musician{ public void play(Instrument i){ i.makeSound(); }} 接口：（要求用多态实现） 1、创建一个用于描述汽车的接口行驶、刹车、鸣笛都继承该接口并且实现具体功能，测试类进行测试。汽车行驶中汽车鸣笛嘀嘀嘀汽车刹车声！ 123456789101112131415161718 public class Test02 { public static void main(String[] args) { Car car = new MingDi(); car.action(); }}interface Car{ public abstract void action();}class MingDi implements Car{ @Override public void action(){ System.out.println(\"汽车鸣笛嘀嘀嘀！\"); }} 2、实现：中午去饭馆吃饭顾客 点菜菜（菜单）是接口厨师 做菜厨师负责实现这个接口顾客负责调用这个接口 12345678910111213141516171819interface Menu{ public abstract void yuXiang();}class Cook implements Menu{ public void yuXiang(){ System.out.println(\"yuXiang\"); }}class Customer{ Menu menu; public void order(){ menu.yuXiang(); }} idea设置设置-&gt;编辑器-&gt;常规-&gt;自动导入 (开启自动导包，删包) 更改用户保存目录在你的IDEA安装目录下的bin目录，可以看到一个idea.properties文件，这个文件是IDEA的核心配置文件添加 123idea.config.path=D:/data/IDEA/.IntelliJIdea/configidea.system.path=D:/data/IDEA/.IntelliJIdea/system maven用户设置文件：C:\\Users\\wenke.m2\\settings.xml本地仓库：C:\\Users\\wenke.m2\\repository 我设置成用户设置文件：D:\\data\\IDEA.IntelliJIdea.m2\\settings.xml本地仓库：D:\\data\\IDEA.IntelliJIdea.m2\\repository 快捷键ctrl + d 快速复制这行到下一行 alt + insert ：自动生成get,set方法 注释行注释Ctrl+/、块注释Ctrl+Shift+/文档注释 /**+enter 比较文件按住ctrl选中多个文件，右击选比较文件或者ctrl+d 自动生成psvm:main()方法 “内容”.sout :输出语句 fori:for循环语句 flag.whil + 回车：while语句 flag.if + 回车 ：if语句 new 类名.var + 回车 ：自动生成对象 推荐插件Alibaba Java Coding Guidelines（阿里巴巴Java开发规范） Key Promoter X（IDEA快捷键提示） Save Actions（当程序员将代码保存后，插件会自动进行格式化） Codota AI Autocomplete（代码自动提示和推荐） Auto filling Java call arguments（自动填充调用方法参数）在调用函数时，通过alt+enter键，触发联想功能，选择”auto fill call parameters”自动填充调用的函数的形参名。 GenerateAllSetter（自动生成调用对象的set方法） Maven Helper（Maven依赖分析工具）该插件可以查看maven的依赖树，分析版本冲突，并提供maven常用命令模板。 代码模板自定义代码模板第一个是代码模板快捷输入语句，第二个是说明，第三个就是我们自己定义的代码模板，$END$是回车后光标自动跳转的地方。 创建类模板1.按照顺序打开File–&gt;settings–&gt;Editor–&gt;File and Code Templates–&gt;Includes-&gt;File Header2.输入类注释模板 123456/** * @Classname ${NAME} * @Description TODO * @Date ${DATE} ${TIME} * @author ${USER} */ 创建方法模板1.按照顺序打开File–&gt;Settings–&gt;Editor–&gt;Live Templates2.点击右边的”+“号,选择Template Group,创建自己的组名3.选择自己的组名，点击”+”号，选择Live Template4.填写Abbreviation(你设定的关键字)，Description(对模板的描述，会在调用时提示;)5.点击 Define(模板作用的位置) 选择java 6.Template text(要显示的完整代码;) 123456789/** * @data: $date$-$time$ * @author: $USER$ * @params: $params$ * @return: $return$ * @Description: 描述 **/ 7.编辑模板变量,然后将每一行最后的“Skip if defined”勾选。data:data()time:time()USER:user() param默认可选择的方法groovyScript(\"def result = '';def params = \\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++) {if(params[i] != '')result+='* @param ' + params[i] + ' ' +((i &lt; params.size() - 1) ? '\\\\r\\\\n ' : '')}; return result == '' ? null : result\", methodParameters()) return默认可选择的方法groovyScript(\"def returnType = \\\"${_1}\\\"; def result ='';if(returnType=='null'||returnType=='void'){return;}else{result += '* @return ';cls = returnType.split('&lt;');for(i = 0; i &lt; cls.size(); i++){temp = cls[i].tokenize('.');result += temp[temp.size() - 1] + ((i &lt; cls.size() - 1) ? '&lt;' : '');};return result + ' ';}\", methodReturnType());","categories":[{"name":"java","slug":"java","permalink":"https://wenkexia.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wenkexia.github.io/tags/java/"}]},{"title":"git使用","slug":"git使用","date":"2021-11-20T13:42:04.000Z","updated":"2022-04-16T12:56:13.533Z","comments":true,"path":"2021/11205629.html","link":"","permalink":"https://wenkexia.github.io/2021/11205629.html","excerpt":"","text":"git安装及配置Git是一个分布式代码管理工具，可以在本地提交，不需要依赖网络，并且会将每次提交自动备份到本地。每个开发者都可以把远程仓库clone一份到本地，并会把提交历史一并拿过来。 官网下载 按照安装向导来安装Git，相关参数勾选为默认即可 安装完成后，右键菜单栏会出现Git GUI和Git Bash git基本操作命令查看系统配置git config -l 配置Github用户名和账号打开Git bash 1234567# 配置git用户和邮箱git config --global user.name \"xxxx\" git config --global user.email \"xxxxx@qq.com\" #查看配置的结果 git config --global --list## 本机生成SSH公钥，实现免密登录 ssh-keygen -t rsa 将公钥添加到Github管理平台我的目录是：C:\\Users\\wenke.ssh将ssh文件夹中的公钥（ id_rsa.pub）添加到GitHub管理平台中，在GitHub的个人账户的设置中找到如下界面 12#测试配置是否成功 ssh -T git@github.com 关联本地与远程仓库第一种方法在github创建一个仓库，然后在本地选择一个文件夹克隆仓库git clone [url] 然后添加文件即可 第二种方法本地创建一个git库进入到指定的文件夹之后，右键打开git bash输入git init本地文件夹中也会出现.git隐藏文件夹（是git的控制文件） 新建仓库，选择ssh方式进行连接Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 复制代码到Git Bash，即可实现新仓库和本地git的相关联 123git remote add origin git@github.com:PanXF-HUST/test.git #命令查看关联状况git remote -v vscode使用git安装git插件git-commit-plugin：自动生成规范 git 提交信息的插件。 安装后在左边功能区有个源代码管理，根据提示操作 1.提交之前先拉取代码 2.点击加号暂存需要提交的文件 3.提交暂存的文件，写注释 4.推送 git工作原理详解工作区域Git有四个工作区域 工作区（Working Directory)：就是你平时存放项目代码的地方 暂存区(Stage/Index)：用于临时存放你的改动，事实上是一个保存即将提交到文件列表信息的文件 仓库区或本地仓库(Repository或Git Directory)：就是安全存放数据的位置，这里面有你提交到所有版本的数据，其中HEAD指向最新放入仓库的版本 远程仓库(Remote Directory)：托管代码的服务器 git的工作流程1.在工作区添加，修改文件2.将需要进行版本管理的文件存入暂存区 git add.3.将暂存区的文件提交到git仓库 git commit 因此，git管理的文件有三种状态：已修改（modified）、已暂存（staged）、已提交（committed） 1234567891011#查看指定文件状态git status [filename]#查看所有文件状态git status#添加所有文件到暂存区git add.#提交暂存区中的内容到本地仓库git commit -m \"描述\" 忽略文件有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立”.gitignore”文件，此文件有如下规则： 1.忽略文件中的空行或以井号(#)开始的行将会被忽略。2.可以使用Liux通配符。例如：星号(*)代表任意多个字符，问号(？)代表一个字符，方括号([abc])代表可选字符范围，大括号({string1,string2})代表可选的字符串等。3.如果名称的最前面有一个感叹号(！)，表示例外规则，将不被忽略。4.如果名称的最前面是一个路径分隔符(/)，表示要忽略的文件在此目录下，而子目录中的文件不忽略。5.如果名称的最后面是一个路径分隔符(/)，表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 提交文件修改到远程仓库的最简步骤git add .git commit -m “注释” 注释必填git pullgit push origin 分支 git bash快捷键 复制 ctrl + insert 粘贴 shift + insert git常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 放弃修改git checkout .查看状态git status -s查看分支git branch创建分支git checkout -b 7-20-删除qq文件夹提交到暂存区git add .提交评论git commit -m '7-20-删除qq文件夹'推送到分支git push origin 7-20-删除qq文件夹切换主干||分支git checkout master || git checkout 7-20-删除qq文件夹本地合并分支到主干git merge 7-20-删除qq文件夹远端合并分支到主干git merge origin/7-20-删除qq文件夹推送主干git push origin master# 把HEAD指向最新下载的版本git reset --hard origin/master# 下载所有分支到本地git branch -a | grep origin | grep -v HEAD | while read rb;do lb=$(echo ${rb} | cut -d/ -f 3-);git checkout -b $lb $rb;donegit clone https://gitee.com/snailuncle/douban-trailer-imooc.git使用Git下载v.2.8.1分支代码，使用命令：git clone -b 7-20-删除qq文件夹 https://gitee.com/snailuncle/douban-trailer-imooc.gitgit clone // 项目地址git checkout 分支名字git pull origin 分支名字# 删除分支git branch -d &lt;branch_name&gt;# 打开当前命令行所在文件夹start \"\" \".\"git status 下中文显示乱码问题解决 $ git status -s ?? \"\\350\\257\\264\\346\\230\\216.txt\\n $ printf \"\\350\\257\\264\\346\\230\\216.txt\\n\" 说明.txt 通过将Git配置变量 core.quotepath 设置为false，就可以解决中文文件名称在这些Git命令输出中的显示问题， 示例： $ git config --global core.quotepath false $ git status -s ?? 说明.txtgit reset --hardgit pull 参考参考文章 参考文章 参考 参考b站视频","categories":[{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/tags/%E7%9F%A5%E8%AF%86/"}],"author":"wenke"},{"title":"hexo博客搭建","slug":"hexo博客搭建","date":"2021-11-19T02:32:49.000Z","updated":"2022-04-23T02:00:14.568Z","comments":true,"path":"2021/111958091.html","link":"","permalink":"https://wenkexia.github.io/2021/111958091.html","excerpt":"","text":"Hexo 简介Hexo 是一个快速，简单且功能强大的博客框架。如果你用 Markdown 写博客，Hexo 可以在几秒内生成带有精美主题的静态文件。 准备环境Node.js 安装。Git 并安装配置环境变量，两个都要配置 安装Hexo，创建一个文件夹例如blog，右键打开Git Bash运行： npm install -g hexo-cli查看版本 hexo -v 初始化Hexohexo init blogcd blog #进入blog目录npm install 新建完成后，指定文件夹目录下有：node_modules: 依赖包public：存放生成的页面scaffolds：生成文章的一些模板source：用来存放你的文章themes：主题_config.yml: 博客的配置文件 Hexo版本升级12345678910111213141516171819# 使用淘宝源的 cnpm 替换 npmnpm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g cnpm # 升级 npmcnpm cache clean -f # 清除 npm 缓存===更新 hexo: 进入 blog 目录，执行如下命令=== # 更新 package.json 中的 hexo 及个插件版本cnpm install -g npm-check npm-check # 检查之前安装的插件，都有哪些是可以升级的 cnpm install -g npm-upgrade npm-upgrade # 升级系统中的插件# 更新 hexo 及所有插件cnpm update# 确认 hexo 已经更新hexo -v 创建GitHub仓库或者码云仓库1.创建仓库，仓库名必须和用户名一致，其他按照默认，直接创建2.打开cmd，添加Git本地用户git config –global user.name “ 用户名 “git config –global user.email “绑定的邮箱” 3.申请Sky秘钥ssh-keygen -t rsa -C “Git绑定的邮箱”sky在这 C:\\Users\\啊科.ssh 4.复制Sky秘钥添加到GitHub或者码云查看是否成功 ssh -T git@github.com 将本地仓库与远程仓库连接1.安装git部署插件：才能用hexo d 上传npm install hexo-deployer-git –save 2.复制生成的仓库连接修改博客目录下的_config.yml文件 1234deploy: type: git repository: https://gitee.com/wenkex/wenkex.git branch: master 本地创建文章，上传到远程仓库hexo clean清理缓存 hexo g 刷新博客文章 hexo s 开启本地映射 #为了在本地检查文章，该步骤可以跳过，该命令按Ctrl+C结束 hexo d 将本地博客上传到远程仓库，第一次上传会让你输入GitHub或码云的账号密码等待上传完成，打开Gitee pages，更新Https内容（每次上传文件后都要执行这一步） 在你创建的博客文件夹下打开git bash，输入命令 hexo new 文章标题 用yarn cgd或npm run cgd运行如下命令hexo cl &amp;&amp; hexo g &amp;&amp; hexo d一键上传到远程仓库hexo cl &amp;&amp; hexo g &amp;&amp; hexo s一键开启本地映射 1.目录结构说明参考参考 在执行过Hexo deploy命令之后，目录结构新增了.deploy_git，public，.gitignore，如下 123456789101112131415161718 $ tree -L 2.├── .deploy_git├── node_modules├── public├── scaffolds│&nbsp;&nbsp; ├── draft.md│&nbsp;&nbsp; ├── page.md│&nbsp;&nbsp; └── post.md├── source│&nbsp;&nbsp; ├── _posts│&nbsp;&nbsp; ├── _drafts├── themes├── _config.yml├── db.json├── package.json└── package-lock.json _config.yml用来配置博客相关的参数，初始化时自动创建 node_modules用来存储已安装的各类依赖包 package.json用来查看 Hexo 的版本以及相关依赖包的版本。 scaffold模板文件夹，初始化时自动创建。包含page，post，draft三种模板，分别对应 页面、要发布的文章、草稿。在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：$ hexo new photo \"My Gallery\"在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章， themes主题文件夹，初始化时自动创建。每一个主题，都有一个单独的文件夹。 source：资源文件夹。用来存放图片、Markdown 文档（文章、草稿）、各种页面（分类、关于页面等）。 public：将 source 文件夹里的 Markdown 文档，转换成 index.html。再结合主题进行渲染，就是我们最终看到的博客。 .deploy_git：将 public 文件夹的内容提交到 Github 后生成，内容与 public 文件夹基本一致。 这三者的关系大致是：source -&gt; public -&gt; .deploy_git执行hexo generate，根据 source，更新 public。执行hexo deploy，根据 public，更新 .deploy_git。 2.常用命令1.hexo server #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。简写：hexo s 2.hexo clean#清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹 3.hexo g#生成静态网页 (执行后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下) 等价于hexo generate 4.hexo d#自动生成网站静态文件，并将本地数据部署到设定的仓库(如github)等价于hexo deploy 3.更换主题Hexo主题升级方法1.使用Git Bash工具跳转到主题文件对应的目录中2.首先，更新工作的状态树：git add .3.之后，输入如下命令，将文件放在堆栈中，获取更新后，再弹栈： 1234git stashgit pullgit stash pop 4.新建文章自动打开编辑器执行 hexo new “名字”，这样就会在_posts 下生成一篇新文章，但需要手动打开，1.只需要在站点根目录下新建 scripts 目录，2.然后在scripts目录下新建 auto_open.js，在文件填入一下内容： 12345var spawn = require('child_process').exec;// Hexo 3 用户复制这段hexo.on('new', function(data){ spawn('start \"D:\\Program Files\\Typora\\Typora.exe\" ' + data.path);}); 其中 “D:\\Program Files\\Typora\\Typora.exe” 是我本地编辑器的路径，只需要改为你本地编辑器的路径即可，然后在执行 hexo cl &amp;&amp; hexo g -d，部署到 GitHub 即可，以后在发布文章就会自动打开编辑器。 5.一键部署通过 hexo-deployer-git 插件可以实现一键将博客同时部署到多个git仓库中。如同时发布到github及gitee提供的pages服务。安装：npm install hexo-deployer-git --save修改 Hexo 根目录下的_config.yml 文件中的如下内容: 12345678910#一键部署，修改成自己的repo和branchdeploy: - type: git repo: https://github.com/lxl80/blog.git branch: gh-pages ignore_hidden:false -type:git repo:https://gitee.com/lxl80/lxl80.git branch:master ignore_hidden:false 简化部署在package.json中添加\"cgd\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo d\"以后就可以用npm run cgd直接部署上线 12345678\"scripts\": { \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"deploy\": \"hexo deploy\", \"server\": \"hexo server\", \"cgs\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\", \"cgd\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo d\"}, 使用文章资源文件夹(弃用，现在用图床)在config.yaml文件中更改一下配置：post_asset_folder: true当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。此时应该使用这样的方式来引入图片：{% asset_img image.jpg 这是一张图片 %} 图片插件 插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true github添加域名参考 1.注册一个域名2.添加域名解析（注：使用自定义域名，需要将记录类型修改为 CNAME 将域名指向另一个域名，记录值修改为 GitHub对应仓库名，如：zhang123-123.github.io）3.在GitHub 中设置新的注册的域名（具体位置：Settings –&gt; Pages –&gt; Custom domain），之后保存验证就可以了4.进入 hexo 根目录的 source 文件夹；创建 CNAME 文件，文件添加域名 –&gt; zhangyh.fun。注意：文件名全部大写，没有后缀；文件内容只有域名；5.重新生成静态文件，并提交。hexo d 搜索1.使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下：npm install hexo-generator-search --save2.在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123search: path: search.xml field: post 3.在主题配置文件中开启本地搜索 文章字数统计插件如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。安装命令如下：npm i --save hexo-wordcount然后只需在主题下的 _config.yml 文件中，激活以下配置项即可： 12345wordCount: enable: false # 将这个值设置为 true 即可. postWordCount: true min2read: true totalCount: true 图片懒加载 图片预加载：顾名思义，图片预加载就是在网页全部加载之前，提前加载图片。当用户需要查看时可直接从本地缓存中渲染，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，这样浏览者可能以为图片预览慢而没兴趣浏览，把网页关掉，这时，就需要图片预加载。当然这种做法实际上牺牲了服务器的性能换取了更好的用户体验。 图片懒加载（缓载）：延迟加载图片或符合某些条件时才加载某些图片。这样做的好处是减少不必要的访问数据库或延迟访问数据库的次数，因为每次访问数据库都是比较耗时的即只有真正使用该对象的数据时才会创建。懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 懒加载对服务器前端有一定的缓解压力作用，预载则会增加服务器前端压力。使用图片懒加载需要安装插件：hexo-lazyload-image在站点根目录执行下面的命令： 1npm install hexo-lazyload-image --save 之后在站点配置文件下添加下面的代码： 1234lazyload: enable: true # 是否开启图片懒加载 onlypost: false # 是否只对文章的图片做懒加载 loadingImg: # eg ./images/loading.gif 代码压缩因为 hexo 生成的 html、css、js 等都有很多的空格或者换行，而空格和换行也是占用字节的，所以需要将空格换行去掉也就是我要进行的 “压缩”。我们采用 gulp 代码压缩方式。使用方法： 进入站点根目录下依次执行下面的命令： 123456# 全局安装gulp模块npm install gulp -g# 安装各种小功能模块 执行这步的时候，可能会提示权限的问题，最好以管理员模式执行npm install gulp gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save# 额外的功能模块npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save 在 Hexo 根目录新建文件 gulpfile.js，并复制以下内容到文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168var gulp = require(\"gulp\");var debug = require(\"gulp-debug\");var cleancss = require(\"gulp-clean-css\"); //css压缩组件var uglify = require(\"gulp-uglify\"); //js压缩组件var htmlmin = require(\"gulp-htmlmin\"); //html压缩组件var htmlclean = require(\"gulp-htmlclean\"); //html清理组件var imagemin = require(\"gulp-imagemin\"); //图片压缩组件var changed = require(\"gulp-changed\"); //文件更改校验组件var gulpif = require(\"gulp-if\"); //任务 帮助调用组件var plumber = require(\"gulp-plumber\"); //容错组件（发生错误不跳出任务，并报出错误内容）var isScriptAll = true; //是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件)var isDebug = true; //是否调试显示 编译通过的文件var gulpBabel = require(\"gulp-babel\");var es2015Preset = require(\"babel-preset-es2015\");var del = require(\"del\");var Hexo = require(\"hexo\");var hexo = new Hexo(process.cwd(), {}); // 初始化一个hexo对象// 清除public文件夹gulp.task(\"clean\", function () { return del([\"public/**/*\"]);});// 下面几个跟hexo有关的操作，主要通过hexo.call()去执行，注意return// 创建静态页面 （等同 hexo generate）gulp.task(\"generate\", function () { return hexo.init().then(function () { return hexo .call(\"generate\", { watch: false }) .then(function () { return hexo.exit(); }) .catch(function (err) { return hexo.exit(err); }); });});// 启动Hexo服务器gulp.task(\"server\", function () { return hexo .init() .then(function () { return hexo.call(\"server\", {}); }) .catch(function (err) { console.log(err); });});// 部署到服务器gulp.task(\"deploy\", function () { return hexo.init().then(function () { return hexo .call(\"deploy\", { watch: false }) .then(function () { return hexo.exit(); }) .catch(function (err) { return hexo.exit(err); }); });});// 压缩public目录下的js文件gulp.task(\"compressJs\", function () { return gulp .src([\"./public/**/*.js\", \"!./public/libs/**\"]) //排除的js .pipe(gulpif(!isScriptAll, changed(\"./public\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress JS:\" }))) .pipe(plumber()) .pipe( gulpBabel({ presets: [es2015Preset] // es5检查机制 }) ) .pipe(uglify()) //调用压缩组件方法uglify(),对合并的文件进行压缩 .pipe(gulp.dest(\"./public\")); //输出到目标目录});// 压缩public目录下的css文件gulp.task(\"compressCss\", function () { var option = { rebase: false, //advanced: true, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: \"ie7\" //保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式] //keepBreaks: true, //类型：Boolean 默认：false [是否保留换行] //keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 }; return gulp .src([\"./public/**/*.css\", \"!./public/**/*.min.css\"]) //排除的css .pipe(gulpif(!isScriptAll, changed(\"./public\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress CSS:\" }))) .pipe(plumber()) .pipe(cleancss(option)) .pipe(gulp.dest(\"./public\"));});// 压缩public目录下的html文件gulp.task(\"compressHtml\", function () { var cleanOptions = { protect: /&lt;\\!--%fooTemplate\\b.*?%--&gt;/g, //忽略处理 unprotect: /&lt;script [^&gt;]*\\btype=\"text\\/x-handlebars-template\"[\\s\\S]+?&lt;\\/script&gt;/gi //特殊处理 }; var minOption = { collapseWhitespace: true, //压缩HTML collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=\"true\"/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=\"\" /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=\"text/javascript\" removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=\"text/css\" removeComments: true, //清除HTML注释 minifyJS: true, //压缩页面JS minifyCSS: true, //压缩页面CSS minifyURLs: true //替换页面URL }; return gulp .src(\"./public/**/*.html\") .pipe(gulpif(isDebug, debug({ title: \"Compress HTML:\" }))) .pipe(plumber()) .pipe(htmlclean(cleanOptions)) .pipe(htmlmin(minOption)) .pipe(gulp.dest(\"./public\"));});// 压缩 public/medias 目录内图片gulp.task(\"compressImage\", function () { var option = { optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false //类型：Boolean 默认：false 多次优化svg直到完全优化 }; return gulp .src(\"./public/medias/**/*.*\") .pipe(gulpif(!isScriptAll, changed(\"./public/medias\"))) .pipe(gulpif(isDebug, debug({ title: \"Compress Images:\" }))) .pipe(plumber()) .pipe(imagemin(option)) .pipe(gulp.dest(\"./public\"));});// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆 -&gt; 部署到服务器gulp.task( \"build\", gulp.series( \"clean\", \"generate\", \"compressHtml\", \"compressCss\", \"compressJs\", \"compressImage\", gulp.parallel(\"deploy\") ));// 默认任务gulp.task( \"default\", gulp.series( \"clean\", \"generate\", gulp.parallel(\"compressHtml\", \"compressCss\", \"compressJs\",\"compressImage\") ));//Gulp4最大的一个改变就是gulp.task函数现在只支持两个参数，分别是任务名和运行任务的函数 以后的执行方式有两种： 直接在 Hexo 根目录执行 gulp 或者 gulp default ，这个命令相当于 hexo cl&amp;&amp;hexo g 并且再把代码和图片压缩。 在 Hexo 根目录执行 gulp build ，等于说生成、压缩文件后又帮你自动部署了。 文章链接转静态短地址如果文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于SEO，且gitment评论对中文链接也不支持。我们可以用hexo-permalink-pinyin Hexo 插件生成文章时生成中文拼音的永久链接，或者用hexo-abbrlink 生成静态文章链接。以下结合hexo-abbrlink生成类似 /yyyy/mmdd+随机数.html 的文章链接地址。安装命令如下：npm install hexo-abbrlink --save在 Hexo 根目录下的 _config.yml 文件中，修改 permalink: ，并在文件末尾新增 abbrlink:配置项： 12345permalink: :year/:month:day:abbrlink.htmlabbrlink: alg: crc16 #算法选项：crc16丨crc32 rep: dec #输出进制：dec为十进制，hex为十六进制 博客备份hexo-git-backup(暂未采用)项目地址 安装npm install hexo-git-backup --save 配置新建仓库，例如 Hexo_backup ，权限设为 private ，分支默认main先获取项目 ssh 链接：在 hexo配置文件 中添加以下内容： 1234backup: type: git repository: backup: git@github.com:xingjiahui/Hexo-Backup.git,main 使用hexo b SEO优化参考 搜索引擎优化，又称为SEO，即Search Engine Optimization，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。Google自动收录效果还不错，百度就差得远了（GitHub不允许百度的Spider爬取GitHub上的内容）。所以在第三步验证网站的时候，建议选择CNAME验证的方式。 生成 sitemap 文件1.安装插件查看是否有安装插件npm [name] -v 百度 npm install hexo-generator-baidu-sitemap --save谷歌 npm install hexo-generator-sitemap --save 2.添加站点配置_config.yml 12345sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 再重启 hexo，在本地访问 localhost:4000/sitemap.xml和 localhost:4000/baidusitemap.xml 就能正确的展示出两个sitemap 文件了。 推送到 谷歌 和 百度百度百度站点管理添加文件方式不可行，hexo会处理html文件 所以选择，在 head.ejs 里添加 html 标签 1.1 手动提交baidusitemap.xml(里面也有自动提交的代码) 1.2 可以用”抓取诊断”，手动-百度抓取 1.3 Robots → 检测并更新 谷歌谷歌站点管理 在根目录下 新建 robots.txtrobots配置 1234567891011121314User-agent: *Allow: /Allow: /home/Allow: /archives/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://yoursite/sitemap.xmlSitemap: http://yoursite/baidusitemap.xml Hexo自定义原理Hexo 系列的博客中的文章都是经Hexo的主题渲染的静态网页。所以Hexo博客大部分都呈现出一种高度的统一化与规范化。不过 Hexo 提供了跳过渲染功能，使得我们可以直接在博客中放入自定义网页。 比如在博客中放入图片、自定义404.html、自定义About页面、简历等创建自定义网页网页可以是自己编写的，也可以是别人现成的源码（下载喜欢的页面）。 添加文件网页编写完成后，在Hexo\\source目录下创建一个文件夹（文件夹名称任意，比如我创建的是about这个文件夹，部署完成后，访问http://mrlsm.github.io/about即可看到效果，依此类推） 将 html 文件放置于此文件夹，并重命名为 index.html 。 跳过渲染有下述两种方法： 1.指定文件跳过渲染实现原理 给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。 实现方法在不需要渲染的文章或HTML文件头部添加以下标记 123---layout: false--- 添加该指令后，执行 hexo g命令时便会跳过该 index.html文件，使得index.html不受当前 hexo 主题影响，完全是一个独立的网页，如果网页引用了 css 或 js，css 和 js 需使用外链或者将css js 文件放入index.html同目录下引用。 引用图片亦是如此 2.对相关文件跳过渲染实现原理只有source目录下的文件才会发布到public（能够在网络上访问到），因此Hexo只渲染source目录下的文件。skip_render参数设置的路径是相对于source目录的路径。Hexo的配置文件中提供了配置项skip_render ，是用来对不需要的目录或者文件进行渲染排除。 实现方法在_config.yml文件中设置skip_render使用编辑器打开 Hexo 目录下的_config.yml文件，找到skip_render skip_render一般有以下四种常用参数： 跳过source目录下的 test.html:skip_render: test.html 跳过source目录下 test 文件夹内所有文件：skip_render: test/* 跳过source目录下 test 文件夹内所有文件包括子文件夹以及子文件夹内的文件：skip_render: test/** 跳过多个路径：1234skip_render: - test.html - test/* 不渲染 md 文件skip_render: test/*.md 单个文件夹下指定类型文件 安装一个本地后台管理(Hexo Admin)1.在博客根目录下运行下列指令npm install –save hexo-admin2.运行hexo s3.接下来在浏览器地址栏粘贴这个地址，http://localhost:4000/admin/4.增加密码进入Settings &gt; Setup authentification设置账户，密码得到一串配置填加到站点配置文件下 12345admin: username: myfavoritename password_hash: be121740bf988b2225a313fa1f107ca1 secret: a secret something 增加上传功能在博客根目录下运行下列指令 123456echo \"hexo clean &amp;&amp; hexo g -d\"&gt;hexo-deploy.bat #生成一个内容为\"hexo clean &amp;&amp; hexo g -d\"，名为\"hexo-deploy\"的bat文件。#配置_config.yml文件，echo admin:&gt;&gt;\"_config.yml\"echo \" deployCommand: 'hexo-deploy.bat'\"&gt;&gt;\"_config.yml\"#开启hexo服务hexo server -d 这个教程是对于github的部署的。如果想用来管理gitee的博客，建议修改成echo “hexo clean &amp;&amp; hexo g -d &amp;&amp; start https://gitee.com/用户名/用户名/pages\"&gt;hexo-deploy.bat，这样方便在网页端同步更新gitee page。在网页中编辑完，直接左上角Deploy，直接点deploy按钮，就可以完成博客的部署。 可能遇到的问题(每次都要输入密码)：查看一下你的_config.yml，将文档最后的deploy的repo从http改为git@github类型。 图床建议使用utool里的图床插件，picGo还要下载，而utool里还有其他有趣的插件 使用 PicGo+GitHub图床参考 新建GitHub仓库创建是记住分支名，默认是main 生成一个Token在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页 配置PicGo前往下载PicGo，安装好后开始配置图床设定仓库名：按照【用户名/图床仓库名】的格式填写 设定分支名：【main】 设定Token：粘贴之前生成的【Token】 设定自定义域名：它的作用是，在图片上传后，PicGo 会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接，并放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【https://cdn.jsdelivr.net/gh/用户名/图床仓库名 】 butterfly主题配置官方文档 安装插件如果你没有 pug 以及 stylus 的渲染器，请下载安装：npm install hexo-renderer-pug hexo-renderer-stylus --save 升级建议1.在 hexo 的根目录创建一个文件 _config.butterfly.yml，并把主题目录的 _config.yml 内容复製到 _config.butterfly.yml 去。( 注意: 复製的是主题的 _config.yml ,而不是 hexo 的 _config.yml)2.不要把主题目录的 _config.yml 删掉3.以后只需要在 _config.butterfly.yml进行配置就行。4.Hexo会自动合併主题中的_config.yml和 _config.butterfly.yml里的配置，如果存在同名配置，会使用_config.butterfly.yml的配置，其优先度较高。 Inject参考打开主题配置文件（butterfly.yml）定位搜索 inject其中head是用来引入css的。bottom是用来引入js的。 以相对路径引入1.将写好的css文件移动到\\Butterfly\\source\\css\\目录下。2.然后修改配置文件的引入方式 123456inject: head: - &lt;link rel=\"stylesheet\" href=\"/css/name.css\"&gt; bottom: - &lt;script src=\"xxxx\"&gt;&lt;/script&gt; 标签外挂（Tag Plugins）(推荐)参考参考标籤外挂是Hexo独有的功能，并不是标準的Markdown格式。 以下的写法，只适用于Butterfly主题，用在其它主题上不会有效果，甚至可能会报错。使用前请留意 Tabs页面内置小标签使用 123456789101112131415161718192021222324{% tabs Unique name, [index] %}&lt;!-- tab [Tab caption] [@icon] --&gt;Any content (support inline tags too).&lt;!-- endtab --&gt;{% endtabs %}Unique name : Unique name of tabs block tag without comma. Will be used in #id's as prefix for each tab with their index numbers. If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes. Only for current url of post/page must be unique![index] : Index number of active tab. If not specified, first tab (1) will be selected. If index is -1, no tab will be selected. It's will be something like spoiler. Optional parameter.[Tab caption] : Caption of current tab. If not caption specified, unique name with tab index suffix will be used as caption of tab. If not caption specified, but specified icon, caption will empty. Optional parameter.[@icon] : FontAwesome icon name (full-name, look like 'fas fa-font') Can be specified with or without space; e.g. 'Tab caption @icon' similar to 'Tab caption@icon'. Optional parameter. 1234567891011121314{% tabs test4 %}&lt;!-- tab 第一个Tab --&gt;**tab名字为第一个Tab**&lt;!-- endtab --&gt;&lt;!-- tab @fab fa-apple-pay --&gt;**只有图标 没有Tab名字**&lt;!-- endtab --&gt;&lt;!-- tab 炸弹@fas fa-bomb --&gt;**名字+icon**&lt;!-- endtab --&gt;{% endtabs %} 第一个Tab炸弹tab名字为第一个Tab只有图标 没有Tab名字名字+icon Button12345678910111213141516171819{% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %}[url] : 链接[text] : 按钮文字[icon] : [可选] 图标[color] : [可选] 按钮背景顔色(默认style时） 按钮字体和边框顔色(outline时) default/blue/pink/red/purple/orange/green[style] : [可选] 按钮样式 默认实心 outline/留空[layout] : [可选] 按钮佈局 默认为line block/留空[position] : [可选] 按钮位置 前提是设置了layout为block 默认为左边 center/right/留空[size] : [可选] 按钮大小 larger/留空 This is my website, click the button Butterfly gallery 相册图库参考参考 编辑主题导航栏加入相册按钮在站点主题_config.yml文件下menu菜单下新增gallery页面。 12menu: 相册: /gallery/ || fas fa-heart 新建相册页面在站点的source文件夹下面新建一个gallery相册页面。hexo new page gallery打开新建的gallery文件夹，里面会有一个index.md文件，设置index.md文件内容。然后使用标签外挂 galleryGroup，具体用法请查看对应的内容。 123456789101112--- title: gallery date: 2020-10-05 12:00:00 type: \"gallery\"layout: \"gallery\" &lt;div class=\"gallery-group-main\"&gt;{% galleryGroup '壁纸' '收藏的一些壁纸' '/Gallery/wallpaper' https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png %}{% galleryGroup '漫威' '关于漫威的图片' '/Gallery/marvel' https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %}{% galleryGroup 'OH MY GIRL' '关于OH MY GIRL的图片' '/Gallery/ohmygirl' https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg %}&lt;/div&gt;--- name：图库名字description：图库描述link：连接到对应相册的地址img-url：图库封面的地址 新建相册图片展示页面在gallery文件夹（也就是刚才创建的那个文件），可以在里面新建一些文件夹，也就是相册文件夹然后在新建的相册文件夹里，分别在每个文件夹里新建文件index.md ,然后使用标签外挂 gallery，具体用法请查看对应的内容。 1234567891011121314--- {% gallery %}![](https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg)![](https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg)![](https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg)![](https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg)![](https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg)![](https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg)![](https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg)![](https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg){% endgallery %}--- 友情链接创建友情链接页面在博客的根目录输入 hexo new page link修改source/link/index.md这个文件 12345 ---title: 友情链接date: 2018-06-07 22:17:49type: \"link\"--- 友情链接添加在Hexo博客目录中的source/_data（如果没有 _data 文件夹，请自行创建），创建一个文件link.yml 123456789101112131415161718192021222324- class_name: 友情链接 class_desc: 那些人，那些事 link_list: - name: Hexo link: https://hexo.io/zh-tw/ avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg descr: 快速、简单且强大的网誌框架- class_name: 网站 class_desc: 值得推荐的网站 link_list: - name: Youtube link: https://www.youtube.com/ avatar: https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png descr: 视频网站 - name: Weibo link: https://www.weibo.com/ avatar: https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png descr: 中国最大社交分享平台 - name: Twitter link: https://twitter.com/ avatar: https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png descr: 社交分享平台 class_name和class_desc支持html格式书写，如不需要，也可以留空。 评论开启评论需要在comments-use中填写你需要的评论。 支持双评论显示，只需要配置两个评论（第一个为默认显示） 参数 解释 use 使用的评论（填写的评论首字母需要大写。最多支持两个）注意：由于共用 ID,双评论不能是 Disqus 和 Disqusjs text 是否显示评论服务商的名字 lazyload 是否为评论开启lazyload，开启后，只有滚动到评论位置时才会加载评论所需要的资源（开启lazyload后，评论数将不显示） count 是否在文章顶部显示评论数livere 和 utterances 不支持评论数显示 card_post_count 是否在首页文章卡片显示评论数gitalk、livere 和 utterances不支持评论数显示 Pjax当用户点击链接，通过ajax更新页面需要变化的部分，然后使用HTML5的pushState修改浏览器的URL地址。 这样可以不用重复加载相同的资源（css/js）， 从而提升网页的加载速度。 12345pjax: enable: true exclude: - /music/ - /no-pjax/ 对于一些第三方插件，有些并不支持 pjax 。你可以把网页加入到 exclude 里，这个网页会被 pjax 排除在外。点击该网页会重新加载网站 使用pjax后，一些自己DIY的js可能会无效，跳转页面时需要重新调用，请参考Pjax文档使用pjax后，一些个别页面加载的js/css，将会改为所有页面都加载 Butterfly的Pjax目前仍有一些问题，请留意 引用文章参考以_post为根目录定位文件（md文件会被渲染成html）因为使用了abbrlink生成文章永久链接，所以在GitHub仓库中由md渲染成的HTML文件名是日期加abbrlink数字 新建一个页面打开文章&lt;a href=\"/2021/12184010.html\" target=\"_blank\"&gt;显示的文字&lt;/a&gt; 在此页面打开新文章[显示的文字](/2021/12184010.html){% post_link 文章文件名 显示文本 %} 添加 RSS 订阅支持本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下：npm install hexo-generator-feed --save 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明已经安装成功了。 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456789# RSS订阅plugin: - hexo-generator-feed# Feed Atomfeed: type: atom path: atom.xml limit: 20 在主题的配置文件_config.butterfly.yml中的social属性下添加rss的icon配置： 12social: fa fa-rss: /atom.xml 添加emoji表情支持Matery 主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：😄）转变成会跳跃的emoji表情，安装命令如下：npm install hexo-filter-github-emojis --save在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 1234567githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 添加动态诗词参考 采用的是今日诗词，每次返回一句诗词，根据时间、地点、天气、事件智能推荐。官网有API文档，可以去看一下，有多种安装方式，最简单的方式就是从官网获取代码，1.在/themes/matery/layout/_partial/head.ejs添加下面的一行代码： 12&lt;script src=\"https://sdk.jinrishici.com/v2/browser/jinrishici.js\" charset=\"utf-8\"&gt;&lt;/script&gt; 2.然后再将/themes/matery/layout/_partial/bg-cover-content.ejs中的&lt;%= config.description %&gt;修改为&lt;%- '&lt;span id=\"jinrishici-sentence\"&gt;正在加载今日诗词....&lt;/span&gt;' %&gt;3.使用前提是将主题配置文件的subtitle的值改为false。 添加萌萌的动漫人物1.安装插件npm install --save hexo-helper-live2d2.输入以下命令，安装下载动画人物库，将 haruto 更换成你想要的模型名称即可 如：npm install live2d-widget-model-haruto更多模型选择请点击 3.根目录_config.yml配置里面添加： 12345678910111213141516171819live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-haruto #模型选择 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: true #是否在手机端显示 react: opacity: 0.7 动漫人物最好不要和不蒜子一起使用，不然不蒜子会显示不出来。 添加全局吸底Aplayer音乐(不采用)安装hexo-tag-aplayer插件关闭 asset_inject由于需要全局都插入aplayer和meting资源，为了防止插入重复的资源，需要把asset_inject设为false在Hexo的配置文件中 123aplayer: meting: true asset_inject: false 开启主题的aplayerInject在主题的配置文件中，enable设为true和per_page设为true 1234# Inject the css and script (aplayer/meting)aplayerInject: enable: true per_page: true 插入Aplayer html把aplayer代码插入到主题配置文件的inject.bottom去 1234inject: head: bottom: - &lt;div class=\"aplayer no-destroy\" data-id=\"000PeZCQ1i4XVs\" data-server=\"tencent\" data-type=\"artist\" data-fixed=\"true\" data-mini=\"true\" data-listFolded=\"false\" data-order=\"random\" data-preload=\"none\" data-autoplay=\"true\" muted&gt;&lt;/div&gt; id是自己分享的歌曲后由链接得到的idserver可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐）。type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） 如果你想切换页面时，音乐不会中断。请把主题配置文件的pjax设为true，在class里需添加no-destroy，这样防止切换页面时Aplayer被销毁 UI 调整按照上面的步骤设置完成后，浏览器左下角会出现Aplayer。打开文章页面时，你会发现打开Toc目录的按钮被遮挡了。我们需要修改CSS来改变按钮的位置。向上调整 123#toggle-sidebar { bottom: 80px} 在主题配置文件中，添加到inject去 123inject: head: - '&lt;style type=\"text/css\"&gt;#toggle-sidebar {bottom: 80px}&lt;/style&gt;' 参考文章https://butterfly.js.org/https://yangchaoyi.vip/ matery主题配置（不采用）下载主题hexo-theme-matery 是一个采用 Material Design 和响应式设计的 Hexo 博客主题去github下载解压缩后，将 hexo-theme-matery 的文件夹复制到 Hexo 的 themes 文件夹中即可。 切换主题修改 Hexo 根目录下的_config.yml 的 theme 的值：theme: hexo-theme-matery 主题目录结构说明1.matery/layout下的.ejs文件是编写关于主页右上角分类，归档的2.目录样式在：themes\\Matery\\layout_partial\\post-detail-toc.ejs3.如果有多语言支持需求，可以更改 themes/next/languages 下对应语言的翻译。 medias个性化参考 1.我先把banner 和 featureimages里的图片来了个大换血。不过这里我发现一个问题，壁纸尺寸必须和电脑显示屏的分辨率一样才能完美显示。比如我的电脑分辨率是1080*1920，那么我下载的壁纸也得是这个尺寸，不然浏览器渲染显示的时候会不好看。 2.接着我又把网站logo，avatars，favicon 也给换成了自己喜欢的图片免费logo生成网站 代码高亮参考 Hexo的matery主题中的代码块出现代码大小不一，代码键复制，无法高亮等BUG 评论主题中内置了valine, miniValine, livere, gitment, gitalk, changyan评论通过主题文件夹下的_config.yml文件中的相应属性进行设置推荐使用valine和livere这里重点说一下valine评论配置 1234567891011valine: on: true # 是否启用 appid: # 你的appid --&gt; https://valine.js.org/quickstart.html，请阅读这个获取appid和appkey appkey: # 你的key avatar: '' # 匿名者头像选项 https://valine.js.org/avatar.html 访客的头像,最好启用下面的`requiredFields`中的邮箱必填，填写qq邮箱，头像会变成qq头像 placeholder: '客官，说点什么吧' # 评论内容输入框的 placeholder master: 'xxxxxx' # 博主标签识别，博主邮箱md5 可以去md5加密网站，例如 https://md5jiami.51240.com/ ，将自己的邮箱输入， 得到 32位小写 的字符串填入这里 friends: ['xxxxxxx', 'xxxxxx'] # 小伙伴的 邮箱md5， 是个数组 requiredFields: ['nick', 'mail'] # 设置必填项 ['nick', 'mail'] nick为昵称必填， mail为邮箱必填, 空数组，则不校验 backgroundImg: '/medias/comment-bg.gif' # 右下角背景图片, or http://xxx.gif backgroundColor: 'rgba(255,255,255,0.9)' # 背景颜色, 0.9标是透明度 打开腾讯兔小巢后台反馈在主题配置文件更改，加入自己注册后得到的产品Id就可以 1234# 腾讯兔小巢，见https://txc.qq.com/tuxiaochao: enable: true productId: 371566 添加 Tidio 在线聊天功能前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 百度优化登录百度搜索资源平台， 登录成功之后在 用户中心 –&gt; 站点管理 页面中点击添加网站，按提示操作。因为我是部署在gitee上的，刚开始我选择的是文件验证方式，但一直提示验证文件内容不符，因此选择了HTML标签验证复制的标签增加在\\themes\\Chic\\layout\\_partial的head.ejs的&lt;head&gt;与&nbsp;&lt;/head&gt;标签之间经过以上步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。hexo-theme-matery主题已经内置了自动推送的方式， 检查themes/hexo-theme-matery/_config.yml文件中如下配置:# 百度搜索资源平台提交链接baiduPush: true自动推送的JS代码部署在站点的每一个页面源代码中，当页面在每次被浏览时，链接就会被自动推送给百度。 添加百度统计参考 1.注册百度统计账号2.添加博客域名3.获取Baidu Analytics ID然后进入代码管理-&gt;代码获取可以看到如下一段javascript代码，这段代码本来是要手动嵌入到网页中的，但是Hexo已经帮我们嵌入了，所以我们自诩配置Baidu Analytics ID即可，这个ID就是下面代码的hm.js?后面那一串，先复制一下 123456789&lt;script&gt;var _hmt = _hmt || [];(function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?5b6ae75148041557ddd693925322myid\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s);})();&lt;/script&gt; 4.配置Baidu Analytics ID打开主题的配置文件，然后搜索Baidu Analytics ID，找到如下配置项： 12# Baidu Analytics IDbaidu_analytics: 5b6ae75148041557ddd69392532288de 去掉baidu_analytics前面的#号开启百度统计，值设置成刚在百度统计后台复制的Baidu Analytics ID 添加导航页参考 1.首先新建页面，执行下面的命令 1hexo new page navigate 2.修改 navigate 目录下的 index.md 的格式 123456---title: 导航date: 2020-05-09 11:19:14type: \"navigate\"layout: \"navigate\"--- 3.在主题配置文件中添加导航 12345678910111213141516171819202122232425262728293031323334# main menu navigation url and icon# 配置菜单导航的名称、路径和图标icon.menu: Index: url: / icon: fas fa-home 统计: url: / icon: fas fa-sitemap children: - name: 分类 url: /categories icon: fas fa-bookmark - name: 标签 url: /tags icon: fas fa-tags - name: 归档 url: /archives icon: fas fa-archive About: url: /about icon: fas fa-address-card Contact: url: /contact icon: fas fa-comments 友人帐: url: /friends icon: fas fa-share-alt 赞助墙: url: /sponsor icon: fa fa-credit-card 导航: url: /navigate icon: fas fa-location-arrow 4.在 matery/layout 下新建 navigate.ejs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414&lt;div class=\"navi-height bg-cover pd-header \"&gt; &lt;div class=\" link-box container\"&gt; &lt;!-- 搜索框 --&gt; &lt;div class=\"baidu baidu-2 large-screen\"&gt; &lt;form name=\"f\" action=\"https://www.baidu.com/\" target=\"_blank\"&gt; &lt;div id=\"Select-2\"&gt; &lt;div class=\"Select-box-2\" id=\"baidu\"&gt; &lt;ul style=\"height: 46px;\"&gt; &lt;li class=\"this_s\"&gt;百 · 度&lt;/li&gt; &lt;li class=\"bing_s\"&gt;必 · 应&lt;/li&gt; &lt;li class=\"google_s\"&gt;谷 · 歌&lt;/li&gt; &lt;li class=\"baidu_s\"&gt;百 · 度&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input name=\"wd\" id=\"kw-2\" maxlength=\"100\" autocomplete=\"off\" type=\"text\"&gt; &lt;/div&gt; &lt;div class=\"qingkong\" id=\"qingkong\" title=\"清 · 空\" style=\"display: none;\"&gt;x&lt;/div&gt; &lt;input value=\"搜 · 索\" id=\"su-2\" type=\"submit\"&gt; &lt;ul class=\"keylist\"&gt;&lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- 链接 --&gt; &lt;div class=\"row tags-posts \"&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;娱乐 · 影视&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.jd.com/\" class=\"link-3\" target=\"_blank\"&gt;京东&lt;/a&gt; &lt;li&gt;&lt;a href=\"https://www.taobao.com/\" class=\"link-3\" target=\"_blank\"&gt;淘宝&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.tmall.com/\" class=\"link-3\" target=\"_blank\"&gt;天猫&lt;/a&gt;&lt;/li&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"https://v.qq.com/\" class=\"link-3\" target=\"_blank\"&gt;腾讯视频&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.iqiyi.com/\" class=\"link-3\" target=\"_blank\"&gt;爱奇艺&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.bilibili.com/\" class=\"link-3\" target=\"_blank\"&gt;哔哩哔哩&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"https://music.163.com/\" class=\"link-3\" target=\"_blank\"&gt;网易云音乐&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://y.qq.com/\" class=\"link-3\" target=\"_blank\"&gt;QQ音乐&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.kugou.com/\" class=\"link-3\" target=\"_blank\"&gt;酷狗音乐&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;社区 · Code&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.mobaijun.com/contact/\" class=\"link-3\" target=\"_blank\"&gt;留言&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://github.com/\" class=\"link-3\" target=\"_blank\"&gt;GitHub&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://coding.net/\" class=\"link-3\" target=\"_blank\"&gt;Coding&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://juejin.im/\" class=\"link-3\" target=\"_blank\"&gt;掘金&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://gitee.com/\" class=\"link-3\" target=\"_blank\"&gt;码云&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.csdn.net/\" class=\"link-3\" target=\"_blank\"&gt;CSDN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.jianshu.com/\" class=\"link-3\" target=\"_blank\"&gt;简书&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://segmentfault.com/\" class=\"link-3\" target=\"_blank\"&gt;思否&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://cloud.tencent.com/developer/\" class=\"link-3\" target=\"_blank\"&gt;云+社区&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;实用 · 工具&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://mdnice.com/\" class=\"link-3\" target=\"_blank\"&gt;Nice编辑器&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://translate.google.cn/\" class=\"link-3\" target=\"_blank\"&gt;谷歌翻译&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.uupoop.com/\" class=\"link-3\" target=\"_blank\"&gt;在线PS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.processon.com/\" class=\"link-3\" target=\"_blank\"&gt;思维导图&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://wallhaven.cc/\" class=\"link-3\" target=\"_blank\"&gt;超清壁纸&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://cli.im/\" class=\"link-3\" target=\"_blank\"&gt;二维码&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.yinfans.me/\" class=\"link-3\" target=\"_blank\"&gt;音范思&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.52pojie.cn/\" class=\"link-3\" target=\"_blank\"&gt;吾爱破解&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://my.openwrite.cn/\" class=\"link-3\" target=\"_blank\"&gt;OW分发&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;编程 · 学习&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.oschina.net/\" class=\"link-3\" target=\"_blank\"&gt;开源中国&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://htmldog.com/\" class=\"link-3\" target=\"_blank\"&gt;HTML狗&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.icourse163.org/\" class=\"link-3\" target=\"_blank\"&gt;中国大学慕课&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.imooc.com/\" class=\"link-3\" target=\"_blank\"&gt;慕课网&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.wxapp-union.com/\" class=\"link-3\" target=\"_blank\"&gt;小程序&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.runoob.com/\" class=\"link-3\" target=\"_blank\"&gt;菜鸟教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://blog.51cto.com/\" class=\"link-3\" target=\"_blank\"&gt;51CTO&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.shiyanlou.com/library/\" class=\"link-3\" target=\"_blank\"&gt;实验楼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://spring.io/\" class=\"link-3\" target=\"_blank\"&gt;Spring&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;资讯 · 趋势&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://www.huxiu.com/\" class=\"link-3\" target=\"_blank\"&gt;虎嗅&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://insights.stackoverflow.com/\" class=\"link-3\" target=\"_blank\"&gt;技术调查&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.asciiworld.com/\" class=\"link-3\" target=\"_blank\"&gt;摸鱼&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://sspai.com/\" class=\"link-3\" target=\"_blank\"&gt;少数派&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://zh.wikihow.com/\" class=\"link-3\" target=\"_blank\"&gt;WikeHom&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.awesomes.cn/rank?sort=hot\" class=\"link-3\" target=\"_blank\"&gt;前端趋势&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://github-trending.com/\" class=\"link-3\" target=\"_blank\"&gt;GitHub趋势&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.tiobe.com/\" class=\"link-3\" target=\"_blank\"&gt;编程趋势&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://trends.google.com/\" class=\"link-3\" target=\"_blank\"&gt;Google趋势&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\"&gt; &lt;div class=\"card\"&gt; &lt;div class=\"jj-list-tit\"&gt;搜索 · 其他&lt;/div&gt; &lt;ul class=\"jj-list-con\"&gt; &lt;li&gt;&lt;a href=\"https://ac.scmor.com/\" class=\"link-3\" target=\"_blank\"&gt;谷歌镜像&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.pansoso.com/\" class=\"link-3\" target=\"_blank\"&gt;网盘搜索&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://tool.mkblog.cn/music/\" class=\"link-3\" target=\"_blank\"&gt;音乐搜索&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.dytt8.net/\" class=\"link-3\" target=\"_blank\"&gt;电影天堂&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://carbon.now.sh/\" class=\"link-3\" target=\"_blank\"&gt;代码图片&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.zhipin.com/\" class=\"link-3\" target=\"_blank\"&gt;Boos&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://fontawesome.com/\" class=\"link-3\" target=\"_blank\"&gt;图标库&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.qvdv.com/tools/qvdv-guid.html\" class=\"link-3\" target=\"_blank\"&gt;在线工具&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"http://zhongguose.com/\" class=\"link-3\" target=\"_blank\"&gt;中国色&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; /*选择搜索引擎*/ $('.Select-box ul').hover(function () { $(this).css('height', 'auto') }, function () { $(this).css('height', '40px') }); $('.Select-box-2 ul').hover(function () { $(this).css('height', 'auto') }, function () { $(this).css('height', '46px') }); $('.Select-box li').click(function () { var _tihs = $(this).attr('class'); var _html = $(this).html(); if (_tihs == 'baidu_s') { _tihs = 'https://www.baidu.com/s'; _name = 'wd'; } if (_tihs == 'google_s') { _tihs = 'https://www.google.com/search'; _name = 'q'; } if (_tihs == 'bing_s') { _tihs = 'https://www.bing.com/search'; _name = 'q'; } $('.baidu form').attr('action', _tihs); $('.this_s').html(_html); $('#kw').attr('name', _name); $('.Select-box ul').css('height', '40px') }); $('.Select-box-2 li').click(function () { var _tihs = $(this).attr('class'); var _html = $(this).html(); if (_tihs == 'baidu_s') { _tihs = 'https://www.baidu.com/s'; _name = 'wd'; } if (_tihs == 'google_s') { _tihs = 'https://www.google.com/search'; _name = 'q'; } if (_tihs == 'bing_s') { _tihs = 'https://www.bing.com/search'; _name = 'q'; } $('.baidu form').attr('action', _tihs); $('.this_s').html(_html); $('#kw-2').attr('name', _name); $('.Select-box-2 ul').css('height', '48px') }); //清空输入框内容 $('.qingkong').click(function () { cls(); $(this).css('display', 'none') }); function cls() { var sum = 0; var t = document.getElementsByTagName(\"INPUT\"); for (var i = 0; i &lt; t.length; i++) { if (t[i].type == 'text') { ++sum; t[i].value = \"\";//清空 } } } //清空输入框按钮的显示和隐藏 function if_btn() { var btn_obj = document.getElementById(\"kw\") || document.getElementById(\"kw-2\"); var cls_btn = document.getElementById(\"qingkong\"); var btn_obj_val; var times; //当元素获得焦点时 if (btn_obj == '' || btn_obj == null) { return false; //如果没有找到这个元素，则将函数返回，不继续执行 } btn_obj.onfocus = function () { times = setInterval(function () { btn_obj_val = btn_obj.value; if (btn_obj_val != 0) { cls_btn.style.display = \"block\"; } else { cls_btn.style.display = \"none\"; } }, 200); } //元素失去焦点时 btn_obj.onblur = function () { clearInterval(times); } } &lt;/script&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; * { margin: 0; padding: 0; font-family: \"微软雅黑\" } ul,li,h1,h2,h3,h4,h5,h6,p,form,dl,dt,dd { margin: 0px; padding: 0px; font-size: 14px; font-weight: normal; } img { border-style: none; } li { list-style: none; float: left } a { text-decoration: none } .card { background-color: rgba(25, 240, 229, 0); width: 96%; margin-left: 2% } .baidu { float: left; margin-left: 100px; } .baidu form { position: relative } .Select-box ul { height: 40px; position: absolute; left: -1px; top: 0px; z-index: 9999; background: #FFF; border: 1px solid #ccc; border-top: none; overflow: hidden } .Select-box li { width: 60px; line-height: 40px; font-size: 14px; color: #484848; border: 0; cursor: pointer; } .Select-box li:hover { background: #3385ff; color: #FFF; } .Select-box .this_s { color: #317ef3; } .Select-box .this_s:hover { background: #FFF; color: #317ef3; } .qingkong { position: absolute; right: 120px; top: 12px; width: 18px; height: 18px; background: rgba(0, 0, 0, 0.1); border-radius: 18px; line-height: 16px; color: #666666; cursor: pointer; text-align: center; font-size: 14px; display: none; } .qingkong:hover { background: rgba(0, 0, 0, 0.2); } .qingkong:active { background: rgba(0, 0, 0, 0.3); } .baidu-2 { width: 100%; height: 110px; margin: 0 auto; background: none; padding-top: 50px; } .baidu-2 form { width: 520px; margin: 0 auto; } .baidu-2 input { padding: 13px 8px; opacity: 0.9; font-size: 15px; } #Select-2 { float: left; } .Select-box-2 { text-align: center; float: left; position: relative; } .Select-box-2 ul { height: 46px; position: absolute; left: 0px; top: 1px; z-index: 9999; background: rgba(255, 255, 255, 0.9); border: 1px solid #ccc; border-top: none; overflow: hidden } .Select-box-2 li { width: 60px; line-height: 46px; font-size: 15px; color: #484848; border: 0; cursor: pointer; } .Select-box-2 li:hover { background: #3385ff; color: #FFF; } .Select-box-2 .this_s { color: #317ef3; } .Select-box-2 .this_s:hover { background: none; color: #317ef3; } #kw-2 { width: 335px; outline: 0; border: 1px solid #ccc; background: rgba(255, 255, 255, 0.2); color: #000000; padding-left: 70px; font-weight: bold; } /*修改搜索框样式*/ #su-2 { width: 90px; background: blue; border: none; border-top: #3385ff 1px solid; border-bottom: 1px solid #2d78f4; color: #FFF; cursor: pointer; /*去轮廓阴影*/ outline: none; } /*光标移动到搜索框颜色*/ #su-2:hover { background: blue; border-bottom: 1px solid blue; } #su-2:active { background: blue; box-shadow: inset 1px 1px 3px blue; -webkit-box-shadow: inset 1px 1px 3px blue; } .jj-list-tit { font-size: 16px; line-height: 25px; color: #ffffff; width: 100%; padding-left: 38.5%; } .jj-list-con { overflow: hidden; margin: 0 auto } /*控制网站列表间距*/ .jj-list-con li { width: 31.333%; margin: 1%; } .link-3 { display: block; background: rgba(0, 0, 0, .35); color: #FFF; font-size: 13px; text-align: center; line-height: 35px; padding: 4px 0; border-radius: 2px; transition: all 0.2s } .link-3:hover { background: rgba(0, 0, 0, .45); font-size: 15px; font-weight: bold } /*1栏 小于584*/ @media only screen and (max-width: 584px) { .navi-height { height: 1300px; } .link-box { margin-top: 5%; } .large-screen { display: none; } } /* 2栏 大于584 小于993px */ @media only screen and (min-width: 584px) and (max-width: 993px) { .navi-height { height: 800px; } .link-box { margin-top: 5%; } .large-screen { display: none; } } /*3栏 大于993px*/ @media only screen and (min-width: 993px) { .navi-height { position: absolute; width: 100%; height: 100%; } } /* 隐藏footer */ .page-footer { display: none; }&lt;/style&gt;&lt;% if (theme.banner.enable) { %&gt;&lt;script&gt; // 每天切换 banner 图. Switch banner image every day. var bannerUrl = \"&lt;%- theme.jsDelivr.url %&gt;&lt;%- url_for('/medias/banner/') %&gt;\" + new Date().getDay() + '.jpg'; $('.bg-cover').css('background-image', 'url(' + bannerUrl + ')');&lt;/script&gt;&lt;% } else { %&gt;&lt;script&gt; $('.bg-cover').css('background-image', 'url(&lt;%- theme.jsDelivr.url %&gt;&lt;%- url_for('/medias/banner/0.jpg') %&gt;)');&lt;/script&gt;&lt;% } %&gt; 修改导航栏颜色以及透明效果打开themes/matery/source/css/matery.css文件，大约在250行，有一个.bg-color属性，修改其属性值即可，代码如下： 1234.bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); //修改成自己喜欢的颜色值 opacity: 0.8; //透明效果 值范围 0~1，看情况自己修改} 新增加载动画参考 1.在 Matery 主题配置文件 _config.yml 中新增配置属性 preloader。 1234# 是否开启页面加载动画 true 开启，false 关闭preloader: enable: true 2.在 Matery 主题目录 /layout/_widget 下新增文件 loading.ejs，将以下内容写入 loading.ejs。 12345678910111213141516171819202122&lt;% if (theme.preloader.enable) { %&gt;&lt;div id=\"loading-box\"&gt; &lt;div class=\"loading-left-bg\"&gt;&lt;/div&gt; &lt;div class=\"loading-right-bg\"&gt;&lt;/div&gt; &lt;div class=\"spinner-box\"&gt; &lt;div class=\"configure-border-1\"&gt; &lt;div class=\"configure-core\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"configure-border-2\"&gt; &lt;div class=\"configure-core\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"loading-word\"&gt;加载中...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; window.addEventListener('load', function(){ document.body.style.overflow = 'auto'; document.getElementById('loading-box').classList.add(\"loaded\") }, false)&lt;/script&gt;&lt;% } %&gt; 3.接着在 Matery 主题目录 /css 下新增 loading.css ，并将以下内容写入 loading.css。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#loading-box .loading-left-bg,#loading-box .loading-right-bg { position: fixed; z-index: 1000; width: 50%; height: 100%; background-color: #37474f; transition: all 0.5s;}#loading-box .loading-right-bg { right: 0;}#loading-box &gt; .spinner-box { position: fixed; z-index: 1001; display: flex; justify-content: center; align-items: center; width: 100%; height: 100vh;}#loading-box .spinner-box .configure-border-1 { position: absolute; padding: 3px; width: 115px; height: 115px; background: #ffab91; animation: configure-clockwise 3s ease-in-out 0s infinite alternate;}#loading-box .spinner-box .configure-border-2 { left: -115px; padding: 3px; width: 115px; height: 115px; background: rgb(63, 249, 220); transform: rotate(45deg); animation: configure-xclockwise 3s ease-in-out 0s infinite alternate;}#loading-box .spinner-box .loading-word { position: absolute; color: #ffffff; font-size: 0.8rem;}#loading-box .spinner-box .configure-core { width: 100%; height: 100%; background-color: #37474f;}div.loaded div.loading-left-bg { transform: translate(-100%, 0);}div.loaded div.loading-right-bg { transform: translate(100%, 0);}div.loaded div.spinner-box { display: none !important; }@keyframes configure-clockwise { 0% { transform: rotate(0); } 25% { transform: rotate(90deg); } 50% { transform: rotate(180deg); } 75% { transform: rotate(270deg); } 100% { transform: rotate(360deg); }}@keyframes configure-xclockwise { 0% { transform: rotate(45deg); } 25% { transform: rotate(-45deg); } 50% { transform: rotate(-135deg); } 75% { transform: rotate(-225deg); } 100% { transform: rotate(-315deg); }} 4.然后找到 Matery 主题目录 /layout/_partial 下找到 head.ejs，并在 &lt;head&gt; 标签中添加以下内容引入 loading.css 文件。&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"&lt;%- theme.jsDelivr.url %&gt;&lt;%- url_for('/css/loading.css') %&gt;\"&gt; 5.再找到 Matery 主题目录 /layout 下找到 layout.ejs，然后在&lt;body&gt; 标签下引入 loading.ejs。&lt;%- partial('_widget/loading') %&gt;","categories":[{"name":"hexo","slug":"hexo","permalink":"https://wenkexia.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wenkexia.github.io/tags/hexo/"}]}],"categories":[{"name":"web","slug":"web","permalink":"https://wenkexia.github.io/categories/web/"},{"name":"数据库","slug":"数据库","permalink":"https://wenkexia.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"java","slug":"java","permalink":"https://wenkexia.github.io/categories/java/"},{"name":"前端","slug":"前端","permalink":"https://wenkexia.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"工具","slug":"工具","permalink":"https://wenkexia.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/categories/python/"},{"name":"学习","slug":"学习","permalink":"https://wenkexia.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"pytohn","slug":"pytohn","permalink":"https://wenkexia.github.io/categories/pytohn/"},{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/categories/%E7%9F%A5%E8%AF%86/"},{"name":"自动化","slug":"自动化","permalink":"https://wenkexia.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkexia.github.io/categories/%E9%B8%BF%E8%92%99/"},{"name":"hexo","slug":"hexo","permalink":"https://wenkexia.github.io/categories/hexo/"}],"tags":[{"name":"postman","slug":"postman","permalink":"https://wenkexia.github.io/tags/postman/"},{"name":"redis","slug":"redis","permalink":"https://wenkexia.github.io/tags/redis/"},{"name":"web","slug":"web","permalink":"https://wenkexia.github.io/tags/web/"},{"name":"框架","slug":"框架","permalink":"https://wenkexia.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"qq","slug":"qq","permalink":"https://wenkexia.github.io/tags/qq/"},{"name":"python","slug":"python","permalink":"https://wenkexia.github.io/tags/python/"},{"name":"图像","slug":"图像","permalink":"https://wenkexia.github.io/tags/%E5%9B%BE%E5%83%8F/"},{"name":"pandas","slug":"pandas","permalink":"https://wenkexia.github.io/tags/pandas/"},{"name":"numpy","slug":"numpy","permalink":"https://wenkexia.github.io/tags/numpy/"},{"name":"web自动化","slug":"web自动化","permalink":"https://wenkexia.github.io/tags/web%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"爬虫","slug":"爬虫","permalink":"https://wenkexia.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"matlab","slug":"matlab","permalink":"https://wenkexia.github.io/tags/matlab/"},{"name":"深度学习","slug":"深度学习","permalink":"https://wenkexia.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"linux","slug":"linux","permalink":"https://wenkexia.github.io/tags/linux/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wenkexia.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"小程序","slug":"小程序","permalink":"https://wenkexia.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"window","slug":"window","permalink":"https://wenkexia.github.io/tags/window/"},{"name":"自动化","slug":"自动化","permalink":"https://wenkexia.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"markdown","slug":"markdown","permalink":"https://wenkexia.github.io/tags/markdown/"},{"name":"vscode","slug":"vscode","permalink":"https://wenkexia.github.io/tags/vscode/"},{"name":"autojs","slug":"autojs","permalink":"https://wenkexia.github.io/tags/autojs/"},{"name":"鸿蒙","slug":"鸿蒙","permalink":"https://wenkexia.github.io/tags/%E9%B8%BF%E8%92%99/"},{"name":"待分","slug":"待分","permalink":"https://wenkexia.github.io/tags/%E5%BE%85%E5%88%86/"},{"name":"容器","slug":"容器","permalink":"https://wenkexia.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"软件","slug":"软件","permalink":"https://wenkexia.github.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"GitHub","slug":"GitHub","permalink":"https://wenkexia.github.io/tags/GitHub/"},{"name":"MySQL","slug":"MySQL","permalink":"https://wenkexia.github.io/tags/MySQL/"},{"name":"计网","slug":"计网","permalink":"https://wenkexia.github.io/tags/%E8%AE%A1%E7%BD%91/"},{"name":"java","slug":"java","permalink":"https://wenkexia.github.io/tags/java/"},{"name":"知识","slug":"知识","permalink":"https://wenkexia.github.io/tags/%E7%9F%A5%E8%AF%86/"},{"name":"hexo","slug":"hexo","permalink":"https://wenkexia.github.io/tags/hexo/"}]}