<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础 | wenke</title><meta name="keywords" content="Java基础"><meta name="author" content="wenke"><meta name="copyright" content="wenke"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2. 基础知识高级语言的编译运行方式编程：写好代码编译: 机器只认识0011的机器语言，将代码转化成机器认识的过程运行：让机器执行编译后的指令 2.1. Java的进制二进制：以0b开头十进制：默认不加前缀八进制：以0开头十六进制：以0x开头 2.2. 用记事本编写Java代码在cmd中调用JDK中的Javac编译.Java文件Javac demo.Java最后会生成字节码.class文件 运行编">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://wenkex.gitee.io/2021/122465132.html">
<meta property="og:site_name" content="wenke">
<meta property="og:description" content="2. 基础知识高级语言的编译运行方式编程：写好代码编译: 机器只认识0011的机器语言，将代码转化成机器认识的过程运行：让机器执行编译后的指令 2.1. Java的进制二进制：以0b开头十进制：默认不加前缀八进制：以0开头十六进制：以0x开头 2.2. 用记事本编写Java代码在cmd中调用JDK中的Javac编译.Java文件Javac demo.Java最后会生成字节码.class文件 运行编">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wenkex.gitee.io/img/top.jpg">
<meta property="article:published_time" content="2021-12-24T00:53:47.000Z">
<meta property="article:modified_time" content="2022-10-19T01:22:48.860Z">
<meta property="article:author" content="wenke">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wenkex.gitee.io/img/top.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wenkex.gitee.io/2021/122465132"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d103aef22d2746c3d56e2dae461c4699";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="/Arts" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离上次更新已经过了","messageNext":"天， 文章内容可能已过期，请留意"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":1000,"languages":{"author":"作者: wenke","link":"链接: ","source":"来源: wenke","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-19 09:22:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="wenke" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/me.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-open"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/box/"><i class="fa-fw fas fa-tags"></i><span> 聚合</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-heart"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-list"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">wenke</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book-open"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/box/"><i class="fa-fw fas fa-tags"></i><span> 聚合</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-heart"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-list"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-24T00:53:47.000Z" title="发表于 2021-12-24 08:53:47">2021-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-19T01:22:48.860Z" title="更新于 2022-10-19 09:22:48">2022-10-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2. 基础知识"></a>2. 基础知识</h2><p>高级语言的编译运行方式<br>编程：写好代码<br>编译: 机器只认识0011的机器语言，将代码转化成机器认识的过程<br>运行：让机器执行编译后的指令</p>
<h3 id="2-1-Java的进制"><a href="#2-1-Java的进制" class="headerlink" title="2.1. Java的进制"></a>2.1. Java的进制</h3><p>二进制：以0b开头<br>十进制：默认不加前缀<br>八进制：以0开头<br>十六进制：以0x开头</p>
<h3 id="2-2-用记事本编写Java代码"><a href="#2-2-用记事本编写Java代码" class="headerlink" title="2.2. 用记事本编写Java代码"></a>2.2. 用记事本编写Java代码</h3><p>在cmd中调用JDK中的Javac编译.Java文件<br><code>Javac demo.Java</code>最后会生成字节码.class文件</p>
<p>运行编译后的文件<code>Java demo</code> 此时不需要带后缀</p>
<h3 id="2-3-跨平台原理"><a href="#2-3-跨平台原理" class="headerlink" title="2.3. 跨平台原理"></a>2.3. 跨平台原理</h3><p>Java的跨平台时通过虚拟机实现的，<br>它不是直接运行在操作系统中，而是运行在虚拟机中，针对不同的操作系统，安装不同的虚拟机就可以了</p>
<h3 id="2-4-JRE和jdk"><a href="#2-4-JRE和jdk" class="headerlink" title="2.4. JRE和jdk"></a>2.4. JRE和jdk</h3><p>JDK : Java Development ToolKit(Java开发工具包)。JDK是整个Java的核心，包括了Java运行环境jre（Java Runtime Envirnment），Java工具（Javac/Java/jdb等）和Java基础的类库</p>
<ul>
<li><p>jre:Java运行环境</p>
<ul>
<li>在JDK的安装目录下有一个jre目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib合起来就称为jre。</li>
</ul>
</li>
<li><p>bin:Java工具</p>
<ul>
<li>Javac：编译工具</li>
<li>Java：运行工具</li>
<li>jdb：调试工具</li>
<li>jhat:内存分析工具</li>
</ul>
</li>
<li><p>lib：类库</p>
</li>
<li><p>include:Java和JVM交互用的头文件</p>
</li>
</ul>
<h3 id="2-5-标识符"><a href="#2-5-标识符" class="headerlink" title="2.5. 标识符"></a>2.5. 标识符</h3><p>命名规则<br>可以包含数字，但不能以数字开头<br>除了下划线_,和$符之外，不能有其它特殊字符，如空格<br>区分字母大小写<br>不能使用Java关键字<br>换行符\n要加双引号<br>System.out.println(“名字”+“\n”);</p>
<h3 id="2-6-注释"><a href="#2-6-注释" class="headerlink" title="2.6. 注释"></a>2.6. 注释</h3><p>单行注释：//<br>多行注释：从“/<em>”开始到“</em>/”结束，<br>文档注释：从“/*<em>”开始到“</em>/”结束<br>文档注释可以用Javadoc命令提取出来，生成类似于jdk文档的网页文件，以便于他人了解一个类的功能。</p>
<h3 id="2-7-变量"><a href="#2-7-变量" class="headerlink" title="2.7. 变量"></a>2.7. 变量</h3><p>变量定义格式：数据类型 变量名 =值;<br>前面不可以有访问符<br>变量只能存一个值，在使用前一定要赋值<br>变量名不允许重复定义</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一条语句可以定义多个变量</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-Java-修饰符"><a href="#3-Java-修饰符" class="headerlink" title="3. Java 修饰符"></a>3. Java 修饰符</h2><h3 id="3-1-访问控制修饰符"><a href="#3-1-访问控制修饰符" class="headerlink" title="3.1. 访问控制修饰符"></a>3.1. 访问控制修饰符</h3><p><span id="fawen">访问符</span><br>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<ul>
<li><p>default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。</p>
</li>
<li><p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类和接口<br>私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，<br>声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。<br>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p>
</li>
<li><p>public : 对所有类可见。使用对象：类、接口、变量、方法</p>
</li>
<li><p>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p>
</li>
</ul>
<h3 id="3-2-非访问修饰符"><a href="#3-2-非访问修饰符" class="headerlink" title="3.2. 非访问修饰符"></a>3.2. 非访问修饰符</h3><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p>
<ul>
<li><p>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>
</li>
<li><p>abstract 修饰符，用来创建抽象类和抽象方法。</p>
</li>
<li><p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p>
</li>
<li><p>static 修饰符：用来修饰类方法和类变量。<br>静态变量：<br>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p>
</li>
</ul>
<p>静态方法：<br>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p>
<h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h2><h3 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1. 算术运算符"></a>4.1. 算术运算符</h3><pre><code>前缀自增自减法(++a,--a): 先进行自增或者自减运算，再进行表达式运算。

后缀自增自减法(a++,a--): 先进行表达式运算，再进行自增或者自减运算
</code></pre>
<ul>
<li>关系运算符</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">!= 检查如果两个操作数的值是否相等，如果值不相等则条件为真。 (A != B) 为真。</span><br><span class="line">&gt;  检查左操作数的值是否大于右操作数的值，如果是那么条件为真。 （A&gt; B）为假。</span><br><span class="line">&lt;  检查左操作数的值是否小于右操作数的值，如果是那么条件为真。（A &lt;B）为真。</span><br><span class="line">&gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 （A&gt; = B）为假。</span><br><span class="line">&lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 （A &lt;= B）为真。</span><br><span class="line">== 在基本数据类型中比较数据值，在引用数据类型中比的是地址值 </span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-2-位运算符"><a href="#4-2-位运算符" class="headerlink" title="4.2. 位运算符"></a>4.2. 位运算符</h3><p>位运算符是对long、int、short、byte和char这5种类型的数据进行运算的，是对二进制位上的数值进行计算,我们不能对double、float和boolean进行位运算操作</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">＆ 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100</span><br><span class="line">| 如果相对应位都是 0，则结果为 0，否则为 1 （A | B）得到61，即 0011 1101</span><br><span class="line">^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001</span><br><span class="line">〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011</span><br><span class="line">&lt;&lt;  按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000</span><br><span class="line">&gt;&gt;  按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111</span><br><span class="line">&gt;&gt;&gt;  按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A&gt;&gt;&gt;2得到15即0000 1111</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-3-逻辑运算符"><a href="#4-3-逻辑运算符" class="headerlink" title="4.3. 逻辑运算符"></a>4.3. 逻辑运算符</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 （A &amp;&amp; B）为假。</span><br><span class="line">|| 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 （A | | B）为真。</span><br><span class="line">！ 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 ！（A &amp;&amp; B）为真。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4. 赋值运算符"></a>4.4. 赋值运算符</h3><h3 id="4-5-条件运算符-三元运算符"><a href="#4-5-条件运算符-三元运算符" class="headerlink" title="4.5. 条件运算符(三元运算符)"></a>4.5. 条件运算符(三元运算符)</h3><p><code>条件判断语句 ? value if true : value if false</code></p>
<h3 id="4-6-其他运算符"><a href="#4-6-其他运算符" class="headerlink" title="4.6. 其他运算符"></a>4.6. 其他运算符</h3><h2 id="9-循环结构"><a href="#9-循环结构" class="headerlink" title="9. 循环结构"></a>9. 循环结构</h2><h3 id="9-1-while循环"><a href="#9-1-while循环" class="headerlink" title="9.1. while循环"></a>9.1. while循环</h3><p>如果您想要同样的操作执行多次,，就需要使用循环结构。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( 布尔表达式 ) {</span><br><span class="line"> <span class="comment">//循环内容</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-2-do-while循环"><a href="#9-2-do-while循环" class="headerlink" title="9.2. do while循环"></a>9.2. do while循环</h3><p>对于while语句而言，如果不满足条件，则不能进入循环。<br>但有时候我们需要即使不满足条件，也至少执行一次。可以用到do…while循环</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> {</span><br><span class="line">       <span class="comment">//代码语句</span></span><br><span class="line">}<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-3-for循环"><a href="#9-3-for循环" class="headerlink" title="9.3. for循环"></a>9.3. for循环</h3><p>关于for循环有以下几点说明：</p>
<p>1.最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。<br>2.然后，检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。<br>3.执行一次循环后，更新循环控制变量。<br>4.再次检测布尔表达式。循环执行上面的过程。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化; 布尔表达式; 更新) {</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="9-4-foreach-循环"><a href="#9-4-foreach-循环" class="headerlink" title="9.4. foreach 循环"></a>9.4. foreach 循环</h3><p>在遍历数组、集合方面使用<br>foreach 循环语句的语法格式如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(类型 变量名:集合) {</span><br><span class="line">    语句块;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>“类型”为集合元素的类型，“变量名”表示集合中的每一个元素，“集合”是被遍历的集合对象或数组。每执行一次循环语句，循环变量就读取集合中的一个元素，</p>
<h3 id="9-5-break关键字"><a href="#9-5-break关键字" class="headerlink" title="9.5. break关键字"></a>9.5. break关键字</h3><p>break主要用在循环语句或者switch语句中，用来跳出整个语句块。</p>
<p>break跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<h3 id="9-6-continue关键字"><a href="#9-6-continue关键字" class="headerlink" title="9.6. continue关键字"></a>9.6. continue关键字</h3><p>continue适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</p>
<p>在for循环中，continue语句使程序立即跳转到更新语句。提前结束本次循环，直接执行下次循环</p>
<p>在while或者do…while循环中，程序立即跳转到布尔表达式的判断语句。</p>
<h2 id="10-分支结构"><a href="#10-分支结构" class="headerlink" title="10. 分支结构"></a>10. 分支结构</h2><h3 id="10-1-if…else-if…else-语句"><a href="#10-1-if…else-if…else-语句" class="headerlink" title="10.1. if…else if…else 语句"></a>10.1. if…else if…else 语句</h3><p>if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。</p>
<p>使用if，else if，else语句的时候，需要注意下面几点：</p>
<p>if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。<br>If 语句可以有若干个 else if 语句，它们必须在 else 语句之前。<br>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(){</span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(){</span><br><span class="line"></span><br><span class="line">}<span class="keyword">else</span>{   <span class="comment">//可以不用else}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-2-switch多重选择"><a href="#10-2-switch多重选择" class="headerlink" title="10.2. switch多重选择"></a>10.2. switch多重选择</h3><p>switch 语句<br>switch 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<p>switch 语法格式如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression){</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>switch 语句有如下规则：</p>
<p>switch 语句中的变量类型只能为 byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</p>
<p>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。<br>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。<br>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到break语句出现才会跳出 switch 语句。</p>
<p>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</p>
<p>switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</p>
<h2 id="11-Java方法"><a href="#11-Java方法" class="headerlink" title="11. Java方法"></a>11. Java方法</h2><p>定义格式</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名){</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</p>
</li>
<li><p>返回值类型 ：方法可能会返回值。returnValueType 是方法返回值的数据类型。若方法中没有returun返回值，则该方法的返回类型为void类型。</p>
</li>
<li><p>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</p>
</li>
<li><p>参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</p>
</li>
<li><p>方法体：方法体包含具体的语句，定义该方法的功能。</p>
</li>
</ul>
<p>若方法中没有returun返回值，则该方法的返回类型为void类型</p>
<h2 id="12-参数"><a href="#12-参数" class="headerlink" title="12. 参数"></a>12. 参数</h2><h3 id="12-1-形参-amp-实参"><a href="#12-1-形参-amp-实参" class="headerlink" title="12.1. 形参&amp;实参"></a>12.1. 形参&amp;实参</h3><p>形参：声明方法时定义的参数，形参前必须有数据类型  格式：方法名（数据类型 形参）<br>实参：调用方法时给方法传递的实际数据，使用格式：对象名.方法名（实参）</p>
<h3 id="12-2-值传递-amp-引用传递"><a href="#12-2-值传递-amp-引用传递" class="headerlink" title="12.2. 值传递&amp;引用传递"></a>12.2. 值传递&amp;引用传递</h3><h3 id="12-3-Java只有值传递"><a href="#12-3-Java只有值传递" class="headerlink" title="12.3. Java只有值传递"></a>12.3. Java只有值传递</h3><p>Java 中将实参传递给方法（或函数）的方式只有 值传递 ：<br> 如果参数是基本类型的话，传递的就是基本类型的字面量值的拷贝，会创建副本。<br> 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</p>
<h3 id="12-4-参数传内置类型"><a href="#12-4-参数传内置类型" class="headerlink" title="12.4. 参数传内置类型"></a>12.4. 参数传内置类型</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> w)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> temp = q;</span><br><span class="line">    q = w;</span><br><span class="line">    w = temp;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    swap(a, b); <span class="comment">//交换a,b</span></span><br><span class="line">    System.out.println(a);  <span class="comment">//1</span></span><br><span class="line">    System.out.println(b); <span class="comment">//2 </span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>  我们用 内置类型作为参数，进行交换变量，但是最后编译的结果 两个变量却并未发生交换.<br>这是因为交换形参 的值, 不影响实参的 值.</p>
<h3 id="12-5-参数传数组类型"><a href="#12-5-参数传数组类型" class="headerlink" title="12.5. 参数传数组类型"></a>12.5. 参数传数组类型</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">       <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">         arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">         arr[<span class="number">1</span>] = temp;</span><br><span class="line">         <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line"> }</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">     <span class="keyword">int</span>[] arr = {<span class="number">1</span>,<span class="number">2</span>};</span><br><span class="line">     System.out.println(<span class="string">"转换器前"</span>+Arrays.toString(arr));  <span class="comment">//转换器前[1, 2]</span></span><br><span class="line">     swap(arr);</span><br><span class="line">     System.out.println(<span class="string">"转换后"</span>+Arrays.toString(arr)); <span class="comment">//转换后[2, 1]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们用 数组作为参数，进行交换变量，编译运行后，发现成功交换两个变量的值。此时数组名 arr 是一个 “引用” . 当传参的时候, 是按照引用传参.</p>
<p>我们可以知道，数组这个在栈中存放的变量实际存放的是 堆中数据的地址，当我们 arr 数组作为参数 传入 方法里，我们就把 堆中数据的地址 传入了进去，在方法内部，我们可以根据 这个地址 找到堆中的数据进而修改数据，从而实现了形参改变了实参的操作.</p>
<p>  所谓的 “引用” 本质上只是存了一个地址. Java 将数组设定成引用类型, 这样的话后续进行数组参数传参, 其实只是将数组的地址传入到函数形参中. 这样可以避免对整个数组的拷贝(数组可能比较长, 那么拷贝开销就会很大).</p>
<h3 id="12-6-可变参数"><a href="#12-6-可变参数" class="headerlink" title="12.6. 可变参数"></a>12.6. 可变参数</h3><p>定义格式<br>方法名（参数列表，数据类型 … 变量）<br>注意：<br>可变参数只能处于参数列表的最后<br>一个方法最多只能包含一个可变参数<br>可变参数本质是一个数组，因此在调用时，既可以传入多个参数，也可传入一个数组</p>
<h2 id="13-类"><a href="#13-类" class="headerlink" title="13. 类"></a>13. 类</h2><p>类可以看成是创建 Java 对象的模板。，描述一类对象的属性(状态)和方法(行为)<br>定义类的注意事项：<br>1.类名使用 UpperCamelCase风格，必须遵从驼峰形式，即每个单词首字母均大写，且public类名应与所在项目名保持一致。<br>2.一个Java文件可以定义多个class类，建议一个文件定义一个类；但只能有一个类被public修饰，而且public修饰的类必须是代码文件名，</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>{</span><br><span class="line">    成员变量</span><br><span class="line">    成员方法</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="13-1-类型变量"><a href="#13-1-类型变量" class="headerlink" title="13.1. 类型变量"></a>13.1. 类型变量</h3><p>一个类可以包含以下类型变量：</p>
<ul>
<li><p>1.成员变量：成员变量是定义在类中，方法体之外的变量。<br>这种变量在创建对象的时候实例化。直接把field用public暴露给外部可能会破坏封装性，所以用private，外部代码可以调用get()方法和set()方法来间接获取和修改指定的私有成员变量的值<br>成员变量可以被类中方法、构造方法和特定类的语句块访问。<br><code>修饰符 数据类型 变量名</code></p>
</li>
<li><p>2.局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</p>
</li>
<li><p>类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</p>
</li>
</ul>
<h4 id="13-1-1-就近原则"><a href="#13-1-1-就近原则" class="headerlink" title="13.1.1. 就近原则"></a>13.1.1. 就近原则</h4><p>谁离我近，我就用谁</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Friend</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">int</span> age =<span class="number">10</span>;</span><br><span class="line">        System.out.println(age); <span class="comment">//10</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="13-1-2-this关键字"><a href="#13-1-2-this关键字" class="headerlink" title="13.1.2. this关键字"></a>13.1.2. this关键字</h4><p>this代表当前对象的内存地址，<br>在实例方法或者构造方法中，为了区分局部变量和实例变量，this不能省略<br>代表当前类将来产生的对象，即将来用该类new出来的对象，用于获取当前类的对象的引用<br>this.name = name  //this.name值成员变量</p>
<h4 id="13-1-3-supper关键字"><a href="#13-1-3-supper关键字" class="headerlink" title="13.1.3. supper关键字"></a>13.1.3. supper关键字</h4><p>通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"animal : eat"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"dog : eat"</span>);</span><br><span class="line">  }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eatTest</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.eat();   <span class="comment">// this 调用自己的方法</span></span><br><span class="line">        <span class="keyword">super</span>.eat();  <span class="comment">// super 调用父类方法</span></span><br><span class="line">        System.out.println(supper.age)   </span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="13-2-构造方法-构造器"><a href="#13-2-构造方法-构造器" class="headerlink" title="13.2. 构造方法(构造器)"></a>13.2. 构造方法(构造器)</h3><p>作用：在创建对象时初始化成员变量</p>
<h4 id="13-2-1-两种构造器"><a href="#13-2-1-两种构造器" class="headerlink" title="13.2.1. 两种构造器"></a>13.2.1. 两种构造器</h4><p>无论是否使用，建议两个都写上，右键直接生成</p>
<ul>
<li>空参构造方法：可以省略，如果我们没有写任何构造方法，虚拟机会给我们加一个空参构造。初始化对象时，成员变量采用默认值</li>
<li>带参构造方法:初始化对象时，同时为对象赋值</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>, <span class="number">15</span>); <span class="comment">// 调用带参数的构造方法</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(); <span class="comment">// 调用无参数构造方法</span></span><br></pre></td></tr></tbody></table></figure>

<p>特点：<br>1.构造方法的名称与类名一致。<br>2.构造方法没有返回类型（也没有void），没有返回值(不能有return)<br>3.构造方法在创建对象时由虚拟机调用，不能手动调用构造方法，每次创建对象，都会调用一次<br>调用构造方法，必须用new操作符。<br>不能被static、final、synchronized、abstract和native修饰。构造方法不能被子类继承，所以用final和abstract修饰没有意义。</p>
<h4 id="13-2-2-定义"><a href="#13-2-2-定义" class="headerlink" title="13.2.2. 定义"></a>13.2.2. 定义</h4><p>构造方法用于初始化一个新建的对象，所以用static修饰没有意义</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">访问修饰符 类名(参数){</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="13-2-3-子类调用"><a href="#13-2-3-子类调用" class="headerlink" title="13.2.3. 子类调用"></a>13.2.3. 子类调用</h4><p>构造器只能够被调用（隐式或显式），而不能被继承<br>如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>
<p>如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">  <span class="comment">//无参构造器</span></span><br><span class="line">  SuperClass(){}</span><br><span class="line">  <span class="comment">//带参构造器</span></span><br><span class="line">  SuperClass(<span class="keyword">int</span> n) {</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SubClass2 类继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">  </span><br><span class="line">  SubClass2(){</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">300</span>);  <span class="comment">// 调用父类中带有参数的构造器</span></span><br><span class="line">    System.out.println(<span class="string">"SubClass2"</span>);</span><br><span class="line">  }  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubClass2</span><span class="params">(<span class="keyword">int</span> n)</span></span>{ <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">    System.out.println(<span class="string">"SubClass2(int n):"</span>+n);</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="13-3-set方法和get方法"><a href="#13-3-set方法和get方法" class="headerlink" title="13.3. set方法和get方法"></a>13.3. set方法和get方法</h3><p>用private修饰的成员只能在本类才能访问，</p>
<p>当类中有private修饰的私有变量时，其他类只能通过set和get方法间接地操作这些私有域变量</p>
<p>因此要对每个私有变量都要提供get(获取),set(赋值)方法，右键直接生成就好</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.返回类型必须是void </span></span><br><span class="line"><span class="comment">// 2.方法名是set+成员变量名字的首字母大写 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>{</span><br><span class="line">    <span class="keyword">this</span>.name= name</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="13-4-方法的调用"><a href="#13-4-方法的调用" class="headerlink" title="13.4. 方法的调用"></a>13.4. 方法的调用</h3><p>1.调用非静态方法<br> 对象名.方法名（）<br>2.调用静态方法<br> 类名.方法名()</p>
<h3 id="13-5-方法重载"><a href="#13-5-方法重载" class="headerlink" title="13.5. 方法重载"></a>13.5. 方法重载</h3><p>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。<br>目的：功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p>
<h3 id="13-6-方法重写"><a href="#13-6-方法重写" class="headerlink" title="13.6. 方法重写"></a>13.6. 方法重写</h3><p>子类重写了父类的方法<br>注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法</p>
<h3 id="13-7-内部类"><a href="#13-7-内部类" class="headerlink" title="13.7. 内部类"></a>13.7. 内部类</h3><p>Java允许在一个类的类体里再定义一个类，该情况下外面的类叫外部类，里面的叫内部类<br>内部类可以访问其所在内部类的所有属性</p>
<h4 id="13-7-1-成员内部类"><a href="#13-7-1-成员内部类" class="headerlink" title="13.7.1. 成员内部类"></a>13.7.1. 成员内部类</h4><p>在外部类的内部定义一个类</p>
<h4 id="13-7-2-静态内部类"><a href="#13-7-2-静态内部类" class="headerlink" title="13.7.2. 静态内部类"></a>13.7.2. 静态内部类</h4><h4 id="13-7-3-非静态内部类"><a href="#13-7-3-非静态内部类" class="headerlink" title="13.7.3. 非静态内部类"></a>13.7.3. 非静态内部类</h4><h4 id="13-7-4-局部内部类"><a href="#13-7-4-局部内部类" class="headerlink" title="13.7.4. 局部内部类"></a>13.7.4. 局部内部类</h4><h4 id="13-7-5-匿名内部类"><a href="#13-7-5-匿名内部类" class="headerlink" title="13.7.5. 匿名内部类"></a>13.7.5. 匿名内部类</h4><h3 id="13-8-抽象类"><a href="#13-8-抽象类" class="headerlink" title="13.8. 抽象类"></a>13.8. 抽象类</h3><p>抽象类是类和类之间的共同特征，将这些共同特征进一步形成抽象类，</p>
<p>包含一个或多个抽象方法的类就是抽象类，抽象方法即没有方法体的方法，抽象方法和抽象类都必须声明为 abstract</p>
<h4 id="13-8-1-抽象类的意义"><a href="#13-8-1-抽象类的意义" class="headerlink" title="13.8.1. 抽象类的意义"></a>13.8.1. 抽象类的意义</h4><p>抽取共性时，无法确定方法体，就把方法定义为抽象<br>抽象类作为子类的模版，强制子类按照格式书写，避免子类设计的随意性</p>
<h4 id="13-8-2-抽象类的特点"><a href="#13-8-2-抽象类的特点" class="headerlink" title="13.8.2. 抽象类的特点"></a>13.8.2. 抽象类的特点</h4><p>抽象类除了抽象方法之外，抽象类还可以包含具体数据和具体方法，这也是接口和抽象类的不同之处，接口中是不能包含具体方法的。</p>
<p>有抽象方法的类只能被定义为抽象类，但抽象类中可以没有抽象方法</p>
<p>final和abstract不能同时同时使用，这两个关键字是对立的。抽象方法不能被 final 修饰，因为抽象方法就是被子类实现的</p>
<p>由于类本身不存在，所以抽象类无法实例化创建对象。只可以通过抽象类派生出新的子类，再由其子类来创建对象</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person是抽象类</span></span><br><span class="line"><span class="comment">// 抽象类不能被实例化</span></span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">"Jack"</span>); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以定义一个抽象类的对象变量， 但是它只能引用非抽象子类的对象。 假设 Student 类是 Person 的非抽象子类：</span></span><br><span class="line">Person p = <span class="keyword">new</span> Student(<span class="string">"Jack"</span>); <span class="comment">// Right</span></span><br></pre></td></tr></tbody></table></figure>

<p>语法格式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>{</span><br><span class="line"><span class="comment">//抽象方法，没有{}括起来的方法体</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名（参数列表）; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//方法体</span></span><br><span class="line">    }   </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="13-8-3-抽象类的子类"><a href="#13-8-3-抽象类的子类" class="headerlink" title="13.8.3. 抽象类的子类"></a>13.8.3. 抽象类的子类</h4><p>抽象类的子类可以是抽象类。也可以是非抽象类</p>
<ul>
<li>抽象子类：如果不重写抽象父类的所有抽象方法，那么子类仍然是一个抽象类，编译器会强制我们为新类加上 abstract 关键字。</li>
<li>非抽象子类：继承抽象类，必须将抽象类中的所有抽象方法进行覆盖/重写/实现，因此不能用private修饰抽象方法</li>
</ul>
<p>写一个子类继承抽象类，重写抽象方法<br>虽然不能直接new一个抽象类，但可以先声明一个抽象类变量，再用这个变量指向其子类对象</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽象类名 a = <span class="keyword">new</span> 子类名();  <span class="comment">//抽象类变量指向子类对象</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="14-Object类"><a href="#14-Object类" class="headerlink" title="14. Object类"></a>14. Object类</h2><p>Object 是 Java 类库中的一个特殊类，也是所有类的父类。也就是说，Java 允许把任何类型的对象赋给 Object 类型的变量。当一个类被定义后，如果没有指定继承的父类，那么默认父类就是 Object 类</p>
<p>由于 Java 所有的类都是 Object 类的子类，所以任何 Java 对象都可以调用 Object 类的方法。<br>| 方法                     | 说明                                                |<br>|————————|—————————————————|<br>| Object clone()         | 创建与该对象的类相同的新对象                                    |<br>| boolean equals(Object) | 比较两对象是否相等                                         |<br>| void finalize()        | 当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法                |<br>| Class getClass()       | 返回一个对象运行时的实例类                                     |<br>| int hashCode()         | 返回该对象的散列码值                                        |<br>| void notify()          | 激活等待在该对象的监视器上的一个线程                                |<br>| void notifyAll()       | 激活等待在该对象的监视器上的全部线程                                |<br>| String toString()      | 返回该对象的字符串表示                                       |<br>| void wait()            | 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待 |</p>
<h3 id="14-1-toString-方法"><a href="#14-1-toString-方法" class="headerlink" title="14.1. toString() 方法"></a>14.1. toString() 方法</h3><p>toString() 方法返回该对象的字符串，当程序输出一个对象或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的 toString() 方法返回该对象的字符串表示。</p>
<p>Object 类的 toString() 方法返回“运行时类名@十六进制哈希码”格式的字符串，但很多类都重写了 Object 类的 toString() 方法，用于返回可以表述该对象信息的字符串。<br>哈希码（hashCode），每个 Java 对象都有哈希码属性，哈希码可以用来标识对象，提高对象在集合操作中的执行效率。</p>
<h3 id="14-2-equals-方法"><a href="#14-2-equals-方法" class="headerlink" title="14.2. equals() 方法"></a>14.2. equals() 方法</h3><p>在前面学习字符串比较时，曾经介绍过两种比较方法，分别是==运算符和 equals() 方法，<br>==运算符是比较两个引用变量是否指向同一个实例<br>equals() 方法是比较两个对象的内容是否相等，通常字符串的比较只是关心内容是否相等。</p>
<h3 id="14-3-getClass-方法"><a href="#14-3-getClass-方法" class="headerlink" title="14.3. getClass() 方法"></a>14.3. getClass() 方法</h3><p>getClass() 方法返回对象所属的类，是一个 Class 对象。通过 Class 对象可以获取该类的各种信息，包括类名、父类以及它所实现接口的名字等。</p>
<h3 id="14-4-接收任意引用类型的对象"><a href="#14-4-接收任意引用类型的对象" class="headerlink" title="14.4. 接收任意引用类型的对象"></a>14.4. 接收任意引用类型的对象</h3><p>既然 Object 类是所有对象的父类，则所有的对象都可以向 Object 进行转换，在这其中也包含了数组和接口类型，即一切的引用数据类型都可以使用 Object 进行接收。</p>
<h2 id="15-接口"><a href="#15-接口" class="headerlink" title="15. 接口"></a>15. 接口</h2><p>接口规定一批类必须提供某些方法，但不提供实现方法<br>不能用final关键字修饰接口<br>当多个对象不能够抽象出共同的父类，但有共同的行为，这种情况下就需要将这种行为封装成接口。</p>
<h3 id="15-1-接口的意义"><a href="#15-1-接口的意义" class="headerlink" title="15.1. 接口的意义"></a>15.1. 接口的意义</h3><p>既然有了抽象类，java还要引入接口的原因：因为一个类可以实现多个接口，但是一个类只能继承一个父类。正是接口的出现打破了 Java 这种单继承的局限，为定义类的行为提供了极大的灵活性。有一条实际经验：在合理的范围内尽可能地抽象。显然，接口比抽象类还要抽象。因此，一般更倾向使用接口而不是抽象类</p>
<p>定义接口并非多余，接口是用来提供公用的方法，规定子类的行为的</p>
<p>比如有个网站， 需要保存不同客户的信息， 有些客户从 Web 网站来， 有些客户从手机客户端来， 有些客户直接从后台管理系统录入。假设不同来源的客户有不同的处理业务流程， 这个时候我们定义接口来提供一个保存客户信息的方法，然后不同的平台实现我们这个保存客户信息的接口，以后保存客户信息的话， 我们只需要知道这个接口就可以了，具体调用的方法被封装成了黑盒子，这也就是 Java 的多态的体现，接口帮助我们对这些有相同功能的方法做了统一管理。</p>
<h3 id="15-2-接口特性"><a href="#15-2-接口特性" class="headerlink" title="15.2. 接口特性"></a>15.2. 接口特性</h3><p>接口没有构造方法，无法实例化对象，不过可以声明一个接口变量引用接口的实现类对象<br><code>Concept x = new Implementation()    //声明Concept接口变量x引用实现类Implementation对象</code></p>
<p>接口中所有方法必须是抽象方法，Java8中允许接口包含默认方法和静态方法<br>接口中不能包含成员变量，除了static和final变量<br>接口不是被类继承了，而是被类实现了，一个类可以实现多个接口<br>接口支持多重继承</p>
<h3 id="15-3-接口成员特点"><a href="#15-3-接口成员特点" class="headerlink" title="15.3. 接口成员特点"></a>15.3. 接口成员特点</h3><p>接口是隐性抽象的，接口中的每个方法也是隐形抽象的，声明时不必使用abstract关键字</p>
<p>接口访问符应该是public或默认，因为接口应该要被继承的，默认是采用包权限访问控制，即在相同包内才可以访问该接口</p>
<ul>
<li>接口的成员变量被隐含地声明为public static final，只能是静态常量</li>
<li>接口没有构造方法</li>
<li>接口的成员方法被隐形指定为public absrtact<br>jdk7接口只能定义抽象方法，jdk9后接口可以定义有方法体的方法(默认，静态)和私有方法<br>默认方法，静态方法，私有方法</li>
</ul>
<h3 id="15-4-定义接口"><a href="#15-4-定义接口" class="headerlink" title="15.4. 定义接口"></a>15.4. 定义接口</h3><p>Java 使用关键字 interface 而不是 class 来创建接口。和类一样，通常我们会在关键字 interface 前加上 public 关键字，否则接口只有包访问权限，只能在接口相同的包下才能使用它。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">访问符 <span class="class"><span class="keyword">interface</span> 接口名  </span>{</span><br><span class="line"><span class="comment">//接口定义的只能是静态常量</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口定义的普通方法只能是public的抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//接口中定义默认方法，用default修饰</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> b)</span></span>{}</span><br><span class="line"><span class="comment">//接口中定义类方法，用static修饰</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span>{}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="15-5-实现接口"><a href="#15-5-实现接口" class="headerlink" title="15.5. 实现接口"></a>15.5. 实现接口</h3><p>接口不能实例化<br>接口和类是实现关系，用implements实现接口，可以单实现，也可以多实现，必须实现接口中定义的所有抽象方法，<br>语法格式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">访问符 <span class="class"><span class="keyword">class</span> 实现类名 <span class="keyword">implements</span> 接口1，接口2</span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[]args)</span></span>{</span><br><span class="line"><span class="comment">//先声明一个接口类型的变量，new一个该接口实现类的实例对象，并将其引用赋值给变量</span></span><br><span class="line">接口名 变量名 = <span class="keyword">new</span> 接口实现类（）;</span><br><span class="line"><span class="comment">//调用接口的默认方法，必须通过实例对象来调用</span></span><br><span class="line">变量名.默认方法（）;</span><br><span class="line"><span class="comment">//调用接口的类方法</span></span><br><span class="line">接口名.类方法（）;</span><br><span class="line"><span class="comment">//声明接口实现类的变量，并实例化该类型对象</span></span><br><span class="line">接口实现类名 变量名 = <span class="keyword">new</span> 接口实现类名（）;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="15-6-接口的继承"><a href="#15-6-接口的继承" class="headerlink" title="15.6. 接口的继承"></a>15.6. 接口的继承</h3><p>接口可以继承多个接口，不能继承类<br>使用interface可以声明一个接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>属性只能是常量</p>
<p>一个类可以实现多个interface，例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Hello</span> </span>{ <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="15-7-Java-8-接口新特性"><a href="#15-7-Java-8-接口新特性" class="headerlink" title="15.7. Java 8 接口新特性"></a>15.7. Java 8 接口新特性</h3><p>在 Java 8 中，允许在接口中增加静态方法和默认方法。理论上讲，没有任何理由认为这是不合法的，只是这有违于将接口作为抽象规范的初衷。举个例子</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Concept</span> </span>{</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String name)</span></span>{</span><br><span class="line">     System.out.println(<span class="string">"hello "</span> + name);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">idea1</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"this is idea1"</span>);</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>用 default 修饰符标记的方法就是默认方法，这样子类就不需要去实现这个方法了。</p>
<p>不过，引入默认方法后，就出现了一个默认方法冲突的问题。如果先在一个接口 A 中将一个方法 idea 定义为默认方法， 然后又在另一个接口 B 或者超类 C 中定义了同样的方法 idea，然后类 D 实现了这两个接口 A 和 B（或超类 C）。于是类 D 中就有了方法 idea 的两个默认实现，出现了冲突，为此，Java 制定了一套规则来解决这个二义性问题：<br>1 ) 超类优先。如果超类提供了一个具体方法，接口中的同名且有相同参数类型的默认方法会被忽略。</p>
<p>2 ) 接口冲突。 如果一个父类接口提供了一个默认方法，另一个父类接口也提供了一个同名而且参数类型相同的方法，子类必须覆盖这个方法来解决冲突。</p>
<h2 id="16-面对对象"><a href="#16-面对对象" class="headerlink" title="16. 面对对象"></a>16. 面对对象</h2><p>对象是类的一个实例，有状态和行为</p>
<p>对比面向过程，是两种不同的处理问题的角度，面向过程注重于每个过程的步骤及顺序</p>
<p>面向对象更注重于事情有哪些参与者即对象，以及各自需要做什么。</p>
<p>面向过程比较直接高效，而面向对象更易于复用，扩展和维护。</p>
<p>面向对象有三大特性：封装，继承，多态</p>
<h3 id="16-1-创建对象"><a href="#16-1-创建对象" class="headerlink" title="16.1. 创建对象"></a>16.1. 创建对象</h3><p>创建类的对象分为两步<br>1.定义该类的一个变量，此时在栈上会分配空间储存对象在堆中的地址（即对象的引用）<br>2.创建该对象的实际物理空间，即在堆中为该对象分配空间，并把此空间的地址（即引用）赋给对象名，此步骤通过new关键字来实例化该类的一个对象</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名=<span class="keyword">new</span> 类名();  <span class="comment">//创建实例对象 </span></span><br><span class="line"></span><br><span class="line">对象名.属性名;     <span class="comment">//访问对象的属性 </span></span><br><span class="line">对象名.方法名();   <span class="comment">//调用对象的方法</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="16-2-面向对象三大特征"><a href="#16-2-面向对象三大特征" class="headerlink" title="16.2. 面向对象三大特征"></a>16.2. 面向对象三大特征</h3><h4 id="16-2-1-封装"><a href="#16-2-1-封装" class="headerlink" title="16.2.1. 封装"></a>16.2.1. 封装</h4><p>封装：告诉我们如何正确的设计对象的属性和方法</p>
<p>原则：对象代表什么，就得封装对应的数据，并提供数据对应的行为。比如人画圆，就得设计一个人类和一个圆类，画圆这个方法要在圆类定义，因为要根据半径画圆</p>
<p>封装的好处：让编程变得简单，有什么事，找对象，调用方法即可</p>
<p>封装的意义：在于明确标识出与允许外部使用的所有成员变量和成员方法</p>
<p>实际上就是信息隐藏，将类中的成员属性和成员方法修饰为私有化，数据被保护在对象的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系，即get/set方法。</p>
<p>其他对象只能通过该对象提供的get/set方法，与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外提供的接口来访问该对象。</p>
<p><a href="#fawen">访问控制修饰符</a></p>
<p>如果有很多代码都使用了Dog这个类；当某一天这个类的age属性需要换成String类型，那么，外部使用它的任何地方都需要需改xxx.age=”xxx”，这将是非常繁琐的一个过程，那该怎么办呢？很简单，使用private修饰符将属性封装，开放访问接口的方法，我们只需要修改一下set方法就能完美解决。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"> Dog d1 = <span class="keyword">new</span> Dog();</span><br><span class="line"> <span class="comment">//调用时发生变化</span></span><br><span class="line"> d1.setName(<span class="string">"旺财"</span>);</span><br><span class="line"> d1.setAge(<span class="number">3</span>);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>{</span><br><span class="line"> <span class="keyword">private</span> String age;<span class="comment">//修改为String类型</span></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="comment">//将属性私有化，提供set方法，将int类型的值转成String</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.age = String.valueOf(age);</span><br><span class="line"> }</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p>这样外部使用它的地方都不用修改，我们只用简单的修改对象内部就可以了，<br>更加方便快捷。到了这里我们应该可以看出，封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。</p>
<p>这里还可以体现出一些封装属性的优势，案例如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"> Dog d1 = <span class="keyword">new</span> Dog();</span><br><span class="line"> d1.setName(<span class="string">"旺财"</span>);</span><br><span class="line"> d1.setAge(<span class="number">300</span>);<span class="comment">//狗的年龄赋值很明显不合理，这里就需要在set方法中给出提示</span></span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>{</span><br><span class="line"> <span class="keyword">private</span> String age;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span>(age&gt;<span class="number">100</span>||age&lt;<span class="number">0</span>) {</span><br><span class="line">   System.out.println(<span class="string">"你见过超过100岁的狗狗吗？"</span>);</span><br><span class="line">  }<span class="keyword">else</span>  {</span><br><span class="line">   <span class="keyword">this</span>.age = String.valueOf(age);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line"> }</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line"> }</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="16-2-2-继承"><a href="#16-2-2-继承" class="headerlink" title="16.2.2. 继承"></a>16.2.2. 继承</h4><p>作用：子类通过extends关键字继承父类，通过继承，子类可以使用父类中的非私有属性和非私有方法，从而提高代码的重用性，提高开发效率。</p>
<p>子类自动获得了父类的所有字段，严禁定义与父类重名的字段！<br>为了让子类可以访问父类的字段，把private改为protected。用protected修饰的字段可以被子类访问<br>除了父类中私有的属性和方法，子类必须全部继承。<br>3、子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。<br>4、子类可以用自己的方式实现父类的方法（即方法的重写/覆盖）。</p>
<p>5、构造器而言，它只能够被调用，而不能被继承，子类可以使用super()调用父类构造器。<br>6、对于继承而已，子类会默认调用父类的无参构造，但是如果父类没有无参构造，子类必须要在其构造方法中的第一行代码调用指定父类的构造器，传递对应参数。<br>7、Java 的继承是单继承，即每个子类只能拥有一个直接父类，但是该父类可以有多个子类</p>
<p>语法格式<br><code>访问符 修饰符 class 子类 extends 父类{  }</code></p>
<h4 id="16-2-3-多态"><a href="#16-2-3-多态" class="headerlink" title="16.2.3. 多态"></a>16.2.3. 多态</h4><p>多态的定义：是同一个行为具有多种表现形式或形态的能力。简单来说就是不同类型的对象（父类或子类）调用同一个方法，根据发出调用的对象不同，执行的方法也就不同。</p>
<p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<p>多态的作用：消除类型之间的耦合关系。</p>
<p>这里举一个简单的小例子：父类是个农民，技能是使用锄头耕地。子类继承了父类，重写了父类的锄头耕地技能，更新换代为使用拖拉机耕地。如果是父类对象调用这个技能，就是使用锄头手动耕地，如果是子类对象调用这个技能，就是使用拖拉机耕地。</p>
<p>Java实现多态有三个必要条件：继承、重写、父类引用指向子类对象。</p>
<ul>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>父类引用指向子类对象（向上转型）：在多态中需要将子类的引用赋给父类对象，只有这样引用才能够调用父类的方法和子类的方法。<code>父类类型 变量名 = new 子类对象</code></li>
</ul>
<p>注意：由于父类引用指向子类对象属于向上转型，它只能访问父类中拥有的方法和属性，无法调用子类特有的方法(子类中存在而父类中不存在的方法)，比如说方法的重载，尽管方法名称相同，但是父类只能调用到子类重写的方法，调用不到重载方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>{<span class="comment">//人类 作为所有职业的父类</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"> <span class="keyword">public</span> String name;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>{<span class="comment">//父类的方法</span></span><br><span class="line">  System.out.println(<span class="string">"劳动"</span>);</span><br><span class="line"> }</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">  <span class="comment">//父类引用指向子类对象就是多态性的体现</span></span><br><span class="line">  People p1 = <span class="keyword">new</span> Doctor();<span class="comment">// p1的类型是人类类型，但是指向的实例对象是医生</span></span><br><span class="line">  p1.work();<span class="comment">//父类引用发出的调用，调用到的是医生类中重写父类的方法</span></span><br><span class="line">  People p2 = <span class="keyword">new</span> Teacher();</span><br><span class="line">  p2.work();<span class="comment">//父类引用发出的调用，调用到的是教师类中重写父类的方法</span></span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> <span class="keyword">extends</span> <span class="title">People</span></span>{</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>{<span class="comment">//医生类继承人类，重写工作方法</span></span><br><span class="line">  System.out.println(<span class="string">"救死扶伤"</span>);</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">People</span></span>{</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>{<span class="comment">//教师类继承人类，重写工作方法</span></span><br><span class="line">  System.out.println(<span class="string">"教书育人"</span>);</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">People</span></span>{</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>{<span class="comment">//教师类继承人类，重写work方法</span></span><br><span class="line">  System.out.println(<span class="string">"教书育人"</span>);</span><br><span class="line"> }</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(String name)</span> </span>{<span class="comment">//重载了work方法，但是此方法父类引用无法调用</span></span><br><span class="line">  System.out.println(<span class="string">"负责教导的课程是"</span>+name);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>多态的好处：</p>
<p>1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如：医生、律师、程序员都是人类的子类，根据使用场景不同随时可以替换为符合的职业。<br>2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在拥有了医生、律师的继承上，还可以继续添加新的职业，比如主播，运动员等，都是添加为人类的多态性。<br>3.接口性（interface-ability）。多态是超类通过抽象方法，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。每个子类都可以根据自身的特性去重写父类的抽象方法。<br>4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。<br>5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p>
<h3 id="16-3-类之间的关系"><a href="#16-3-类之间的关系" class="headerlink" title="16.3. 类之间的关系"></a>16.3. 类之间的关系</h3><h4 id="16-3-1-继承"><a href="#16-3-1-继承" class="headerlink" title="16.3.1. 继承"></a>16.3.1. 继承</h4><h4 id="16-3-2-依赖关系"><a href="#16-3-2-依赖关系" class="headerlink" title="16.3.2. 依赖关系"></a>16.3.2. 依赖关系</h4><p>在一个类的方法中操作另一个类的对象，则称其依赖于第二个类<br>例如方法的参数时某个类的对象</p>
<h4 id="16-3-3-关联关系"><a href="#16-3-3-关联关系" class="headerlink" title="16.3.3. 关联关系"></a>16.3.3. 关联关系</h4><p>体现为一个类中使用另一个类的对象作为该类的成员变量</p>
<h4 id="16-3-4-聚合关系"><a href="#16-3-4-聚合关系" class="headerlink" title="16.3.4. 聚合关系"></a>16.3.4. 聚合关系</h4><p>聚合关系是关联关系的一种特例，体现是整体与部分的关系，<br>表现为一个类（整体）由多个其他类的对象（部分）作为该类的成员变量</p>
<h4 id="16-3-5-组成关系"><a href="#16-3-5-组成关系" class="headerlink" title="16.3.5. 组成关系"></a>16.3.5. 组成关系</h4><h2 id="18-Java泛型"><a href="#18-Java泛型" class="headerlink" title="18. Java泛型"></a>18. Java泛型</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性<br>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<br>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。<br>检查并限制传入参数的类型，消除了类型的强制转换。</p>
<p>Java 中<strong>泛型标记符</strong>即类型形参：</p>
<pre><code>E - Element (在集合中使用，因为集合中存放的是元素)
T - Type（Java 类）
K - Key（键）
V - Value（值）
N - Number（数值类型）
？ - 表示不确定的 Java 类型
</code></pre>
<h3 id="18-1-泛型类"><a href="#18-1-泛型类" class="headerlink" title="18.1. 泛型类"></a>18.1. 泛型类</h3><p>泛型类的定义语法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&lt;泛型标识，泛型标识，....&gt;</span>{</span><br><span class="line">    <span class="keyword">private</span> 泛型标识 变量名;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用语法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名&lt;具体的数据类型&gt; 对象名 =  <span class="keyword">new</span> 类名&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>{}  <span class="comment">//定义一个泛型类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类型在逻辑上可以看成多个不同的类型，但实际上都是相同类型，即Generic类</span></span><br><span class="line">Generic&lt;String&gt; generic = <span class="keyword">new</span> Generic&lt;&gt;(<span class="string">"Hello"</span>);   <span class="comment">//初始化类对象</span></span><br><span class="line">Generic&lt;Integer&gt; generic1 = <span class="keyword">new</span> Generic&lt;&gt;(<span class="number">1223</span>);   </span><br><span class="line"></span><br><span class="line">Generic&lt;<span class="keyword">int</span>&gt; generic1 = <span class="keyword">new</span> Generic&lt;&gt;(<span class="number">1223</span>);   <span class="comment">//报错，泛型的类型参数只能是类类型，不能是基本数据类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有指定具体的数据类型，此时泛型类的操作类型是Object</span></span><br><span class="line">Generic&lt;&gt; generic = <span class="keyword">new</span> Generic&lt;&gt;(<span class="string">"Hello"</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="18-2-泛型接口"><a href="#18-2-泛型接口" class="headerlink" title="18.2. 泛型接口"></a>18.2. 泛型接口</h3><h3 id="18-3-泛型方法"><a href="#18-3-泛型方法" class="headerlink" title="18.3. 泛型方法"></a>18.3. 泛型方法</h3><p>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p>
<p>下面是定义泛型方法的规则：</p>
<p>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前<br>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。<br>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。<br>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像 int、double、char 等）。</p>
<p>定义语法规则</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;T,E,..&gt;声明是泛型方法</span></span><br><span class="line">修饰符 &lt;T,E,..&gt; 返回值类型 方法名 (形参列表){</span><br><span class="line">    方法体；</span><br><span class="line">}</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@parmesan</span>&lt;E&gt; 泛型标识，具体类型由调用方法的时候来指定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> {*}</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">getProduct</span> <span class="params">(ArrayList&lt;E&gt; list)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> list.get(random.nextInt(list.size()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用泛型方法</span></span><br><span class="line">ArraryList&lt;String&gt; strList = <span class="keyword">new</span> ArraryList&lt;&gt; ();</span><br><span class="line">getProduct(strList);  <span class="comment">//传入strList集合对象</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="19-异常"><a href="#19-异常" class="headerlink" title="19. 异常"></a>19. 异常</h2><p> Error严重的错误<br>  OutOfMemoryError：内存耗尽<br>  NoClassDefFoundError：无法加载某个Class<br>  StackOverflowError：栈溢出<br> Exceptio是运行时的错误，它可以被捕获并处理。<br>  RuntimeException以及它的子类；<br>  非RuntimeException<br>  （包括IOException、ReflectiveOperationException等等）<br>   异常类分为两种<br>    1.错误。一般指与虚拟机相关的问题，这些错误无法恢复和捕获<br>    2.异常（Exception），因编码错误或外在因素导致的问题<br> 两种异常处理机制<br>  1.使用try    catch捕获异常<br>   存在多个catch的时候，catch的顺序非常重要：子类必须写在前面<br>  2.trrows抛出异常</p>
<h3 id="19-1-异常简介"><a href="#19-1-异常简介" class="headerlink" title="19.1. 异常简介"></a>19.1. 异常简介</h3><p>Java 中的异常又称为例外，是一个在程序执行期间发生的事件，它中断正在执行程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类，这可以让程序具有极好的容错性且更加健壮。</p>
<p>在 Java 中一个异常的产生，主要有如下三种原因：<br>Java 内部错误发生异常，Java 虚拟机产生的异常。<br>编写的程序代码中的错误所产生的异常，例如空指针异常、数组越界异常等。<br>通过 throw 语句手动生成的异常，一般用来告知该方法的调用者一些必要信息。</p>
<p>Java 通过面向对象的方法来处理异常。在一个方法的运行过程中，如果发生了异常，则这个方法会产生代表该异常的一个对象，并把它交给运行时的系统，运行时系统寻找相应的代码来处理这一异常。</p>
<p>我们把生成异常对象，并把它提交给运行时系统的过程称为拋出（throw）异常。<br>运行时系统在方法的调用栈中查找，直到找到能够处理该类型异常的对象，这一个过程称为捕获（catch）异常。</p>
<h3 id="19-2-Throwable类"><a href="#19-2-Throwable类" class="headerlink" title="19.2. Throwable类"></a>19.2. Throwable类</h3><p>为了能够及时有效地处理程序中的运行错误，Java 专门引入了异常类。在 Java 中所有异常类型都是内置类 java.lang.Throwable 类的子类，即 Throwable 位于异常类层次结构的顶层。Throwable 类下有两个异常分支 Exception 和 Error</p>
<p>Throwable 类是所有异常和错误的超类，下面有 Error 和 Exception 两个子类分别表示错误和异常。其中异常类 Exception 又分为运行时异常和非运行时异常，这两种异常有很大的区别，也称为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。<br>Exception 类用于用户程序可能出现的异常情况，它也是用来创建自定义异常类型类的类。<br>Error 定义了在通常环境下不希望被程序捕获的异常。一般指的是 JVM 错误，如堆栈溢出。</p>
<p>本节不讨论关于 Error 类型的异常处理，因为它们通常是灾难性的致命错误，不是程序可以控制的。接下来将讨论 Exception 类型的异常处理。</p>
<p>运行时异常都是 RuntimeException 类及其子类异常，如 NullPointerException、IndexOutOfBoundsException 等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般由程序逻辑错误引起，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>非运行时异常是指 RuntimeException 以外的异常，类型上都属于 Exception 类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如 IOException、ClassNotFoundException 等以及用户自定义的 Exception 异常（一般情况下不自定义检查异常）。</p>
<h3 id="19-3-Java异常处理机制"><a href="#19-3-Java异常处理机制" class="headerlink" title="19.3. Java异常处理机制"></a>19.3. Java异常处理机制</h3><p>Java 的异常处理通过 5 个关键字来实现：try、catch、throw、throws 和 finally。try catch 语句用于捕获并处理异常，finally 语句用于在任何情况下（除特殊情况外）都必须执行的代码，throw 语句用于拋出异常，throws 语句用于声明可能会出现的异常。</p>
<p>本节先主要介绍异常处理的机制及基本的语句结构。</p>
<p>Java 的异常处理机制提供了一种结构性和控制性的方式来处理程序执行期间发生的事件。异常处理的机制如下：<br>1.在方法中用 try catch 语句捕获并处理异常，catch 语句可以有多个，用来匹配多个异常。<br>2.对于处理不了的异常或者要转型的异常，在方法的声明处通过 throws 语句拋出异常，即由上层的调用方法来处理。</p>
<p>以下代码是异常处理程序的基本结构：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 可能发生异常的语句</span></span><br><span class="line">} <span class="keyword">catch</span>(ExceptionType1 e) {</span><br><span class="line">    处理代码块<span class="number">1</span></span><br><span class="line">} <span class="keyword">catch</span> (ExceptionType2 e) {</span><br><span class="line">    处理代码块<span class="number">2</span></span><br><span class="line">    <span class="keyword">throw</span>(e);    <span class="comment">// 再抛出这个"异常"</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    释放资源代码块</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在以上语法中，把可能引发异常的语句封装在 try 语句块中，用以捕获可能发生的异常。catch 后的( )里放匹配的异常类，指明 catch 语句可以处理的异常类型，发生异常时产生异常类的实例化对象。</p>
<p>如果 try 语句块中发生异常，那么一个相应的异常对象就会被拋出，然后 catch 语句就会依据所拋出异常对象的类型进行捕获，并处理。处理之后，程序会跳过 try 语句块中剩余的语句，转到 catch 语句块后面的第一条语句开始执行。</p>
<p>如果 try 语句块中没有异常发生，那么 try 块正常结束，后面的 catch 语句块被跳过，程序将从 catch 语句块后的第一条语句开始执行。</p>
<p>注意：try…catch 与 if…else 不一样，try 后面的花括号{ }不可以省略，即使 try 块里只有一行代码，也不可省略这个花括号。与之类似的是，catch 块后的花括号{ }也不可以省略。另外，try 块里声明的变量只是代码块内的局部变量，它只在 try 块内有效，其它地方不能访问该变量。</p>
<p>可以使用以下 3 个方法输出相应的异常信息。<br>printStackTrace() 方法：指出异常的类型、性质、栈层次及出现在程序中的位置<br>getMessage() 方法：输出错误的性质。<br>toString() 方法：给出异常的类型与性质。</p>
<h2 id="20-反射机制"><a href="#20-反射机制" class="headerlink" title="20. 反射机制"></a>20. 反射机制</h2><h3 id="20-1-为什么使用反射"><a href="#20-1-为什么使用反射" class="headerlink" title="20.1. 为什么使用反射"></a>20.1. 为什么使用反射</h3><p>反射拥有以下四大功能：</p>
<ul>
<li>在运行时（动态编译）获知任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时获知任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法和属性。</li>
</ul>
<p>上述这种动态获取信息、动态调用对象的方法的功能称为 Java 语言的反射机制</p>
<h2 id="21-JVM内存区域"><a href="#21-JVM内存区域" class="headerlink" title="21. JVM内存区域"></a>21. JVM内存区域</h2><p>栈内存：方法在执行时进栈，执行完毕后出栈<br>堆内存：new出来的对象都在这里<br>方法区：字节码文件临时存储</p>
<h3 id="21-1-虚拟机栈-JVM-Stack"><a href="#21-1-虚拟机栈-JVM-Stack" class="headerlink" title="21.1. 虚拟机栈(JVM Stack)"></a>21.1. 虚拟机栈(JVM Stack)</h3><p> 重点是存储局部变量表(当然也有其他信息). 我们刚才创建的 int[] arr 这样的存储地址的引用就是在这里保存.</p>
<h3 id="21-2-堆-Heap"><a href="#21-2-堆-Heap" class="headerlink" title="21.2. 堆(Heap)"></a>21.2. 堆(Heap)</h3><p> JVM所管理的最大内存区域. 使用 new 创建的对象都是在堆上保存 (例如前面的 new int[]{1, 2, 3} )</p>
<h3 id="21-3-栈与堆的区别"><a href="#21-3-栈与堆的区别" class="headerlink" title="21.3. 栈与堆的区别"></a>21.3. 栈与堆的区别</h3><p> 1.局部变量和引用保存在栈上, new 出的对象保存在堆上.</p>
<p> 2.堆的空间非常大, 栈的空间比较小.</p>
<p> 3.堆是整个 JVM 共享一个, 而栈每个线程具有一份(一个 Java 程序中可能存在多个栈).</p>
<h3 id="21-4-本地方法栈-Native-Method-Stack"><a href="#21-4-本地方法栈-Native-Method-Stack" class="headerlink" title="21.4. 本地方法栈(Native Method Stack)"></a>21.4. 本地方法栈(Native Method Stack)</h3><p> 本地方法栈与虚拟机栈的作用类似. 只不过保存的内容是Native方法的局部变量. 在有些版本的 JVM 实现中(例如HotSpot), 本地方法栈和虚拟机栈是一起的.</p>
<h3 id="21-5-串池"><a href="#21-5-串池" class="headerlink" title="21.5. 串池"></a>21.5. 串池</h3><p>程序计数器 (PC Register):</p>
<p> 只是一个很小的空间, 保存下一条执行的指令的地址.</p>
<h3 id="21-6-方法区-Method-Area"><a href="#21-6-方法区-Method-Area" class="headerlink" title="21.6. 方法区(Method Area)"></a>21.6. 方法区(Method Area)</h3><p> 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据. 方法编译出的的字节码就是保存在这个区域.</p>
<h3 id="21-7-运行时常量池-Runtime-Constant-Pool"><a href="#21-7-运行时常量池-Runtime-Constant-Pool" class="headerlink" title="21.7. 运行时常量池(Runtime Constant Pool)"></a>21.7. 运行时常量池(Runtime Constant Pool)</h3><p> 是方法区的一部分, 存放字面量(字符串常量)与符号引用. (注意 从JDK1.7 开始, 运行时常量池在堆上)</p>
<h3 id="21-8-数组在内存中的存储"><a href="#21-8-数组在内存中的存储" class="headerlink" title="21.8. 数组在内存中的存储"></a>21.8. 数组在内存中的存储</h3><p>数组的数据则在堆上进行存放， 数组的数据在堆上都有特定的地址，<br>局部变量都在Java虚拟机栈上存放，数组的变量存放的其实是这组数据的地址，栈上的这个变量根据这个地址找到堆上的数据</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] str = {<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>};</span><br><span class="line">System.out.println(str.getClass());</span><br><span class="line"></span><br><span class="line">System.out.println(str);  <span class="comment">//输出@776ec8df</span></span><br></pre></td></tr></tbody></table></figure>

<p>@776ec8df就是str变量指向的数据在堆中的地址，这个地址并不是真正的地址，它是通过正式的地址 hash 得到的.但是我们可以把它当作真实的地址，因为这个地址也是唯一的. 那么真实的地址为什么要hash操作呢？这就是Java的安全性了，不会轻易暴露自己数据的地址.</p>
<h2 id="22-Java注解"><a href="#22-Java注解" class="headerlink" title="22. Java注解"></a>22. Java注解</h2><p>从 Java 5 版本之后可以在源代码中嵌入一些补充信息，这种补充信息称为注解（Annotation），是 Java 平台中非常重要的一部分。注解都是 @ 符号开头的<br>同 Class 和 Interface 一样，注解也属于一种类型。无论是哪一种注解，本质上都一种数据类型，是一种接口类型。<br>注解并不能改变程序的运行结果，也不会影响程序运行的性能。有些注解可以在编译时给用户提示或警告，有的注解可以在运行时读写字节码文件信息。</p>
<p>注解可以元数据这个词来描述，即一种描述数据的数据。所以可以说注解就是源代码的元数据</p>
<p>注解常见的作用有以下几种：<br>生成帮助文档。这是最常见的，也是 Java 最早提供的注解。常用的有 @see、@param 和 @return 等；<br>跟踪代码依赖性，实现替代配置文件功能。比较常见的是 Spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量；<br>在编译时进行格式检查。如把 @Override 注解放在方法前，如果这个方法并不是重写了父类方法，则编译时就能检查出。</p>
<p>到 Java 8 为止 Java SE 提供了 11 个内置注解。其中有 5 个是基本注解，它们来自于 java.lang 包。有 6 个是元注解，它们来自于 java.lang.annotation 包，自定义注解会用到元注解。</p>
<p>提示：元注解就是负责注解其他的注解。</p>
<p>基本注解包括：@Override、@Deprecated、@SuppressWarnings、@SafeVarargs 和 @FunctionalInterface</p>
<p>@Override注解:用来指定方法重写的，只能修饰方法并且只能用于方法重写，不能修饰其它的元素。它可以强制一个子类必须重写父类方法或者实现接口的方法。</p>
<p>@Deprecated注解:可以用来注解类、接口、成员方法和成员变量等，用于表示某个元素（类、方法等）已过时。当其他程序使用已过时的元素时，编译器将会给出警告。</p>
<h3 id="22-1-元注解作用及使用"><a href="#22-1-元注解作用及使用" class="headerlink" title="22.1. 元注解作用及使用"></a>22.1. 元注解作用及使用</h3><p>@Documented 是一个标记注解，没有成员变量。用 @Documented 注解修饰的注解类会被 JavaDoc 工具提取成文档。默认情况下，JavaDoc 是不包括注解的，但如果声明注解时指定了 @Documented，就会被 JavaDoc 之类的工具处理，所以注解类型信息就会被包括在生成的帮助文档中。</p>
<h3 id="22-2-自定义注解"><a href="#22-2-自定义注解" class="headerlink" title="22.2. 自定义注解"></a>22.2. 自定义注解</h3><h3 id="22-3-通过反射获取注解信息"><a href="#22-3-通过反射获取注解信息" class="headerlink" title="22.3. 通过反射获取注解信息"></a>22.3. 通过反射获取注解信息</h3><h2 id="23-IDEA使用"><a href="#23-IDEA使用" class="headerlink" title="23. IDEA使用"></a>23. IDEA使用</h2><h3 id="23-1-快捷键"><a href="#23-1-快捷键" class="headerlink" title="23.1. 快捷键"></a>23.1. 快捷键</h3><p>ctrl + d 快速复制这行到下一行</p>
<p>alt + insert ：自动生成get,set方法</p>
<p>注释<br>行注释Ctrl+/、<br>块注释Ctrl+Shift+/<br>文档注释  /**+enter</p>
<p>ctrl+alt+v  快速定义一个变量来接收对象</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wenkex.gitee.io">Arts</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wenkex.gitee.io/2021/122465132.html">https://wenkex.gitee.io/2021/122465132.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wenkex.gitee.io" target="_blank">wenke</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post_share"><div class="social-share" data-image="/img/top.jpg" data-sites="wechat,qq,facebook,twitter,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/122451189.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/top.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络学习</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wenke</div><div class="author-info__description">专注于编程,分享生活,分享知识</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wenkexia"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wenkexia" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1184664659@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">备用网址:https://wenkex.gitee.io (速度更快)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">2. 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Java%E7%9A%84%E8%BF%9B%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">2.1. Java的进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%94%A8%E8%AE%B0%E4%BA%8B%E6%9C%AC%E7%BC%96%E5%86%99Java%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.</span> <span class="toc-text">2.2. 用记事本编写Java代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">2.3. 跨平台原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-JRE%E5%92%8Cjdk"><span class="toc-number">1.4.</span> <span class="toc-text">2.4. JRE和jdk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">2.5. 标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%B3%A8%E9%87%8A"><span class="toc-number">1.6.</span> <span class="toc-text">2.6. 注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%8F%98%E9%87%8F"><span class="toc-number">1.7.</span> <span class="toc-text">2.7. 变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">3. Java 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.1.</span> <span class="toc-text">3.1. 访问控制修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%9D%9E%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">3.2. 非访问修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">4. 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text">4.1. 算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text">4.2. 位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.3.</span> <span class="toc-text">4.3. 逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">4.4. 赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.5.</span> <span class="toc-text">4.5. 条件运算符(三元运算符)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.6.</span> <span class="toc-text">4.6. 其他运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">9. 循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.1.</span> <span class="toc-text">9.1. while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-do-while%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.</span> <span class="toc-text">9.2. do while循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.3.</span> <span class="toc-text">9.3. for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-foreach-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.4.</span> <span class="toc-text">9.4. foreach 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-break%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.5.</span> <span class="toc-text">9.5. break关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-continue%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.6.</span> <span class="toc-text">9.6. continue关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">10. 分支结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-if%E2%80%A6else-if%E2%80%A6else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.1.</span> <span class="toc-text">10.1. if…else if…else 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-switch%E5%A4%9A%E9%87%8D%E9%80%89%E6%8B%A9"><span class="toc-number">5.2.</span> <span class="toc-text">10.2. switch多重选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Java%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">11. Java方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%8F%82%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">12. 参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%BD%A2%E5%8F%82-amp-%E5%AE%9E%E5%8F%82"><span class="toc-number">7.1.</span> <span class="toc-text">12.1. 形参&amp;实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E5%80%BC%E4%BC%A0%E9%80%92-amp-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">7.2.</span> <span class="toc-text">12.2. 值传递&amp;引用传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-Java%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">7.3.</span> <span class="toc-text">12.3. Java只有值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E5%8F%82%E6%95%B0%E4%BC%A0%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.4.</span> <span class="toc-text">12.4. 参数传内置类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E5%8F%82%E6%95%B0%E4%BC%A0%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.5.</span> <span class="toc-text">12.5. 参数传数组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">12.6. 可变参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">13. 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">8.1.</span> <span class="toc-text">13.1. 类型变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-1-%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99"><span class="toc-number">8.1.1.</span> <span class="toc-text">13.1.1. 就近原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-2-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.1.2.</span> <span class="toc-text">13.1.2. this关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-3-supper%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.1.3.</span> <span class="toc-text">13.1.3. supper关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.2.</span> <span class="toc-text">13.2. 构造方法(构造器)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-1-%E4%B8%A4%E7%A7%8D%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.2.1.</span> <span class="toc-text">13.2.1. 两种构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-2-%E5%AE%9A%E4%B9%89"><span class="toc-number">8.2.2.</span> <span class="toc-text">13.2.2. 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-3-%E5%AD%90%E7%B1%BB%E8%B0%83%E7%94%A8"><span class="toc-number">8.2.3.</span> <span class="toc-text">13.2.3. 子类调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-set%E6%96%B9%E6%B3%95%E5%92%8Cget%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">13.3. set方法和get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">8.4.</span> <span class="toc-text">13.4. 方法的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">8.5.</span> <span class="toc-text">13.5. 方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">8.6.</span> <span class="toc-text">13.6. 方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.7.</span> <span class="toc-text">13.7. 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.7.1.</span> <span class="toc-text">13.7.1. 成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.7.2.</span> <span class="toc-text">13.7.2. 静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-3-%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.7.3.</span> <span class="toc-text">13.7.3. 非静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-4-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.7.4.</span> <span class="toc-text">13.7.4. 局部内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-5-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.7.5.</span> <span class="toc-text">13.7.5. 匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">8.8.</span> <span class="toc-text">13.8. 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">8.8.1.</span> <span class="toc-text">13.8.1. 抽象类的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-2-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.8.2.</span> <span class="toc-text">13.8.2. 抽象类的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="toc-number">8.8.3.</span> <span class="toc-text">13.8.3. 抽象类的子类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Object%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">14. Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-toString-%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">14.1. toString() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-equals-%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">14.2. equals() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-getClass-%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">14.3. getClass() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-%E6%8E%A5%E6%94%B6%E4%BB%BB%E6%84%8F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.4.</span> <span class="toc-text">14.4. 接收任意引用类型的对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.</span> <span class="toc-text">15. 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">10.1.</span> <span class="toc-text">15.1. 接口的意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%80%A7"><span class="toc-number">10.2.</span> <span class="toc-text">15.2. 接口特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9"><span class="toc-number">10.3.</span> <span class="toc-text">15.3. 接口成员特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.4.</span> <span class="toc-text">15.4. 定义接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.5.</span> <span class="toc-text">15.5. 实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-6-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">10.6.</span> <span class="toc-text">15.6. 接口的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-7-Java-8-%E6%8E%A5%E5%8F%A3%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">10.7.</span> <span class="toc-text">15.7. Java 8 接口新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.</span> <span class="toc-text">16. 面对对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.1.</span> <span class="toc-text">16.1. 创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">11.2.</span> <span class="toc-text">16.2. 面向对象三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-1-%E5%B0%81%E8%A3%85"><span class="toc-number">11.2.1.</span> <span class="toc-text">16.2.1. 封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-2-%E7%BB%A7%E6%89%BF"><span class="toc-number">11.2.2.</span> <span class="toc-text">16.2.2. 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-3-%E5%A4%9A%E6%80%81"><span class="toc-number">11.2.3.</span> <span class="toc-text">16.2.3. 多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">11.3.</span> <span class="toc-text">16.3. 类之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-1-%E7%BB%A7%E6%89%BF"><span class="toc-number">11.3.1.</span> <span class="toc-text">16.3.1. 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-2-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">11.3.2.</span> <span class="toc-text">16.3.2. 依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-3-%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-number">11.3.3.</span> <span class="toc-text">16.3.3. 关联关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-4-%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">11.3.4.</span> <span class="toc-text">16.3.4. 聚合关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-5-%E7%BB%84%E6%88%90%E5%85%B3%E7%B3%BB"><span class="toc-number">11.3.5.</span> <span class="toc-text">16.3.5. 组成关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Java%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">18. Java泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">18.1. 泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.2.</span> <span class="toc-text">18.2. 泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">12.3.</span> <span class="toc-text">18.3. 泛型方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%BC%82%E5%B8%B8"><span class="toc-number">13.</span> <span class="toc-text">19. 异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-%E5%BC%82%E5%B8%B8%E7%AE%80%E4%BB%8B"><span class="toc-number">13.1.</span> <span class="toc-text">19.1. 异常简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-Throwable%E7%B1%BB"><span class="toc-number">13.2.</span> <span class="toc-text">19.2. Throwable类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">13.3.</span> <span class="toc-text">19.3. Java异常处理机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">14.</span> <span class="toc-text">20. 反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84"><span class="toc-number">14.1.</span> <span class="toc-text">20.1. 为什么使用反射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">15.</span> <span class="toc-text">21. JVM内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-JVM-Stack"><span class="toc-number">15.1.</span> <span class="toc-text">21.1. 虚拟机栈(JVM Stack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-2-%E5%A0%86-Heap"><span class="toc-number">15.2.</span> <span class="toc-text">21.2. 堆(Heap)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-3-%E6%A0%88%E4%B8%8E%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.3.</span> <span class="toc-text">21.3. 栈与堆的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-4-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-Native-Method-Stack"><span class="toc-number">15.4.</span> <span class="toc-text">21.4. 本地方法栈(Native Method Stack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-5-%E4%B8%B2%E6%B1%A0"><span class="toc-number">15.5.</span> <span class="toc-text">21.5. 串池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-6-%E6%96%B9%E6%B3%95%E5%8C%BA-Method-Area"><span class="toc-number">15.6.</span> <span class="toc-text">21.6. 方法区(Method Area)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-7-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0-Runtime-Constant-Pool"><span class="toc-number">15.7.</span> <span class="toc-text">21.7. 运行时常量池(Runtime Constant Pool)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-8-%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">15.8.</span> <span class="toc-text">21.8. 数组在内存中的存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-Java%E6%B3%A8%E8%A7%A3"><span class="toc-number">16.</span> <span class="toc-text">22. Java注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-1-%E5%85%83%E6%B3%A8%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-number">16.1.</span> <span class="toc-text">22.1. 元注解作用及使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">16.2.</span> <span class="toc-text">22.2. 自定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF"><span class="toc-number">16.3.</span> <span class="toc-text">22.3. 通过反射获取注解信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-IDEA%E4%BD%BF%E7%94%A8"><span class="toc-number">17.</span> <span class="toc-text">23. IDEA使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-1-%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">17.1.</span> <span class="toc-text">23.1. 快捷键</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/101963206.html" title="蓝桥杯准备">蓝桥杯准备</a><time datetime="2022-10-19T10:20:35.000Z" title="发表于 2022-10-19 18:20:35">2022-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10190.html" title="无题">无题</a><time datetime="2022-10-19T09:08:06.139Z" title="发表于 2022-10-19 17:08:06">2022-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/101954372.html" title="Git使用">Git使用</a><time datetime="2022-10-19T09:06:04.000Z" title="发表于 2022-10-19 17:06:04">2022-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/101960077.html" title="Github使用">Github使用</a><time datetime="2022-10-19T09:05:27.000Z" title="发表于 2022-10-19 17:05:27">2022-10-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/101913972.html" title="Joplin全平台同步笔记">Joplin全平台同步笔记</a><time datetime="2022-10-19T07:56:14.000Z" title="发表于 2022-10-19 15:56:14">2022-10-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By wenke</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'BbuBjGh9to6TtPug5KeFflx1-gzGzoHsz',
      appKey: '73XAE3zu9AokVhAvE61OP01g',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'bfb6298af9f1ff707b95',
      clientSecret: '8d5b4c3eb2db8da51a90e0c40823fa3ed7b9c539',
      repo: 'wenkexia.github.io',
      owner: 'wenkexia',
      admin: ['wenkexia'],
      id: 'f2b68f7cf8a87e353fa138c2bb55fdf5',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Valine' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="Arts,ke,xia" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>